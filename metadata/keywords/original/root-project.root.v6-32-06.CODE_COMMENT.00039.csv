id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:166,Safety,safe,safety,166,/// Return true if the value is known to produce a single fixed value across; /// all iterations on which it executes. Note that this does not imply; /// speculation safety. That must be established separately.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:23,Safety,safe,safe,23,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:360,Safety,safe,safe,360,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:797,Safety,safe,safely,797,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:231,Integrability,wrap,wraps,231,"// This check makes sure that the IV does not change sign during loop; // iterations. Consider latchType = i64, LatchStart = 5, Pred = ICMP_SGE,; // LatchEnd = 2, rangeCheckType = i32. If it's not a monotonic predicate, the; // IV wraps around, and the truncation of the IV would lose the range of; // iterations between 2^32 and 2^64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:146,Safety,safe,safe,146,// The active bits should be less than the bits in the RangeCheckType. This; // guarantees that truncating the latch check to RangeCheckType is a safe; // operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:106,Safety,safe,safe,106,// Return an LoopICmp describing a latch check equivlent to LatchCheck but with; // the requested type if safe to do so. May involve the use of a new IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:14,Safety,safe,safely,14,// We can now safely identify the truncated version of the IV and limit for; // RangeCheckType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:541,Safety,safe,safe,541,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:803,Safety,predict,predictable,803,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:583,Security,expose,exposes,583,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:762,Testability,log,logic,762,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:981,Testability,test,test,981,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:168,Integrability,depend,depends,168,// Generate the widened condition for the forward loop:; // guardStart u< guardLimit &&; // latchLimit <pred> guardLimit - 1 - guardStart + latchStart; // where <pred> depends on the latch condition predicate. See the file; // header comment for the reasoning.; // guardLimit - guardStart + latchStart - 1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:117,Safety,safe,safety,117,"// Subtlety: We need all the values to be *invariant* across all iterations,; // but we only need to check expansion safety for those which *aren't*; // already guaranteed to dominate the guard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:117,Safety,safe,safety,117,"// Subtlety: We need all the values to be *invariant* across all iterations,; // but we only need to check expansion safety for those which *aren't*; // already guaranteed to dominate the guard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:31,Testability,log,logic,31,"// At the moment, our matching logic for wideable conditions implicitly; // assumes we preserve the form: (br (and Cond, WC())). FIXME",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:168,Safety,predict,predict,168,// Walk back through any unconditional executed blocks and see if we can find; // a widenable condition which seems to control execution of this loop. Note; // that we predict that maythrow calls are likely untaken and thus that it's; // profitable to widen a branch before a maythrow call with a condition; // afterwards even though that may cause the slow path to run in a case where; // it wouldn't have otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:209,Usability,simpl,simplify,209,"/// This implements an analogous, but entirely distinct transform from the main; /// loop predication transform. This one is phrased in terms of using a; /// widenable branch *outside* the loop to allow us to simplify loop exits in a; /// following loop. This is close in spirit to the IndVarSimplify transform; /// of the same name, but is materially different widening loosens legality; /// sharply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:388,Availability,down,down,388,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:22,Performance,perform,performed,22,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1016,Safety,avoid,avoid,1016,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:336,Performance,perform,perform,336,"// profitability - want hot exit in analyzeable set; // At this point, we have found an analyzeable latch, and a widenable; // condition above the loop. If we have a widenable exit within the loop; // (for which we can't compute exit counts), drop the ability to further; // widen so that we gain ability to analyze it's exit count and perform this; // transform. TODO: It'd be nice to know for sure the exit became; // analyzeable after dropping widenability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:411,Safety,avoid,avoid,411,"// The use of umin(all analyzeable exits) instead of latch is subtle, but; // important for profitability. We may have a loop which hasn't been fully; // canonicalized just yet. If the exit we chose to widen is provably never; // taken, we want the widened form to *also* be provably never taken. We; // can't guarantee this as a current unanalyzeable exit may later become; // analyzeable, but we can at least avoid the obvious cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:58,Modifiability,rewrite,rewrite,58,"// If our exiting block exits multiple loops, we can only rewrite the; // innermost one. Otherwise, we're changing how many times the innermost; // loop runs before it exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:9,Modifiability,rewrite,rewrite,9,// Can't rewrite non-branch yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:351,Safety,avoid,avoids,351,"/// Here we can be fairly sure that executing this exit will most likely; /// lead to executing llvm.experimental.deoptimize.; /// This is a profitability heuristic, not a legality constraint.; // If we found a widenable exit condition, do two things:; // 1) fold the widened exit test into the widenable condition; // 2) fold the branch to untaken - avoids infinite looping",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:281,Testability,test,test,281,"/// Here we can be fairly sure that executing this exit will most likely; /// lead to executing llvm.experimental.deoptimize.; /// This is a profitability heuristic, not a legality constraint.; // If we found a widenable exit condition, do two things:; // 1) fold the widened exit test into the widenable condition; // 2) fold the branch to untaken - avoids infinite looping",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:406,Usability,simpl,simple,406,"//===- LoopReroll.cpp - Loop rerolling pass -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements a simple loop reroller.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:16,Deployability,rolling,rolling,16,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:507,Modifiability,variab,variable,507,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:589,Modifiability,variab,variable,589,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:657,Modifiability,variab,variable,657,"// This loop re-rolling transformation aims to transform loops like this:; //; // int foo(int a);; // void bar(int *x) {; // for (int i = 0; i < 500; i += 3) {; // foo(i);; // foo(i+1);; // foo(i+2);; // }; // }; //; // into a loop like this:; //; // void bar(int *x) {; // for (int i = 0; i < 500; ++i); // foo(i);; // }; //; // It does this by looking for loops that, besides the latch code, are composed; // of isomorphic DAGs of instructions, with each DAG rooted at some increment; // to the induction variable, and where each DAG is isomorphic to the DAG; // rooted at the induction variable (excepting the sub-DAGs which root the; // other induction-variable increments). In other words, we're looking for loop; // bodies of the form:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // where each f(i) is a set of instructions that, collectively, are a function; // only of i (and other loop-invariant values).; //; // As a special case, we can also reroll loops like this:; //; // int foo(int);; // void bar(int *x) {; // for (int i = 0; i < 500; ++i) {; // x[3*i] = foo(0);; // x[3*i+1] = foo(0);; // x[3*i+2] = foo(0);; // }; // }; //; // into this:; //; // void bar(int *x) {; // for (int i = 0; i < 1500; ++i); // x[i] = foo(0);; // }; //; // in which case, we're looking for inputs like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // %scaled.iv = mul %iv, scale; // f(%scaled.iv); // %scaled.iv.1 = add %scaled.iv, 1; // f(%scaled.iv.1); // %scaled.iv.2 = add %scaled.iv, 2; // f(%scaled.iv.2); // %scaled.iv.scale_m_1 = add %scaled.iv, scale-1; // f(%scaled.iv.scale_m_1); // ...; // %iv.next = add %iv, 1; // %cmp = icmp(%iv, ...); // br %cmp, header, exit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:47,Modifiability,variab,variables,47,/// The bitvector index used by loop induction variables and other; /// instructions that belong to all iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:25,Modifiability,variab,variable,25,// Map between induction variable and its increment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:36,Modifiability,variab,variables,36,"// For loop with multiple induction variables, remember the ones used only to; // control the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:368,Energy Efficiency,reduce,reduced,368,// Setup to track possible reductions corresponding to the provided; // rerolling scale. Only reductions with a number of non-PHI instructions; // that is divisible by the scale are considered. Three instructions sets; // are filled in:; // - A set of all possible instructions in eligible reductions.; // - A set of all PHIs in eligible reductions; // - A set of all reduced values (last instructions) in eligible; // reductions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:36,Modifiability,variab,variable,36,"// A DAGRootSet models an induction variable being used in a rerollable; // loop. For example,; //; // x[i*3+0] = y1; // x[i*3+1] = y2; // x[i*3+2] = y3; //; // Base instruction -> i*3; // +---+----+; // / | \; // ST[y1] +1 +2 <-- Roots; // | |; // ST[y2] ST[y3]; //; // There may be multiple DAGRoots, for example:; //; // x[i*2+0] = ... (1); // x[i*2+1] = ... (1); // x[i*2+4] = ... (2); // x[i*2+5] = ... (2); // x[(i+1234)*2+5678] = ... (3); // x[(i+1234)*2+5679] = ... (3); //; // The loop will be rerolled by adding a new loop induction variable,; // one for the Base instruction in each DAGRootSet.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:543,Modifiability,variab,variable,543,"// A DAGRootSet models an induction variable being used in a rerollable; // loop. For example,; //; // x[i*3+0] = y1; // x[i*3+1] = y2; // x[i*3+2] = y3; //; // Base instruction -> i*3; // +---+----+; // / | \; // ST[y1] +1 +2 <-- Roots; // | |; // ST[y2] ST[y3]; //; // There may be multiple DAGRoots, for example:; //; // x[i*2+0] = ... (1); // x[i*2+1] = ... (1); // x[i*2+4] = ... (2); // x[i*2+5] = ... (2); // x[(i+1234)*2+5678] = ... (3); // x[(i+1234)*2+5679] = ... (3); //; // The loop will be rerolled by adding a new loop induction variable,; // one for the Base instruction in each DAGRootSet.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:92,Modifiability,variab,variable,92,"// The set of all DAG roots, and state tracking of all roots; // for a particular induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:54,Modifiability,variab,variable,54,/// Stage 1: Find all the DAG roots for the induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:13,Security,Validat,Validate,13,/// Stage 2: Validate if the found roots are valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:48,Performance,perform,perform,48,"/// Stage 3: Assuming validate() returned true, perform the; /// replacement.; /// @param BackedgeTakenCount The backedge-taken count of L.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:22,Security,validat,validate,22,"/// Stage 3: Assuming validate() returned true, perform the; /// replacement.; /// @param BackedgeTakenCount The backedge-taken count of L.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:22,Modifiability,variab,variable,22,// The loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:25,Modifiability,variab,variable,25,// Map between induction variable and its increment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:23,Modifiability,extend,extending,23,// Skip SExt if we are extending an nsw value; // TODO: Allow ZExt too,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:38,Modifiability,variab,variables,38,// Collect the list of loop induction variables with respect to which it might; // be possible to reroll the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:38,Modifiability,variab,variable,38,"// Add the remainder of the reduction-variable chain to the instruction vector; // (the initial PHINode has already been added). If successful, the object is; // marked as valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:17,Modifiability,variab,variable,17,"// The reduction variable must be a chain of single-use instructions; // (including the PHI), except for the last value (which is used by the PHI; // and also outside the loop).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:44,Modifiability,variab,variables,44,// Collect the vector of possible reduction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:637,Deployability,update,update,637,"// Collect the set of all users of the provided root instruction. This set of; // users contains not only the direct users of the root instruction, but also; // all users of those users, and so on. There are two exceptions:; //; // 1. Instructions in the set of excluded instructions are never added to the; // use set (even if they are users). This is used, for example, to exclude; // including root increments in the use set of the primary IV.; //; // 2. Instructions in the set of final instructions are added to the use set; // if they are users, but their users are not added. This is used, for; // example, to prevent a reduction update from forcing all later reduction; // updates into the use set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:681,Deployability,update,updates,681,"// Collect the set of all users of the provided root instruction. This set of; // users contains not only the direct users of the root instruction, but also; // all users of those users, and so on. There are two exceptions:; //; // 1. Instructions in the set of excluded instructions are never added to the; // use set (even if they are users). This is used, for example, to exclude; // including root increments in the use set of the primary IV.; //; // 2. Instructions in the set of final instructions are added to the use set; // if they are users, but their users are not added. This is used, for; // example, to prevent a reduction update from forcing all later reduction; // updates into the use set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:11,Integrability,wrap,wrap-around,11,"// Ignore ""wrap-around"" uses to PHIs of this loop's header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:29,Usability,simpl,simple,29,"/// Return true if IVU is a ""simple"" arithmetic operation.; /// This is used for narrowing the search space for DAGRoots; only arithmetic; /// and GEPs can be part of a DAGRoot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:133,Performance,optimiz,optimized,133,"// If we found non-loop-inc, non-root users of Base, assume they are; // for the zeroth root index. This is because ""add %a, 0"" gets optimized; // away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:85,Usability,simpl,simple,85,// Does the user look like it could be part of a root set?; // All its users must be simple arithmetic ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:33,Integrability,depend,depends,33,/// Return true if instruction I depends on any instruction between; /// Start and End.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:884,Availability,down,down,884,"// We now need to check for equivalence of the use graph of each root with; // that of the primary induction variable (excluding the roots). Our goal; // here is not to solve the full graph isomorphism problem, but rather to; // catch common cases without a lot of work. As a result, we will assume; // that the relative order of the instructions in each unrolled iteration; // is the same (although we will not make an assumption about how the; // different iterations are intermixed). Note that while the order must be; // the same, the instructions may not be in the same basic block.; // An array of just the possible reductions for this scale factor. When we; // collect the set of all users of some root instructions, these reduction; // instructions are treated as 'final' (their uses are not considered).; // This is important because we don't want the root use set to search down; // the reduction chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:109,Modifiability,variab,variable,109,"// We now need to check for equivalence of the use graph of each root with; // that of the primary induction variable (excluding the roots). Our goal; // here is not to solve the full graph isomorphism problem, but rather to; // catch common cases without a lot of work. As a result, we will assume; // that the relative order of the instructions in each unrolled iteration; // is the same (although we will not make an assumption about how the; // different iterations are intermixed). Note that while the order must be; // the same, the instructions may not be in the same basic block.; // An array of just the possible reductions for this scale factor. When we; // collect the set of all users of some root instructions, these reduction; // instructions are treated as 'final' (their uses are not considered).; // This is important because we don't want the root use set to search down; // the reduction chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:213,Energy Efficiency,efficient,efficiently,213,"// Last chance saloon. We don't try and solve the full isomorphism; // problem, but try and at least catch the case where two instructions; // *of different types* are round the wrong way. We won't be able to; // efficiently tell, given two ADD instructions, which way around we; // should match them, but given an ADD and a SUB, we can at least infer; // which one is which.; //; // This should allow us to deal with a greater subset of the isomorphism; // problem. It does however change a linear algorithm into a quadratic; // one, so limit the number of probes we do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:117,Performance,optimiz,optimization,117,"// Note: This is specifically guarded by a check on isa<PHINode>,; // which while a valid (somewhat arbitrary) micro-optimization, is; // needed because otherwise isSafeToSpeculativelyExecute returns; // false on PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:102,Integrability,depend,depend,102,"// Make sure that we don't alias with any instruction in the alias set; // tracker. If we do, then we depend on a future iteration, and we; // can't reroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:271,Integrability,depend,dependencies,271,"// If we've past an instruction from a future iteration that may have; // side effects, and this instruction might also, then we can't reorder; // them, and this matching fails. As an exception, we allow the alias; // set tracker to handle regular (unordered) load/store dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:260,Performance,load,load,260,"// If we've past an instruction from a future iteration that may have; // side effects, and this instruction might also, then we can't reorder; // them, and this matching fails. As an exception, we allow the alias; // set tracker to handle regular (unordered) load/store dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each BaseInst using SCEV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:28,Modifiability,variab,variable,28,// Insert the new induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:3,Security,Validat,Validate,3,"// Validate the selected reductions. All iterations must have an isomorphic; // part of the reduction chain and, for non-associative reductions, the chain; // entries must appear in order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:132,Energy Efficiency,reduce,reduced,132,"// For all selected reductions, remove all parts except those in the first; // iteration (and the PHI). Replace outside uses of the reduced value with uses; // of the first-iteration reduced value (in other words, reroll the selected; // reductions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:183,Energy Efficiency,reduce,reduced,183,"// For all selected reductions, remove all parts except those in the first; // iteration (and the PHI). Replace outside uses of the reduced value with uses; // of the first-iteration reduced value (in other words, reroll the selected; // reductions).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:1591,Integrability,depend,dependency,1591," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:67,Modifiability,variab,variable,67,"// Reroll the provided loop with respect to the provided induction variable.; // Generally, we're looking for a loop like this:; //; // %iv = phi [ (preheader, ...), (body, %iv.next) ]; // f(%iv); // %iv.1 = add %iv, 1 <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop in",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:2058,Security,validat,validated,2058," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:2182,Security,validat,validated,2182," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:2030,Usability,simpl,simple,2030," <-- a root increment; // f(%iv.1); // %iv.2 = add %iv, 2 <-- a root increment; // f(%iv.2); // %iv.scale_m_1 = add %iv, scale-1 <-- a root increment; // f(%iv.scale_m_1); // ...; // %iv.next = add %iv, scale; // %cmp = icmp(%iv, ...); // br %cmp, header, exit; //; // Notably, we do not require that f(%iv), f(%iv.1), etc. be isolated groups of; // instructions. In other words, the instructions in f(%iv), f(%iv.1), etc. can; // be intermixed with eachother. The restriction imposed by this algorithm is; // that the relative order of the isomorphic instructions in f(%iv), f(%iv.1),; // etc. be the same.; //; // First, we collect the use set of %iv, excluding the other increment roots.; // This gives us f(%iv). Then we iterate over the loop instructions (scale-1); // times, having collected the use set of f(%iv.(i+1)), during which we:; // - Ensure that the next unmatched instruction in f(%iv) is isomorphic to; // the next unmatched instruction in f(%iv.(i+1)).; // - Ensure that both matched instructions don't have any external users; // (with the exception of last-in-chain reduction instructions).; // - Track the (aliasing) write set, and other side effects, of all; // instructions that belong to future iterations that come before the matched; // instructions. If the matched instructions read from that write set, then; // f(%iv) or f(%iv.(i+1)) has some dependency on instructions in; // f(%iv.(j+1)) for some j > i, and we cannot reroll the loop. Similarly,; // if any of these future instructions had side effects (could not be; // speculatively executed), and so do the matched instructions, when we; // cannot reorder those side-effect-producing instructions, and rerolling; // fails.; //; // Finally, we make sure that all loop instructions are either loop increment; // roots, belong to simple latch code, parts of validated reductions, part of; // f(%iv) or part of some f(%iv.i). If all of that is true (and all reductions; // have been validated), then we reroll the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:24,Security,validat,validated,24,"// At this point, we've validated the rerolling, and we're committed to; // making changes!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:40,Modifiability,variab,variable,40,"// First, we need to find the induction variable with respect to which we can; // reroll (there may be several possible options).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp:50,Availability,avail,available,50,// Not requiring MemorySSA and getting it only if available will split; // the loop pass pipeline when LoopRotate is being run first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp:89,Deployability,pipeline,pipeline,89,// Not requiring MemorySSA and getting it only if available will split; // the loop pass pipeline when LoopRotate is being run first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRotation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:614,Performance,perform,perform,614,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:46,Usability,Simpl,Simplification,46,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:413,Usability,Simpl,SimplifyCFG,413,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:465,Modifiability,variab,variable,465,"// Whether or not the current loop will still exist after terminator constant; // folding will be done. In theory, there are two ways how it can happen:; // 1. Loop's latch(es) become unreachable from loop header;; // 2. Loop's header becomes unreachable from method entry.; // In practice, the second situation is impossible because we only modify the; // current loop and its preheader and do not affect preheader's reachibility; // from any other block. So this variable set to true means that loop's latch; // has become unreachable from loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:176,Deployability,update,updates,176,// The blocks that have terminators with constant condition that can be; // folded. Note: fold candidates should be in L but not in any of its; // subloops to avoid complex LI updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:159,Safety,avoid,avoid,159,// The blocks that have terminators with constant condition that can be; // folded. Note: fold candidates should be in L but not in any of its; // subloops to avoid complex LI updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:176,Usability,simpl,simplify,176,"// Now, all exit blocks that are not marked as live are dead, if all their; // predecessors are in the loop. This may not be the case, as the input loop; // may not by in loop-simplify/canonical form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:482,Safety,avoid,avoid,482,"/// We need to preserve static reachibility of all loop exit blocks (this is); /// required by loop pass manager. In order to do it, we make the following; /// trick:; ///; /// preheader:; /// <preheader code>; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit, label %loop_block; /// ...; ///; /// We cannot simply remove edge from the loop to dead exit because in this; /// case dead_exit (and its successors) may become unreachable. To avoid that,; /// we insert the following fictive preheader:; ///; /// preheader:; /// <preheader code>; /// switch i32 0, label %preheader-split,; /// [i32 1, label %dead_exit_1],; /// [i32 2, label %dead_exit_2],; /// ...; /// [i32 N, label %dead_exit_N],; ///; /// preheader-split:; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit_N, label %loop_block; /// ...; ///; /// Doing so, we preserve static reachibility of all dead exits and can later; /// remove edges from the loop to these blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:352,Usability,simpl,simply,352,"/// We need to preserve static reachibility of all loop exit blocks (this is); /// required by loop pass manager. In order to do it, we make the following; /// trick:; ///; /// preheader:; /// <preheader code>; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit, label %loop_block; /// ...; ///; /// We cannot simply remove edge from the loop to dead exit because in this; /// case dead_exit (and its successors) may become unreachable. To avoid that,; /// we insert the following fictive preheader:; ///; /// preheader:; /// <preheader code>; /// switch i32 0, label %preheader-split,; /// [i32 1, label %dead_exit_1],; /// [i32 2, label %dead_exit_2],; /// ...; /// [i32 N, label %dead_exit_N],; ///; /// preheader-split:; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit_N, label %loop_block; /// ...; ///; /// Doing so, we preserve static reachibility of all dead exits and can later; /// remove edges from the loop to these blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:18,Deployability,update,updates,18,// We need all DT updates to be done before forming LCSSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:13,Deployability,update,updates,13,// Clear all updates now. Facilitates deletes that follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:3,Usability,Clear,Clear,3,// Clear all updates now. Facilitates deletes that follow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:90,Deployability,update,updates,90,/// Delete loop blocks that have become unreachable after folding. Make all; /// relevant updates to DT and LI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:116,Availability,redundant,redundant,116,"// If TheOnlySucc was BB's successor more than once, after transform it; // will be its successor only once. Remove redundant inputs from; // TheOnlySucc's Phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:116,Safety,redund,redundant,116,"// If TheOnlySucc was BB's successor more than once, after transform it; // will be its successor only once. Remove redundant inputs from; // TheOnlySucc's Phis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:15,Availability,avail,available,15,// Collect all available information about status of blocks after constant; // folding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:19,Deployability,update,updates,19,"// If we didn't do updates inside deleteDeadLoopBlocks, do them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:18,Usability,simpl,simple,18,"// To keep things simple, only process loops with single latch. We; // canonicalize most loops to this form. We can support multi-latch if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:41,Safety,avoid,avoid,41,// Copy blocks into a temporary array to avoid iterator invalidation issues; // as we remove them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:1097,Safety,avoid,avoid,1097,"/// Return a set of basic blocks to insert sinked instructions.; ///; /// The returned set of basic blocks (BBsToSinkInto) should satisfy:; ///; /// * Inside the loop \p L; /// * For each UseBB in \p UseBBs, there is at least one BB in BBsToSinkInto; /// that domintates the UseBB; /// * Has minimum total frequency that is no greater than preheader frequency; ///; /// The purpose of the function is to find the optimal sinking points to; /// minimize execution cost, which is defined as ""sum of frequency of; /// BBsToSinkInto"".; /// As a result, the returned BBsToSinkInto needs to have minimum total; /// frequency.; /// Additionally, if the total frequency of BBsToSinkInto exceeds preheader; /// frequency, the optimal solution is not sinking (return empty set).; ///; /// \p ColdLoopBBs is used to help find the optimal sinking locations.; /// It stores a list of BBs that is:; ///; /// * Inside the loop \p L; /// * Has a frequency no larger than the loop's preheader; /// * Sorted by BB frequency; ///; /// The complexity of the function is O(UseBBs.size() * ColdLoopBBs.size()).; /// To avoid expensive computation, we cap the maximum UseBBs.size() in its; /// caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:93,Safety,avoid,avoid,93,// findBBsToSinkInto is O(BBs.size() * ColdLoopBBs.size()). We cap the max; // BBs.size() to avoid expensive computation.; // FIXME: Handle code size growth for min_size and opt_size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:10,Performance,Optimiz,Optimize,10,// FIXME: Optimize the efficiency for cloned value replacement. The current; // implementation is O(SortedBBsToSinkInto.size() * I.num_uses()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:64,Security,access,access,64,// Create a new MemoryAccess and let MemorySSA set its defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:88,Safety,avoid,avoid,88,// If there are no basic blocks with lower frequency than the preheader then; // we can avoid the detailed analysis as we will never find profitable sinking; // opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:67,Integrability,depend,depends,67,"// Traverse preheader's instructions in reverse order because if A depends; // on B (A appears after B), A needs to be sunk first before B can be; // sinked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:48,Availability,avail,available,48,"// Enable LoopSink only when runtime profile is available.; // With static profile, the sinking decision may be sub-optimal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:797,Availability,avail,available,797,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:41,Energy Efficiency,Reduce,Reduce,41,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:516,Energy Efficiency,efficient,efficient,516,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:441,Modifiability,variab,variables,441,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:704,Modifiability,variab,variable,704,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:721,Modifiability,rewrite,rewrites,721,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:901,Modifiability,variab,variables,901,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1590,Modifiability,variab,variable,1590," a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands to make it a; // smaller encoding (on x86 at least).; //; // TODO: When a negated register is used by an add (such as in a list of; // multiple base registers, or as the increment expression in an addrec),; // we may not actually need both reg and (-1 * reg) in registers; the; // negation can be implemented by using a sub instead of an add. The; // lack of support for taking this into consideration when making; // register pressure decisions is partly worked around by the ""Special""; // use kind.; //; //===---------------------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:573,Performance,perform,performs,573,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:829,Performance,perform,performs,829,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:857,Performance,optimiz,optimizations,857,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:10,Testability,test,test,10,// Stress test IV chain generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,Security,access,accessed,33,/// Used in situations where the accessed memory type is unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update RegUses. The data structure is not optimized for this purpose;; // we must iterate through it and update each of the bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:108,Deployability,update,update,108,// Update RegUses. The data structure is not optimized for this purpose;; // we must iterate through it and update each of the bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:45,Performance,optimiz,optimized,45,// Update RegUses. The data structure is not optimized for this purpose;; // we must iterate through it and update each of the bit vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test if this formula references the given register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether this formula uses registers which are used by uses other than; /// the use with the given index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:48,Modifiability,extend,extended,48,/// Return true if the given addrec can be sign-extended without changing its; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:45,Modifiability,extend,extended,45,/// Return true if the given add can be sign-extended without changing its; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:45,Modifiability,extend,extended,45,/// Return true if the given mul can be sign-extended without changing its; /// value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:204,Usability,simpl,simplified,204,"/// Return an expression for LHS /s RHS, if it can be determined and if the; /// remainder is known to be zero, or null otherwise. If IgnoreSignificantBits; /// is true, expressions like (X * Y) /s Y are simplified to X, ignoring that; /// the multiplication may overflow, which is useful when the result will be; /// used in a context where the most significant bits are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:40,Security,access,accessed,40,/// Return the type of the memory being accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Security,access,accessed,38,// First get the type of memory being accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:108,Energy Efficiency,reduce,reduced,108,"/// An operand value in an instruction which is to be replaced with some; /// equivalent, possibly strength-reduced, replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:34,Deployability,update,updated,34,/// The instruction which will be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:75,Modifiability,variab,variable,75,"/// If this user is to use the post-incremented value of an induction; /// variable, this set is non-empty and holds the loops associated with the; /// induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:162,Modifiability,variab,variable,162,"/// If this user is to use the post-incremented value of an induction; /// variable, this set is non-empty and holds the loops associated with the; /// induction variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Modifiability,variab,variables,60,// It is bad to allow LSR for current loop to add induction variables; // for its sibling loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether this fixup always uses its value outside of the given loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether this use as a formula which has the same registers as the given; /// formula.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:34,Deployability,update,update,34,"/// Recompute the Regs field, and update RegUses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update the RegTracker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Testability,Test,Test,4,/// Test whether we know how to expand the current formula.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:64,Testability,log,logic,64,/// This class holds state for the main loop strength reduction logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:66,Modifiability,variab,variable,66,"/// This is the insert position that the current loop's induction variable; /// increment should be placed. In simple loops, this is the latch block's; /// terminator. But in more complicated cases, this is a position which will; /// dominate all the in-loop post-increment users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:111,Usability,simpl,simple,111,"/// This is the insert position that the current loop's induction variable; /// increment should be placed. In simple loops, this is the latch block's; /// terminator. But in more complicated cases, this is a position which will; /// dominate all the in-loop post-increment users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,Safety,avoid,avoid,33,// Limit the number of chains to avoid quadratic behavior. We don't expect to; // have more than a few IV increment chains in a loop. Missing a Chain falls; // back to normal LSR behavior for those uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:14,Modifiability,variab,variables,14,/// Induction variables that were generated and inserted by the SCEV Expander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:109,Usability,simpl,simple,109,"// NOTE: we could handle setcc instructions with multiple uses here, but; // InstCombine does it as well for simple uses, it's not clear that it; // occurs enough in real life to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Usability,clear,clear,131,"// NOTE: we could handle setcc instructions with multiple uses here, but; // InstCombine does it as well for simple uses, it's not clear that it; // occurs enough in real life to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:897,Modifiability,variab,variable,897,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1034,Modifiability,variab,variables,1034,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1407,Modifiability,variab,variable,1407,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:654,Performance,optimiz,optimization,654,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1612,Safety,detect,detecting,1612,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:461,Testability,test,test,461,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:690,Testability,test,test,690,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:778,Testability,test,test,778,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1329,Usability,simpl,simple,1329,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:53,Performance,optimiz,optimization,53,"// To handle a max with more than two operands, this optimization would; // require additional checking and setup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:32,Modifiability,variab,variable,32,// Check the relevant induction variable for conformance to; // the pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:211,Energy Efficiency,reduce,reduce,211,"// We need a different set of heuristics for rotated and non-rotated loops.; // If a loop is rotated then the latch is also the backedge, so inserting; // post-inc expressions just before the latch is ideal. To reduce live ranges; // it also makes sense to rewrite terminating conditions to use post-inc; // expressions.; //; // If the loop is not rotated then the latch is not a backedge; the latch; // check is done in the loop head. Adding post-inc expressions before the; // latch will cause overlapping live-ranges of pre-inc and post-inc expressions; // in the loop body. In this case we do *not* want to use post-inc expressions; // in the latch check, and we want to insert post-inc expressions before; // the backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:257,Modifiability,rewrite,rewrite,257,"// We need a different set of heuristics for rotated and non-rotated loops.; // If a loop is rotated then the latch is also the backedge, so inserting; // post-inc expressions just before the latch is ideal. To reduce live ranges; // it also makes sense to rewrite terminating conditions to use post-inc; // expressions.; //; // If the loop is not rotated then the latch is not a backedge; the latch; // check is done in the loop head. Adding post-inc expressions before the; // latch will cause overlapping live-ranges of pre-inc and post-inc expressions; // in the loop body. In this case we do *not* want to use post-inc expressions; // in the latch check, and we want to insert post-inc expressions before; // the backedge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Testability,test,tested,60,// The backedge doesn't exit the loop; treat this as a head-tested loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:150,Modifiability,variab,variable,150,"// Get the terminating condition for the loop if possible. If we; // can, we want to change it to use a post-incremented version of its; // induction variable, to allow coalescing the live ranges for the IV into; // one register value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:266,Availability,down,down,266,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:275,Performance,optimiz,optimization,275,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:383,Safety,avoid,avoid,383,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:18,Safety,avoid,avoid,18,// Conservatively avoid trying to use the post-inc value in non-latch; // exits if there may be pre-inc users in intervening blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Testability,Test,Test,3,// Test if the use is reachable from the exiting block. This dominator; // query is a conservative approximation of reachability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Safety,Avoid,Avoid,3,// Avoid weird situations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:55,Modifiability,variab,variable,55,"// Determine an insertion point for the loop induction variable increment. It; // must dominate all the post-inc comparisons we just set up, and it must; // dominate the loop latch edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:106,Deployability,update,update,106,"/// Determine if the given use can accommodate a fixup at the given offset and; /// other details. If so, update the use and return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:26,Security,access,access,26,"// Check for a mismatched access type, and fall back conservatively as needed.; // TODO: Be less conservative when the type is similar and can use the same; // addressing modes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update the use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Security,access,access,131,"/// Return an LSRUse index and an offset value for a fixup which needs the given; /// expression, with the given kind and optional access type. Either reuse an; /// existing use or create a new one, as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,// Update RegUses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:69,Integrability,wrap,wrap,69,"/// IVChain logic must consistently peek base TruncInst operands, so wrap it in; /// a convenient helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:12,Testability,log,logic,12,"/// IVChain logic must consistently peek base TruncInst operands, so wrap it in; /// a convenient helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:382,Safety,avoid,avoids,382,"/// Return an approximation of this SCEV expression's ""base"", or NULL for any; /// constant. Returning the expression itself is conservative. Returning a; /// deeper subexpression is more precise and valid as long as it isn't less; /// complex than another subexpression. For expressions involving multiple; /// unscaled values, we need to return the pointer-type SCEVUnknown. This avoids; /// forming chains across objects, such as: PrevOper==a[i], IVOper==b[i],; /// IVInc==b-a.; ///; /// Since SCEVUnknown is the rightmost type, and pointers are the rightmost; /// SCEVUnknown, we simply return the rightmost SCEV operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:584,Usability,simpl,simply,584,"/// Return an approximation of this SCEV expression's ""base"", or NULL for any; /// constant. Returning the expression itself is conservative. Returning a; /// deeper subexpression is more precise and valid as long as it isn't less; /// complex than another subexpression. For expressions involving multiple; /// unscaled values, we need to return the pointer-type SCEVUnknown. This avoids; /// forming chains across objects, such as: PrevOper==a[i], IVOper==b[i],; /// IVInc==b-a.; ///; /// Since SCEVUnknown is the rightmost type, and pointers are the rightmost; /// SCEVUnknown, we simply return the rightmost SCEV operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:138,Modifiability,extend,extended,138,"// Materializing increment expressions in the preheader that didn't exist in; // the original code may cost a register. For example, sign-extended array; // indices can produce ridiculous increments like this:; // IV + ((sext i32 (2 * %s) to i64) + (-1 * (sext i32 %s to i64)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:11,Modifiability,variab,variable,11,// Reusing variable increments likely saves a register to hold the multiple of; // the stride.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:231,Safety,avoid,avoids,231,"// Prune the solution space aggressively by checking that both IV operands; // are expressions that operate on the same unscaled SCEVUnknown. This; // ""base"" will be canceled by the subsequent getMinusSCEV call. Checking; // first avoids creating extra SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:666,Availability,redundant,redundant,666,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:537,Energy Efficiency,schedul,scheduling,537,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:745,Energy Efficiency,schedul,scheduler,745,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:336,Modifiability,variab,variables,336,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:666,Safety,redund,redundant,666,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,Availability,down,down,20,// Continue walking down the instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,Availability,down,down,20,// Continue walking down the domtree.; // Visit phi backedges to determine if the chain can generate the IV postinc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:50,Modifiability,rewrite,rewrite,50,"// Equality (== and !=) ICmps are special. We can rewrite (i == N) as; // (N - i == 0), and this allows (N - i) to be the expression that we work; // with rather than just N or i, so we can consider the register; // requirements for both N and i at the same time. Limiting this code to; // equality icmps is not a problem because all interesting loops use; // equality icmps, thanks to IndVarSimplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:80,Energy Efficiency,Power,PowerPC,80,"// If CI can be saved in some target, like replaced inside hardware loop; // in PowerPC, no need to generate initial formulae for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:145,Integrability,wrap,wrap,145,"// If we can't generally expand the expression (e.g. it contains; // a divide), but it is already at a loop invariant point before the; // loop, wrap it in an unknown (to prevent the expander from trying; // to re-expand in a potentially unsafe way.) The restriction to; // integer types is required because the unknown hides the base, and; // SCEV can't compute the difference of two unknown pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:238,Safety,unsafe,unsafe,238,"// If we can't generally expand the expression (e.g. it contains; // a divide), but it is already at a loop invariant point before the; // loop, wrap it in an unknown (to prevent the expander from trying; // to re-expand in a potentially unsafe way.) The restriction to; // integer types is required because the unknown hides the base, and; // SCEV can't compute the difference of two unknown pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:13,Usability,simpl,simple,13,/// Insert a simple single-register formula for the given expression into the; /// given use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:330,Modifiability,rewrite,rewrite,330,"// Ignore cases in which the currently-examined value could come from; // a basic block terminated with an EHPad. This checks all incoming; // blocks of the phi node since it is possible that the same incoming; // value comes from multiple basic blocks, only some of which may end; // in an EHPad. If any of them do, a subsequent rewrite attempt by this; // pass would try to insert instructions into an EHPad, hitting an; // assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:426,Testability,assert,assertion,426,"// Ignore cases in which the currently-examined value could come from; // a basic block terminated with an EHPad. This checks all incoming; // blocks of the phi node since it is possible that the same incoming; // value comes from multiple basic blocks, only some of which may end; // in an EHPad. If any of them do, a subsequent rewrite attempt by this; // pass would try to insert instructions into an EHPad, hitting an; // assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Safety,avoid,avoid,60,"// Ignore uses which are part of other SCEV expressions, to avoid; // analyzing them multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:27,Performance,load,load,27,// Check if a post-indexed load/store can be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:262,Energy Efficiency,efficient,efficient,262,"// Don't generate reassociations for the base register of a value that; // may generate a post-increment operator. The reason is that the; // reassociations cause extra base+register formula to be created,; // and possibly chosen, but the post-increment is more efficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:58,Deployability,update,update,58,"// If it cancelled out, drop the base register, otherwise update it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:278,Deployability,update,updates,278,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:73,Security,access,accesses,73,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:127,Security,access,access,127,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:214,Security,access,access,214,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:266,Security,access,access,266,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:354,Security,access,accesses,354,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:411,Security,access,access,411,"// With constant offsets and constant steps, we can generate pre-inc; // accesses by having the offset equal the step. So, for access #0 with a; // step of 8, we generate a G - 8 base which would require the first access; // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer; // for itself and hopefully becomes the base for other accesses. This means; // means that a single pre-indexed access can be generated to become the new; // base pointer for each iteration of the loop, resulting in no extra add/sub; // instructions for pointer updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:23,Performance,optimiz,optimized,23,// TODO: This could be optimized to avoid all the copying.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:36,Safety,avoid,avoid,36,// TODO: This could be optimized to avoid all the copying.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Modifiability,Extend,Extend,4,"/// Extend/Truncate \p Expr to \p ToTy considering post-inc uses in \p Loops.; /// For all PostIncLoopSets in \p Loops, first de-normalize \p Expr, then; /// perform the extension/truncate and normalize again, as the normalized form; /// can result in folds that are not valid in the post-inc use contexts. The; /// expressions for all PostIncLoopSets must match, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:158,Performance,perform,perform,158,"/// Extend/Truncate \p Expr to \p ToTy considering post-inc uses in \p Loops.; /// For all PostIncLoopSets in \p Loops, first de-normalize \p Expr, then; /// perform the extension/truncate and normalize again, as the normalized form; /// can result in folds that are not valid in the post-inc use contexts. The; /// expressions for all PostIncLoopSets must match, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:20,Modifiability,extend,extend,20,// It is invalid to extend a pointer type so exit early if ScaledReg or; // any of the BaseRegs are pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:59,Integrability,depend,depend,59,"// Some formulas are instant losers. For example, they may depend on; // nonexistent AddRecs from other loops. These need to be filtered; // immediately, otherwise heuristics could choose them over others leading; // to an unsatisfactory solution. Passing LoserRegs into RateFormula here; // avoids the need to recompute this information across formulae using the; // same bad AddRec. Passing LoserRegs is also essential unless we remove; // the corresponding bad register from the Regs set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:292,Safety,avoid,avoids,292,"// Some formulas are instant losers. For example, they may depend on; // nonexistent AddRecs from other loops. These need to be filtered; // immediately, otherwise heuristics could choose them over others leading; // to an unsatisfactory solution. Passing LoserRegs into RateFormula here; // avoids the need to recompute this information across formulae using the; // same bad AddRec. Passing LoserRegs is also essential unless we remove; // the corresponding bad register from the Regs set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:93,Energy Efficiency,reduce,reduce,93,"/// When one formula uses a superset of the registers of another formula, it; /// won't help reduce register pressure (though it may not necessarily hurt; /// register pressure); remove it to simplify the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:192,Usability,simpl,simplify,192,"/// When one formula uses a superset of the registers of another formula, it; /// won't help reduce register pressure (though it may not necessarily hurt; /// register pressure); remove it to simplify the system.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:46,Integrability,wrap,wrapping,46,//FIXME: Formulas should store bitwidth to do wrapping properly.; // See PR41034.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:79,Energy Efficiency,allocate,allocate,79,"/// When there are many registers for expressions like A, A+1, A+2, etc.,; /// allocate a single register for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:607,Safety,avoid,avoid,607,"/// If a LSRUse has multiple formulae with the same ScaledReg and Scale.; /// Pick the best one and delete the others.; /// This narrowing heuristic is to keep as many formulae with different; /// Scale and ScaledReg pair as possible while narrowing the search space.; /// The benefit is that it is more likely to find out a better solution; /// from a formulae set with more Scale and ScaledReg variations than; /// a formulae set with the same Scale and ScaledReg. The picking winner; /// reg heuristic will often keep the formulae with the same Scale and; /// ScaledReg and filter others, and we want to avoid that if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:80,Modifiability,variab,variables,80,"/// If we are over the complexity limit, filter out any post-inc prefering; /// variables to only post-inc values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Performance,perform,performance,38,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Safety,avoid,avoid,131,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,Testability,test,test,33,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:62,Usability,simpl,simple,62,"// With all other options exhausted, loop until the system is simple; // enough to handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:46,Usability,simpl,simpler,46,"// If the scores are the same, but the Reg is simpler for the target; // (for example {x,+,1} as opposed to {x+C,+,1}, where the target can; // handle +C but not -C), opt for the simpler formula.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:179,Usability,simpl,simpler,179,"// If the scores are the same, but the Reg is simpler for the target; // (for example {x,+,1} as opposed to {x+C,+,1}, where the target can; // handle +C but not -C), opt for the simpler formula.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:109,Availability,down,down,109,"/// If there are an extraordinary number of formulae to choose from, use some; /// rough heuristics to prune down the number of formulae. This keeps the main; /// solver from taking an extraordinary amount of time in some worst-case; /// scenarios.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:79,Usability,clear,clear,79,"// If none of the formulae satisfied the required registers, then we could; // clear ReqRegs and try again. Currently, we simply give up in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:122,Usability,simpl,simply,122,"// If none of the formulae satisfied the required registers, then we could; // clear ReqRegs and try again. Currently, we simply give up in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:14,Modifiability,Rewrite,Rewriter,14,"// Inform the Rewriter if we have a post-increment use, so that it can; // perform an advantageous expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:75,Performance,perform,perform,75,"// Inform the Rewriter if we have a post-increment use, so that it can; // perform an advantageous expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:42,Modifiability,rewrite,rewriter,42,"// We're done expanding now, so reset the rewriter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:154,Deployability,update,update,154,"// An ICmpZero Formula represents an ICmp which we're handling as a; // comparison against zero. Now that we've expanded an expression for that; // form, update the ICmp's other operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:15,Modifiability,Rewrite,Rewrite,15,"/// Helper for Rewrite. PHI nodes are special because the use of their operands; /// effectively happens in their predecessor blocks, so the expression may need; /// to be expanded in multiple places.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:111,Usability,simpl,simple,111,"// If NewBB==NULL, then SplitCriticalEdge refused to split because all; // phi predecessors are identical. The simple thing to do is skip; // splitting in this case rather than complicate the API.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:26,Energy Efficiency,reduce,reduce,26,// Splitting the edge can reduce the number of PHI entries we have.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:93,Deployability,update,update,93,"// If LSR splits critical edge and phi node has other pending; // fixup operands, we need to update those pending fixups. Otherwise; // formulae will not be implemented completely and some instructions; // will not be eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:77,Deployability,update,updated,77,"// If fixup is supposed to rewrite some operand in the phi; // that was just updated, it may be already moved to; // another phi node. Such fixup requires update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:155,Deployability,update,update,155,"// If fixup is supposed to rewrite some operand in the phi; // that was just updated, it may be already moved to; // another phi node. Such fixup requires update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:27,Modifiability,rewrite,rewrite,27,"// If fixup is supposed to rewrite some operand in the phi; // that was just updated, it may be already moved to; // another phi node. Such fixup requires update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:59,Deployability,update,update,59,// Otherwise it might be moved to another PHI and requires update.; // If fixup operand not found in any of the incoming blocks that; // means we have already rewritten it - nothing to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:114,Deployability,update,update,114,"/// Emit instructions for the leading candidate expression for this LSRUse (this; /// is called ""expanding""), and update the UserInst to reference the newly; /// expanded value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Update,Update,3,"// Update the user. ICmpZero is handled specially here (for now) because; // Expand may have updated one of the operands of the icmp already, and; // its new value may happen to be equal to LF.OperandValToReplace, in; // which case doing replaceUsesOfWith leads to replacing both operands; // with the same value. TODO: Reorganize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:93,Deployability,update,updated,93,"// Update the user. ICmpZero is handled specially here (for now) because; // Expand may have updated one of the operands of the icmp already, and; // its new value may happen to be equal to LF.OperandValToReplace, in; // which case doing replaceUsesOfWith leads to replacing both operands; // with the same value. TODO: Reorganize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:135,Performance,load,load,135,// Trying to hoist the IVInc to loop header if all IVInc users are in; // the loop header. It will help backend to generate post index load/store; // when the latch block is different from loop header block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:41,Performance,optimiz,optimization,41,"// For now this code do the conservative optimization, only work for; // the header block. Later we can hoist the IVInc to the block post; // dominate all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite all the fixup locations with new values, following the chosen; /// solution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:40,Deployability,update,update,40,// Expand the new value definitions and update the users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:403,Energy Efficiency,schedul,schedule,403,"// In our cost analysis above, we assume that each addrec consumes exactly; // one register, and arrange to have increments inserted just before the; // latch to maximimize the chance this is true. However, if we reused; // existing IVs, we now need to move the increments to match our; // expectations. Otherwise, our cost modeling results in us having a; // chosen a non-optimal result for the actual schedule. (And yes, this; // scheduling decision does impact later codegen.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:432,Energy Efficiency,schedul,scheduling,432,"// In our cost analysis above, we assume that each addrec consumes exactly; // one register, and arrange to have increments inserted just before the; // latch to maximimize the chance this is true. However, if we reused; // existing IVs, we now need to move the increments to match our; // expectations. Otherwise, our cost modeling results in us having a; // chosen a non-optimal result for the actual schedule. (And yes, this; // scheduling decision does impact later codegen.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:18,Energy Efficiency,schedul,schedule,18,// Can we legally schedule inc at the desired point?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:31,Availability,avail,available,31,"// If LoopSimplify form is not available, stay out of trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Modifiability,Config,Configure,3,"// Configure SCEVExpander already now, so the correct mode is used for; // isSafeToExpand() checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:10,Performance,perform,perform,10,"// First, perform some low-level loop optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Performance,optimiz,optimizations,38,"// First, perform some low-level loop optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:161,Performance,optimiz,optimization,161,"// Start collecting data and preparing for the solver.; // If number of registers is not the major cost, we cannot benefit from the; // current profitable chain optimization which is based on number of; // registers.; // FIXME: add profitable chain optimization for other kinds major cost, for; // example number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:249,Performance,optimiz,optimization,249,"// Start collecting data and preparing for the solver.; // If number of registers is not the major cost, we cannot benefit from the; // current profitable chain optimization which is based on number of; // registers.; // FIXME: add profitable chain optimization for other kinds major cost, for; // example number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Deployability,Release,Release,3,// Release memory that is no longer needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:65,Deployability,update,update,65,"// We split critical edges, so we change the CFG. However, we do update; // many analyses if they are around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:118,Modifiability,extend,extended,118,/// Several SCEV types are sequences of the same arithmetic operator applied; /// to constants and values that may be extended or truncated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:65,Testability,test,test,65,// TODO: MinMax - although these haven't been encountered in the test suite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:3,Testability,Assert,Assert,3,// Assert if a new and unknown SCEVCastEXpr type is encountered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:83,Availability,recover,recovers,83,/// Combine a translation of the SCEV and the IV to create an expression that; /// recovers a location's value.; /// returns true if an expression was created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:83,Safety,recover,recovers,83,/// Combine a translation of the SCEV and the IV to create an expression that; /// recovers a location's value.; /// returns true if an expression was created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:119,Availability,recover,recovery,119,// Initialise a new builder with the iteration count expression. In; // combination with the value's SCEV this enables recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:119,Safety,recover,recovery,119,// Initialise a new builder with the iteration count expression. In; // combination with the value's SCEV this enables recovery.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:86,Energy Efficiency,reduce,reduce,86,"/// Write the new expression and new location ops for the dbg.value. If possible; /// reduce the szie of the dbg.value intrinsic by omitting DIArglist. This; /// can be omitted if:; /// 1. There is only a single location, refenced by a single DW_OP_llvm_arg.; /// 2. The DW_OP_LLVM_arg is the first operand in the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:165,Availability,avail,available,165,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Performance,Cache,Cached,4,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:114,Performance,cache,cache,114,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:107,Deployability,update,update,107,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:183,Deployability,update,updated,183,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,Safety,avoid,avoiding,60,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:23,Deployability,update,updated,23,// Most Ops needn't be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:127,Deployability,update,updated,127,"// The location doesn't have s SCEVDbgValueBuilder, so LSR did not; // optimise it away. So just translate the argument to the updated; // location index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:22,Availability,recover,recovery,22,// The location has a recovery expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:22,Safety,recover,recovery,22,// The location has a recovery expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Availability,recover,recover,38,// The iteration count is required to recover location values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Safety,recover,recover,38,// The iteration count is required to recover location values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:17,Performance,cache,cache,17,/// Identify and cache salvageable DVI locations and expressions along with the; /// corresponding SCEV(s). Also ensure that the DVI is not deleted between; /// cacheing and salvaging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:161,Performance,cache,cacheing,161,/// Identify and cache salvageable DVI locations and expressions along with the; /// corresponding SCEV(s). Also ensure that the DVI is not deleted between; /// cacheing and salvaging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:72,Performance,cache,cached,72,// Ensure that if any location op is undef that the dbg.vlue is not; // cached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:63,Availability,recover,recover,63,// Each location Op may need a SCEVDbgValueBuilder in order to recover; // it. Pre-allocating a vector will enable quick lookups of the builder; // later during the salvage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:63,Safety,recover,recover,63,// Each location Op may need a SCEVDbgValueBuilder in order to recover; // it. Pre-allocating a vector will enable quick lookups of the builder; // later during the salvage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:116,Usability,usab,usable,116,"/// Ideally pick the PHI IV inserted by ScalarEvolutionExpander. As a fallback; /// any PHi from the loop header is usable, but may have less chance of; /// surviving subsequent transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:19,Usability,simpl,simple,19,// Only inspect on simple loop structure,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,Deployability,pipeline,pipeline,131,"// We could pattern match the inverse form of the icmp, but that is; // non-canonical, and this pass is running *very* late in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:34,Modifiability,rewrite,rewrite,34,"// If that IV isn't dead after we rewrite the exit condition in terms of; // another IV, there's no point in doing the transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:206,Integrability,wrap,wrap,206,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:296,Integrability,wrap,wrap,296,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:356,Testability,test,test,356,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:459,Usability,simpl,simplest,459,"// Check that we can compute the value of AddRec on the exiting iteration; // without soundness problems. evaluateAtIteration internally needs; // to multiply the stride of the iteration number - which may wrap around.; // The issue here is subtle because computing the result accounting for; // wrap is insufficient. In order to use the result in an exit test, we; // must also know that AddRec doesn't take the same value on any previous; // iteration. The simplest case to consider is a candidate IV which is; // narrower than the trip count (and thus original IV), but this can; // also happen due to non-unit strides on the candidate IVs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:15,Performance,perform,perform,15,"// In order to perform the transform, we need to drop the poison generating; // flags on this instruction (if any).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:302,Deployability,update,updates,302,"// LSR may at times remove all uses of an induction variable from a loop.; // The only remaining use is the PHI in the exit block.; // When this is the case, if the exit value of the IV can be calculated using; // SCEV, we can replace the exit block PHI with the final value of the IV and; // skip the updates in each loop iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:52,Modifiability,variab,variable,52,"// LSR may at times remove all uses of an induction variable from a loop.; // The only remaining use is the PHI in the exit block.; // When this is the case, if the exit value of the IV can be calculated using; // SCEV, we can replace the exit block PHI with the final value of the IV and; // skip the updates in each loop iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,Modifiability,rewrite,rewrite,38,// Obtain relevant IVs and attempt to rewrite the salvageable DVIs with; // expressions composed using the derived iteration count.; // TODO: Allow for multiple IV references for nested AddRecSCEVs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp:99,Performance,perform,performance,99,"// If we are explicitly unroll and jamming, we are done. Otherwise there are a; // number of extra performance heuristics to check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp:115,Performance,load,loads,115,"// Limit to loops where there is something to gain from unrolling and; // jamming the loop. In this case, look for loads that are invariant in the; // outer loop and can become shared.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:406,Usability,simpl,simple,406,"//===- LoopUnroll.cpp - Loop unroller pass --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements a simple loop unroller. It works best when loops have; // been canonicalized by the -indvars pass, allowing it to determine the trip; // counts of loops easily.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:103,Performance,perform,performed,103,/// A magic value for use with the Threshold parameter to indicate; /// that the loop unroll should be performed regardless of how much; /// code expansion would result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:195,Security,hash,hashing,195,"/// A struct to densely store the state of an instruction after unrolling at; /// each iteration.; ///; /// This is designed to work like a tuple of <Instruction *, int> for the; /// purposes of hashing and lookup, but to be able to associate two boolean; /// states with each key.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:4,Security,Hash,Hashing,4,/// Hashing and equality testing for a set of the instruction states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:25,Testability,test,testing,25,/// Hashing and equality testing for a set of the instruction states.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:235,Integrability,rout,routine,235,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:128,Performance,load,loads,128,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:202,Performance,optimiz,optimization,202,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:263,Performance,optimiz,optimization,263,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:183,Security,expose,expose,183,"// end anonymous namespace; /// Figure out if the loop is worth full unrolling.; ///; /// Complete loop unrolling can make some loads constant, and we need to know; /// if that would expose any further optimization opportunities. This routine; /// estimates this optimization. It computes cost of unrolled loop; /// (UnrolledCost) and dynamic cost of the original loop (RolledDynamicCost). By; /// dynamic cost we mean that we won't count costs of blocks that are known not; /// to be executed (i.e. if we have a branch in the loop and we know that at the; /// given iteration its condition would be resolved to true, we won't add up the; /// cost of the 'false'-block).; /// \returns Optional value, holding the RolledDynamicCost and UnrolledCost. If; /// the analysis failed (no benefits expected from the unrolling, or the loop is; /// too big to analyze), the returned value is std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:87,Usability,simpl,simplifying,87,// The estimated cost of the unrolled form of the loop. We try to estimate; // this by simplifying as much as we can while computing the estimate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:211,Energy Efficiency,reduce,reduced,211,"// We also track the estimated dynamic (that is, actually executed) cost in; // the rolled form. This helps identify cases when the savings from unrolling; // aren't just exposing dead control flows, but actual reduced dynamic; // instructions due to the simplifications which we expect to occur after; // unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:255,Usability,simpl,simplifications,255,"// We also track the estimated dynamic (that is, actually executed) cost in; // the rolled form. This helps identify cases when the savings from unrolling; // aren't just exposing dead control flows, but actual reduced dynamic; // instructions due to the simplifications which we expect to occur after; // unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:16,Usability,simpl,simplification,16,"// We track the simplification of each instruction in each iteration. We use; // this to recursively merge costs into the unrolled cost on-demand so that; // we don't count the cost of any dead code. This is essentially a map from; // <instruction, int> to <bool, bool>, but stored as a densely packed struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:108,Usability,simpl,simply,108,"// We must count the cost of every operand which is not free,; // recursively. If we reach a loop PHI node, simply add it to the set; // to be considered on the next iteration (backwards!).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:125,Performance,load,load,125,"// Simulate execution of each iteration of the loop counting instructions,; // which would be simplified.; // Since the same load will take different values on different iterations,; // we literally have to go through all loop's iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:94,Usability,simpl,simplified,94,"// Simulate execution of each iteration of the loop counting instructions,; // which would be simplified.; // Since the same load will take different values on different iterations,; // we literally have to go through all loop's iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:47,Usability,simpl,simplified,47,// Prepare for the iteration by collecting any simplified entry or backedge; // inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:7,Usability,clear,clear,7,// Now clear and re-populate the map for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:27,Performance,cache,cache,27,"// Note that we *must not* cache the size, this loop grows the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:121,Performance,optimiz,optimization,121,"// Visit all instructions in the given basic block and try to simplify; // it. We don't change the actual IR, just count optimization; // opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:62,Usability,simpl,simplify,62,"// Visit all instructions in the given basic block and try to simplify; // it. We don't change the actual IR, just count optimization; // opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:91,Usability,simpl,simplified,91,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:122,Usability,simpl,simplified,122,// Add in the live successors by first checking whether we have terminator; // that may be simplified based on the values simplified by this call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:18,Performance,optimiz,optimization,18,"// If we found no optimization opportunities on the first iteration, we; // won't find them on later ones too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce unroll count to be modulo of TripCount for partial unrolling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:78,Energy Efficiency,power,power-of-two,78,"// If there is no Count that is modulo of TripCount, set Count to; // largest power-of-two factor that satisfies the threshold limit.; // As we'll create fixup loop, do the type of unrolling only if; // remainder loop is allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:466,Modifiability,refactor,refactored,466,"// Returns true if unroll count was set explicitly.; // Calculates unroll count and writes it to UP.Count.; // Unless IgnoreUser is true, will also use metadata and command-line options; // that are specific to to the LoopUnroll pass (which, for instance, are; // irrelevant for the LoopUnrollAndJam pass).; // FIXME: This function is used by LoopUnroll and LoopUnrollAndJam, but consumes; // many LoopUnroll-specific options. The shared functionality should be; // refactored into it own function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:58,Testability,test,testing,58,// Use an explicit peel count that has been specified for testing. In this; // case it's not permitted to also specify an explicit unroll count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:89,Testability,test,test,89,// 3rd priority is exact full unrolling. This will eliminate all copies; // of some exit test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:521,Safety,predict,predictor,521,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:241,Testability,test,test,241,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:273,Testability,test,tests,273,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:408,Testability,test,test,408,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:439,Testability,test,tests,439,"// 4th priority is bounded unrolling.; // We can unroll by the upper bound amount if it's generally allowed or if; // we know that the loop is executed either the upper bound or zero times.; // (MaxOrZero unrolling keeps only the first loop test, so the number of; // loop tests remains the same compared to the non-unrolled version, whereas; // the generic upper bound unrolling keeps all but the last loop test so the; // number of loop tests goes up which may end up being worse on targets with; // constrained branch predictor resources so is controlled by an option.); // In addition we only unroll small upper bounds.; // Note that the cost of bounded unrolling is always strictly greater than; // cost of exact full unrolling. As such, if we have an exact count and; // found it unprofitable, we'll never chose to bounded unroll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:64,Availability,avail,available,64,// Check if the runtime trip count is too small when profile is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce unroll count to be the largest power-of-two factor of; // the original count which satisfies the threshold limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:41,Energy Efficiency,power,power-of-two,41,// Reduce unroll count to be the largest power-of-two factor of; // the original count which satisfies the threshold limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:45,Safety,avoid,avoid,45,"// If this loop isn't forced to be unrolled, avoid unrolling it when the; // parent loop has an explicit unroll-and-jam pragma. This is to prevent; // automatic unrolling from interfering with the user requested; // transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:45,Safety,avoid,avoid,45,"// If this loop isn't forced to be unrolled, avoid unrolling it when the; // loop has an explicit unroll-and-jam pragma. This is to prevent automatic; // unrolling from interfering with the user requested transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:8,Performance,optimiz,optimizing,8,"// When optimizing for size, use LoopSize + 1 as threshold (we use < Threshold; // later), to (fully) unroll loops, if it does not increase code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:670,Energy Efficiency,power,powerful,670,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:178,Integrability,depend,dependency,178,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:145,Safety,unsafe,unsafe,145,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:615,Safety,safe,safe,615,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:113,Performance,perform,perform,113,"// At this point, UP.Runtime indicates that run-time unrolling is allowed.; // However, we only want to actually perform it if we don't know the trip; // count and the unroll count doesn't divide the known trip multiple.; // TODO: This decision should probably be pushed up into; // computeUnrollCount().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the old PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:32,Performance,Optimiz,OptimizationRemarkEmitter,32,"// For the new PM, we can't use OptimizationRemarkEmitter as an analysis; // pass. Function analyses need to be preserved across loop transformations; // but ORE cannot be preserved (see comment before the pass definition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:659,Performance,optimiz,optimizations,659,"// Unrolling can do several things to introduce new loops into a loop nest:; // - Full unrolling clones child loops within the current loop but then; // removes the current loop making all of the children appear to be new; // sibling loops.; //; // When a new loop appears as a sibling loop after fully unrolling,; // its nesting structure has fundamentally changed and we want to revisit; // it to reflect that.; //; // When unrolling has removed the current loop, we need to tell the; // infrastructure that it is gone.; //; // Finally, we support a debugging/testing mode where we revisit child loops; // as well. These are not expected to require further optimizations as either; // they or the loop they were cloned from have been directly visited already.; // But the debugging mode allows us to check this assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:562,Testability,test,testing,562,"// Unrolling can do several things to introduce new loops into a loop nest:; // - Full unrolling clones child loops within the current loop but then; // removes the current loop making all of the children appear to be new; // sibling loops.; //; // When a new loop appears as a sibling loop after fully unrolling,; // its nesting structure has fundamentally changed and we want to revisit; // it to reflect that.; //; // When unrolling has removed the current loop, we need to tell the; // infrastructure that it is gone.; //; // Finally, we support a debugging/testing mode where we revisit child loops; // as well. These are not expected to require further optimizations as either; // they or the loop they were cloned from have been directly visited already.; // But the debugging mode allows us to check this assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:40,Usability,simpl,simplified,40,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:89,Usability,simpl,simplification,89,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:239,Usability,simpl,simplify,239,"// The unroller requires loops to be in simplified form, and also needs LCSSA.; // Since simplification may add new inner loops, it has to run before the; // legality and profitability checks. This means running the loop unroller; // will simplify all loops, regardless of whether anything end up being; // unrolled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:179,Performance,optimiz,optimization,179,"// Because the LoopInfo stores the loops in RPO, we walk the worklist; // from back to front so that we work forward across the CFG, which; // for unrolling is only needed to get optimization remarks emitted in; // a forward order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:141,Safety,avoid,avoid,141,"// Check if the profile summary indicates that the profiled application; // has a huge working set size, in which case we disable peeling to avoid; // bloating it further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:13,Performance,cache,cached,13,// Clear any cached analysis results for L if we removed it completely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:3,Usability,Clear,Clear,3,// Clear any cached analysis results for L if we removed it completely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1483,Performance,Perform,Perform,1483," MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop Body |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Exit Block| |Cloned Loop Exit Block|; // +--------------------+ +-----------+-",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1287,Safety,detect,detects,1287,".0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:451,Security,access,accesses,451,"//===- LoopVersioningLICM.cpp - LICM Loop Versioning ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+-----",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:939,Security,access,accesses,939,"//===- LoopVersioningLICM.cpp - LICM Loop Versioning ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+-----",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1113,Security,access,accessed,1113,"ect, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // When alias analysis is uncertain about the aliasing between any two accesses,; // it will return MayAlias. This uncertainty from alias analysis restricts LICM; // from proceeding further. In cases where alias analysis is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Pr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1644,Security,access,accesses,1644,"is is uncertain we might; // use loop versioning as an alternative.; //; // Loop Versioning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop Body |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Exit Block| |Cloned Loop Exit Block|; // +--------------------+ +-----------+----------+; // | |; // +----------+--------------+-----------+; // |; // +-----+----+; // |Join Block|; // +----------+",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:1713,Security,access,accesses,1713,"oning will create a version of the loop with aggressive aliasing; // assumptions in addition to the original with conservative (default) aliasing; // assumptions. The version of the loop making aggressive aliasing assumptions; // will have all the memory accesses marked as no-alias. These two versions of; // loop will be preceded by a memory runtime check. This runtime check consists; // of bound checks for all unique memory accessed in loop, and it ensures the; // lack of memory aliasing. The result of the runtime check determines which of; // the loop versions is executed: If the runtime check detects any memory; // aliasing, then the original loop is executed. Otherwise, the version with; // aggressive aliasing assumptions is used.; //; // Following are the top level steps:; //; // a) Perform LoopVersioningLICM's feasibility check.; // b) If loop is a candidate for versioning then create a memory bound check,; // by considering all the memory accesses in loop body.; // c) Clone original loop and set all memory accesses as no-alias in new loop.; // d) Set original loop & versioned loop as a branch target of the runtime check; // result.; //; // It transforms loop as shown below:; //; // +----------------+; // |Runtime Memcheck|; // +----------------+; // |; // +----------+----------------+----------+; // | |; // +---------+----------+ +-----------+----------+; // |Orig Loop Preheader | |Cloned Loop Preheader |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Body | |Cloned Loop Body |; // +--------------------+ +----------------------+; // | |; // +--------------------+ +----------------------+; // |Orig Loop Exit Block| |Cloned Loop Exit Block|; // +--------------------+ +-----------+----------+; // | |; // +----------+--------------+-----------+; // |; // +-----+----+; // |Join Block|; // +----------+; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:147,Safety,safe,safe,147,// We don't explicitly pass in LoopAccessInfo to the constructor since the; // loop versioning might return early due to instructions that are not safe; // for versioning. By passing the proxy instead the construction of; // LoopAccessInfo will take place only when it's necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:27,Performance,load,load,27,// Counter to track num of load & store,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Performance,Optimiz,OptimizationRemarkEmitter,3,// OptimizationRemarkEmitter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:24,Usability,simpl,simplify,24,// Loop must be in loop simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:25,Testability,test,tested,25,"// We only handle bottom-tested loop, i.e. loop in which the condition is; // checked at the end of each iteration. With that we can assume that all; // instructions in the loop are executed the same number of times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:63,Security,access,accesses,63,// Parallel loops must not have aliasing loop-invariant memory accesses.; // Hence we don't need to version anything in this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:17,Security,access,accesses,17,/// Check memory accesses in loop and confirms it's good for; /// LoopVersioningLICM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:306,Safety,avoid,avoided,306,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:223,Security,access,access,223,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:414,Security,access,access,414,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:206,Testability,assert,asserts,206,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they dont alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:167,Security,access,accesses,167,"// Alias tracker should have pointers of same data type.; //; // FIXME: check no longer effective since opaque pointers?; // If the intent is to check that the memory accesses use the; // same data type (such that LICM can promote them), then we; // can no longer see this from the pointer value types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:151,Performance,load,load,151,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:28,Safety,safe,safe,28,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:83,Safety,safe,safe,83,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:234,Safety,safe,safety,234,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:262,Security,access,accessing,262,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:23,Safety,safe,safety,23,// Check function call safety,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Safety,Avoid,Avoid,3,// Avoid loops with possiblity of throw,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:29,Performance,load,load,29,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:75,Performance,load,load,75,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:68,Usability,simpl,simple,68,// If current instruction is load instructions; // make sure it's a simple load (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:68,Usability,simpl,simple,68,// If current instruction is store instruction; // make sure it's a simple store (non atomic & non volatile),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:85,Safety,safe,safety,85,// Iterate over loop blocks and instructions of each block and check; // instruction safety.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:21,Safety,unsafe,unsafe,21,// If instruction is unsafe just return false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:43,Performance,load,load,43,// Loop should have at least one invariant load or store instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:150,Security,access,access,150,/// Checks legality for LoopVersioningLICM by considering following:; /// a) loop structure legality b) loop instruction legality; /// c) loop memory access legality.; /// Return true if legal else returns false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:21,Security,access,access,21,// Check loop memory access leagality.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:4,Deployability,Update,Update,4,/// Update loop with aggressive aliasing assumptions.; /// It marks no-alias to any pairs of memory operations by assuming; /// loop should not have any must-alias memory accesses pairs.; /// During LoopVersioningLICM legality we ignore loops having must; /// aliasing memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:171,Security,access,accesses,171,/// Update loop with aggressive aliasing assumptions.; /// It marks no-alias to any pairs of memory operations by assuming; /// loop should not have any must-alias memory accesses pairs.; /// During LoopVersioningLICM legality we ignore loops having must; /// aliasing memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:276,Security,access,accesses,276,/// Update loop with aggressive aliasing assumptions.; /// It marks no-alias to any pairs of memory operations by assuming; /// loop should not have any must-alias memory accesses pairs.; /// During LoopVersioningLICM legality we ignore loops having must; /// aliasing memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:67,Performance,load,load,67,// Iterate over each instruction of loop.; // set no-alias for all load & store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:119,Usability,simpl,simply,119,"// Check feasiblity of LoopVersioningLICM.; // If versioning found to be feasible and beneficial then proceed; // else simply return, by cleaning up memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:54,Security,access,accessed,54,"// Do loop versioning.; // Create memcheck for memory accessed inside loop.; // Clone original loop, and set blocks properly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:127,Security,access,access,127,"// Set ""llvm.mem.parallel_loop_access"" metaData to versioned loop.; // FIXME: ""llvm.mem.parallel_loop_access"" annotates memory access; // instructions, not loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:3,Deployability,Update,Update,3,// Update version loop with aggressive aliasing assumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerConstantIntrinsics.cpp:262,Usability,Simpl,Simplify,262,/// Legacy pass for lowering is.constant intrinsics out of the IR.; ///; /// When this pass is run over a function it converts is.constant intrinsics; /// into 'true' or 'false'. This complements the normal constant folding; /// to 'true' as part of Instruction Simplify passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerConstantIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerConstantIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:549,Security,expose,exposed,549,"// These default values are chosen to represent an extremely skewed outcome for; // a condition, but they leave some room for interpretation by later passes.; //; // If the documentation for __builtin_expect() was made explicit that it should; // only be used in extreme cases, we could make this ratio higher. As it stands,; // programmers may be using __builtin_expect() / llvm.expect to annotate that a; // branch is likely or unlikely to be taken.; // WARNING: these values are internal implementation detail of the pass.; // They should not be exposed to the outside of the pass, front-end codegen; // should emit @llvm.expect intrinsics instead of using these weights directly.; // Transforms should use TargetTransformInfo's getPredictableBranchThreshold().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:14,Performance,optimiz,optimized,14,"// Handle non-optimized IR code like:; // %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1); // %tobool = icmp ne i64 %expval, 0; // br i1 %tobool, label %if.then, label %if.end; //; // Or the following simpler case:; // %expval = call i1 @llvm.expect.i1(i1 %cmp, i1 1); // br i1 %expval, label %if.then, label %if.end",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp:208,Usability,simpl,simpler,208,"// Handle non-optimized IR code like:; // %expval = call i64 @llvm.expect.i64(i64 %conv1, i64 1); // %tobool = icmp ne i64 %expval, 0; // br i1 %tobool, label %if.then, label %if.end; //; // Or the following simpler case:; // %expval = call i1 @llvm.expect.i1(i1 %cmp, i1 1); // br i1 %expval, label %if.then, label %if.end",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerExpectIntrinsic.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:50,Safety,avoid,avoid,50,/// Erase \p V from \p BB and move \II forward to avoid invalidating; /// iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:919,Deployability,Update,Update,919,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:1171,Deployability,update,update,1171,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:1197,Performance,Cache,Cache,1197,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:52,Performance,load,loads,52,"/// Contains estimates of the number of operations (loads, stores, compute) required to lower a matrix operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:14,Performance,load,loads,14,/// Number of loads emitted to generate this matrix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:203,Performance,optimiz,optimizations,203,"/// Most of the time transposes can be fused with matrix multiplies or can; /// be folded away via algebraic simplifications. This is the number of; /// transposes that we failed to make ""free"" via such optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:109,Usability,simpl,simplifications,109,"/// Most of the time transposes can be fused with matrix multiplies or can; /// be folded away via algebraic simplifications. This is the number of; /// transposes that we failed to make ""free"" via such optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class representing a matrix as a set of vectors, either in row or; /// column major layout. All vectors must have the same vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:474,Performance,optimiz,optimizeTransposes,474,"/// Maps instructions to their shape information. The shape information; /// describes the shape to be used while lowering. This matches the shape of; /// the result value of the instruction, with the only exceptions being store; /// instructions and the matrix_column_major_store intrinsics. For those, the; /// shape information indicates that those instructions should be lowered; /// using shape information as well. A ValueMap is used so that when; /// sub-passes like optimizeTransposes performs RAUW the map stays; /// up-to-date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:493,Performance,perform,performs,493,"/// Maps instructions to their shape information. The shape information; /// describes the shape to be used while lowering. This matches the shape of; /// the result value of the instruction, with the only exceptions being store; /// instructions and the matrix_column_major_store intrinsics. For those, the; /// shape information indicates that those instructions should be lowered; /// using shape information as well. A ValueMap is used so that when; /// sub-passes like optimizeTransposes performs RAUW the map stays; /// up-to-date.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:138,Availability,avail,available,138,"/// List of instructions to remove. While lowering, we are not replacing all; /// users of a lowered instruction, if shape information is available and; /// those need to be removed after we finished lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:56,Deployability,pipeline,pipelines,56,/// Is this the minimal version executed in the backend pipelines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:119,Performance,cache,cache,119,"/// Return the set of vectors that a matrix value is lowered to.; ///; /// If we lowered \p MatrixVal, just return the cache result matrix. Otherwise; /// split the flat vector \p MatrixVal containing a matrix with shape \p SI; /// into vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:187,Safety,avoid,avoid,187,"/// Sink a top-level transpose inside matmuls and adds.; /// This creates and erases instructions as needed, and returns the newly; /// created instruction while updating the iterator to avoid invalidation. If; /// this returns nullptr, no new instruction was created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:3,Safety,Avoid,Avoid,3,// Avoid unnecessary work if there are no matrix intrinsics in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.; //; // Because we add to ToRemove during fusion we can't guarantee that defs; // are before uses. Change uses to poison temporarily as these should get; // removed as well.; //; // For verification, we keep track of where we changed uses to poison in; // PoisonedInsts and then check that we in fact remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.; //; // Because we add to ToRemove during fusion we can't guarantee that defs; // are before uses. Change uses to poison temporarily as these should get; // removed as well.; //; // For verification, we keep track of where we changed uses to poison in; // PoisonedInsts and then check that we in fact remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:62,Availability,error,error,62,"// If we didn't remove all poisoned instructions, it's a hard error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:167,Energy Efficiency,reduce,reduce,167,"/// Compute the alignment for a column/row \p Idx with \p Stride between them.; /// The address at \p Idx == 0 has alignment \p A. If \p Stride is a; /// ConstantInt, reduce the initial alignment based on the byte offset. For; /// non-ConstantInt strides, return the common alignment of the initial; /// alignment and the element size in bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Performance,Load,Load,4,/// Load a matrix with \p Shape starting at \p Ptr and using \p Stride between; /// vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Performance,Load,Loads,4,"/// Loads a sub-matrix with shape \p ResultShape from a \p R x \p C matrix,; /// starting at \p MatrixPtr[I][J].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:12,Performance,load,load,12,/// Lower a load instruction with shape information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:36,Performance,load,load,36,/// Lowers llvm.matrix.column.major.load.; ///; /// The intrinsic loads a matrix from memory using a stride between columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:66,Performance,load,loads,66,/// Lowers llvm.matrix.column.major.load.; ///; /// The intrinsic loads a matrix from memory using a stride between columns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:57,Availability,mask,mask,57,"// If Col is 7 long and I is 2 and BlockNumElts is 2 the mask is: 0, 1, 7,; // 8, 4, 5, 6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:45,Deployability,update,update,45,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:256,Deployability,update,updated,256,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Performance,Cache,Cache,4,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:158,Performance,cache,cached,158,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:54,Performance,load,loads,54,/// Special case for MatMul lowering. Prevents scalar loads of row-major; /// vectors Lowers to vector reduction add instead of sequential add if; /// reassocation is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:13,Performance,load,loads,13,// Costs for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:36,Energy Efficiency,reduce,reduce,36,// We compare the costs of a vector.reduce.add to sequential add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:35,Performance,load,loads,35,// Matmul must be the only user of loads because we don't use LowerLoad; // for row vectors (LowerLoad results in scalar loads and shufflevectors; // instead of single vector load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:121,Performance,load,loads,121,// Matmul must be the only user of loads because we don't use LowerLoad; // for row vectors (LowerLoad results in scalar loads and shufflevectors; // instead of single vector load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:175,Performance,load,load,175,// Matmul must be the only user of loads because we don't use LowerLoad; // for row vectors (LowerLoad results in scalar loads and shufflevectors; // instead of single vector load).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:30,Performance,load,load,30,"// If vector uses the builtin load, lower to a LoadInst",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:47,Performance,Load,LoadInst,47,"// If vector uses the builtin load, lower to a LoadInst",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:35,Energy Efficiency,reduce,reduce,35,// Insert mul/fmul and llvm.vector.reduce.fadd,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:33,Performance,Load,Load,33,/// Ensure that the memory in \p Load does not alias \p Store by potentially; /// copying it to a new location. This new or otherwise the original location; /// is returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:55,Performance,Load,Load,55,"// Create code to check if the memory locations of the Load and Store; // overlap and if they do, copy Load's operand to a new buffer.; // First, create new blocks for 2n part of the check and the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:103,Performance,Load,Load,103,"// Create code to check if the memory locations of the Load and Store; // overlap and if they do, copy Load's operand to a new buffer.; // First, create new blocks for 2n part of the check and the copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:27,Deployability,update,update,27,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:114,Deployability,update,updates,114,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:126,Safety,avoid,avoid,126,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:16,Performance,load,loaded,16,"// Check if the loaded memory location begins before the end of the store; // location. If the condition holds, they might overlap, otherwise they are; // guaranteed to not overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:51,Performance,load,load,51,"// Check if the store begins before the end of the load location. If the; // condition holds, they alias, otherwise they are guaranteed to not; // overlap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:8,Performance,load,load,8,// Copy load operand to new alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:40,Safety,avoid,avoid,40,"// Use an array type for the alloca, to avoid potentially huge alignment; // requirements for large vector types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:165,Performance,load,loads,165,// Then we need enough elements to exceed the number of vector; // registers we have. Note that this is an oversimplification since; // fusing also takes some extra loads which may exceed the number of; // reloads necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:60,Performance,Load,Load,60,"// Insert in the inner loop body, which computes; // Res += Load(CurrentRow, K) * Load(K, CurrentColumn)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:82,Performance,Load,Load,82,"// Insert in the inner loop body, which computes; // Res += Load(CurrentRow, K) * Load(K, CurrentColumn)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:3,Performance,Load,Load,3,// Load tiles of the operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:171,Usability,simpl,simplifications,171,"// TODO: Improve estimate of operations needed for transposes. Currently we; // just count the insertelement/extractelement instructions, but do not; // account for later simplifications/combines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:53,Availability,avail,available,53,"/// Lower load instructions, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:10,Performance,load,load,10,"/// Lower load instructions, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:52,Availability,avail,available,52,"/// Lower binary operators, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:13,Performance,perform,perform,13,// Helper to perform binary op on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:51,Availability,avail,available,51,"/// Lower unary operators, if shape information is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:13,Performance,perform,perform,13,// Helper to perform unary op on vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:29,Performance,Optimiz,Optimize,29,"//===- MemCpyOptimizer.cpp - Optimize use of memcpy and friends -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:393,Performance,perform,performs,393,"//===- MemCpyOptimizer.cpp - Optimize use of memcpy and friends -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:331,Modifiability,extend,extends,331,"/// Represents a range of memset'd bytes with the ByteVal value.; /// This allows us to analyze stores like:; /// store 0 -> P+1; /// store 0 -> P+0; /// store 0 -> P+3; /// store 0 -> P+2; /// which sometimes happens with stores to arrays of structs etc. When we see; /// the first store, we make a range [1, 2). The second store extends the range; /// to [0, 2). The third makes a new range [2, 3). The fourth store joins the; /// two ranges into [0, 3) which is memset'able.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:64,Modifiability,extend,extend,64,"// If any of the stores are a memset, then it is always good to extend the; // memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:328,Performance,optimiz,optimizer,328,"// If we have fewer than 8 stores, it can still be worthwhile to do this.; // For example, merging 4 i8 stores into an i32 store is useful almost always.; // However, merging 2 32-bit stores isn't useful on a 32-bit architecture (the; // memset will be split into 2 32-bit stores anyway) and doing so can; // pessimize the llvm optimizer.; //; // Since we don't have perfect knowledge here, make some assumptions: assume; // the maximum GPR width is the same size as the largest legal integer; // size. If so, check to see whether we will end up actually reducing the; // number of stores used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:14,Energy Efficiency,reduce,reduce,14,"// If we will reduce the # stores (according to this heuristic), do the; // transformation. This encourages merging 4 x i8 -> i32 and 2 x i16 -> i32; // etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:151,Modifiability,extend,extends,151,"// Now we know that Start <= I->End and End >= I->Start so the range overlaps; // but is not entirely contained within the range.; // See if the range extends the start of the range. In this case, it couldn't; // possibly cause it to join the prior range, because otherwise we would have; // stopped on *it*.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:140,Modifiability,Extend,Extend,140,"// Now we know that Start <= I->End and Start >= I->Start (so the startpoint; // is in or right at the end of I), and that End >= I->Start. Extend I out to; // End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:223,Security,access,accessible,223,"//===----------------------------------------------------------------------===//; // MemCpyOptLegacyPass Pass; //===----------------------------------------------------------------------===//; // Check that V is either not accessible by the caller, or unwinding cannot; // occur between Start and End.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:101,Security,access,accesses,101,"// For MemoryUses, getClobberingMemoryAccess may skip non-clobbering writes.; // Manually check read accesses between Start and End, if they are in the; // same block, for clobbers. Otherwise assume Loc is clobbered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Deployability,Update,Update,3,// Update AA metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:18,Performance,scalab,scalable,18,// We can't track scalable types,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:19,Security,access,access,19,// Calls that only access inaccessible memory do not block merging; // accessible stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:71,Security,access,accessible,71,// Calls that only access inaccessible memory do not block merging; // accessible stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:35,Performance,scalab,scalable,35,// We can't track ranges involving scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:189,Performance,optimiz,optimization,189,"// If we had at least one store that could be merged in, add the starting; // store as well. We try to avoid this unless there is at least something; // interesting as a small compile-time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:103,Safety,avoid,avoid,103,"// If we had at least one store that could be merged in, add the starting; // store as well. We try to avoid this unless there is at least something; // interesting as a small compile-time optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:31,Performance,perform,perform,31,// Make sure hoisting does not perform a store that was not guaranteed to; // happen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:32,Availability,down,downwards,32,"// Since LI is implicitly moved downwards past the lifted instructions,; // none of them may modify its source.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:154,Deployability,pipeline,pipelines,154,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:326,Performance,load,load,326,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:85,Security,access,access,85,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:254,Security,access,access,254,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:350,Security,access,access,350,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:368,Usability,Simpl,Simplify,368,"// Find MSSA insertion point. Normally P will always have a corresponding; // memory access before which we can insert. However, with non-standard AA; // pipelines, there may be a mismatch between AA and MSSA, in which case we; // will scan for a memory access before P. In either case, we know for sure; // that at least the load will have a memory access.; // TODO: Simplify this once P will be determined by MSSA, in which case the; // discrepancy can no longer occur.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:112,Availability,avail,available,112,// Don't introduce calls to memcpy/memmove intrinsics out of thin air if; // the corresponding libcalls are not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:178,Availability,avail,availability,178,// Don't introduce calls to memcpy/memmove intrinsics out of thin air if; // the corresponding libcalls are not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:83,Performance,load,load,83,"// We use alias analysis to check if an instruction may store to; // the memory we load from in between the load and the store. If; // such an instruction is found, we try to promote there instead; // of at the store position.; // TODO: Can use MSSA for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:108,Performance,load,load,108,"// We use alias analysis to check if an instruction may store to; // the memory we load from in between the load and the store. If; // such an instruction is found, we try to promote there instead; // of at the store position.; // TODO: Can use MSSA for this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:49,Performance,load,loaded,49,// We found an instruction that may write to the loaded memory.; // We can try to promote at this position instead of the store; // position if nothing aliases the store memory after this and the store; // destination is not in the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:71,Performance,load,load,71,"// If a valid insertion position is found, then we can promote; // the load/store pair to a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:9,Performance,load,load,9,"// If we load from memory that may alias the memory we store to,; // memmove must be used to preserve semantic. If not, memcpy can; // be used. Also, if we load from constant memory, memcpy can be used; // as the constant memory won't be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:156,Performance,load,load,156,"// If we load from memory that may alias the memory we store to,; // memmove must be used to preserve semantic. If not, memcpy can; // be used. Also, if we load from constant memory, memcpy can be used; // as the constant memory won't be modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:28,Performance,perform,performing,28,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:90,Performance,load,load-store,90,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Detect,Detect,3,"// Detect cases where we're performing call slot forwarding, but; // happen to be using a load-store pair to implement it, rather than; // a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:103,Performance,perform,performCallSlotOptzn,103,// We defer this expensive clobber walk until the cheap checks; // have been done on the source inside performCallSlotOptzn.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:16,Performance,load,load-store,16,"// If this is a load-store pair from a stack slot to a stack slot, we; // might be able to perform the stack-move optimization just as we do for; // memcpys from an alloca to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:91,Performance,perform,perform,91,"// If this is a load-store pair from a stack slot to a stack slot, we; // might be able to perform the stack-move optimization just as we do for; // memcpys from an alloca to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:114,Performance,optimiz,optimization,114,"// If this is a load-store pair from a stack slot to a stack slot, we; // might be able to perform the stack-move optimization just as we do for; // memcpys from an alloca to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,"// Avoid merging nontemporal stores since the resulting; // memcpy/memset would not be able to preserve the nontemporal hint.; // In theory we could teach how to propagate the !nontemporal metadata to; // memset calls. However, that change would force the backend to; // conservatively expand !nontemporal memset calls back to sequences of; // store instructions (effectively undoing the merging).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:376,Usability,undo,undoing,376,"// Avoid merging nontemporal stores since the resulting; // memcpy/memset would not be able to preserve the nontemporal hint.; // In theory we could teach how to propagate the !nontemporal metadata to; // memset calls. However, that change would force the backend to; // conservatively expand !nontemporal memset calls back to sequences of; // store instructions (effectively undoing the merging).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:92,Security,audit,audited,92,"// Not all the transforms below are correct for non-integral pointers, bail; // until we've audited the individual pieces.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Performance,Load,Load,3,// Load to store forwarding can be interpreted as memcpy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:119,Availability,avail,available,119,// The following code creates memset intrinsics out of thin air. Don't do; // this if the corresponding libfunc is not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:185,Availability,avail,availability,185,// The following code creates memset intrinsics out of thin air. Don't do; // this if the corresponding libfunc is not available.; // TODO: We should really distinguish between libcall availability and; // our ability to introduce intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:118,Performance,optimiz,optimization,118,"// If we have an aggregate, we try to promote it to memset regardless; // of opportunity for merging as it can expose optimization opportunities; // in subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:111,Security,expose,expose,111,"// If we have an aggregate, we try to promote it to memset regardless; // of opportunity for merging as it can expose optimization opportunities; // in subsequent passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:38,Integrability,depend,depends,38,"/// Takes a memcpy and a call that it depends on,; /// and checks for the possibility of a call slot optimization by having; /// the call write its result directly into the destination of the memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:101,Performance,optimiz,optimization,101,"/// Takes a memcpy and a call that it depends on,; /// and checks for the possibility of a call slot optimization by having; /// the call write its result directly into the destination of the memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:410,Performance,optimiz,optimize,410,"// The general transformation to keep in mind is; //; // call @func(..., src, ...); // memcpy(dest, src, ...); //; // ->; //; // memcpy(dest, src, ...); // call @func(..., dest, ...); //; // Since moving the memcpy is technically awkward, we additionally check that; // src only holds uninitialized values at the moment of the call, meaning that; // the memcpy can be discarded rather than moved.; // We can't optimize scalable types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:419,Performance,scalab,scalable,419,"// The general transformation to keep in mind is; //; // call @func(..., src, ...); // memcpy(dest, src, ...); //; // ->; //; // memcpy(dest, src, ...); // call @func(..., dest, ...); //; // Since moving the memcpy is technically awkward, we additionally check that; // src only holds uninitialized values at the moment of the call, meaning that; // the memcpy can be discarded rather than moved.; // We can't optimize scalable types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:39,Usability,simpl,simplifies,39,// Require that src be an alloca. This simplifies the reasoning considerably.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:12,Performance,optimiz,optimize,12,// We can't optimize scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:21,Performance,scalab,scalable,21,// We can't optimize scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:137,Security,access,accessed,137,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:233,Security,access,access,233,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:330,Security,access,accessible,330,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:573,Security,access,accesses,573,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:722,Security,access,access,722,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:745,Security,access,accesses,745,"// Make sure that nothing can observe cpyDest being written early. There are; // a number of cases to consider:; // 1. cpyDest cannot be accessed between C and cpyStore as a precondition of; // the transform.; // 2. C itself may not access cpyDest (prior to the transform). This is; // checked further below.; // 3. If cpyDest is accessible to the caller of this function (potentially; // captured and not based on an alloca), we need to ensure that we cannot; // unwind between C and cpyStore. This is checked here.; // 4. If cpyDest is potentially captured, there may be accesses to it from; // another thread. In this case, we need to check that cpyStore is; // guaranteed to be executed if C is. As it is a non-atomic access, it; // renders accesses from other threads undefined.; // TODO: This is currently not checked.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:25,Security,access,accessed,25,"// Check that src is not accessed except via the call and the memcpy. This; // guarantees that it holds only undefined values when passed in (so the final; // memcpy can be dropped), that it is not read or written between the call and; // the memcpy, and that writing beyond the end of it is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:40,Performance,load,load,40,// Ignore the direct read of src in the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:49,Security,access,access,49,"// In addition to knowing that the call does not access src in some; // unexpected manner, for example via a global, which we deduce from; // the use analysis, we also need to know that it does not sneakily; // access dest. We rely on AA to figure this out for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:211,Security,access,access,211,"// In addition to knowing that the call does not access src in some; // unexpected manner, for example via a global, which we deduce from; // the use analysis, we also need to know that it does not sneakily; // access dest. We rely on AA to figure this out for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:17,Performance,perform,perform,17,"// If necessary, perform additional analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:81,Safety,safe,safe,81,// We can't create address space casts here because we don't know if they're; // safe for the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:50,Integrability,depend,dependence,50,/// We've found that the (upward scanning) memory dependence of memcpy 'M' is; /// the memcpy 'MDep'. Try to simplify M to copy from MDep's input if we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:109,Usability,simpl,simplify,109,/// We've found that the (upward scanning) memory dependence of memcpy 'M' is; /// the memcpy 'MDep'. Try to simplify M to copy from MDep's input if we can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:339,Performance,perform,perform,339,"// Verify that the copied-from memory doesn't change in between the two; // transfers. For example, in:; // memcpy(a <- b); // *b = 42;; // memcpy(c <- a); // It would be invalid to transform the second memcpy into memcpy(c <- b).; //; // TODO: If the code between M and MDep is transparent to the destination ""c"",; // then we could still perform the xform by moving M up to the first memcpy.; // TODO: It would be sufficient to check the MDep source up to the memcpy; // size of M, rather than MDep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:50,Integrability,depend,dependence,50,"/// We've found that the (upward scanning) memory dependence of \p MemCpy is; /// \p MemSet. Try to simplify \p MemSet to only set the trailing bytes that; /// weren't copied over by \p MemCpy.; ///; /// In other words, transform:; /// \code; /// memset(dst, c, dst_size);; /// ...; /// memcpy(dst, src, src_size);; /// \endcode; /// into:; /// \code; /// ...; /// memset(dst + src_size, c, dst_size <= src_size ? 0 : dst_size - src_size);; /// memcpy(dst, src, src_size);; /// \endcode; ///; /// The memset is sunk to just before the memcpy to ensure that src_size is; /// present when emitting the simplified memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:100,Usability,simpl,simplify,100,"/// We've found that the (upward scanning) memory dependence of \p MemCpy is; /// \p MemSet. Try to simplify \p MemSet to only set the trailing bytes that; /// weren't copied over by \p MemCpy.; ///; /// In other words, transform:; /// \code; /// memset(dst, c, dst_size);; /// ...; /// memcpy(dst, src, src_size);; /// \endcode; /// into:; /// \code; /// ...; /// memset(dst + src_size, c, dst_size <= src_size ? 0 : dst_size - src_size);; /// memcpy(dst, src, src_size);; /// \endcode; ///; /// The memset is sunk to just before the memcpy to ensure that src_size is; /// present when emitting the simplified memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:600,Usability,simpl,simplified,600,"/// We've found that the (upward scanning) memory dependence of \p MemCpy is; /// \p MemSet. Try to simplify \p MemSet to only set the trailing bytes that; /// weren't copied over by \p MemCpy.; ///; /// In other words, transform:; /// \code; /// memset(dst, c, dst_size);; /// ...; /// memcpy(dst, src, src_size);; /// \endcode; /// into:; /// \code; /// ...; /// memset(dst + src_size, c, dst_size <= src_size ? 0 : dst_size - src_size);; /// memcpy(dst, src, src_size);; /// \endcode; ///; /// The memset is sunk to just before the memcpy to ensure that src_size is; /// present when emitting the simplified memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:111,Security,access,accessed,111,"// We know that dst up to src_size is not written. We now need to make sure; // that dst up to dst_size is not accessed. (If we did not move the memset,; // checking for reads would be sufficient.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:30,Usability,simpl,simply,30,"// If the sizes are the same, simply drop the memset instead of generating; // a replacement with zero size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:96,Security,access,access,96,"// The new memset is inserted before the memcpy, and it is known that the; // memcpy's defining access is the memset about to be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:268,Security,access,access,268,"// If the lifetime.start covers a whole alloca (as it almost always; // does) and we're querying a pointer based on that alloca, then we know; // the memory is definitely undef, regardless of how exactly we alias.; // The size also doesn't matter, as an out-of-bounds access would be UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:513,Integrability,wrap,wrap,513,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:646,Integrability,wrap,wrapping,646,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:15,Performance,optimiz,optimize,15,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:390,Performance,optimiz,optimization,390,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:414,Performance,perform,perform,414,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:738,Performance,optimiz,optimization,738,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:406,Safety,safe,safe,406,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:671,Safety,safe,safe,671,"// Attempts to optimize the pattern whereby memory is copied from an alloca to; // another alloca, where the two allocas don't have conflicting mod/ref. If; // successful, the two allocas can be merged into one and the transfer can be; // deleted. This pattern is generated frequently in Rust, due to the ubiquity of; // move operations in that language.; //; // Once we determine that the optimization is safe to perform, we replace all; // uses of the destination alloca with the source alloca. We also ""shrink wrap""; // the lifetime markers of the single merged alloca to before the first use; // and after the last use. Note that the ""shrink wrapping"" procedure is a safe; // transformation only because we restrict the scope of this optimization to; // allocas that aren't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:164,Integrability,wrap,wrap,164,"// Check that src and dest are never captured, unescaped allocas. Also; // find the nearest common dominator and postdominator for all users in; // order to shrink wrap the lifetimes, and instructions with noalias metadata; // to remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:308,Availability,alive,alive,308,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:94,Performance,optimiz,optimization,94,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:125,Safety,safe,safe,125,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:30,Performance,Load,Load,30,"// Check that, from after the Load to the end of the BB,; // - if the dest has any Mod, src has no Ref, and; // - if the dest has any Ref, src has no Mod except full-sized lifetimes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:32,Performance,Load,Load,32,"// Any ModRef post-dominated by Load doesn't matter, also Load and Store; // themselves can be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:58,Performance,Load,Load,58,"// Any ModRef post-dominated by Load doesn't matter, also Load and Store; // themselves can be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:43,Security,access,accesses,43,"// As this transformation can cause memory accesses that didn't previously; // alias to begin to alias one another, we remove !noalias metadata from any; // uses of either alloca. This is conservative, but more precision doesn't; // seem worthwhile right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:201,Integrability,depend,depending,201,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:132,Modifiability,rewrite,rewrite,132,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:4,Performance,Perform,Perform,4,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:12,Usability,simpl,simplification,12,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:15,Performance,optimiz,optimize,15,// We can only optimize non-volatile memcpy's.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:41,Security,access,accessing,41,// Degenerate case: memcpy marked as not accessing memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,Availability,redundant,redundant,27,"// Try to turn a partially redundant memset + memcpy into; // smaller memset + memcpy. We don't need the memcpy size for this.; // The memcpy must post-dom the memset, so limit this to the same basic; // block. A non-local generalization is likely not worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,Safety,redund,redundant,27,"// Try to turn a partially redundant memset + memcpy into; // smaller memset + memcpy. We don't need the memcpy size for this.; // The memcpy must post-dom the memset, so limit this to the same basic; // block. A non-local generalization is likely not worthwhile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,Performance,optimiz,optimizations,27,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:165,Performance,optimiz,optimization,165,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:509,Performance,optimiz,optimization,509,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:104,Safety,redund,redundance,104,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:96,Security,expose,exposes,96,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:84,Performance,perform,perform,84,"// If the transfer is from a stack slot to a stack slot, then we may be able; // to perform the stack-move optimization. See the comments in; // performStackMoveOptzn() for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:107,Performance,optimiz,optimization,107,"// If the transfer is from a stack slot to a stack slot, then we may be able; // to perform the stack-move optimization. See the comments in; // performStackMoveOptzn() for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:145,Performance,perform,performStackMoveOptzn,145,"// If the transfer is from a stack slot to a stack slot, then we may be able; // to perform the stack-move optimization. See the comments in; // performStackMoveOptzn() for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:25,Deployability,Update,Update,25,// Otherwise we're good! Update the byval argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:729,Safety,safe,safe,729,"/// This is called on memcpy dest pointer arguments attributed as immutable; /// during call. Try to use memcpy source directly if all of the following; /// conditions are satisfied.; /// 1. The memcpy dst is neither modified during the call nor captured by the; /// call. (if readonly, noalias, nocapture attributes on call-site.); /// 2. The memcpy dst is an alloca with known alignment & size.; /// 2-1. The memcpy length == the alloca size which ensures that the new; /// pointer is dereferenceable for the required range; /// 2-2. The src pointer has alignment >= the alloca alignment or can be; /// enforced so.; /// 3. The memcpy dst and src is not modified between the memcpy and the call.; /// (if MSSA clobber check is safe.); /// 4. The memcpy src is not modified during the call. (ModRef check shows no; /// Mod.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:47,Modifiability,Variab,Variable,47,"// Can't handle unknown size alloca.; // (e.g. Variable Length Array, Scalable Vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:70,Performance,Scalab,Scalable,70,"// Can't handle unknown size alloca.; // (e.g. Variable Length Array, Scalable Vector)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:25,Deployability,Update,Update,25,// Otherwise we're good! Update the immut argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:3,Safety,Avoid,Avoid,3,// Avoid invalidating the iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:56,Performance,load,load,56,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:405,Performance,perform,performs,405,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:424,Performance,load,loads,424,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:497,Performance,load,loads,497,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:570,Performance,load,loads,570,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:657,Performance,load,load,657,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:860,Performance,load,load,860,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1106,Performance,optimiz,optimization,1106,"nder the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else];",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1141,Performance,load,load,1141,"https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1252,Performance,perform,performs,1252,"ache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1261,Performance,load,load,1261,"ache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1566,Performance,load,load,1566,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1585,Performance,load,load,1585,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1841,Performance,load,load,1841,"d sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %s.sink = phi [%st, if.then], [%se, if.else]; // <...>; // store %s.sink, %addr_s; // <...>; //; //; //===----------------------- TODO -----------------------------------------===//; //; // 1) Generalize to regions other than diamonds; // 2) Be more aggressive merging memory operations; // Note that both changes require register pressure control; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:1086,Safety,safe,safe,1086,"---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:3,Integrability,Rout,Routines,3,// Routines for sinking stores,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:115,Safety,safe,safe,115,///; /// Check if \p BB contains a store to the same address as \p SI; ///; /// \return The store in \p when it is safe to sink. Otherwise return Null.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:18,Usability,simpl,simple,18,"// Don't sink non-simple (atomic, volatile) stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:64,Performance,optimiz,optimization,64,"// Merge unconditional branches, allowing PRE to catch more; // optimization opportunities.; // This loop doesn't care about newly inserted/split blocks ; // since they never will be diamond heads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:20,Performance,load,loads,20,// Hoist equivalent loads and sink stores; // outside diamonds when possible,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:498,Energy Efficiency,efficient,efficient,498,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:24,Performance,Optimiz,Optimize,24,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:672,Performance,load,loaded,672,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:883,Performance,cache,cache,883,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:1264,Performance,optimiz,optimized,1264,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:69,Performance,load,load,69,"// A BCE atom ""Binary Compare Expression Atom"" represents an integer load; // that is a constant offset from a base value, e.g. `a` or `o.c` in the example; // at the top.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:22,Performance,load,load,22,"// If this value is a load from a constant offset w.r.t. a base address, and; // there are no other users of the load or address, returns the base address and; // the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:113,Performance,load,load,113,"// If this value is a load from a constant offset w.r.t. a base address, and; // there are no other users of the load or address, returns the base address and; // the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:10,Performance,optimiz,optimize,10,// Do not optimize atomic loads to non-atomic memcmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:26,Performance,load,loads,26,// Do not optimize atomic loads to non-atomic memcmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:299,Performance,load,loads,299,"// A comparison between two BCE atoms, e.g. `a == o.a` in the example at the; // top.; // Note: the terminology is misleading: the comparison is symmetric, so there; // is no real {l/r}hs. What we want though is to have the same base on the; // left (resp. right), so that we can detect consecutive loads. To ensure this; // we put the smallest atom on the left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:280,Safety,detect,detect,280,"// A comparison between two BCE atoms, e.g. `a == o.a` in the example at the; // top.; // Note: the terminology is misleading: the comparison is symmetric, so there; // is no real {l/r}hs. What we want though is to have the same base on the; // left (resp. right), so that we can detect consecutive loads. To ensure this; // we put the smallest atom on the left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:39,Performance,load,loads,39,"// If this instruction may clobber the loads and is in middle of the BCE cmp; // block instructions, then bail for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:60,Performance,load,load,60,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:99,Performance,load,load,99,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:83,Safety,safe,safely,83,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:214,Performance,load,loads,214,// TODO(courbet): Can we allow some other things ? This is very conservative.; // We might be able to get away with anything does not have any side; // effects outside of the basic block.; // Note: The GEPs and/or loads are not necessarily in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:18,Deployability,continuous,continuous,18,// Sort to detect continuous offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:11,Safety,detect,detect,11,// Sort to detect continuous offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:442,Safety,abort,abort,442,"// This is the initial block in the chain, in case this block does other; // work, we can try to split the block and move the irrelevant; // instructions to the predecessor.; //; // If this is not the initial block in the chain, splitting it wont; // work.; //; // As once split, there will still be instructions before the BCE cmp; // instructions that do other work in program order, i.e. within the; // chain before sorting. Unless we can abort the chain at this point; // and start anew.; //; // NOTE: we only handle blocks a with single predecessor for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:31,Safety,abort,abort,31,"// TODO(courbet): Right now we abort the whole chain. We could be; // merging only the blocks that don't do other work and resume the; // chain from there. For example:; // if (a[0] == b[0]) { // bb1; // if (a[1] == b[1]) { // bb2; // some_value = 3; //bb3; // if (a[2] == b[2]) { //bb3; // do a ton of stuff //bb4; // }; // }; // }; //; // This is:; //; // bb1 --eq--> bb2 --eq--> bb3* -eq--> bb4 --+; // \ \ \ \; // ne ne ne \; // \ \ \ v; // +------------+-----------+----------> bb_phi; //; // We can only merge the first two comparisons, because bb3* does; // ""other work"" (setting some_value to 3).; // We could still merge bb1 and bb2 though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:123,Usability,resume,resume,123,"// TODO(courbet): Right now we abort the whole chain. We could be; // merging only the blocks that don't do other work and resume the; // chain from there. For example:; // if (a[0] == b[0]) { // bb1; // if (a[1] == b[1]) { // bb2; // some_value = 3; //bb3; // if (a[2] == b[2]) { //bb3; // do a ton of stuff //bb4; // }; // }; // }; //; // This is:; //; // bb1 --eq--> bb2 --eq--> bb3* -eq--> bb4 --+; // \ \ \ \; // ne ne ne \; // \ \ \ v; // +------------+-----------+----------> bb_phi; //; // We can only merge the first two comparisons, because bb3* does; // ""other work"" (setting some_value to 3).; // We could still merge bb1 and bb2 though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:76,Performance,optimiz,optimized,76,// A class to compute the name of a set of merged basic blocks.; // This is optimized for the common case of no block names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:116,Availability,avail,available,116,// Effectively merge blocks. We go in the reverse direction from the phi block; // so that the next block is always available to branch to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:59,Deployability,update,update,59,"// If the old cmp chain was the function entry, we need to update the function; // entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:103,Safety,avoid,avoid,103,// We only try merging comparisons if the target wants to expand memcmp later.; // The rationale is to avoid turning small chains into memcmp calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:84,Availability,avail,available,84,"// MergeICmps does not need the DominatorTree, but we update it if it's; // already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:54,Deployability,update,update,54,"// MergeICmps does not need the DominatorTree, but we update it if it's; // already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1523,Energy Efficiency,efficient,efficiently,1523,"// }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1947,Modifiability,rewrite,rewrites,1947," // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and mu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1993,Modifiability,rewrite,rewrites,1993," // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and mu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:2978,Modifiability,extend,extended,2978,"eassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instruction and thus eligible for split consideration. For; // example,; //; // ac = a + c; // ab = a + b; // abc = ab + c; // ab2 = ab + b; // ab2c = ab2 + c; //; // In the first iteration, we cannot reassociate abc to ac+b because ab is used; // twice. However, we can reassociate ab2c to abc+b in the first iteration. As a; // result, ab2 becomes dead and ab will be used only once in the second; // iteration.; //; // Limitations and TODO items:; //; // 1) We only considers n-ary adds and muls for now. This should be extended; // and generalized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:447,Safety,redund,redundancy,447,"//===- NaryReassociate.cpp - Reassociate n-ary expressions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1177,Safety,detect,detects,1177,"th LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations befo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:1496,Safety,redund,redundancy,1496," exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites; // ((a + c) + b) + d into ((a + c) + d) + b.; //; // Finally, the above dominator-based algorithm may need to be run multiple; // iterations before emitting optimal code. One source of this need is that we; // only split an operand when it is used only once. The above algorithm can; // eliminate an instruction and decrease the usage count of its operands. As a; // result, an instruction that previously had multiple uses may become a; // single-use instru",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:462,Security,expose,exposed,462,"//===- NaryReassociate.cpp - Reassociate n-ary expressions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:675,Usability,simpl,simplify,675,"//===- NaryReassociate.cpp - Reassociate n-ary expressions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass reassociates n-ary add expressions and eliminates the redundancy; // exposed by the reassociation.; //; // A motivating example:; //; // void foo(int a, int b) {; // bar(a + b);; // bar((a + 2) + b);; // }; //; // An ideal compiler should reassociate (a + 2) + b to (a + b) + 2 and simplify; // the above code to; //; // int t = a + b;; // bar(t);; // bar(t + 2);; //; // However, the Reassociate pass is unable to do that because it processes each; // instruction individually and believes (a + 2) + b is the best form according; // to its rank system.; //; // To address this limitation, NaryReassociate reassociates an expression in a; // form that reuses existing instructions. As a result, NaryReassociate can; // reassociate (a + 2) + b in the example to (a + b) + 2 because it detects that; // (a + b) is computed before.; //; // NaryReassociate works as follows. For every instruction in the form of (a +; // b) + c, it checks whether a + c or b + c is already computed by a dominating; // instruction. If so, it then reassociates (a + b) + c into (a + c) + b or (b +; // c) + a and removes the redundancy accordingly. To efficiently look up whether; // an expression is computed before, we store each instruction seen and its SCEV; // into an SCEV-to-instruction map.; //; // Although the algorithm pattern-matches only ternary additions, it; // automatically handles many >3-ary expressions by walking through the function; // in the depth-first order. For example, given; //; // (a + c) + d; // ((a + b) + c) + d; //; // NaryReassociate first rewrites (a + b) + c to (a + c) + b, and then rewrites",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:85,Deployability,update,updated,85,// Delete all dead instructions from 'DeadInsts'.; // Please note ScalarEvolution is updated along the way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:8,Modifiability,extend,extend,8,// Zero-extend LHS if it is non-negative. InstCombine canonicalizes sext to; // zext if the source operand is proved non-negative. We should do that; // consistently so that CandidateExpr more likely appears before. See; // @reassociate_gep_assume for an example of this canonicalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:235,Performance,optimiz,optimization,235,"// Because we process the basic blocks in pre-order of the dominator tree, a; // candidate that doesn't dominate the current instruction won't dominate any; // future instruction either. Therefore, we pop it out of the stack. This; // optimization makes the algorithm O(n).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp:7,Performance,optimiz,optimization,7,// The optimization is profitable only if LHS can be removed in the end.; // In other words LHS should be used (directly or indirectly) by I only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NaryReassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2482,Availability,Redundant,Redundant,2482,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1691,Deployability,update,updated,1691,"ecution of the program. In that respect, congruency is a; /// compile-time approximation of equivalence of values at runtime.; /// The algorithm implemented here uses a sparse formulation and it's based; /// on the ideas described in the paper:; /// ""A Sparse Algorithm for Predicated Global Value Numbering"" from; /// Karthik Gargi.; ///; /// A brief overview of the algorithm: The algorithm is essentially the same as; /// the standard RPO value numbering algorithm (a good reference is the paper; /// ""SCC based value numbering"" by L. Taylor Simpson) with one major difference:; /// The RPO algorithm proceeds, on every iteration, to process every reachable; /// block and every instruction in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algori",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2246,Performance,perform,performing,2246,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2958,Performance,perform,perform,2958,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2469,Safety,Detect,Detection,2469,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2482,Safety,Redund,Redundant,2482,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2672,Safety,detect,detect,2672,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2308,Usability,simpl,simplification,2308,"n in that block. This is because the standard RPO; /// algorithm does not track what things have the same value number, it only; /// tracks what the value number of a given operation is (the mapping is; /// operation -> value number). Thus, when a value number of an operation; /// changes, it must reprocess everything to ensure all uses of a value number; /// get updated properly. In constrast, the sparse algorithm we use *also*; /// tracks what operations have a given value number (IE it also tracks the; /// reverse mapping from value number -> operations with that value number), so; /// that it only needs to reprocess the instructions that are affected when; /// something's value number changes. The vast majority of complexity and code; /// in this file is devoted to tracking what value numbers could change for what; /// instructions when various things happen. The rest of the algorithm is; /// devoted to performing symbolic evaluation, forward propagation, and; /// simplification of operations based on the value numbers deduced so far; ///; /// In order to make the GVN mostly-complete, we use a technique derived from; /// ""Detection of Redundant Expressions: A Complete and Polynomial-time; /// Algorithm in SSA"" by R.R. Pai. The source of incompleteness in most SSA; /// based GVN algorithms is related to their inability to detect equivalence; /// between phi of ops (IE phi(a+b, c+d)) and op of phis (phi(a,c) + phi(b, d)).; /// We resolve this issue by generating the equivalent ""phi of ops"" form for; /// each op of phis we see, in a way that only takes polynomial time to resolve.; ///; /// We also do not perform elimination by using any published algorithm. All; /// published algorithms are O(Instructions). Instead, we use a technique that; /// is O(number of operations with the same value number), enabling us to skip; /// trying to eliminate things that have unique value numbers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,Security,access,access,28,// Currently store defining access refinement is too slow due to basicaa being; // egregiously slow. This flag lets us keep it working while we work on this; // issue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:257,Safety,risk,risk,257,"// Tarjan's SCC finding algorithm with Nuutila's improvements; // SCCIterator is actually fairly complex for the simple thing we want.; // It also wants to hand us SCC's that are unrelated to the phi node we ask; // about, and have us process them there or risk redoing work.; // Graph traits over a filter iterator also doesn't work that well here.; // This SCC finder is specialized to walk use-def chains, and only follows; // instructions,; // not generic values (arguments, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,Usability,simpl,simple,113,"// Tarjan's SCC finding algorithm with Nuutila's improvements; // SCCIterator is actually fairly complex for the simple thing we want.; // It also wants to hand us SCC's that are unrelated to the phi node we ask; // about, and have us process them there or risk redoing work.; // Graph traits over a filter iterator also doesn't work that well here.; // This SCC finder is specialized to walk use-def chains, and only follows; // instructions,; // not generic values (arguments, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1476,Integrability,depend,depends,1476,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1580,Integrability,depend,depends,1580,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:166,Performance,perform,perform,166,"// Congruence classes represent the set of expressions/instructions; // that are all the same *during some scope in the function*.; // That is, because of the way we perform equality propagation, and; // because of memory value numbering, it is not correct to assume; // you can willy-nilly replace any member with any other at any; // point in the function.; //; // For any Value in the Member set, it is valid to replace any dominated member; // with that Value.; //; // Every congruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:1705,Performance,optimiz,optimization,1705,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:734,Usability,simpl,simplify,734,"// Congruence classes represent the set of expressions/instructions; // that are all the same *during some scope in the function*.; // That is, because of the way we perform equality propagation, and; // because of memory value numbering, it is not correct to assume; // you can willy-nilly replace any member with any other at any; // point in the function.; //; // For any Value in the Member set, it is valid to replace any dominated member; // with that Value.; //; // Every congruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:2323,Usability,simpl,simpler,2323,"gruence class has a leader, and the leader is used to symbolize; // instructions in a canonical way (IE every operand of an instruction that is a; // member of the same congruence class will always be replaced with leader; // during symbolization). To simplify symbolization, we keep the leader as a; // constant if class can be proved to be a constant value. Otherwise, the; // leader is the member of the value set with the smallest DFS number. Each; // congruence class also has a defining expression, though the expression may be; // null. If it exists, it can be used for forward propagation and reassociation; // of values.; // For memory, we also track a representative MemoryAccess, and a set of memory; // members for MemoryPhis (which have no real instructions). Note that for; // memory, it seems tempting to try to split the memory members into a; // MemoryCongruenceClass or something. Unfortunately, this does not work; // easily. The value numbering of a given memory expression depends on the; // leader of the memory congruence class, and the leader of memory congruence; // class depends on the value numbering of a given memory expression. This; // leads to wasted propagation, and in some cases, missed optimization. For; // example: If we had value numbered two stores together before, but now do not,; // we move them to a new value congruence class. This in turn will move at one; // of the memorydefs to a new memory congruence class. Which in turn, affects; // the value numbering of the stores we just value numbered (because the memory; // congruence class is part of the value number). So while theoretically; // possible to split them up, it turns out to be *incredibly* complicated to get; // it to work right, because of the interdependency. While structurally; // slightly messier, it is algorithmically much simpler and faster to do what we; // do here, and track them both at once in the same class.; // Note: The default iterators for this class iterate over values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Testability,assert,assertion,67,"// True if this class has no members left. This is mainly used for assertion; // purposes, and for skipping empty classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:83,Security,access,access,83,"// If this class contains MemoryDefs or MemoryPhis, this is the leading memory; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:73,Safety,detect,detect,73,// Number of stores in this congruence class.; // This is used so we can detect store equivalence changes properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Security,hash,hashes,11,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:58,Security,hash,hashtable,58,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:167,Security,hash,hash,167,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:192,Security,hash,hashes,192,"// Compare hashes before equality. This is *not* what the hashtable does,; // since it is computing it modulo the number of buckets, whereas we are; // using the full hash keyspace. Since the hashes are precomputed, this; // check is *much* faster than equality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:561,Performance,perform,perform,561,"// In order to know when we should re-process instructions that have; // phi-of-ops, we track the set of expressions that they needed as; // leaders. When we discover new leaders for those expressions, we process the; // associated phi-of-op instructions again in case they have changed. The; // other way they may change is if they had leaders, and those leaders; // disappear. However, at the point they have leaders, there are uses of the; // relevant operands in the created phi node, and so they will get reprocessed; // through the normal user marking we perform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:152,Testability,test,test,152,// Set of all temporary instructions we created.; // Note: This will include instructions that were just created during value; // numbering. The way to test if something is using them is to check; // RealToTemp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:468,Integrability,depend,depended,468,"// This is the set of instructions to revisit on a reachability change. At; // the end of the main iteration loop it will contain at least all the phi of; // ops instructions that will be changed to phis, as well as regular phis.; // During the iteration loop, it may contain other things, such as phi of ops; // instructions that used edge reachability to reach a result, and so need to; // be revisited when the edge changes, independent of whether the phi they; // depended on changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:539,Safety,avoid,avoid,539,"// We could, if we wanted, build MemoryPhiExpressions and; // MemoryVariableExpressions, etc, and value number them the same way we value; // number phi expressions. For the moment, this seems like overkill. They; // can only exist in one of three states: they can be TOP (equal to; // everything), Equivalent to something else, or unique. Because we do not; // create expressions for them, we need to simulate leader change not just; // when they change class, but when they change state. Note: We can do the; // same thing for phis, and avoid having phi expressions if we wanted, We; // should eventually unify in one direction or the other, so this is a little; // bit of an experiment in which turns out easier to maintain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:411,Energy Efficiency,efficient,efficiently,411,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:183,Performance,optimiz,optimization,183,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:432,Testability,test,test,432,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:441,Usability,clear,clear,441,"// This is a bitvector because, on larger functions, we may have; // thousands of touched instructions at once (entire blocks,; // instructions with hundreds of uses, etc). Even with optimization; // for when we mark whole blocks as touched, when this was a; // SmallPtrSet or DenseSet, for some functions, we spent >20% of all; // the time in GVN just managing this list. The bitvector, on the; // other hand, efficiently supports test/set/clear of both; // individual and ranges, as well as ""find next element"" This; // enables us to use it as a worklist with essentially 0 cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:61,Integrability,depend,dependency,61,/// Helper struct return a Expression with an optional extra dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:51,Availability,avail,available,51,// Return true if V is a value that will always be available (IE can; // be placed anywhere) in the function. We don't do globals here; // because they are often worse to put in place.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:232,Energy Efficiency,efficient,efficient,232,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since all commutative instructions have two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,Usability,simpl,simplification,28,"// Take a Value returned by simplification of Expression E/Instruction; // I, and see if it resulted in a simpler expression. If so, return; // that expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:106,Usability,simpl,simpler,106,"// Take a Value returned by simplification of Expression E/Instruction; // I, and see if it resulted in a simpler expression. If so, return; // that expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:232,Energy Efficiency,efficient,efficient,232,"// Ensure that commutative instructions that only differ by a permutation; // of their operands get the same value number by sorting the operand value; // numbers. Since all commutative instructions have two operands it is more; // efficient to sort by hand rather than using, say, std::sort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Performance,Perform,Perform,3,// Perform simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Usability,simpl,simplification,11,// Perform simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:37,Usability,simpl,simplifyCmpInst,37,// TODO: 25% of our time is spent in simplifyCmpInst with pointer operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:263,Integrability,interface,interface,263,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Usability,simpl,simplify,29,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,Usability,Simpl,Simplify,113,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:280,Usability,simpl,simplify,280,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:305,Usability,Simpl,SimplifyZExt,305,"// We don't bother trying to simplify unless all of the operands; // were constant.; // TODO: There are a lot of Simplify*'s we could call here, if we; // wanted to. The original motivating case for this code was a; // zext i1 false to i8, which we don't have an interface to; // simplify (IE there is no SimplifyZExt).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:657,Integrability,Depend,Depending,657,"// This must be an instruction because we are only called from phi nodes; // in the case that the value it needs to check against is an instruction.; // The most likely candidates for dominance are the leader and the next leader.; // The leader or nextleader will dominate in all cases where there is an; // equivalent that is higher up in the dom tree.; // We can't *only* check them, however, because the; // dominator tree could have an infinite number of non-dominating siblings; // with instructions that are in the right congruence class.; // A; // B C D E F G; // |; // H; // Instruction U could be in H, with equivalents in every other sibling.; // Depending on the rpo order picked, the leader could be the equivalent in; // any of these siblings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:18,Performance,load,loads,18,// Give store and loads same opcode so they value number together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:135,Performance,load,load,135,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:195,Performance,load,load,195,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:18,Performance,load,loads,18,// Give store and loads same opcode so they value number together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:135,Performance,load,load,135,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:195,Performance,load,load,195,"// TODO: Value number heap versions. We may be able to discover; // things alias analysis can't on it's own (IE that a store and a; // load have the same value, and thus, it isn't clobbering the load).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:10,Performance,load,loads,10,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:97,Safety,avoid,avoid,97,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:86,Usability,simpl,simple,86,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:173,Usability,simpl,simple,173,"// See if we are defined by a previous store expression, it already has a; // value, and it's the same value as our current store. FIXME: Right now, we; // only do this for simple stores, we should expand to cover memcpys, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:346,Performance,load,load,346,"// We really want to check whether the expression we matched was a store. No; // easy way to do that. However, we can check that the class we found has a; // store, which, assuming the value numbering state is not corrupt, is; // sufficient, because we must also be equivalent to that store's expression; // for it to be in the same class as the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:51,Performance,load,load,51,"// Also check if our value operand is defined by a load of the same memory; // location, and the memory state is the same as it was then (otherwise, it; // could have been overwritten later. See test32 in; // transforms/DeadStoreElimination/simple.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:241,Usability,simpl,simple,241,"// Also check if our value operand is defined by a load of the same memory; // location, and the memory state is the same as it was then (otherwise, it; // could have been overwritten later. See test32 in; // transforms/DeadStoreElimination/simple.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Performance,load,loaded,40,"// See if we can extract the value of a loaded pointer from a load, a store, or; // a memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:62,Performance,load,load,62,"// See if we can extract the value of a loaded pointer from a load, a store, or; // a memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:28,Performance,load,load,28,// We can coerce a constant load into a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Performance,load,load,40,// We can coerce a constant load into a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:79,Integrability,depend,dependent,79,// All of the below are only true if the loaded pointer is produced; // by the dependent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:41,Performance,load,loaded,41,// All of the below are only true if the loaded pointer is produced; // by the dependent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:31,Integrability,depend,depend,31,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Performance,load,load,11,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Performance,load,loading,67,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:116,Performance,load,loading,116,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:294,Performance,load,load,294,"// If this load really doesn't depend on anything, then we must be loading an; // undef value. This can happen when loading for a fresh allocation with no; // intervening stores, for example. Note that this is only true in the case; // that the result of the allocation is pointer equal to the load ptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:11,Performance,load,load,11,"// If this load occurs either right after a lifetime begin,; // then the loaded value is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:73,Performance,load,loaded,73,"// If this load occurs either right after a lifetime begin,; // then the loaded value is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,Performance,load,loads,43,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,Performance,load,loads,92,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:36,Usability,simpl,simple,36,"// We can eliminate in favor of non-simple loads, but we won't be able to; // eliminate the loads themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Performance,Load,Load,3,// Load of undef is UB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:79,Security,access,access,79,"// This will handle stores and memory insts. We only do if it the; // defining access has a different type, or it is a pointer produced by; // certain memory operations that cause the memory to have a fixed value; // (IE things like calloc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,Security,access,access,43,"// If our MemoryLeader is not our defining access, add a use to the; // MemoryLeader, so that we get reprocessed when it changes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:229,Performance,optimiz,optimization,229,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:317,Performance,optimiz,optimizations,317,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:356,Safety,detect,detect,356,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Security,access,access,40,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:90,Security,access,accessing,90,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:378,Security,access,accessing,378,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:177,Usability,resume,resume,177,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:57,Integrability,depend,depend,57,"// Do not combine convergent calls since they implicitly depend on the set of; // threads that is currently executing, and they might be in different basic; // blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:36,Security,access,access,36,// MSSA determined that CI does not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Deployability,Update,Update,3,"// Update the MemoryAccess equivalence table to say that From is equal to To,; // and return true if this is different from what already existed in the table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:53,Deployability,update,updates,53,"// If this is a phi, we have to handle memory member updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:96,Integrability,depend,depend,96,"// Determine if a instruction is cycle-free. That means the values in the; // instruction don't depend on any expressions that can change value as a result; // of the instruction. For example, a non-cycle free instruction would be v =; // phi(0, v+1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Usability,Simpl,SimplifyPhiNode,29,// We match the semantics of SimplifyPhiNode from InstructionSimplify here.; // See if all arguments are the same.; // We track if any were undef because they need special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:107,Integrability,depend,dependent,107,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:145,Integrability,depend,dependent,145,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:442,Modifiability,variab,variable,442,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:9,Usability,simpl,simplify,9,"// Can't simplify to something that comes later in the iteration.; // Otherwise, when and if it changes congruence class, we will never catch; // up. We will always be a class behind it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Safety,Avoid,Avoid,3,// Avoid processing the same info twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:27,Integrability,depend,depend,27,"// This condition does not depend on predicates, no need to add users",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:39,Usability,simpl,simplifyCmpInst,39,// Create expression will take care of simplifyCmpInst,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:33,Integrability,depend,depend,33,// Touch all the predicates that depend on this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:42,Deployability,update,updated,42,"// Touch the instructions that need to be updated after a congruence class has a; // leader change, and mark changed values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:13,Testability,assert,assertion,13,"// Given our assertion, hitting this part must mean; // !OldClass->memory_empty()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:82,Testability,test,testing,82,"// NOTE: If this ends up to slow, we can maintain a dual structure for; // member testing/insertion, or keep things mostly sorted, and sort only; // here, or use SparseBitVector or ....",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:70,Deployability,update,updates,70,"// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to; // the memory members, etc for the move.; //; // The invariants of this function are:; //; // - I must be moving to NewClass from OldClass; // - The StoreCount of OldClass and NewClass is expected to have been updated; // for I already if it is a store.; // - The OldClass memory leader has not been updated yet if I was the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:292,Deployability,update,updated,292,"// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to; // the memory members, etc for the move.; //; // The invariants of this function are:; //; // - I must be moving to NewClass from OldClass; // - The StoreCount of OldClass and NewClass is expected to have been updated; // for I already if it is a store.; // - The OldClass memory leader has not been updated yet if I was the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:382,Deployability,update,updated,382,"// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to; // the memory members, etc for the move.; //; // The invariants of this function are:; //; // - I must be moving to NewClass from OldClass; // - The StoreCount of OldClass and NewClass is expected to have been updated; // for I already if it is a store.; // - The OldClass memory leader has not been updated yet if I was the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Deployability,Update,Update,67,"// Move a value, currently in OldClass, to be part of NewClass; // Update OldClass and NewClass for the move (including changing leaders, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:110,Performance,load,load,110,"// Okay, so when do we want to make a store a leader of a class?; // If we have a store defined by an earlier load, we want the earlier load; // to lead the class.; // If we have a store defined by something else, we want the store to lead; // the class so everything else gets the ""something else"" as a value.; // If we have a store as the single member of the class, we want the store; // as the leader",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:136,Performance,load,load,136,"// Okay, so when do we want to make a store a leader of a class?; // If we have a store defined by an earlier load, we want the earlier load; // to lead the class.; // If we have a store defined by something else, we want the store to lead; // the class so everything else gets the ""something else"" as a value.; // If we have a store as the single member of the class, we want the store; // as the leader",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Performance,Perform,Perform,3,// Perform congruence finding on a given value numbering expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:17,Modifiability,variab,variables,17,// Constants and variables should always be made the leader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:118,Performance,load,loads,118,"// If we changed the class of the store, we want to ensure nothing finds the; // old store expression. In particular, loads do not compare against stored; // value, so they will find old store expressions (and associated class; // mappings) if we leave them in the table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:170,Integrability,depend,depend,170,"// We've made an edge reachable to an existing block, which may; // impact predicates. Otherwise, only mark the phi nodes as touched, as; // they are the only thing that depend on new edges. Anything using their; // values will get propagated to if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Integrability,depend,dependency,67,"// Did not use simplification result, no need to add the extra; // dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:15,Usability,simpl,simplification,15,"// Did not use simplification result, no need to add the extra; // dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:39,Safety,safe,safe,39,"// Return true if this operand will be safe to use for phi of ops.; //; // The reason some operands are unsafe is that we are not trying to recursively; // translate everything back through phi nodes. We actually expect some lookups; // of expressions to fail. In particular, a lookup where the expression cannot; // exist in the predecessor. This is true even if the expression, as shown, can; // be determined to be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:104,Safety,unsafe,unsafe,104,"// Return true if this operand will be safe to use for phi of ops.; //; // The reason some operands are unsafe is that we are not trying to recursively; // translate everything back through phi nodes. We actually expect some lookups; // of expressions to fail. In particular, a lookup where the expression cannot; // exist in the predecessor. This is true even if the expression, as shown, can; // be determined to be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:49,Performance,load,load,49,"// When we hit an instruction that reads memory (load, call, etc), we must; // consider any store that may happen in the loop. For now, we assume the; // worst: there is a store in the loop that alias with this read.; // The case where the load is outside the loop is already covered by the; // dominator check above.; // TODO: relax this condition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:240,Performance,load,load,240,"// When we hit an instruction that reads memory (load, call, etc), we must; // consider any store that may happen in the loop. For now, we assume the; // worst: there is a store in the loop that alias with this read.; // The case where the load is outside the loop is already covered by the; // dominator check above.; // TODO: relax this condition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:26,Safety,unsafe,unsafe,26,// Stop now if we find an unsafe operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,Performance,load,load,92,"// TODO: We don't do phi translation on memory accesses because it's; // complicated. For a load, we'd need to be able to simulate a new memoryuse,; // which we don't have a good way of doing ATM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:47,Security,access,accesses,47,"// TODO: We don't do phi translation on memory accesses because it's; // complicated. For a load, we'd need to be able to simulate a new memoryuse,; // which we don't have a good way of doing ATM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:174,Safety,abort,abort,174,"// No point in doing this for one-operand phis.; // Since all PHIs for operands must be in the same block, then they must; // have the same number of operands so we can just abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,Safety,safe,safe,43,"// If we phi-translated the op, it must be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:91,Availability,down,down,91,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Safety,safe,safe,40,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:179,Safety,unsafe,unsafe,179,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:52,Integrability,rout,routine,52,"// The algorithm initially places the values of the routine in the TOP; // congruence class. The leader of TOP is the undetermined value `poison`.; // When the algorithm has finished, values still in TOP are unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:391,Security,access,access,391,"// Note that even though we use the live on entry def as a representative; // MemoryAccess, it is *not* the same as the actual live on entry def. We; // have no real equivalent to poison for MemoryAccesses, and so we really; // should be checking whether the MemoryAccess is top if we want to know if it; // is equivalent to everything. Otherwise, what this really signifies is that; // the access ""it reaches all the way back to the beginning of the function""; // Initialize all other instructions to be in TOP class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:107,Security,access,access,107,"// and now check if all the elements are equal.; // Sadly, we can't use std::equals since these are random access iterators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:63,Performance,perform,performing,63,"// Value number a single instruction, symbolically evaluating, performing; // congruence finding, and updating mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:192,Integrability,rout,routine,192,"// This is not perfect, but as we're just verifying here, we can live with; // the loss of precision. The real solution would be that of doing strongly; // connected component finding in this routine, and it's probably not worth; // the complexity for the time being. So, we just keep a set of visited; // MemoryAccess and return true when we hit a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:225,Testability,test,testing,225,"// Verify the that the memory equivalence table makes sense relative to the; // congruence classes. Note that this checking is not perfect, and is currently; // subject to very rare false negatives. It is only useful for; // testing/debugging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:189,Deployability,update,updated,189,"// Anything equivalent in the MemoryAccess table should be in the same; // congruence class.; // Filter out the unreachable and trivially dead entries, because they may; // never have been updated if the instructions were not processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:151,Performance,load,loads,151,"// Verify that for each store expression in the expression to class mapping,; // only the latest appears, and multiple ones do not appear.; // Because loads do not use the stored value when doing equality with stores,; // if we don't erase the old store expressions from the table, a load can find; // a no-longer valid StoreExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:284,Performance,load,load,284,"// Verify that for each store expression in the expression to class mapping,; // only the latest appears, and multiple ones do not appear.; // Because loads do not use the stored value when doing equality with stores,; // if we don't erase the old store expressions from the table, a load can find; // a no-longer valid StoreExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,Security,hash,hash,92,"// This is the only use of this, and it's not worth defining a complicated; // densemapinfo hash/equality function for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:47,Performance,load,loads,47,// Make sure a version that will conflict with loads is not already there,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:46,Security,hash,hash,46,"// Count number of instructions for sizing of hash tables, and come; // up with a global dfs numbering for instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:276,Performance,perform,performing,276,"// Note: We want ideal RPO traversal of the blocks, which is not quite the; // same as dominator tree order, particularly with regard whether backedges; // get visited first or second, given a block with multiple successors.; // If we visit in the wrong order, we will end up performing N times as many; // iterations.; // The dominator tree does guarantee that, for a given dom tree node, it's; // parent must occur before it in the RPO ordering. Thus, we only need to sort; // the siblings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:76,Availability,avail,available,76,"// If it's a store, use the leader of the value operand, if it's always; // available, or the value operand. TODO: We could do dominance checks to; // find a dominating leader, but not worth it ATM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:108,Performance,load,loads,108,"// This function converts the set of members for a congruence class from values,; // to the set of defs for loads and stores, with associated DFS info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of having; // to update as many def-use and use-def chains. Start after the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of having; // to update as many def-use and use-def chains. Start after the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Usability,simpl,simplifycfg,29,// Now insert something that simplifycfg will turn into an unreachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:63,Integrability,depend,dependencies,63,// We save the actual erasing to avoid invalidating memory; // dependencies until we are done with everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:33,Safety,avoid,avoid,33,// We save the actual erasing to avoid invalidating memory; // dependencies until we are done with everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:65,Availability,avail,available,65,"// Given a value and a basic block we are trying to see if it is available in,; // see if the value has a leader available in that block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,Availability,avail,available,113,"// Given a value and a basic block we are trying to see if it is available in,; // see if the value has a leader available in that block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:48,Availability,avail,available,48,// Anything that isn't an instruction is always available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:127,Availability,avail,available,127,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:567,Performance,perform,perform,567,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:746,Testability,log,log,746,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:97,Deployability,update,updated,97,"// Since we are going to walk the domtree anyway, and we can't guarantee the; // DFS numbers are updated, we compute some ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:38,Availability,avail,available,38,"// If this is a leader that is always available, and it's a; // constant or has no equivalences, just replace everything with; // it. We then update the congruence class with whatever members; // are left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:142,Deployability,update,update,142,"// If this is a leader that is always available, and it's a; // constant or has no equivalences, just replace everything with; // it. We then update the congruence class with whatever members; // are left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:220,Integrability,synchroniz,synchronize,220,"// First, we see if we are out of scope or empty. If so,; // and there equivalences, we try to replace the top of; // stack with equivalences (if it's on the stack, it must; // not have been eliminated yet).; // Then we synchronize to our current scope, by; // popping until we are back within a DFS scope that; // dominates the current member.; // Then, what happens depends on a few factors; // If the stack is now empty, we need to push; // If we have a constant or a local equivalence we want to; // start using, we also push.; // Otherwise, we walk along, processing members who are; // dominated by this scope, and eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:368,Integrability,depend,depends,368,"// First, we see if we are out of scope or empty. If so,; // and there equivalences, we try to replace the top of; // stack with equivalences (if it's on the stack, it must; // not have been eliminated yet).; // Then we synchronize to our current scope, by; // popping until we are back within a DFS scope that; // dominates the current member.; // Then, what happens depends on a few factors; // If the stack is now empty, we need to push; // If we have a constant or a local equivalence we want to; // start using, we also push.; // Otherwise, we walk along, processing members who are; // dominated by this scope, and eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:89,Availability,down,downstreams,89,"// Even if the instruction is removed, we still need to update; // flags/metadata due to downstreams users of the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:56,Deployability,update,update,56,"// Even if the instruction is removed, we still need to update; // flags/metadata due to downstreams users of the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:58,Deployability,patch,patching,58,"// If we replaced something in an instruction, handle the patching of; // metadata. Skip this if we are replacing predicateinfo with its; // original operand, as we already know we can just drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:20,Availability,alive,alive,20,// It's about to be alive again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:18,Performance,load,load,18,"// We already did load elimination, so nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:252,Usability,simpl,simplify,252,"// This function provides global ranking of operations so that we can place them; // in a canonical order. Note that rank alone is not necessarily enough for a; // complete ordering, as constants all have the same rank. However, generally,; // we will simplify an operation with all constants so that it doesn't matter; // what order they appear in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:244,Modifiability,inherit,inheritance,244,"// Prefer constants to undef to anything else; // Undef is a constant, have to check it first.; // Prefer poison to undef as it's less defined.; // Prefer smaller constants to constantexprs; // Note that the order here matters because of class inheritance",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:58,Modifiability,rewrite,rewrite,58,"// Because we only care about a total ordering, and don't rewrite expressions; // in this order, we order by rank, which will give a strict weak ordering to; // everything but constants, and then we order by pointer address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2741,Deployability,Patch,Patches,2741,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:946,Integrability,wrap,wrapped,946,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1133,Integrability,rout,routine,1133,"art of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1224,Integrability,rout,routine,1224,"tion.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:502,Modifiability,variab,variable,502,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:549,Modifiability,Rewrite,RewriteStatepointsForGC,549,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:785,Modifiability,Rewrite,RewriteStatepointsForGC,785,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1866,Performance,optimiz,optimizer,1866,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1939,Performance,optimiz,optimization,1939,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:38,Safety,Safe,Safepoints,38,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:408,Safety,safe,safepoints,408,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1652,Safety,avoid,avoid,1652,"he call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1914,Safety,avoid,avoid,1914,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2279,Safety,safe,safepoints,2279,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2335,Safety,safe,safepoint,2335,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2405,Safety,safe,safepoint,2405,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2431,Safety,safe,safepoint,2431,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2491,Safety,safe,safepoint,2491,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2675,Safety,safe,safepoints,2675,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1279,Testability,log,logic,1279,"-------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:27,Safety,avoid,avoid,27,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:41,Safety,safe,safepoints,41,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:81,Security,validat,validation,81,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:122,Safety,safe,safepoints,122,"/// How narrow does the trip count of a loop have to be to have to be considered; /// ""counted""? Counted loops do not get safepoints at backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:223,Performance,optimiz,optimizes,223,"// If true, split the backedge of a loop when placing the safepoint, otherwise; // split the latch block itself. Both are useful to support for; // experimentation, but in practice, it looks like splitting the backedge; // optimizes better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:58,Safety,safe,safepoint,58,"// If true, split the backedge of a loop when placing the safepoint, otherwise; // split the latch block itself. Both are useful to support for; // experimentation, but in practice, it looks like splitting the backedge; // optimizes better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:109,Safety,safe,safepoint,109,/// An analysis pass whose purpose is to identify each of the backedges in; /// the function which require a safepoint poll to be inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:90,Integrability,depend,dependent,90,/// True unless we're running spp-no-calls in which case we need to disable; /// the call-dependent placement opts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:247,Deployability,pipeline,pipeline,247,"// Loop through all loop latches (branches controlling backedges). We need; // to place a safepoint on every backedge (potentially).; // Note: In common usage, there will be only one edge due to LoopSimplify; // having run sometime earlier in the pipeline, but this code must be correct; // w.r.t. loops with multiple backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:90,Safety,safe,safepoint,90,"// Loop through all loop latches (branches controlling backedges). We need; // to place a safepoint on every backedge (potentially).; // Note: In common usage, there will be only one edge due to LoopSimplify; // having run sometime earlier in the pipeline, but this code must be correct; // w.r.t. loops with multiple backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:120,Performance,optimiz,optimizer,120,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:58,Safety,safe,safepoint,58,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:148,Safety,avoid,avoiding,148,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:188,Safety,safe,safepoint,188,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:176,Safety,safe,safepoint,176,"// Note: This is only semantically legal since we won't do any further; // IPO or inlining before the actual call insertion.. If we hadn't, we; // might latter loose this call safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:397,Modifiability,variab,variables,397,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:161,Performance,perform,performance,161,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:221,Performance,optimiz,optimize,221,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:118,Safety,safe,safepoint,118,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:250,Safety,Safe,Safepoint,250,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:370,Safety,safe,safepoint,370,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:60,Safety,avoid,avoid,60,"// This is a declaration, nothing to do. Must exit early to avoid crash in; // dom tree calculation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:39,Safety,safe,safepoint,39,"// Given we're inlining this inside of safepoint poll insertion, this; // doesn't make any sense. Note that we do make any contained calls; // parseable after we inline a poll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,Safety,safe,safepoint,23,// STEP 1 - Insert the safepoint polling locations. We do not need to; // actually insert parse points yet. That will be done for all polls and; // calls in a single pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:103,Energy Efficiency,schedul,scheduling,103,// Construct a pass manager to run the LoopPass backedge logic. We; // need the pass manager to handle scheduling all the loop passes; // appropriately. Doing this by hand is painful and just not worth messing; // with for the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:57,Testability,log,logic,57,// Construct a pass manager to run the LoopPass backedge logic. We; // need the pass manager to handle scheduling all the loop passes; // appropriately. Doing this by hand is painful and just not worth messing; // with for the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:108,Testability,test,test,108,// We need the order of list to be stable so that naming ends up stable; // when we split edges. This makes test cases much easier to write.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:203,Testability,test,test,203,"// We can sometimes end up with duplicate poll locations. This happens if; // a single loop is visited more than once. The fact this happens seems; // wrong, but it does happen for the split-backedge.ll test case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:206,Performance,optimiz,optimize,206,"// Split the backedge of the loop and insert the poll within that new; // basic block. This creates a loop with two latches per original; // latch (which is non-ideal), but this appears to be easier to; // optimize in practice than inserting the poll immediately before the; // latch test.; // Since this is a latch, at least one of the successors must dominate; // it. Its possible that we have a) duplicate edges to the same header; // and b) edges to distinct loop headers. We need to insert pools on; // each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:284,Testability,test,test,284,"// Split the backedge of the loop and insert the poll within that new; // basic block. This creates a loop with two latches per original; // latch (which is non-ideal), but this appears to be easier to; // optimize in practice than inserting the poll immediately before the; // latch test.; // Since this is a latch, at least one of the successors must dominate; // it. Its possible that we have a) duplicate edges to the same header; // and b) edges to distinct loop headers. We need to insert pools on; // each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:98,Safety,safe,safepoint,98,"// TODO: else we should assert that there was, in fact, a policy choice to; // not insert a entry safepoint poll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:24,Testability,assert,assert,24,"// TODO: else we should assert that there was, in fact, a policy choice to; // not insert a entry safepoint poll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:44,Safety,safe,safepoint,44,"// Now that we've identified all the needed safepoint poll locations, insert; // safepoint polls themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:81,Safety,safe,safepoint,81,"// Now that we've identified all the needed safepoint poll locations, insert; // safepoint polls themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:57,Safety,safe,safepoint,57,/// Returns true if this loop is known to contain a call safepoint which; /// must unconditionally execute on any iteration of the loop which returns; /// to the loop header via an edge from Pred. Returns a conservative correct; /// answer; i.e. false is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:638,Performance,cache,cache,638,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:87,Safety,safe,safepoint,87,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:673,Safety,avoid,avoid,673,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:32,Safety,safe,safepoint,32,"// Note: Technically, needing a safepoint isn't quite the right; // condition here. We should instead be checking if the target method; // has an; // unconditional poll. In practice, this is only a theoretical concern; // since we don't have any methods with conditional-only safepoint; // polls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:276,Safety,safe,safepoint,276,"// Note: Technically, needing a safepoint isn't quite the right; // condition here. We should instead be checking if the target method; // has an; // unconditional poll. In practice, this is only a theoretical concern; // since we don't have any methods with conditional-only safepoint; // polls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:108,Security,expose,expose,108,"// This returns an exact expression only. TODO: We really only need an; // upper bound here, but SE doesn't expose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:29,Safety,safe,safepoint,29,/// Returns true if an entry safepoint is not required before this callsite in; /// the caller function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:11,Integrability,wrap,wrap,11,// The can wrap an actual call which may grow the stack by an unbounded; // amount or run forever.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:179,Performance,optimiz,optimizer,179,"// Most LLVM intrinsics are things which do not expand to actual calls, or; // at least if they do, are leaf functions that cause only finite stack; // growth. In particular, the optimizer likes to form things like memsets; // out of stores in the original IR. Another important example is; // llvm.localescape which must occur in the entry block. Inserting a; // safepoint before it is not legal since it could push the localescape; // out of the entry block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:364,Safety,safe,safepoint,364,"// Most LLVM intrinsics are things which do not expand to actual calls, or; // at least if they do, are leaf functions that cause only finite stack; // growth. In particular, the optimizer likes to form things like memsets; // out of stores in the original IR. Another important example is; // llvm.localescape which must occur in the entry block. Inserting a; // safepoint before it is not legal since it could push the localescape; // out of the entry block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,Safety,safe,safepoint,23,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:124,Safety,safe,safepoints,124,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:232,Safety,safe,safepoint,232,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:452,Safety,detect,detect,452,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:65,Safety,safe,safepoint,65,/// Returns true if this function should be rewritten to include safepoint; /// polls and parseable call sites. The main point of this function is to be; /// an extension point for custom logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:188,Testability,log,logic,188,/// Returns true if this function should be rewritten to include safepoint; /// polls and parseable call sites. The main point of this function is to be; /// an extension point for custom logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:12,Safety,safe,safepoint,12,"// Insert a safepoint poll immediately before the given instruction. Does; // not handle the parsability of state at the runtime call, that's the; // callers job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:14,Safety,safe,safepoint,14,"// Inline the safepoint poll implementation - this will get all the branch,; // control flow, etc.. Most importantly, it will introduce the actual slow; // path call - where we need to insert a safepoint (parsepoint).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:194,Safety,safe,safepoint,194,"// Inline the safepoint poll implementation - this will get all the branch,; // control flow, etc.. Most importantly, it will introduce the actual slow; // path call - where we need to insert a safepoint (parsepoint).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,Deployability,release,release-asserts,23,// suppress warning in release-asserts; // Check post-conditions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:31,Testability,assert,asserts,31,// suppress warning in release-asserts; // Check post-conditions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:201,Safety,safe,safepoint,201,// Record the fact we need a parsable state at the runtime call contained in; // the poll function. This is required so that the runtime knows how to; // parse the last frame when we actually take the safepoint (i.e. execute; // the slow path),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:6,Safety,safe,safepoint,6,// No safepoint needed or wanted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:45,Testability,assert,assert,45,// These are likely runtime calls. Should we assert that via calling; // convention or something?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:233,Integrability,rout,routine,233,/// Return true if I is an instruction with the FastMathFlags that are needed; /// for general reassociation set. This is not the same as testing; /// Instruction::isAssociative() because it includes operations like fsub.; /// (This routine is only intended to be called for floating-point operations.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:138,Testability,test,testing,138,/// Return true if I is an instruction with the FastMathFlags that are needed; /// for general reassociation set. This is not the same as testing; /// Instruction::isAssociative() because it includes operations like fsub.; /// (This routine is only intended to be called for floating-point operations.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:19,Safety,safe,safe,19,// FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:473,Integrability,rout,routine,473,"/// Add the extra weight 'RHS' to the existing weight 'LHS',; /// reducing the combined weight using any special properties of the operation.; /// The existing weight LHS represents the computation X op X op ... op X where; /// X occurs LHS times. The combined weight represents X op X op ... op X with; /// X occurring LHS + RHS times. If op is ""Xor"" for example then the combined; /// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;; /// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:364,Energy Efficiency,reduce,reduce,364,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:209,Integrability,wrap,wraps,209,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:414,Integrability,wrap,wrapping,414,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:140,Integrability,wrap,wrapping,140,"// Idempotent means X op X === X, so any non-zero weight is equivalent to a; // weight of 1. Keeping weights at zero or one also means that wrapping is; // not a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:36,Energy Efficiency,reduce,reduce,36,"// Nilpotent means X op X === 0, so reduce weights modulo 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:9,Energy Efficiency,Reduce,Reduce,9,// TODO: Reduce the weight by exploiting nsw/nuw?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:356,Energy Efficiency,reduce,reduced,356,"// If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth; // can be replaced with W-CM. That's because x^W=x^(W-CM) for every Bitwidth; // bit number x, since either x is odd in which case x^CM = 1, or x is even in; // which case both x^W and x^(W - CM) are zero. By subtracting off multiples; // of CM like this weights can always be reduced to the range [0, CM+Bitwidth); // which by a happy accident means that they can always be represented using; // Bitwidth bits.; // TODO: Reduce the weight by exploiting nsw/nuw? (Could do much better than; // the Carmichael number).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:501,Energy Efficiency,Reduce,Reduce,501,"// If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth; // can be replaced with W-CM. That's because x^W=x^(W-CM) for every Bitwidth; // bit number x, since either x is odd in which case x^CM = 1, or x is even in; // which case both x^W and x^(W - CM) are zero. By subtracting off multiples; // of CM like this weights can always be reduced to the range [0, CM+Bitwidth); // which by a happy accident means that they can always be represented using; // Bitwidth bits.; // TODO: Reduce the weight by exploiting nsw/nuw? (Could do much better than; // the Carmichael number).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:6,Safety,avoid,avoid,6,// To avoid problems with overflow do everything the same as above but using; // a larger type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:547,Integrability,rout,routine,547,"/// Given an associative binary expression, return the leaf; /// nodes in Ops along with their weights (how many times the leaf occurs). The; /// original expression is the same as; /// (Ops[0].first op Ops[0].first op ... Ops[0].first) <- Ops[0].second times; /// op; /// (Ops[1].first op Ops[1].first op ... Ops[1].first) <- Ops[1].second times; /// op; /// ...; /// op; /// (Ops[N].first op Ops[N].first op ... Ops[N].first) <- Ops[N].second times; ///; /// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.; ///; /// This routine may modify the function, in which case it returns 'true'. The; /// changes it makes may well be destructive, changing the value computed by 'I'; /// to something completely different. Thus if the routine returns 'true' then; /// you MUST either replace I with a new expression computed from the Ops array,; /// or use RewriteExprTree to put the values back in.; ///; /// A leaf node is either not a binary operation of the same kind as the root; /// node 'I' (i.e. is not a binary operator at all, or is, but with a different; /// opcode), or is the same kind of binary operator but has a use which either; /// does not belong to the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:751,Integrability,rout,routine,751,"/// Given an associative binary expression, return the leaf; /// nodes in Ops along with their weights (how many times the leaf occurs). The; /// original expression is the same as; /// (Ops[0].first op Ops[0].first op ... Ops[0].first) <- Ops[0].second times; /// op; /// (Ops[1].first op Ops[1].first op ... Ops[1].first) <- Ops[1].second times; /// op; /// ...; /// op; /// (Ops[N].first op Ops[N].first op ... Ops[N].first) <- Ops[N].second times; ///; /// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.; ///; /// This routine may modify the function, in which case it returns 'true'. The; /// changes it makes may well be destructive, changing the value computed by 'I'; /// to something completely different. Thus if the routine returns 'true' then; /// you MUST either replace I with a new expression computed from the Ops array,; /// or use RewriteExprTree to put the values back in.; ///; /// A leaf node is either not a binary operation of the same kind as the root; /// node 'I' (i.e. is not a binary operator at all, or is, but with a different; /// opcode), or is the same kind of binary operator but has a use which either; /// does not belong to the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:2100,Integrability,rout,routine,2100,"the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:2460,Integrability,rout,routine,2460,"se is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of the wrong type; /// that have all uses inside the expression (i.e. only used by non-leaf nodes; /// of the expression) if it can turn them into binary operators of the right; /// type and thus make the expression bigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3143,Integrability,rout,routine,3143,"se is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of the wrong type; /// that have all uses inside the expression (i.e. only used by non-leaf nodes; /// of the expression) if it can turn them into binary operators of the right; /// type and thus make the expression bigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:873,Modifiability,Rewrite,RewriteExprTree,873,"/// Given an associative binary expression, return the leaf; /// nodes in Ops along with their weights (how many times the leaf occurs). The; /// original expression is the same as; /// (Ops[0].first op Ops[0].first op ... Ops[0].first) <- Ops[0].second times; /// op; /// (Ops[1].first op Ops[1].first op ... Ops[1].first) <- Ops[1].second times; /// op; /// ...; /// op; /// (Ops[N].first op Ops[N].first op ... Ops[N].first) <- Ops[N].second times; ///; /// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.; ///; /// This routine may modify the function, in which case it returns 'true'. The; /// changes it makes may well be destructive, changing the value computed by 'I'; /// to something completely different. Thus if the routine returns 'true' then; /// you MUST either replace I with a new expression computed from the Ops array,; /// or use RewriteExprTree to put the values back in.; ///; /// A leaf node is either not a binary operation of the same kind as the root; /// node 'I' (i.e. is not a binary operator at all, or is, but with a different; /// opcode), or is the same kind of binary operator but has a use which either; /// does not belong to the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:2411,Modifiability,Rewrite,RewriteExprTree,2411,"se is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of the wrong type; /// that have all uses inside the expression (i.e. only used by non-leaf nodes; /// of the expression) if it can turn them into binary operators of the right; /// type and thus make the expression bigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:77,Safety,safe,safe,77,"// This value has uses not accounted for by the expression, so it is; // not safe to modify. Mark it as being a leaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Deployability,Update,Update,3,// Update the number of paths to the leaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:89,Safety,safe,safe,89,// If we still have uses that are not accounted for by the expression; // then it is not safe to modify the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:181,Safety,safe,safely,181,"// At this point we have a value which, first of all, is not a binary; // expression of the right kind, and secondly, is only used inside the; // expression. This means that it can safely be modified. See if we; // can usefully morph it into an expression of the right kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:246,Security,expose,exposed,246,"// If this is a multiply expression, turn any internal negations into; // multiplies by -1 so they can be reassociated. Add any users of the; // newly created multiplication by -1 to the redo list, so any; // reassociation opportunities that are exposed will be reassociated; // further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:186,Energy Efficiency,reduce,reduces,186,"// For nilpotent operations or addition there may be no operands, for example; // because the expression was ""X xor X"" or consisted of 2^Bitwidth additions:; // in both cases the weight reduces to 0 causing the value to be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:75,Performance,optimiz,optimized,75,"/// Now that the operands for this expression tree are; /// linearized and optimized, emit them in-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:621,Availability,avail,available,621,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,Performance,optimiz,optimizations,13,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:507,Usability,clear,clear,507,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:446,Performance,optimiz,optimization,446,"/// NotRewritable - The operands being written will be the leaves of the new; /// expression and must not be used as inner nodes (via NodesToRewrite) by; /// mistake. Inner nodes are always reassociable, and usually leaves are not; /// (if they were they would have been incorporated into the expression and so; /// would not be leaves), so most of the time there is no danger of this. But; /// in rare cases a leaf may become reassociable if an optimization kills uses; /// of it, or it may momentarily become reassociable during rewriting (below); /// due it being removed as an operand of one of its uses. Ensure that misuse; /// of leaf nodes as inner nodes cannot occur by remembering all of the future; /// leaves and refusing to reuse any of them as inner nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:134,Usability,clear,clearing,134,"// ExpressionChangedStart - Non-null if the rewritten expression differs from; // the original in some non-trivial way, requiring the clearing of optional; // flags. Flags are cleared from the operator in ExpressionChangedStart up to; // ExpressionChangedEnd inclusive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:176,Usability,clear,cleared,176,"// ExpressionChangedStart - Non-null if the rewritten expression differs from; // the original in some non-trivial way, requiring the clearing of optional; // flags. Flags are cleared from the operator in ExpressionChangedStart up to; // ExpressionChangedEnd inclusive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:117,Modifiability,rewrite,rewrite,117,// Now deal with the left-hand side. If this is already an operation node; // from the original expression then just rewrite the rest of the expression; // into it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:137,Performance,optimiz,optimizers,137,"// Otherwise, grab a spare node from the original expression and use that as; // the left-hand side. If there are no nodes left then the optimizers made; // an expression with more nodes than the original! This usually means that; // they did something stupid but it might mean that the problem was just too; // hard (finding the mimimal number of multiplications needed to realize a; // multiplication expression is NP-complete). Whatever the reason, smart or; // stupid, create a new node if there are none left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:48,Usability,clear,clear,48,"// If the expression changed non-trivially then clear out all subclass data; // starting from the operator specified in ExpressionChanged, and compactify; // the operators to just before the expression root to guarantee that the; // expression tree is dominated by all of Ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:480,Security,expose,exposed,480,"/// Insert instructions before the instruction pointed to by BI,; /// that computes the negative version of the value specified. The negative; /// version of the value is returned, and BI is left pointing at the instruction; /// that should be processed next by the reassociation pass.; /// Also add intermediate instructions to the redo list that are modified while; /// pushing the negates through adds. These will be revisited to see if; /// additional opportunities have been exposed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:20,Security,expose,expose,20,"// We are trying to expose opportunity for reassociation. One of the things; // that we want to do to achieve this is to push a negation as deep into an; // expression chain as possible, to expose the add instructions. In practice,; // this means that we turn this:; // X = -(A+12+C+D) into X = -A + -12 + -C + -D = -12 + -A + -C + -D; // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate; // the constants. We assume that instcombine will clean up the mess later if; // we introduce tons of unnecessary negation instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:190,Security,expose,expose,190,"// We are trying to expose opportunity for reassociation. One of the things; // that we want to do to achieve this is to push a negation as deep into an; // expression chain as possible, to expose the add instructions. In practice,; // this means that we turn this:; // X = -(A+12+C+D) into X = -A + -12 + -C + -D = -12 + -A + -C + -D; // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate; // the constants. We assume that instcombine will clean up the mess later if; // we introduce tons of unnecessary negation instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:84,Security,expose,expose,84,// Add the intermediate negates to the redo list as processing them later; // could expose more reassociating opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:12,Safety,safe,safely,12,// We can't safely propagate a vector zero constant with poison/undef lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:34,Performance,load,load,34,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:110,Performance,load,load,110,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:189,Performance,load,load,189,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:281,Performance,load,load,281,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:41,Performance,load,load,41,// Node is certainly not part of an `or` load reduction.; // Only process instructions we have never processed before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,Performance,load,load,13,"// Perfect, `load` node means we've reached an edge of the graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:10,Safety,safe,safely,10,"// We can safely preserve the nuw flag in all cases. It's also safe to turn a; // nuw nsw shl into a nuw nsw mul. However, nsw in isolation requires special; // handling. It can be preserved as long as we're not left shifting by; // bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:63,Safety,safe,safe,63,"// We can safely preserve the nuw flag in all cases. It's also safe to turn a; // nuw nsw shl into a nuw nsw mul. However, nsw in isolation requires special; // handling. It can be preserved as long as we're not left shifting by; // bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:129,Energy Efficiency,reduce,reduced,129,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:85,Performance,optimiz,optimizes,85,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:103,Usability,simpl,simplify,103,"// Scan the operand lists looking for X and ~X pairs, along with X,X pairs.; // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:22,Performance,Optimiz,OptimizeXor,22,"// Helper function of OptimizeXor(). It tries to simplify ""Opnd1 ^ ConstOpnd""; // into ""R ^ C"", where C would be 0, and R is a symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively; otherwise, false is returned,; // and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:49,Usability,simpl,simplify,49,"// Helper function of OptimizeXor(). It tries to simplify ""Opnd1 ^ ConstOpnd""; // into ""R ^ C"", where C would be 0, and R is a symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively; otherwise, false is returned,; // and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:22,Performance,Optimiz,OptimizeXor,22,"// Helper function of OptimizeXor(). It tries to simplify; // ""Opnd1 ^ Opnd2 ^ ConstOpnd"" into ""R ^ C"", where C would be 0, and R is a; // symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively (If the entire expression is; // evaluated to a constant, the Res is set to NULL); otherwise, false is; // returned, and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:49,Usability,simpl,simplify,49,"// Helper function of OptimizeXor(). It tries to simplify; // ""Opnd1 ^ Opnd2 ^ ConstOpnd"" into ""R ^ C"", where C would be 0, and R is a; // symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively (If the entire expression is; // evaluated to a constant, the Res is set to NULL); otherwise, false is; // returned, and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:72,Energy Efficiency,reduce,reduced,72,"/// Optimize a series of operands to an 'xor' instruction. If it can be reduced; /// to a single Value, it is returned, otherwise the Ops list is mutated as; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a series of operands to an 'xor' instruction. If it can be reduced; /// to a single Value, it is returned, otherwise the Ops list is mutated as; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:487,Security,expose,expose,487,"// Step 2: Sort the Xor-Operands in a way such that the operands containing; // the same symbolic value cluster together. For instance, the input operand; // sequence (""x | 123"", ""y & 456"", ""x & 789"") will be sorted into:; // (""x | 123"", ""x & 789"", ""y & 456"").; //; // The purpose is twofold:; // 1) Cluster together the operands sharing the same symbolic-value.; // 2) Operand having smaller symbolic-value-rank is permuted earlier, which; // could potentially shorten crital path, and expose more loop-invariants.; // Note that values' rank are basically defined in RPO order (FIXME).; // So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier; // than Y which is defined earlier than Z. Permute ""x | 1"", ""Y & 2"",; // ""z"" in the order of X-Y-Z is better than any other orders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:17,Usability,simpl,simplifying,17,"// Step 3.1: Try simplifying ""CurrOpnd ^ ConstOpnd""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:90,Usability,simpl,simplify,90,"// step 3.2: When previous and current operands share the same symbolic; // value, try to simplify ""PrevOpnd ^ CurrOpnd ^ ConstOpnd""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:113,Energy Efficiency,reduce,reduced,113,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:69,Performance,optimiz,optimizes,69,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:81,Usability,simpl,simplify,81,"// Scan the operand lists looking for X and -X pairs. If we find any, we; // can simplify expressions like X+-X == 0 and X+~X ==-1. While we're at it,; // scan for any; // duplicates. We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:41,Performance,optimiz,optimize,41,"// Now that we have inserted a multiply, optimize it. This allows us to; // handle cases that require multiple factoring steps, such as this:; // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:193,Energy Efficiency,reduce,reduces,193,"// Scan the operand list, checking to see if there are any common factors; // between operands. Consider something like A*A+A*B*C+D. We would like to; // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.; // To efficiently find this, we count the number of times a factor occurs; // for any ADD operands that are MULs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:234,Energy Efficiency,efficient,efficiently,234,"// Scan the operand list, checking to see if there are any common factors; // between operands. Consider something like A*A+A*B*C+D. We would like to; // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.; // To efficiently find this, we count the number of times a factor occurs; // for any ADD operands that are MULs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:42,Safety,avoid,avoid,42,"// Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4); // where they are actually the same multiply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:43,Performance,optimiz,optimize,43,"// Now that we have inserted the add tree, optimize it. This allows us to; // handle cases that require multiple factoring steps, such as this:; // A*A*B + A*A*C --> A*(A*B+A*C) --> A*(A*(B+C))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:31,Energy Efficiency,power,power,31,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:156,Energy Efficiency,power,powers,156,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:255,Energy Efficiency,power,power,255,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:406,Energy Efficiency,power,power,406,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:97,Energy Efficiency,power,powers,97,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:56,Usability,simpl,simplifying,56,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:107,Usability,simpl,simplifiable,107,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,Usability,simpl,simplification,13,// Track for simplification all factors which occur 2 or more times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:50,Energy Efficiency,power,powers,50,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:15,Usability,simpl,simplify,15,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:64,Usability,simpl,simplifiable,64,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:156,Usability,simpl,simplification,156,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:237,Usability,simpl,simplify,237,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:18,Usability,simpl,simplifiable,18,"// Now gather the simplifiable factors, removing them from Ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:45,Energy Efficiency,reduce,reduced,45,// None of the adjustments above should have reduced the sum of factor powers; // below our mininum of '4'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:71,Energy Efficiency,power,powers,71,// None of the adjustments above should have reduced the sum of factor powers; // below our mininum of '4'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:118,Energy Efficiency,power,powers,118,"/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...; ///; /// Given a vector of values raised to various powers, where no two values are; /// equal and the powers are sorted in decreasing order, compute the minimal; /// DAG of multiplies to compute the final product, and return that product; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:169,Energy Efficiency,power,powers,169,"/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...; ///; /// Given a vector of values raised to various powers, where no two values are; /// equal and the powers are sorted in decreasing order, compute the minimal; /// DAG of multiplies to compute the final product, and return that product; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:60,Energy Efficiency,power,power,60,// We want to multiply across all the factors with the same power so that; // we can raise them to that power as a single entity. Build a mini tree; // for that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:104,Energy Efficiency,power,power,104,// We want to multiply across all the factors with the same power so that; // we can raise them to that power as a single entity. Build a mini tree; // for that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:119,Energy Efficiency,power,power,119,// Reset the base value of the first factor to the new expression tree.; // We'll remove all the factors with the same power in a second pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:29,Energy Efficiency,power,powers,29,// Unique factors with equal powers -- we've folded them into the first one's; // base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:59,Energy Efficiency,power,power,59,"// Iteratively collect the base of each factor with an add power into the; // outer product, and halve each power in preparation for squaring the; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:108,Energy Efficiency,power,power,108,"// Iteratively collect the base of each factor with an add power into the; // outer product, and halve each power in preparation for squaring the; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:15,Performance,optimiz,optimize,15,"// We can only optimize the multiplies when there is a chain of more than; // three, such that a balanced tree might require fewer total multiplies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:55,Performance,perform,performed,55,// The reassociate transformation for FP operations is performed only; // if unsafe algebra is permitted by FastMathFlags. Propagate those flags; // to the newly generated operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:77,Safety,unsafe,unsafe,77,// The reassociate transformation for FP operations is performed only; // if unsafe algebra is permitted by FastMathFlags. Propagate those flags; // to the newly generated operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:59,Performance,optimiz,optimize,59,"// Now that we have the linearized expression tree, try to optimize it.; // Start by folding any constants that we found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Performance,Optimiz,Optimize,3,// Optimize its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Safety,Detect,Detect,3,// Detect self-referential nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:109,Performance,optimiz,optimization,109,"// If this is a node in an expression tree, climb to the expression root; // and add that since that's where optimization actually happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:16,Performance,optimiz,optimize,16,/// Inspect and optimize the given instruction. Note that erasing; /// instructions is not allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:99,Security,expose,expose,99,"// Commute binary operators, to canonicalize the order of their operands.; // This can potentially expose more CSE opportunities, and makes writing other; // transformations simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:174,Usability,simpl,simpler,174,"// Commute binary operators, to canonicalize the order of their operands.; // This can potentially expose more CSE opportunities, and makes writing other; // transformations simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:9,Performance,optimiz,optimize,9,// Don't optimize floating-point instructions unless they have the; // appropriate FastMathFlags for reassociation enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:229,Performance,optimiz,optimized,229,"// Do not reassociate boolean (i1) expressions. We want to preserve the; // original order of evaluation for short-circuited comparisons that; // SimplifyCFG has folded to AND/OR expressions. If the expression; // is not further optimized, it is likely to be transformed back to a; // short-circuited form for code gen, and the source order may have been; // optimized for the most likely conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:359,Performance,optimiz,optimized,359,"// Do not reassociate boolean (i1) expressions. We want to preserve the; // original order of evaluation for short-circuited comparisons that; // SimplifyCFG has folded to AND/OR expressions. If the expression; // is not further optimized, it is likely to be transformed back to a; // short-circuited form for code gen, and the source order may have been; // optimized for the most likely conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:146,Usability,Simpl,SimplifyCFG,146,"// Do not reassociate boolean (i1) expressions. We want to preserve the; // original order of evaluation for short-circuited comparisons that; // SimplifyCFG has folded to AND/OR expressions. If the expression; // is not further optimized, it is likely to be transformed back to a; // short-circuited form for code gen, and the source order may have been; // optimized for the most likely conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:21,Usability,simpl,simplified,21,"// If the negate was simplified, revisit the users to see if we can; // reassociate further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:21,Usability,simpl,simplified,21,"// If the negate was simplified, revisit the users to see if we can; // reassociate further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:110,Safety,avoid,avoid,110,"// If this is an interior node of a reassociable tree, ignore it until we; // get to the root of the tree, to avoid N^2 analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:73,Performance,optimiz,optimize,73,"// Now that we have the expression tree in a convenient; // sorted form, optimize it globally if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:24,Usability,simpl,simplified,24,"// This expression tree simplified to something that isn't a tree,; // eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:24,Usability,simpl,simplified,24,"// This expression tree simplified to something that isn't a tree,; // eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:208,Integrability,depend,dependences,208,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:453,Integrability,depend,dependent,453,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:193,Safety,avoid,avoid,193,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:400,Safety,avoid,avoid,400,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:400,Availability,down,down,400,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:32,Integrability,depend,dependencies,32,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:304,Integrability,depend,dependencies,304,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:841,Integrability,depend,dependent,841,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:195,Security,expose,expose,195,"// By construction, the operands are sorted in reverse order of their; // topological order.; // So we tend to form (sub) expressions with values that are close to; // each other.; //; // Now to expose more CSE opportunities we want to expose the pair of; // operands that occur the most (as statically computed in; // BuildPairMap.) as the first sub-expression.; //; // If two pairs occur as many times, we pick the one with the; // lowest rank, meaning the one with both operands appearing first in; // the topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:236,Security,expose,expose,236,"// By construction, the operands are sorted in reverse order of their; // topological order.; // So we tend to form (sub) expressions with values that are close to; // each other.; //; // Now to expose more CSE opportunities we want to expose the pair of; // operands that occur the most (as statically computed in; // BuildPairMap.) as the first sub-expression.; //; // If two pairs occur as many times, we pick the one with the; // lowest rank, meaning the one with both operands appearing first in; // the topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:27,Performance,optimiz,optimized,27,"// Now that we ordered and optimized the expressions, splat them back into; // the expression tree, removing any unneeded nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:359,Deployability,pipeline,pipeline,359,"// Build the pair map before running reassociate.; // Technically this would be more accurate if we did it after one round; // of reassociation, but in practice it doesn't seem to help much on; // real-world code, so don't waste the compile time running reassociate; // twice.; // If a user wants, they could expicitly run reassociate twice in their; // pass pipeline for further potential gains.; // It might also be possible to update the pair map during runtime, but the; // overhead of that may be large if there's many reassociable chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:430,Deployability,update,update,430,"// Build the pair map before running reassociate.; // Technically this would be more accurate if we did it after one round; // of reassociation, but in practice it doesn't seem to help much on; // real-world code, so don't waste the compile time running reassociate; // twice.; // If a user wants, they could expicitly run reassociate twice in their; // pass pipeline for further potential gains.; // It might also be possible to update the pair map during runtime, but the; // overhead of that may be large if there's many reassociable chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Performance,Optimiz,Optimize,3,// Optimize every instruction in the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:10,Integrability,interface,interface,10,// Public interface to the Reassociate pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:519,Performance,load,loads,519,"//===- Reg2Mem.cpp - Convert registers to allocas -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file demotes all registers to memory references. It is intended to be; // the inverse of PromoteMemoryToRegister. By converting to loads, the only; // values live across basic blocks are allocas and loads before phi nodes.; // It is intended that this should make CFG hacking much easier.; // To make later hacking easier, the entry block is split into two, such that; // all introduced allocas and nothing else are in the entry block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:587,Performance,load,loads,587,"//===- Reg2Mem.cpp - Convert registers to allocas -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file demotes all registers to memory references. It is intended to be; // the inverse of PromoteMemoryToRegister. By converting to loads, the only; // values live across basic blocks are allocas and loads before phi nodes.; // It is intended that this should make CFG hacking much easier.; // To make later hacking easier, the entry block is split into two, such that; // all introduced allocas and nothing else are in the entry block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:77,Safety,safe,safe,77,"// Find first non-alloca instruction and create insertion point. This is; // safe if block is well-formed: it always have terminator, otherwise; // we'll get and assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:162,Testability,assert,assertion,162,"// Find first non-alloca instruction and create insertion point. This is; // safe if block is well-formed: it always have terminator, otherwise; // we'll get and assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:7,Modifiability,Rewrite,RewriteStatepointsForGC,7,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:383,Modifiability,Rewrite,Rewrite,383,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:456,Performance,perform,performed,456,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:20,Modifiability,Rewrite,RewriteStatepointsForGC,20,"/// The IR fed into RewriteStatepointsForGC may have had attributes and; /// metadata implying dereferenceability that are no longer valid/correct after; /// RewriteStatepointsForGC has run. This is because semantically, after; /// RewriteStatepointsForGC runs, all calls to gc.statepoint ""free"" the entire; /// heap. stripNonValidData (conservatively) restores; /// correctness by erasing all attributes in the module that externally imply; /// dereferenceability. Similar reasoning also applies to the noalias; /// attributes and metadata. gc.statepoint can touch the entire heap including; /// noalias objects.; /// Apart from attributes and metadata, we also remove instructions that imply; /// constant physical memory: llvm.invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:158,Modifiability,Rewrite,RewriteStatepointsForGC,158,"/// The IR fed into RewriteStatepointsForGC may have had attributes and; /// metadata implying dereferenceability that are no longer valid/correct after; /// RewriteStatepointsForGC has run. This is because semantically, after; /// RewriteStatepointsForGC runs, all calls to gc.statepoint ""free"" the entire; /// heap. stripNonValidData (conservatively) restores; /// correctness by erasing all attributes in the module that externally imply; /// dereferenceability. Similar reasoning also applies to the noalias; /// attributes and metadata. gc.statepoint can touch the entire heap including; /// noalias objects.; /// Apart from attributes and metadata, we also remove instructions that imply; /// constant physical memory: llvm.invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:232,Modifiability,Rewrite,RewriteStatepointsForGC,232,"/// The IR fed into RewriteStatepointsForGC may have had attributes and; /// metadata implying dereferenceability that are no longer valid/correct after; /// RewriteStatepointsForGC has run. This is because semantically, after; /// RewriteStatepointsForGC runs, all calls to gc.statepoint ""free"" the entire; /// heap. stripNonValidData (conservatively) restores; /// correctness by erasing all attributes in the module that externally imply; /// dereferenceability. Similar reasoning also applies to the noalias; /// attributes and metadata. gc.statepoint can touch the entire heap including; /// noalias objects.; /// Apart from attributes and metadata, we also remove instructions that imply; /// constant physical memory: llvm.invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:29,Modifiability,rewrite,rewrite,29,// Policy choice says not to rewrite - the most common reason is that we're; // compiling code without a GCStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:21,Testability,assert,asserts,21,"// stripNonValidData asserts that shouldRewriteStatepointsIn; // returns true for at least one function in the module. Since at least; // one function changed, we know that the precondition is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:549,Deployability,update,update,549,"// The type of the internal cache used inside the findBasePointers family; // of functions. From the callers perspective, this is an opaque type and; // should not be inspected.; //; // In the actual implementation this caches two relations:; // - The base relation itself (i.e. this pointer is based on that one); // - The base defining value relation (i.e. before base_phi insertion); // Generally, after the execution of a full findBasePointer call, only the; // base relation will remain. Internally, we add a mixture of the two; // types, then update all the second type to the first type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:28,Performance,cache,cache,28,"// The type of the internal cache used inside the findBasePointers family; // of functions. From the callers perspective, this is an opaque type and; // should not be inspected.; //; // In the actual implementation this caches two relations:; // - The base relation itself (i.e. this pointer is based on that one); // - The base defining value relation (i.e. before base_phi insertion); // Generally, after the execution of a full findBasePointer call, only the; // base relation will remain. Internally, we add a mixture of the two; // types, then update all the second type to the first type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:220,Performance,cache,caches,220,"// The type of the internal cache used inside the findBasePointers family; // of functions. From the callers perspective, this is an opaque type and; // should not be inspected.; //; // In the actual implementation this caches two relations:; // - The base relation itself (i.e. this pointer is based on that one); // - The base defining value relation (i.e. before base_phi insertion); // Generally, after the execution of a full findBasePointer call, only the; // base relation will remain. Internally, we add a mixture of the two; // types, then update all the second type to the first type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:51,Safety,safe,safepoint,51,/// The set of values known to be live across this safepoint,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:186,Testability,assert,assert,186,// Return true if this type is one which a) is a gc pointer or contains a GC; // pointer and b) is of a type this code expects to encounter as a live value.; // (The insertion code will assert that a type which matches (a) and not (b); // is not encountered.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:62,Testability,assert,assert,62,// We partially support vectors of gc pointers. The code will assert if it; // can't handle something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:186,Testability,assert,assertions,186,// Returns true if this is a type which a) is a gc pointer or contains a GC; // pointer and b) is of a type which the code doesn't expect (i.e. first class; // aggregates). Used to trip assertions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:111,Performance,perform,performed,111,// Conservatively identifies any definitions which might be live at the; // given instruction. The analysis is performed immediately before the; // given instruction. Values defined by that instruction are not considered; // live. Values used by that instruction are considered live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:4,Performance,Cache,Caches,4,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:91,Performance,cache,cache,91,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,Testability,assert,asserts,48,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:169,Performance,optimiz,optimization,169,"/// Return a base defining value for the 'Index' element of the given vector; /// instruction 'I'. If Index is null, returns a BDV for the entire vector; /// 'I'. As an optimization, this method will try to determine when the; /// element is known to already be a base pointer. If this can be established,; /// the second value in the returned pair will be true. Note that either a; /// vector or a pointer typed value can be returned. For the former, the; /// vector returned is a BDV (and possibly a base) of the entire vector 'I'.; /// If the later, the return pointer is a BDV (or possibly a base) for the; /// particular element in 'I'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:245,Performance,optimiz,optimizations,245,"// We don't know whether this vector contains entirely base pointers or; // not. To be conservatively correct, we treat it as a BDV and will; // duplicate code as needed to construct a parallel vector of bases.; // TODO: There a number of local optimizations which could be applied here; // for particular sufflevector patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,Usability,simpl,simple,137,"/// Helper function for findBasePointer - Will return a value which either a); /// defines the base pointer for the input, b) blocks the simple search; /// (i.e. a PHI or Select of two derived pointers), or c) involves a change; /// from pointer to vector type or back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:307,Performance,optimiz,optimizer,307,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:445,Safety,avoid,avoid,445,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:600,Testability,test,test,600,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:250,Performance,optimiz,optimizer,250,// inttoptrs in an integral address space are currently ill-defined. We; // treat them as defining base pointers here for consistency with the; // constant rule above and because we don't really have a better semantic; // to give them. Note that the optimizer is always free to insert undefined; // behavior on dynamically dead paths as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,Usability,simpl,simply,84,"// If we find a cast instruction here, it means we've found a cast which is; // not simply a pointer cast (i.e. an inttoptr). We don't know how to; // handle int->ptr conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,Performance,load,loaded,13,// The value loaded is an gc base itself,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,Safety,safe,safepoint,13,"// Rerunning safepoint insertion after safepoints are already; // inserted is not supported. It could probably be made to work,; // but why are you doing this? There's no good reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:39,Safety,safe,safepoints,39,"// Rerunning safepoint insertion after safepoints are already; // inserted is not supported. It could probably be made to work,; // but why are you doing this? There's no good reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,Modifiability,extend,extended,41,"// Currently, this mechanism hasn't been extended to work with gcroot.; // There's no reason it couldn't be, but I haven't thought about the; // implications much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:43,Performance,load,load,43,"// A CAS is effectively a atomic store and load combined under a; // predicate. From the perspective of base pointers, we just treat it; // like a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:147,Performance,load,load,147,"// A CAS is effectively a atomic store and load combined under a; // predicate. From the perspective of base pointers, we just treat it; // like a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:123,Performance,load,load,123,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:200,Performance,load,load,200,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:108,Usability,simpl,simply,108,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:155,Testability,test,test,155,// Note: There a lot of obvious peephole cases here. This are deliberately; // handled after the main base pointer inference algorithm to make writing; // test cases to exercise that code easier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:14,Availability,avail,available,14,// Only a BDV available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:194,Availability,reliab,reliable,194,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:244,Availability,failure,failure,244,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:110,Usability,simpl,simply,110,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:738,Usability,simpl,simpler,738,"// Here's the rough algorithm:; // - For every SSA value, construct a mapping to either an actual base; // pointer or a PHI which obscures the base pointer.; // - Construct a mapping from PHI to unknown TOP state. Use an; // optimistic algorithm to propagate base pointer information. Lattice; // looks like:; // UNKNOWN; // b1 b2 b3 b4; // CONFLICT; // When algorithm terminates, all PHIs will either have a single concrete; // base or be in a conflict state.; // - For every conflict, insert a dummy PHI node without arguments. Add; // these to the base[Instruction] = BasePtr mapping. For every; // non-conflict, add the actual base.; // - For every conflict, add arguments for the base[a] of each input; // arguments.; //; // Note: A simpler form of this would be to add the conflict form of all; // PHIs without running the optimistic algorithm. This would be; // analogous to pessimistic data flow and would likely lead to an; // overall worse solution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:77,Safety,safe,safely,77,"// Known bases won't need new instructions introduced and can be; // ignored safely. However, this can only be done when InVal and Base; // are both scalar or both vector. Otherwise, we need to find a; // correct BDV for InVal, by creating an entry in the lattice; // (States).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Cache,Cache,3,// Cache the fact V is it's own base for later usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:122,Performance,cache,cached,122,// Return a phi state for a base defining value. We'll generate a new; // base state for known bases and expect to find a cached state otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:1115,Performance,optimiz,optimized,1115,"// Even though we have identified a concrete base (or a conflict) for all live; // pointers at this point, there are cases where the base is of an; // incompatible type compared to the original instruction. We conservatively; // mark those as conflicts to ensure that corresponding BDVs will be generated; // in the next steps.; // this is a rather explicit check for all cases where we should mark the; // state as a conflict to force the latter stages of the algorithm to emit; // the BDVs.; // TODO: in many cases the instructions emited for the conflicting states; // will be identical to the I itself (if the I's operate on their BDVs; // themselves). We should exploit this, but can't do it here since it would; // break the invariant about the BDVs not being known to be a base.; // TODO: the code also does not handle constants at all - the algorithm relies; // on all constants having the same BDV and therefore constant-only insns; // will never be in conflict, but this check is ignored here. If the; // constant conflicts will be to BDVs themselves, they will be identical; // instructions and will get optimized away (as in the above TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:49,Safety,safe,safe,49,"// We're only changing values in this loop, thus safe to keep iterators.; // Since this is computing a fixed point, the order of visit does not; // effect the result. TODO: We could use a worklist here and make this run; // much faster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:89,Testability,assert,asserts,89,// since we do the conflict marking as part of the fixpoint iteration this; // loop only asserts that invariants are met,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:99,Integrability,depend,dependency,99,// Insert Phis for all conflicts; // TODO: adjust naming patterns to avoid this order of iteration dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:69,Safety,avoid,avoid,69,// Insert Phis for all conflicts; // TODO: adjust naming patterns to avoid this order of iteration dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:87,Safety,predict,predictable,87,// Fixup all the inputs of the new PHIs. Visit order needs to be; // deterministic and predictable because we're naming newly created; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,Testability,assert,assert,19,// In essence this assert states: the only way two values; // incoming from the same basic block may be different is by; // being different bitcasts of the same value. A cleanup; // that remains TODO is changing findBaseOrBDV to return an; // llvm::Value of the correct type (and still remain pure).; // This will remove the need to add bitcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Cache,Cache,3,// Cache all of our results so we can cheaply reuse them; // NOTE: This is actually two caches: one of the base defining value; // relation and one of the base pointer relation! FIXME,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:88,Performance,cache,caches,88,// Cache all of our results so we can cheaply reuse them; // NOTE: This is actually two caches: one of the base defining value; // relation and one of the base pointer relation! FIXME,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:131,Integrability,rout,routine,131,"// For a set of live pointers (base and/or derived), identify the base; // pointer of the object which they are derived from. This routine will; // mutate the IR graph as needed to make the 'base' pointer live at the; // definition site of 'derived'. This ensures that any use of 'derived' can; // also use 'base'. This may involve the insertion of a number of; // additional PHI nodes.; //; // preconditions: live is a set of pointer type Values; //; // side effects: may insert PHI nodes into the existing CFG, will preserve; // CFG, will not remove or mutate any existing nodes; //; // post condition: PointerToBase contains one (derived, base) pair for every; // pointer in live. Note that derived can be equal to base if the original; // pointer was a base pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:76,Performance,optimiz,optimization,76,"// We assume that all pointers passed to deopt are base pointers; as an; // optimization, we can use this to avoid seperately materializing the base; // pointer graph. This is only relevant since we're very conservative about; // generating new conflict nodes during base pointer insertion. If we were; // smarter there, this would be irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:109,Safety,avoid,avoid,109,"// We assume that all pointers passed to deopt are base pointers; as an; // optimization, we can use this to avoid seperately materializing the base; // pointer graph. This is only relevant since we're very conservative about; // generating new conflict nodes during base pointer insertion. If we were; // smarter there, this would be irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,Deployability,update,updated,13,"/// Given an updated version of the dataflow liveness results, update the; /// liveset and base pointer maps for the call site CS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:63,Deployability,update,update,63,"/// Given an updated version of the dataflow liveness results, update the; /// liveset and base pointer maps for the call site CS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,Usability,simpl,simply,48,"// TODO-PERF: reuse the original liveness, then simply run the dataflow; // again. The old values are still live and will help it stabilize quickly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:99,Deployability,update,update,99,// If it is not first instruction in the chain then it uses previously; // cloned value. We should update it to use cloned value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,Assert,Assert,3,// Assert that cloned instruction does not use any instructions from; // this chain other than LastClonedValue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,Assert,Assert,3,// Assert that the cloned instruction does not use the RootOfChain; // or the AlternateLiveBase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,Safety,safe,safely,48,// Now that 'Ret' has unique predecessor we can safely remove all phi nodes; // from it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:25,Safety,safe,safely,25,"// At this point, we can safely insert a gc.relocate or gc.result as the first; // instruction in Ret if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:264,Performance,optimiz,optimization,264,"// List of all function attributes which must be stripped when lowering from; // abstract machine model to physical machine model. Essentially, these are; // all the effects a safepoint might have which we ignored in the abstract; // machine model for purposes of optimization. We have to strip these on; // both function declarations and call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:176,Safety,safe,safepoint,176,"// List of all function attributes which must be stripped when lowering from; // abstract machine model to physical machine model. Essentially, these are; // all the effects a safepoint might have which we ignored in the abstract; // machine model for purposes of optimization. We have to strip these on; // both function declarations and call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:114,Safety,safe,safepoint,114,// Create new attribute set containing only attributes which can be transferred; // from the original call to the safepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:168,Safety,avoid,avoid,168,// The memory intrinsics do not have a 1:1 correspondence of the original; // call arguments to the produced statepoint. Do not transfer the argument; // attributes to avoid putting them on incorrect arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:129,Modifiability,variab,variables,129,/// Helper function to place all gc relocates necessary for the given; /// statepoint.; /// Inputs:; /// liveVariables - list of variables to be relocated.; /// basePtrs - base pointers.; /// statepointToken - statepoint instruction to which relocates should be; /// bound.; /// Builder - Llvm IR builder to be used to construct new calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:127,Performance,cache,cached,127,// Lazily populated map from input types to the canonicalized form mentioned; // in the comment above. This should probably be cached somewhere more; // broadly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:80,Safety,avoid,avoids,80,/// This struct is used to defer RAUWs and `eraseFromParent` s. Using this; /// avoids having to worry about keeping around dangling pointers to Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:42,Integrability,interface,interface,42,// FIXME: Calls have a *really* confusing interface around attributes; // with values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:175,Availability,avail,available,175,// Then go ahead and use the builder do actually do the inserts. We insert; // immediately before the previous instruction under the assumption that all; // arguments will be available here. We can't insert afterwards since we may; // be replacing a terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:809,Availability,avail,available,809,"// Unordered atomic memcpy and memmove intrinsics which are not explicitly; // marked as ""gc-leaf-function"" should be lowered in a GC parseable way.; // Specifically, these calls should be lowered to the; // __llvm_{memcpy|memmove}_element_unordered_atomic_safepoint symbols.; // Similarly to __llvm_deoptimize we want to resolve this now, since the; // verifier does not allow taking the address of an intrinsic function.; //; // Moreover we need to shuffle the arguments for the call in order to; // accommodate GC. The underlying source and destination objects might be; // relocated during copy operation should the GC occur. To relocate the; // derived source and destination pointers the implementation of the; // intrinsic should know the corresponding base pointers.; //; // To make the base pointers available pass them explicitly as arguments:; // memcpy(dest_derived, source_derived, ...) =>; // memcpy(dest_base, dest_offset, source_base, source_offset, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Optimiz,Optimizations,3,"// Optimizations in unreachable code might substitute the real pointer; // with undef, poison or null-derived constant. Return null base for; // them to be consistent with the handling in the main algorithm in; // findBaseDefiningValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,Integrability,wrap,wrapping,12,"// If we're wrapping an @llvm.experimental.deoptimize in a statepoint, we; // transform the tail-call like structure to a call to a void function; // followed by unreachable to get better codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:102,Safety,safe,safepoint,102,"// We cannot RAUW or delete CS.getInstruction() because it could be in the; // live set of some other safepoint, in which case that safepoint's; // PartiallyConstructedSafepointRecord will hold a raw pointer to this; // llvm::Instruction. Instead, we defer the replacement and deletion to; // after the live sets have been made explicit in the IR, and we no longer; // have raw pointers to worry about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:132,Safety,safe,safepoint,132,"// We cannot RAUW or delete CS.getInstruction() because it could be in the; // live set of some other safepoint, in which case that safepoint's; // PartiallyConstructedSafepointRecord will hold a raw pointer to this; // llvm::Instruction. Instead, we defer the replacement and deletion to; // after the live sets have been made explicit in the IR, and we no longer; // have raw pointers to worry about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:47,Modifiability,variab,variable,47,"// Second, create a gc.relocate for every live variable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:127,Safety,safe,safepoint,127,// Replace an existing gc.statepoint with a new one and a set of gc.relocates; // which make the relocations happening at this safepoint explicit.; //; // WARNING: Does not do any fixup to adjust users of the original live; // values. That's the callers responsibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:25,Energy Efficiency,efficient,efficient,25,// Convert to vector for efficient cross referencing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:297,Security,validat,validation,297,"// Helper function for the relocationViaAlloca.; //; // It receives iterator to the statepoint gc relocates and emits a store to the; // assigned location (via allocaMap) for the each one of them. It adds the; // visited values into the visitedLiveValues set, which we will later use them; // for validation checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:26,Deployability,update,update,26,/// Do all the relocation update via allocas and mem2reg,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:273,Deployability,Update,Update,273,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:469,Deployability,update,update,469,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:182,Performance,load,load,182,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:248,Performance,perform,performance,248,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:496,Performance,load,load,496,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Deployability,Update,Update,3,// Update use with load allocas and add store for gc_relocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,Performance,load,load,19,// Update use with load allocas and add store for gc_relocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:83,Deployability,update,update,83,// We pre-record the uses of allocas so that we dont have to worry about; // later update that changes the user information..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:200,Integrability,depend,dependent,200,"// If the def has a ConstantExpr use, then the def is either a; // ConstantExpr use itself or null. In either case; // (recursively in the first, directly in the second), the oop; // it is ultimately dependent on is null and this particular; // use does not need to be fixed up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:69,Performance,load,load,69,"// Emit store for the initial gc value. Store must be inserted after load,; // otherwise store will be in alloca's use list and an extra load will be; // inserted before it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,Performance,load,load,137,"// Emit store for the initial gc value. Store must be inserted after load,; // otherwise store will be in alloca's use list and an extra load will be; // inserted before it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:211,Safety,safe,safepoints,211,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:152,Testability,test,tests,152,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:197,Testability,test,testing,197,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,Safety,safe,safepoints,12,// For call safepoints insert dummy calls right after safepoint,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:54,Safety,safe,safepoint,54,// For call safepoints insert dummy calls right after safepoint,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:14,Safety,safe,safepooints,14,// For invoke safepooints insert dummy calls both in normal and; // exceptional destination blocks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:204,Usability,simpl,simple,204,"// Helper function for the ""rematerializeLiveValues"". It walks use chain; // starting from the ""CurrentValue"" until it reaches the root of the chain, i.e.; // the base or a value it cannot process. Only ""simple"" values are processed; // (currently it is GEP's and casts). The returned root is examined by the; // callers of findRematerializableChainToBasePointer. Fills ""ChainToBase"" array; // with all visited values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:117,Performance,optimiz,optimization,117,"// TODO: We can also account for cases when we will be able to remove some; // of the rematerialized values by later optimization passes. I.e if; // we rematerialized several intersecting chains. Or if original values; // don't have any uses besides this statepoint.; // Ok, there is a candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:228,Safety,avoid,avoid,228,"// Current rematerialization algorithm is very simple: we rematerialize; // immediately before EVERY use, even if there are several uses in same; // block or if use is local to Cand Def. The reason is that this allows; // us to avoid recomputing liveness without complicated analysis:; // - If we did not eliminate all uses of original Candidate, we do not; // know exaclty in what BBs it is still live.; // - If we rematerialize once per BB, we need to find proper insertion; // place (first use in block, but after Def) and analyze if there is; // statepoint between uses in the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:47,Usability,simpl,simple,47,"// Current rematerialization algorithm is very simple: we rematerialize; // immediately before EVERY use, even if there are several uses in same; // block or if use is local to Cand Def. The reason is that this allows; // us to avoid recomputing liveness without complicated analysis:; // - If we did not eliminate all uses of original Candidate, we do not; // know exaclty in what BBs it is still live.; // - If we rematerialize once per BB, we need to find proper insertion; // place (first use in block, but after Def) and analyze if there is; // statepoint between uses in the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Security,Validat,Validate,3,// Validate the input,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,Safety,safe,safepoint,84,// Insert a dummy call with all of the deopt operands we'll need for the; // actual safepoint insertion as arguments. This ensures reference operands; // in the deopt argument list are considered live through the safepoint (and; // thus makes sure they get relocated.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:213,Safety,safe,safepoint,213,// Insert a dummy call with all of the deopt operands we'll need for the; // actual safepoint insertion as arguments. This ensures reference operands; // in the deopt argument list are considered live through the safepoint (and; // thus makes sure they get relocated.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,Safety,safe,safepoint,41,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:118,Safety,safe,safepoint,118,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:219,Safety,safe,safepoint,219,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:280,Safety,safe,safepoint,280,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:346,Safety,safe,safepoint,346,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:433,Safety,safe,safepoint,433,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:26,Testability,log,logic,26,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:133,Usability,simpl,simplest,133,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,Modifiability,variab,variables,41,"// It is possible that non-constant live variables have a constant base. For; // example, a GEP with a variable offset from a global. In this case we can; // remove it from the liveset. We already don't add constants to the liveset; // because we assume they won't move at runtime and the GC doesn't need to be; // informed about them. The same reasoning applies if the base is constant.; // Note that the relocation placement code relies on this filtering for; // correctness as it expects the base to be in the liveset, which isn't true; // if the base is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:103,Modifiability,variab,variable,103,"// It is possible that non-constant live variables have a constant base. For; // example, a GEP with a variable offset from a global. In this case we can; // remove it from the liveset. We already don't add constants to the liveset; // because we assume they won't move at runtime and the GC doesn't need to be; // informed about them. The same reasoning applies if the base is constant.; // Note that the relocation placement code relies on this filtering for; // correctness as it expects the base to be in the liveset, which isn't true; // if the base is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:15,Energy Efficiency,reduce,reduce,15,"// In order to reduce live set of statepoint we might choose to rematerialize; // some values instead of relocating them. This is purely an optimization and; // does not influence correctness.; // First try rematerialization at uses, then after statepoints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:140,Performance,optimiz,optimization,140,"// In order to reduce live set of statepoint we might choose to rematerialize; // some values instead of relocating them. This is purely an optimization and; // does not influence correctness.; // First try rematerialization at uses, then after statepoints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,Safety,safe,safely,19,"// We need this to safely RAUW and delete call or invoke return values that; // may themselves be live over a statepoint. For details, please see usage in; // makeStatepointExplicitImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:120,Deployability,update,update,120,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:88,Modifiability,variab,variables,88,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:194,Modifiability,variab,variables,194,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:329,Modifiability,variab,variable,329,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:113,Integrability,wrap,wrapped,113,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:230,Safety,avoid,avoid,230,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:207,Usability,Clear,Clear,207,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:42,Modifiability,variab,variables,42,// Do all the fixups of the original live variables to their relocated selves,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:283,Deployability,update,updated,283,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,Safety,safe,safepoint,137,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,Usability,simpl,simply,12,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:72,Performance,perform,performing,72,// Do some basic validation checking on our liveness results before; // performing relocation. Relocation can and will turn mistakes in liveness; // results into non-sensical code which is must harder to debug.; // TODO: It would be nice to test consistency as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:17,Security,validat,validation,17,// Do some basic validation checking on our liveness results before; // performing relocation. Relocation can and will turn mistakes in liveness; // results into non-sensical code which is must harder to debug.; // TODO: It would be nice to test consistency as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:241,Testability,test,test,241,// Do some basic validation checking on our liveness results before; // performing relocation. Relocation can and will turn mistakes in liveness; // results into non-sensical code which is must harder to debug.; // TODO: It would be nice to test consistency as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Security,Validat,Validation,3,// Validation check,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:52,Integrability,depend,depends,52,"// Intrinsics are very delicate. Lowering sometimes depends the presence; // of certain attributes for correctness, but we may have also inferred; // additional ones in the abstract machine model which need stripped. This; // assumes that the attributes defined in Intrinsic.td are conservatively; // correct for both physical and abstract model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:75,Performance,Optimiz,Optimizations,75,/// Certain metadata on instructions are invalid after running RS4GC.; /// Optimizations that run after RS4GC can incorrectly use this metadata to; /// optimize functions. We drop such metadata on the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:152,Performance,optimiz,optimize,152,/// Certain metadata on instructions are invalid after running RS4GC.; /// Optimizations that run after RS4GC can incorrectly use this metadata to; /// optimize functions. We drop such metadata on the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:213,Modifiability,Rewrite,RewriteStatepointsForGC,213,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:52,Performance,load,loads,52,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:550,Performance,load,load,550,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:571,Performance,load,load,571,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:637,Performance,load,load,637,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:833,Performance,load,loads,833,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:78,Safety,avoid,avoid,78,// Set of invariantstart instructions that we need to remove.; // Use this to avoid invalidating the instruction iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:147,Modifiability,Rewrite,RewriteStatepointsForGC,147,"// invariant.start on memory location implies that the referenced memory; // location is constant and unchanging. This is no longer true after; // RewriteStatepointsForGC runs because there can be calls to gc.statepoint; // which frees the entire heap and the presence of invariant.start allows; // the optimizer to sink the load of a memory location past a statepoint,; // which is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:303,Performance,optimiz,optimizer,303,"// invariant.start on memory location implies that the referenced memory; // location is constant and unchanging. This is no longer true after; // RewriteStatepointsForGC runs because there can be calls to gc.statepoint; // which frees the entire heap and the presence of invariant.start allows; // the optimizer to sink the load of a memory location past a statepoint,; // which is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:325,Performance,load,load,325,"// invariant.start on memory location implies that the referenced memory; // location is constant and unchanging. This is no longer true after; // RewriteStatepointsForGC runs because there can be calls to gc.statepoint; // which frees the entire heap and the presence of invariant.start allows; // the optimizer to sink the load of a memory location past a statepoint,; // which is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:140,Performance,cache,cache,140,"/// Looks up the GC strategy for a given function, returning null if the; /// function doesn't have a GC tag. The strategy is stored in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:141,Testability,log,logic,141,/// Returns true if this function should be rewritten by this pass. The main; /// point of this function is as an extension point for custom logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:287,Performance,optimiz,optimizer,287,// Normally it's up to the frontend to make sure that non-leaf calls also; // have proper deopt state if it is required. We make an exception for; // element atomic memcpy/memmove intrinsics here. Unlike other intrinsics; // these are non-leaf by default. They might be generated by the optimizer; // which doesn't know how to produce a proper deopt state. So if we see a; // non-leaf memcpy/memmove without deopt state just treat it as a leaf; // copy and don't produce a statepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:120,Testability,test,testing,120,// Delete any unreachable statepoints so that we don't have unrewritten; // statepoints surviving this pass. This makes testing easier and the; // resulting IR less confusing to human readers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:487,Availability,avail,available,487,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:588,Energy Efficiency,schedul,scheduler,588,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:691,Modifiability,extend,extend,691,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:81,Safety,avoid,avoid,81,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:230,Safety,safe,safepoints,230,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:947,Safety,safe,safer,947,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:9,Modifiability,Extend,Extend,9,// TODO: Extend this to handle switches,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:122,Security,access,access,122,// TODO: Handle more than just ICmps here. We should be able to move; // most instructions without side effects or memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:189,Deployability,integrat,integrate,189,"// Nasty workaround - The base computation code in the main algorithm doesn't; // consider the fact that a GEP can be used to convert a scalar to a vector.; // The right fix for this is to integrate GEPs into the base rewriting; // algorithm properly, this is just a short term workaround to prevent; // crashes by canonicalizing such GEPs into fully vector GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:189,Integrability,integrat,integrate,189,"// Nasty workaround - The base computation code in the main algorithm doesn't; // consider the fact that a GEP can be used to convert a scalar to a vector.; // The right fix for this is to integrate GEPs into the base rewriting; // algorithm properly, this is just a short term workaround to prevent; // crashes by canonicalizing such GEPs into fully vector GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Cache,Cache,3,// Cache the 'defining value' relation used in the computation and; // insertion of base phis and selects. This ensures that we don't insert; // large numbers of duplicate base_phis. Use one cache for both; // inlineGetBaseAndOffset() and insertParsePoints().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:191,Performance,cache,cache,191,// Cache the 'defining value' relation used in the computation and; // insertion of base phis and selects. This ensures that we don't insert; // large numbers of duplicate base_phis. Use one cache for both; // inlineGetBaseAndOffset() and insertParsePoints().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:250,Modifiability,variab,variable,250,"// The choice to exclude all things constant here is slightly subtle.; // There are two independent reasons:; // - We assume that things which are constant (from LLVM's definition); // do not move at runtime. For example, the address of a global; // variable is fixed, even though it's contents may not be.; // - Second, we can't disallow arbitrary inttoptr constants even; // if the language frontend does. Optimization passes are free to; // locally exploit facts without respect to global reachability. This; // can create sections of code which are dynamically unreachable and; // contain just about anything. (see constants.ll in tests)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:408,Performance,Optimiz,Optimization,408,"// The choice to exclude all things constant here is slightly subtle.; // There are two independent reasons:; // - We assume that things which are constant (from LLVM's definition); // do not move at runtime. For example, the address of a global; // variable is fixed, even though it's contents may not be.; // - Second, we can't disallow arbitrary inttoptr constants even; // if the language frontend does. Optimization passes are free to; // locally exploit facts without respect to global reachability. This; // can create sections of code which are dynamically unreachable and; // contain just about anything. (see constants.ll in tests)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:635,Testability,test,tests,635,"// The choice to exclude all things constant here is slightly subtle.; // There are two independent reasons:; // - We assume that things which are constant (from LLVM's definition); // do not move at runtime. For example, the address of a global; // variable is fixed, even though it's contents may not be.; // - Second, we can't disallow arbitrary inttoptr constants even; // if the language frontend does. Optimization passes are free to; // locally exploit facts without respect to global reachability. This; // can create sections of code which are dynamically unreachable and; // contain just about anything. (see constants.ll in tests)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:79,Security,validat,validation,79,/// Check that the items in 'Live' dominate 'TI'. This is used as a basic; /// validation check for the liveness computation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,assert,assert,3,// assert OutLiveOut is a subset of LiveOut,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,assert,assert,3,// assert: OldLiveIn is a subset of LiveTmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,Deployability,update,update,84,// We may have base pointers which are now live that weren't before. We need; // to update the PointerToBase structure to reflect this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:60,Availability,mask,masked,60,"//===- ScalarizeMaskedMemIntrin.cpp - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:417,Availability,mask,masked,417,"//===- ScalarizeMaskedMemIntrin.cpp - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:573,Availability,mask,mask,573,"//===- ScalarizeMaskedMemIntrin.cpp - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:64,Availability,mask,masked,64,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:122,Availability,mask,mask,122,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:237,Availability,mask,mask,237,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:327,Availability,mask,mask,327,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:697,Availability,mask,mask,697,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:1096,Availability,mask,mask,1096,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:22,Performance,load,load,22,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:71,Performance,load,load,71,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:187,Performance,load,loading,187,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:365,Performance,load,load,365,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:396,Performance,load,load,396,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:462,Performance,load,load,462,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:587,Performance,load,load,587,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:639,Performance,load,load,639,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:838,Performance,load,load,838,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:20,Availability,mask,mask,20,// Short-cut if the mask is all-true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:262,Performance,load,load,262,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = and i16 %scalar_mask, i32 1 << Idx; // %cond = icmp ne i16 %mask_1, 0; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:82,Performance,load,load,82,"// Create ""cond"" block; //; // %EltAddr = getelementptr i32* %1, i32 0; // %Elt = load i32* %EltAddr; // VResult = insertelement <16 x i32> VResult, i32 %Elt, i32 Idx; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:59,Availability,mask,masked,59,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:134,Availability,mask,mask,134,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:226,Availability,mask,mask,226,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:316,Availability,mask,mask,316,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:611,Availability,mask,mask,611,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:20,Availability,mask,mask,20,// Short-cut if the mask is all-true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:66,Availability,mask,masked,66,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:129,Availability,Mask,Mask,129,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:239,Availability,mask,mask,239,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:357,Availability,Mask,Mask,357,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:734,Availability,Mask,Mask,734,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:1043,Availability,Mask,Mask,1043,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:189,Performance,load,loading,189,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:399,Performance,load,load,399,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:430,Performance,load,load,430,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:501,Performance,load,load,501,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:675,Performance,load,load,675,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:881,Performance,load,load,881,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:177,Performance,load,load,177,"// Fill the ""else"" block, created in the previous iteration; //; // %Mask1 = and i16 %scalar_mask, i32 1 << Idx; // %cond = icmp ne i16 %mask_1, 0; // br i1 %Mask1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:82,Performance,load,load,82,"// Create ""cond"" block; //; // %EltAddr = getelementptr i32* %1, i32 0; // %Elt = load i32* %EltAddr; // VResult = insertelement <16 x i32> VResult, i32 %Elt, i32 Idx; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:61,Availability,mask,masked,61,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:142,Availability,Mask,Mask,142,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:234,Availability,mask,mask,234,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:352,Availability,Mask,Mask,352,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:648,Availability,Mask,Mask,648,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,"// Shorten the way if the mask is a vector of constants.; // Create a build_vector pattern, with loads/poisons as necessary and then; // shuffle blend with the pass through value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:97,Performance,load,loads,97,"// Shorten the way if the mask is a vector of constants.; // Create a build_vector pattern, with loads/poisons as necessary and then; // shuffle blend with the pass through value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:187,Availability,mask,mask,187,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:232,Performance,load,load,232,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:82,Performance,load,load,82,"// Create ""cond"" block; //; // %EltAddr = getelementptr i32* %1, i32 0; // %Elt = load i32* %EltAddr; // VResult = insertelement <16 x i32> VResult, i32 %Elt, i32 Idx; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:104,Availability,mask,mask,104,"// Fill the ""else"" block, created in the previous iteration; //; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.store, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:50,Performance,scalab,scalable,50,// The scalarization code below does not work for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:32,Availability,mask,masked,32,// Scalarize unsupported vector masked load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:39,Performance,load,load,39,// Scalarize unsupported vector masked load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:521,Performance,optimiz,optimization,521,"//===- Scalarizer.cpp - Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass converts vector operations into scalar operations (or, optionally,; // operations on smaller vector widths), in order to expose optimization; // opportunities on the individual scalar operations.; // It is mainly intended for targets that do not have vector units, but it; // may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:514,Security,expose,expose,514,"//===- Scalarizer.cpp - Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass converts vector operations into scalar operations (or, optionally,; // operations on smaller vector widths), in order to expose optimization; // opportunities on the individual scalar operations.; // It is mainly intended for targets that do not have vector units, but it; // may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:55,Performance,load,loads,55,// This is disabled by default because having separate loads and stores; // makes it more likely that the -combiner-alias-analysis limits will be; // reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:191,Performance,load,load,191,"// Used to map a vector Value and associated type to its scattered form.; // The associated type is only non-null for pointer values that are ""scattered""; // when used as pointer operands to load or store.; //; // We use std::map because we want iterators to persist across insertion and; // because the values are relatively large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:39,Integrability,interface,interface,39,// Provides a very limited vector-like interface for lazily accessing one; // component of a scattered vector or vector pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:60,Security,access,accessing,60,// Provides a very limited vector-like interface for lazily accessing one; // component of a scattered vector or vector pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:104,Performance,Cache,Cache,104,"// Scatter V into Size components. If new instructions are needed,; // insert them before BBI in BB. If Cache is nonnull, use it to cache; // the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:132,Performance,cache,cache,132,"// Scatter V into Size components. If new instructions are needed,; // insert them before BBI in BB. If Cache is nonnull, use it to cache; // the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:23,Performance,load,load,23,// Information about a load or store that we're scalarizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:29,Availability,mask,masks,29,// Prepare the shufflevector masks once and re-use them for all; // fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:107,Performance,cache,cache,107,// Search through a chain of InsertElementInsts looking for element Frag.; // Record other elements in the cache. The new V is still suitable; // for all uncached indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:8,Performance,cache,cache,8,// Only cache the first entry we find for each index we're not actively; // searching for. This prevents us from going too far up the chain and; // caching incorrect entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:44,Security,access,accessed,44,// Return a scattered form of V that can be accessed by Point. V must be a; // vector or a pointer to a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:54,Modifiability,rewrite,rewrite,54,"// When scalarizing PHI nodes we might try to examine/rewrite InsertElement; // nodes in predecessors. If those predecessors are unreachable from entry,; // then the IR in those blocks could have unexpected properties resulting in; // infinite loops in Scatterer::operator[]. By simply treating values; // originating from instructions in unreachable blocks as undef we do not; // need to analyse them further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:279,Usability,simpl,simply,279,"// When scalarizing PHI nodes we might try to examine/rewrite InsertElement; // nodes in predecessors. If those predecessors are unreachable from entry,; // then the IR in those blocks could have unexpected properties resulting in; // infinite loops in Scatterer::operator[]. By simply treating values; // originating from instructions in unreachable blocks as undef we do not; // need to analyse them further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:168,Safety,avoid,avoid,168,"// Replace Op with the gathered form of the components in CV. Defer the; // deletion of Op and creation of the gathered form to the end of the pass,; // so that we can avoid creating the gathered form if all uses of Op are; // replaced with uses of CV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:24,Safety,safe,safe,24,// Return true if it is safe to transfer the given metadata tag from; // vector to scalar instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:80,Safety,safe,safe,80,// Transfer metadata from Op to the instructions in CV if it is known; // to be safe to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:3,Performance,Perform,Perform,3,"// Perform actual scalarization, taking care to preserve any scalar operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:17,Modifiability,variab,variable,17,// Never split a variable insertelement that isn't fully scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:17,Modifiability,variab,variable,17,// Never split a variable extractelement that isn't fully scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1570,Energy Efficiency,reduce,reduce,1570,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3262,Integrability,depend,depending,3262,"example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportuni",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:507,Modifiability,variab,variable,507,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:708,Performance,load,load,708,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:740,Performance,load,load,740,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:772,Performance,load,load,772,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:808,Performance,load,load,808,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1299,Performance,load,load,1299,"//===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load ba",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1330,Performance,load,loads,1330,"//===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load ba",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1604,Performance,optimiz,optimization,1604,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2169,Performance,load,loads,2169," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2240,Performance,load,load,2240," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2288,Performance,load,load,2288," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2323,Performance,load,load,2323," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2499,Performance,load,loads,2499," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3498,Performance,optimiz,optimization,3498,". For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3692,Performance,load,load,3692,"ant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3790,Performance,load,load,3790,"8;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4388,Performance,load,load,4388,"P with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4738,Performance,load,load,4738,"owing GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:5266,Performance,load,load,5266,"ultiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %11, struct_field_2 ; Constant offset; // %p2 = bitcast i8* %12 to i32*; // load %p2; // ...; //; // Lowering GEPs can also benefit other passes such as LICM and CGP.; // LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple; // indices if one of the index is variant. If we lower such GEP into invariant; // parts and variant parts, LICM can hoist/sink those invariant parts.; // CGP (CodeGen Prepare) tries to sink addres",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:5653,Performance,load,load,5653,"set; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %11, struct_field_2 ; Constant offset; // %p2 = bitcast i8* %12 to i32*; // load %p2; // ...; //; // Lowering GEPs can also benefit other passes such as LICM and CGP.; // LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple; // indices if one of the index is variant. If we lower such GEP into invariant; // parts and variant parts, LICM can hoist/sink those invariant parts.; // CGP (CodeGen Prepare) tries to sink address calculations that match the; // target's addressing modes. A GEP with multiple indices may not match and will; // not be sunk. If we lower such GEP into smaller parts, CGP may sink some of; // them. So we end up with a better addressing mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:853,Safety,redund,redundancy,853,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:437,Security,access,accesses,437,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1744,Usability,simpl,simple,1744,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:142,Testability,test,tests,142,"// Setting this flag may emit false positives when the input module already; // contains dead instructions. Therefore, we set it only in unit tests that are; // free of dead code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:829,Performance,optimiz,optimized,829,"/// A helper class for separating a constant offset from a GEP index.; ///; /// In real programs, a GEP index may be more complicated than a simple addition; /// of something and a constant integer which can be trivially splitted. For; /// example, to split ((a << 3) | 5) + b, we need to search deeper for the; /// constant offset, so that we can separate the index to (a << 3) + b and 5.; ///; /// Therefore, this class looks into the expression that computes a given GEP; /// index, and tries to find a constant integer that can be hoisted to the; /// outermost level of the expression as an addition. Not every constant in an; /// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +; /// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,; /// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:141,Usability,simpl,simple,141,"/// A helper class for separating a constant offset from a GEP index.; ///; /// In real programs, a GEP index may be more complicated than a simple addition; /// of something and a constant integer which can be trivially splitted. For; /// example, to split ((a << 3) | 5) + b, we need to search deeper for the; /// constant offset, so that we can separate the index to (a << 3) + b and 5.; ///; /// Therefore, this class looks into the expression that computes a given GEP; /// index, and tries to find a constant integer that can be hoisted to the; /// outermost level of the expression as an addition. Not every constant in an; /// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +; /// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,; /// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:175,Deployability,update,update,175,"/// Searches the expression that computes V for a non-zero constant C s.t.; /// V can be reassociated into the form V' + C. If the searching is; /// successful, returns C and update UserChain as a def-use chain from C to V;; /// otherwise, UserChain is empty.; ///; /// \p V The given expression; /// \p SignExtended Whether V will be sign-extended in the computation of the; /// GEP index; /// \p ZeroExtended Whether V will be zero-extended in the computation of the; /// GEP index; /// \p NonNegative Whether V is guaranteed to be non-negative. For example,; /// an index of an inbounds GEP is guaranteed to be; /// non-negative. Levaraging this, we can better split; /// inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:340,Modifiability,extend,extended,340,"/// Searches the expression that computes V for a non-zero constant C s.t.; /// V can be reassociated into the form V' + C. If the searching is; /// successful, returns C and update UserChain as a def-use chain from C to V;; /// otherwise, UserChain is empty.; ///; /// \p V The given expression; /// \p SignExtended Whether V will be sign-extended in the computation of the; /// GEP index; /// \p ZeroExtended Whether V will be zero-extended in the computation of the; /// GEP index; /// \p NonNegative Whether V is guaranteed to be non-negative. For example,; /// an index of an inbounds GEP is guaranteed to be; /// non-negative. Levaraging this, we can better split; /// inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:434,Modifiability,extend,extended,434,"/// Searches the expression that computes V for a non-zero constant C s.t.; /// V can be reassociated into the form V' + C. If the searching is; /// successful, returns C and update UserChain as a def-use chain from C to V;; /// otherwise, UserChain is empty.; ///; /// \p V The given expression; /// \p SignExtended Whether V will be sign-extended in the computation of the; /// GEP index; /// \p ZeroExtended Whether V will be zero-extended in the computation of the; /// GEP index; /// \p NonNegative Whether V is guaranteed to be non-negative. For example,; /// an index of an inbounds GEP is guaranteed to be; /// non-negative. Levaraging this, we can better split; /// inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:294,Deployability,update,updates,294,"/// After the first step of rebuilding the GEP index without the constant; /// offset, distribute s/zext to the operands of all operators in UserChain.; /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =>; /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).; ///; /// The function also updates UserChain to point to new subexpressions after; /// distributing s/zext. e.g., the old UserChain of the above example is; /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),; /// and the new UserChain is; /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) ->; /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5)); ///; /// \p ChainIndex The index to UserChain. ChainIndex is initially; /// UserChain.size() - 1, and is decremented during; /// the recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:353,Modifiability,extend,extends,353,"/// Canonicalize array indices to pointer-size integers. This helps to; /// simplify the logic of splitting a GEP. For example, if a + b is a; /// pointer-size integer, we have; /// gep base, a + b = gep (gep base, a), b; /// However, this equality may not hold if the size of a + b is smaller than; /// the pointer size, because LLVM conceptually sign-extends GEP indices to; /// pointer size before computing the address; /// (http://llvm.org/docs/LangRef.html#id181).; ///; /// This canonicalization is very likely already done in clang and; /// instcombine. Therefore, the program will probably remain the same.; ///; /// Returns true if the module changes.; ///; /// Verified in @i32_add in split-gep.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:89,Testability,log,logic,89,"/// Canonicalize array indices to pointer-size integers. This helps to; /// simplify the logic of splitting a GEP. For example, if a + b is a; /// pointer-size integer, we have; /// gep base, a + b = gep (gep base, a), b; /// However, this equality may not hold if the size of a + b is smaller than; /// the pointer size, because LLVM conceptually sign-extends GEP indices to; /// pointer size before computing the address; /// (http://llvm.org/docs/LangRef.html#id181).; ///; /// This canonicalization is very likely already done in clang and; /// instcombine. Therefore, the program will probably remain the same.; ///; /// Returns true if the module changes.; ///; /// Verified in @i32_add in split-gep.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:76,Usability,simpl,simplify,76,"/// Canonicalize array indices to pointer-size integers. This helps to; /// simplify the logic of splitting a GEP. For example, if a + b is a; /// pointer-size integer, we have; /// gep base, a + b = gep (gep base, a), b; /// However, this equality may not hold if the size of a + b is smaller than; /// the pointer size, because LLVM conceptually sign-extends GEP indices to; /// pointer size before computing the address; /// (http://llvm.org/docs/LangRef.html#id181).; ///; /// This canonicalization is very likely already done in clang and; /// instcombine. Therefore, the program will probably remain the same.; ///; /// Returns true if the module changes.; ///; /// Verified in @i32_add in split-gep.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.; /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting; /// the constant offset. After extraction, it becomes desirable to reunion the; /// distributed sexts. For example,; ///; /// &a[sext(i +nsw (j +nsw 5)]; /// => distribute &a[sext(i) +nsw (sext(j) +nsw 5)]; /// => constant extraction &a[sext(i) + sext(j)] + 5; /// => reunion &a[sext(i +nsw j)] + 5",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:18,Safety,safe,safe,18,// Check if it is safe to swap operand of two GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:198,Testability,test,tests,198,"// Do not trace into ""or"" unless it is equivalent to ""add"". If LHS and RHS; // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).; // FIXME: this does not appear to be covered by any tests; // (with x86/aarch64 backends at least)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:90,Modifiability,extend,extended,90,"// FIXME: We don't currently support constants from the RHS of subs,; // when we are zero-extended, because we need a way to zero-extended; // them before they are negated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:130,Modifiability,extend,extended,130,"// FIXME: We don't currently support constants from the RHS of subs,; // when we are zero-extended, because we need a way to zero-extended; // them before they are negated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:91,Usability,Clear,Clear,91,// BO being non-negative does not shed light on whether its operands are; // non-negative. Clear the NonNegative flag here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:341,Performance,optimiz,optimizations,341,"// If we found a constant offset in the left operand, stop and return that.; // This shortcut might cause us to miss opportunities of combining the; // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.; // However, such cases are probably already handled by -instcombine,; // given this pass runs after the standard optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:204,Testability,benchmark,benchmarks,204,"// TODO(jingyue): We could trace into integer/pointer casts, such as; // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only; // integers because it gives good enough results for our benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:9,Performance,optimiz,optimization,9,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:30,Usability,clear,clear,30,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:143,Usability,Clear,Clear,143,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:156,Performance,optimiz,optimization,156,"// If we found a non-zero constant offset, add it to the path for; // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't; // help this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:56,Usability,simpl,simplify,56,"// If NextInChain is 0 and not the LHS of a sub, we can simplify the; // sub-expression to be just TheOther.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:23,Performance,scalab,scalable,23,// Constant offsets of scalable types are not really constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:363,Modifiability,variab,variable,363,"// If LowerGEP is disabled, before really splitting the GEP, check whether the; // backend supports the addressing mode we are about to produce. If no, this; // splitting probably won't be beneficial.; // If LowerGEP is enabled, even the extracted constant offset can not match; // the addressing mode, we can still do optimizations to other lowered parts; // of variable indices. Therefore, we don't check for addressing modes in that; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:319,Performance,optimiz,optimizations,319,"// If LowerGEP is disabled, before really splitting the GEP, check whether the; // backend supports the addressing mode we are about to produce. If no, this; // splitting probably won't be beneficial.; // If LowerGEP is enabled, even the extracted constant offset can not match; // the addressing mode, we can still do optimizations to other lowered parts; // of variable indices. Therefore, we don't check for addressing modes in that; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:23,Performance,scalab,scalable,23,// Constant offsets of scalable types are not really constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:537,Integrability,wrap,wrapping,537,"// Clear the inbounds attribute because the new index may be off-bound.; // e.g.,; //; // b = add i64 a, 5; // addr = gep inbounds float, float* p, i64 b; //; // is transformed to:; //; // addr2 = gep float, float* p, i64 a ; inbounds removed; // addr = gep inbounds float, float* addr2, i64 5; //; // If a is -4, although the old index b is in bounds, the new index a is; // off-bound. http://llvm.org/docs/LangRef.html#id181 says ""if the; // inbounds keyword is not present, the offsets are added to the base; // address with silently-wrapping two's complement arithmetic"".; // Therefore, the final code will be a semantically equivalent.; //; // TODO(jingyue): do some range analysis to keep as many inbounds as; // possible. GEPs with inbounds are more friendly to alias analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3,Usability,Clear,Clear,3,"// Clear the inbounds attribute because the new index may be off-bound.; // e.g.,; //; // b = add i64 a, 5; // addr = gep inbounds float, float* p, i64 b; //; // is transformed to:; //; // addr2 = gep float, float* p, i64 a ; inbounds removed; // addr = gep inbounds float, float* addr2, i64 5; //; // If a is -4, although the old index b is in bounds, the new index a is; // off-bound. http://llvm.org/docs/LangRef.html#id181 says ""if the; // inbounds keyword is not present, the offsets are added to the base; // address with silently-wrapping two's complement arithmetic"".; // Therefore, the final code will be a semantically equivalent.; //; // TODO(jingyue): do some range analysis to keep as many inbounds as; // possible. GEPs with inbounds are more friendly to alias analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:213,Safety,safe,safely,213,"// As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to; // arithmetic operations if the target uses alias analysis in codegen.; // Additionally, pointers that aren't integral (and so can't be safely; // converted to integers) or those whose offset size is different from their; // pointer size (which means that doing integer arithmetic on them could; // affect that data) can't be lowered in this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:235,Performance,optimiz,optimization,235,"// Because we process the basic blocks in pre-order of the dominator tree, a; // candidate that doesn't dominate the current instruction won't dominate any; // future instruction either. Therefore, we pop it out of the stack. This; // optimization makes the algorithm O(n).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:95,Performance,optimiz,optimize,95,"// Dom: LHS+RHS; // I: sext(LHS)+sext(RHS); // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).; // TODO: handle zext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:8,Usability,Simpl,SimpleLoopUnswitch,8,"///===- SimpleLoopUnswitch.cpp - Hoist loop-invariant control flow ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:93,Testability,log,logical,93,"// end anonymous namespace.; // Helper to skip (select x, true, false), which matches both a logical AND and; // OR and can confuse code that tries to determine if \p Cond is either a; // logical AND or OR but not both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:188,Testability,log,logical,188,"// end anonymous namespace.; // Helper to skip (select x, true, false), which matches both a logical AND and; // OR and can confuse code that tries to determine if \p Cond is either a; // logical AND or OR but not both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:233,Performance,perform,perform,233,/// Collect all of the loop invariant input values transitively used by the; /// homogeneous instruction graph from a given root.; ///; /// This essentially walks from a root recursively through loop variant operands; /// which have perform the same logical operation (AND or OR) and finds all; /// inputs which are loop invariant. For some operations these can be; /// re-associated and unswitched out of the loop entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:250,Testability,log,logical,250,/// Collect all of the loop invariant input values transitively used by the; /// homogeneous instruction graph from a given root.; ///; /// This essentially walks from a root recursively through loop variant operands; /// which have perform the same logical operation (AND or OR) and finds all; /// inputs which are loop invariant. For some operations these can be; /// re-associated and unswitched out of the loop entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:26,Security,access,access,26,// Get the first defining access before the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Security,access,access,19,"// If the defining access is a MemoryPhi, get the incoming; // value for the pre-header as defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:100,Security,access,access,100,"// If the defining access is a MemoryPhi, get the incoming; // value for the pre-header as defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the PHI nodes in an unswitched loop exit basic block.; ///; /// Requires that the loop exit and unswitched basic block are the same, and; /// that the exiting block was a unique predecessor of that block. Rewrites the; /// PHI nodes in that block such that what were LCSSA PHI nodes become trivial; /// PHI nodes from the old preheader that now contains the unswitched; /// terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:217,Modifiability,Rewrite,Rewrites,217,"/// Rewrite the PHI nodes in an unswitched loop exit basic block.; ///; /// Requires that the loop exit and unswitched basic block are the same, and; /// that the exiting block was a unique predecessor of that block. Rewrites the; /// PHI nodes in that block such that what were LCSSA PHI nodes become trivial; /// PHI nodes from the old preheader that now contains the unswitched; /// terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,Deployability,update,update,61,"// When the loop exit is directly unswitched we just need to update the; // incoming basic block. We loop to handle weird cases with repeated; // incoming blocks, but expect to typically only have one operand here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the PHI nodes in the loop exit basic block and the split off; /// unswitched block.; ///; /// Because the exit block remains an exit from the loop, this rewrites the; /// LCSSA PHI nodes in it to remove the unswitched edge and introduces PHI; /// nodes into the unswitched basic block to select between the value in the; /// old preheader and the loop exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:165,Modifiability,rewrite,rewrites,165,"/// Rewrite the PHI nodes in the loop exit basic block and the split off; /// unswitched block.; ///; /// Because the exit block remains an exit from the loop, this rewrites the; /// LCSSA PHI nodes in it to remove the unswitched edge and introduces PHI; /// nodes into the unswitched basic block to select between the value in the; /// old preheader and the loop exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:122,Deployability,update,update,122,"// The preheader will need to move with the body of this loop. However,; // because it isn't in this loop we also need to update the primary loop map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:121,Deployability,update,update,121,// Remove this loops blocks from the old parent and every other loop up the; // nest until reaching the new parent. Also update all of these; // no-longer-containing loops to reflect the nesting change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:316,Performance,optimiz,optimize,316,"// We shouldn't need to form dedicated exits because the exit introduced; // here is the (just split by unswitching) preheader. However, after trivial; // unswitching it is possible to get new non-dedicated exits out of parent; // loop so let's conservatively form dedicated exit blocks and figure out; // if we can optimize later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:865,Deployability,update,updated,865,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:81,Integrability,rout,routine,81,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:207,Integrability,rout,routine,207,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:398,Integrability,rout,routine,398,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:501,Integrability,rout,routine,501,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:162,Security,validat,validated,162,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:590,Usability,simpl,simplified,590,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:655,Usability,simpl,simplifies,655,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:800,Usability,simpl,simplifycfg,800,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,Safety,safe,safe,56,"// Split the preheader, so that we know that there is a safe place to insert; // the conditional branch. We will change the preheader to have a conditional; // branch on LoopCond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:250,Usability,simpl,simplified,250,"// Now that we have a place to insert the conditional branch, create a place; // to branch to: this is the exit block out of the loop that we are; // unswitching. We need to split this if there are other loop predecessors.; // Because the loop is in simplified form, *any* other predecessor is enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:50,Deployability,update,update,50,"// Temporarily clone the terminator, to make MSSA update cheaper by; // separating ""insert edge"" updates from ""remove edge"" ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:97,Deployability,update,updates,97,"// Temporarily clone the terminator, to make MSSA update cheaper by; // separating ""insert edge"" updates from ""remove edge"" ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Deployability,Update,Update,3,// Update the dominator tree with the added edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Availability,avail,available,85,"// After the dominator tree was updated with the added edge, update MemorySSA; // if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:32,Deployability,update,updated,32,"// After the dominator tree was updated with the added edge, update MemorySSA; // if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,Deployability,update,update,61,"// After the dominator tree was updated with the added edge, update MemorySSA; // if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the relevant PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1533,Deployability,update,updated,1533,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:81,Integrability,rout,routine,81,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:207,Integrability,rout,routine,207,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:417,Integrability,rout,routine,417,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:520,Integrability,rout,routine,520,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:162,Security,validat,validated,162,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:851,Usability,simpl,simplified,851,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:917,Usability,simpl,simplifies,917,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1383,Usability,simpl,simplified,1383,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1468,Usability,simpl,simplifycfg,1468,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Usability,Clear,Clear,3,// Clear out the default destination temporarily to allow accurate; // predecessor lists to be examined below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,Safety,safe,safe,56,"// Split the preheader, so that we know that there is a safe place to insert; // the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:161,Deployability,update,update,161,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:196,Integrability,depend,depending,196,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:144,Energy Efficiency,power,powerful,144,// Handle the default exit if necessary.; // FIXME: It'd be great if we could merge this with the loop below but LLVM's; // ranges aren't quite powerful enough yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:64,Deployability,update,update,64,// Note that we must use a reference in the for loop so that we update the; // container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:65,Deployability,update,update,65,// Grab a reference to the exit block in the pair so that we can update it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,Usability,simpl,simply,61,"// If this case is the last edge into the exit block, we can simply reuse it; // as it will no longer be a loop exit. No mapping necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:8,Modifiability,rewrite,rewrite,8,// Only rewrite once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Deployability,Update,Update,3,// Update the case pair to point to the split block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:99,Modifiability,rewrite,rewrite,99,"// If we ended up with a common successor for every path through the switch; // after unswitching, rewrite it to an unconditional branch to make it easy; // to recognize. Otherwise we potentially have to recognize the default case; // pointing at unreachable and other complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:262,Deployability,update,update,262,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:245,Safety,avoid,avoiding,245,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:157,Usability,simpl,simple,157,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:71,Deployability,update,update,71,"// Walk the unswitched exit blocks and the unswitched split blocks and update; // the dominator tree based on the CFG edits. While we are walking unordered; // containers here, the API for applyUpdates takes an unordered list of; // updates and requires them to not contain duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:233,Deployability,update,updates,233,"// Walk the unswitched exit blocks and the unswitched split blocks and update; // the dominator tree based on the CFG edits. While we are walking unordered; // containers here, the API for applyUpdates takes an unordered list of; // updates and requires them to not contain duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:542,Deployability,update,updated,542,"/// This routine scans the loop to find a branch or switch which occurs before; /// any side effects occur. These can potentially be unswitched without; /// duplicating the loop. If a branch or switch is successfully unswitched the; /// scanning continues to see if subsequent branches or switches have become; /// trivial. Once all trivial candidates have been unswitched, this routine; /// returns.; ///; /// The return value indicates whether anything was unswitched (and therefore; /// changed).; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:9,Integrability,rout,routine,9,"/// This routine scans the loop to find a branch or switch which occurs before; /// any side effects occur. These can potentially be unswitched without; /// duplicating the loop. If a branch or switch is successfully unswitched the; /// scanning continues to see if subsequent branches or switches have become; /// trivial. Once all trivial candidates have been unswitched, this routine; /// returns.; ///; /// The return value indicates whether anything was unswitched (and therefore; /// changed).; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:379,Integrability,rout,routine,379,"/// This routine scans the loop to find a branch or switch which occurs before; /// any side effects occur. These can potentially be unswitched without; /// duplicating the loop. If a branch or switch is successfully unswitched the; /// scanning continues to see if subsequent branches or switches have become; /// trivial. Once all trivial candidates have been unswitched, this routine; /// returns.; ///; /// The return value indicates whether anything was unswitched (and therefore; /// changed).; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:88,Performance,load,loads,88,"// Check if there are any side-effecting instructions (e.g. stores, calls,; // volatile loads) in the part of the loop that the code *would* execute; // without unswitching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:137,Usability,simpl,simplifycfg,137,// Don't bother trying to unswitch past a switch with a constant; // condition. This should be removed prior to running this pass by; // simplifycfg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:111,Testability,log,logic,111,// If unswitching turned the terminator into an unconditional branch then; // we can continue. The unswitching logic specifically works to fold any; // cases it can into an unconditional branch to make it easier to; // recognize here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:130,Usability,simpl,simplifycfg,130,// Don't bother trying to unswitch past an unconditional branch or a branch; // with a constant value. These should be removed by simplifycfg prior to; // running this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:902,Deployability,update,updates,902,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1092,Deployability,update,updates,1092,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1125,Deployability,update,update,1125,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1328,Deployability,update,update,1328,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:277,Integrability,rout,routine,277,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:683,Usability,simpl,simple,683,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:44,Integrability,wrap,wrap,44,"// We will need to clone a bunch of blocks, wrap up the clone operation in; // a helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:211,Safety,safe,safe,211,"// When we are going to clone an exit, we don't need to clone all the; // instructions in the exit block and we want to ensure we have an easy; // place to merge the CFG, so split the exit first. This is always safe to; // do because there cannot be any non-loop predecessors of a loop exit in; // loop simplified form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:303,Usability,simpl,simplified,303,"// When we are going to clone an exit, we don't need to clone all the; // instructions in the exit block and we want to ensure we have an easy; // place to merge the CFG, so split the exit first. This is always safe to; // do because there cannot be any non-loop predecessors of a loop exit in; // loop simplified form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:50,Testability,test,test,50,// Rearrange the names to make it easier to write test cases by having the; // exit block carry the suffix rather than the merge block carrying the; // suffix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:171,Availability,avail,available,171,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:269,Deployability,update,update,269,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:291,Performance,cache,cache,291,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the cloned successors of the skipped blocks to not; // have spurious incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:11,Usability,Simpl,Simplification,11,// Trivial Simplification. If Terminator is a conditional branch and; // condition becomes dead - erase it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:22,Deployability,update,updates,22,// Record the domtree updates for the new blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:173,Safety,avoid,avoid,173,"// If we have a nest, we can quickly clone the entire loop nest using an; // iterative approach because it is a tree. We keep the cloned parent in the; // data structure to avoid repeatedly querying through a map to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:95,Usability,simpl,simplifies,95,"/// Build the cloned loops of an original loop from unswitching.; ///; /// Because unswitching simplifies the CFG of the loop, this isn't a trivial; /// operation. We need to re-verify that there even is a loop (as the backedge; /// may not have been cloned), and even if there are remaining backedges the; /// backedge set may be different. However, we know that each child loop is; /// undisturbed, we only need to find where to place each child loop within; /// either any parent loop or within a cloned version of the original loop.; ///; /// Because child loops may end up cloned outside of any cloned version of the; /// original loop, multiple cloned sibling loops may be created. All of them; /// are returned so that the newly introduced loop nest roots can be; /// identified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:108,Usability,simpl,simplified,108,// The only possible non-loop header predecessor is the preheader because; // we know we cloned the loop in simplified form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:27,Usability,simpl,simplified,27,"// Because the loop was in simplified form, the only non-loop predecessor; // should be the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:225,Testability,log,logic,225,"// We don't want to just add the cloned loop blocks based on how we; // discovered them. The original order of blocks was carefully built in; // a way that doesn't rely on predecessor ordering. Rather than re-invent; // that logic, we just re-walk the original blocks (and those of the child; // loops) and filter them as we add them into the cloned loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:90,Deployability,update,update,90,"// If this pred has already been moved to our set or is part of some; // (inner) loop, no update needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:57,Usability,clear,clear,57,// Now delete the dead child loops. This raw delete will clear them; // recursively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:50,Deployability,update,updated,50,// Check that the dominator tree has already been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:27,Usability,simpl,simplified,27,"// Because the loop was in simplified form, the only non-loop predecessor; // is the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:178,Usability,simpl,simplified,178,"// Because we know the inner loop structure remains valid we can use the; // loop structure to jump immediately across the entire nested loop.; // Further, because it is in loop simplified form, we can directly jump; // to its preheader afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:388,Deployability,update,update,388,"/// Rebuild a loop after unswitching removes some subset of blocks and edges.; ///; /// The removal may have removed some child loops entirely but cannot have; /// disturbed any remaining child loops. However, they may need to be hoisted; /// to the parent loop (or to be top-level loops). The original loop may be; /// completely removed.; ///; /// The sibling loops resulting from this update are returned. If the original; /// loop remains a valid loop, it will be the first entry in this list with all; /// of the newly sibling loops following it.; ///; /// Returns true if the loop remains a loop after unswitching, and false if it; /// is no longer a loop after unswitching (and should not continue to be; /// referenced).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:10,Deployability,update,update,10,// Now we update all the blocks which are no longer within the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:90,Deployability,update,update,90,"// If this pred has already been moved to our set or is part of some; // (inner) loop, no update needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:104,Deployability,update,update,104,// If blocks in this exit loop were directly part of the original loop (as; // opposed to a child loop) update the map to point to this exit loop. This; // just updates a map and so the fact that the order is unstable is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:161,Deployability,update,updates,161,// If blocks in this exit loop were directly part of the original loop (as; // opposed to a child loop) update the map to point to this exit loop. This; // just updates a map and so the fact that the order is unstable is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:158,Deployability,update,update,158,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:203,Deployability,update,update,203,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:210,Energy Efficiency,efficient,efficient,210,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:474,Usability,simpl,simplified,474,// To compute the new parent of this hoisted loop we look at where we; // placed the preheader above. We can't lookup the header itself because we; // retained the mapping from the header to the hoisted loop. But the; // preheader and header should have the exact same new parent computed; // based on the set of exit blocks from the original loop as the preheader; // is a predecessor of the header and so reached in the reverse walk. And; // because the loops were all in simplified form the preheader of the; // hoisted loop can't be part of some *other* loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:49,Safety,avoid,avoid,49,"// Mark the new loop as partially unswitched, to avoid unswitching on; // the same condition again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Integrability,inject,injection,19,// Do the same for injection of invariant conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Security,inject,injection,19,// Do the same for injection of invariant conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:35,Modifiability,variab,variable,35,// Save the current loop name in a variable so that we can report it even; // after it has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:155,Integrability,rout,routine,155,// The branch should be in this exact loop. Any inner loop's invariant branch; // should be handled by unswitching that inner loop. The caller of this; // routine should filter out any candidates that remain (but were skipped for; // whatever reason).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:36,Deployability,update,update,36,"// Get blocks in RPO order for MSSA update, before changing the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:160,Deployability,update,update,160,"// Compute the outer-most loop containing one of our exit blocks. This is the; // furthest up our loopnest which can be mutated, which we will use below to; // update things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Performance,cache,cached,85,"// At this point, we're definitely going to unswitch something so invalidate; // any cached information in ScalarEvolution for the outer most loop; // containing an exit block and all nested loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:320,Energy Efficiency,reduce,reduce,320,"// If the edge from this terminator to a successor dominates that successor,; // store a map from each block in its dominator subtree to it. This lets us; // tell when cloning for a particular successor if a block is dominated by; // some *other* successor with a single data structure. We use this to; // significantly reduce cloning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,Safety,safe,safe,56,"// Split the preheader, so that we know that there is a safe place to insert; // the conditional branch. We will change the preheader to have a conditional; // branch on LoopCond. The original preheader will become the split point; // between the unswitched versions, and we will have a new preheader for the; // original loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:36,Deployability,update,updates,36,// Keep track of the dominator tree updates needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,Integrability,depend,depends,52,// The stitching of the branched code back together depends on whether we're; // doing full unswitching or not with the exception that we always want to; // nuke the initial terminator placed in the split block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,Modifiability,rewrite,rewrite,52,// Splice the terminator from the original loop and rewrite its; // successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:43,Deployability,update,updates,43,// Keep a clone of the terminator for MSSA updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:31,Deployability,update,update,31,// Walk the cases and directly update their successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:46,Deployability,update,updates,46,// We need to use the set to populate domtree updates as even when there; // are multiple cases pointing at the same successor we only want to; // remove and insert one edge in the domtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:91,Safety,avoid,avoid,91,"// Remove all but one edge to the retained block and all unswitched; // blocks. This is to avoid having duplicate entries in the cloned Phis,; // when we know we only keep a single edge for each case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:117,Usability,simpl,simpler,117,// Now unhook the successor relationship as we'll be replacing; // the terminator with a direct branch. This is much simpler for branches; // than switches so we handle those first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:46,Deployability,update,updates,46,// We need to use the set to populate domtree updates as even when there; // are multiple cases pointing at the same successor we only want to; // remove and insert one edge in the domtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:15,Deployability,update,update,15,"// After MSSAU update, remove the cloned terminator instruction NewTI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:24,Deployability,update,updates,24,// Perform MSSA cloning updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Performance,Perform,Perform,3,// Perform MSSA cloning updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:13,Deployability,update,updates,13,// Apply the updates accumulated above to get an up-to-date dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:122,Usability,simpl,simplified,122,// Build the cloned loop structure itself. This may be substantially; // different from the original structure due to the simplified CFG. This also; // handles inserting all the cloned blocks into the correct loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:53,Deployability,update,update,53,"// Now that our cloned loops have been built, we can update the original loop.; // First we delete the dead blocks from it and then we rebuild the loop; // structure taking these deletions into account.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:157,Availability,error,errors,157,"// This transformation has a high risk of corrupting the dominator tree, and; // the below steps to rebuild loop structures will result in hard to debug; // errors in that case so verify that the dominator tree is sane first.; // FIXME: Remove this when the bugs stop showing up and rely on existing; // verification steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:34,Safety,risk,risk,34,"// This transformation has a high risk of corrupting the dominator tree, and; // the below steps to rebuild loop structures will result in hard to debug; // errors in that case so verify that the dominator tree is sane first.; // FIXME: Remove this when the bugs stop showing up and rely on existing; // verification steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:228,Deployability,update,updated,228,// If we unswitched a branch which collapses the condition to a known; // constant we want to replace all the uses of the invariants within both; // the original and cloned blocks. We do this here so that we can use the; // now updated dominator tree to identify which side the users are on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:541,Deployability,update,update,541,"// We can change which blocks are exit blocks of all the cloned sibling; // loops, the current loop, and any parent loops which shared exit blocks; // with the current loop. As a consequence, we need to re-form LCSSA for; // them. But we shouldn't need to re-form LCSSA for any child loops.; // FIXME: This could be made more efficient by tracking which exit blocks are; // new, and focusing on them, but that isn't likely to be necessary.; //; // In order to reasonably rebuild LCSSA we need to walk inside-out across the; // loop nest and update every loop that could have had its exits changed. We; // also need to cover any intervening loops. We add all of these loops to; // a list and sort them by loop depth to achieve this without updating; // unnecessary loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:326,Energy Efficiency,efficient,efficient,326,"// We can change which blocks are exit blocks of all the cloned sibling; // loops, the current loop, and any parent loops which shared exit blocks; // with the current loop. As a consequence, we need to re-form LCSSA for; // them. But we shouldn't need to re-form LCSSA for any child loops.; // FIXME: This could be made more efficient by tracking which exit blocks are; // new, and focusing on them, but that isn't likely to be necessary.; //; // In order to reasonably rebuild LCSSA we need to walk inside-out across the; // loop nest and update every loop that could have had its exits changed. We; // also need to cover any intervening loops. We add all of these loops to; // a list and sort them by loop depth to achieve this without updating; // unnecessary loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:65,Deployability,update,update,65,"// For non-child cloned loops and hoisted loops, we just need to update LCSSA; // and we can do it in any order as they don't nest relative to each other.; //; // Also check if any of the loops we have updated have become top-level loops; // as that will necessitate widening the outer loop scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:202,Deployability,update,updated,202,"// For non-child cloned loops and hoisted loops, we just need to update LCSSA; // and we can do it in any order as they don't nest relative to each other.; //; // Also check if any of the loops we have updated have become top-level loops; // as that will necessitate widening the outer loop scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:105,Deployability,update,update,105,"// If the original loop had exit blocks, walk up through the outer most loop; // of those exit blocks to update LCSSA and form updated dedicated exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:127,Deployability,update,updated,127,"// If the original loop had exit blocks, walk up through the outer most loop; // of those exit blocks to update LCSSA and form updated dedicated exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:59,Deployability,update,updates,59,// Verify the entire loop structure to catch any incorrect updates before we; // progress in the pass pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:102,Deployability,pipeline,pipeline,102,// Verify the entire loop structure to catch any incorrect updates before we; // progress in the pass pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:121,Deployability,update,updated,121,"// Now that we've unswitched something, make callbacks to report the changes.; // For that we need to merge together the updated loops and the cloned loops; // and check whether the original loop survived.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:64,Deployability,update,update,64,"// If not, we have to compute it. We can't use insert above and update; // because computing the cost may insert more things into the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:477,Deployability,update,updates,477,"/// Turns a select instruction into implicit control flow branch,; /// making the following replacement:; ///; /// head:; /// --code before select--; /// select %cond, %trueval, %falseval; /// --code after select--; ///; /// into; ///; /// head:; /// --code before select--; /// br i1 %cond, label %then, label %tail; ///; /// then:; /// br %tail; ///; /// tail:; /// phi [ %trueval, %then ], [ %falseval, %head]; /// unreachable; ///; /// It also makes all relevant DT and LI updates, so that all structures are in; /// valid state after this transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:546,Deployability,update,updates,546,"/// Turns a llvm.experimental.guard intrinsic into implicit control flow branch,; /// making the following replacement:; ///; /// --code before guard--; /// call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ ""deopt""() ]; /// --code after guard--; ///; /// into; ///; /// --code before guard--; /// br i1 %cond, label %guarded, label %deopt; ///; /// guarded:; /// --code after guard--; ///; /// deopt:; /// call void (i1, ...) @llvm.experimental.guard(i1 false) [ ""deopt""() ]; /// unreachable; ///; /// It also makes all relevant DT and LI updates, so that all structures are in; /// valid state after this transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:166,Availability,avail,available,166,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:543,Safety,predict,prediction,543,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:677,Safety,predict,predictions,677,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:376,Usability,simpl,simple,376,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:458,Usability,simpl,simple,458,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:97,Energy Efficiency,power,power-of-two,97,"// Ignore up to the ""unscaled candidates"" number of unswitch candidates; // when calculating the power-of-two scaling of the cost. The main idea; // with this control is to allow a small number of unswitches to happen; // and rely more on siblings multiplier (see below) when the number; // of candidates is small.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:38,Testability,log,logical,38,// Do not unswitch vector selects and logical and/or selects,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:183,Integrability,inject,injected,183,"/// Tries to canonicalize condition described by:; ///; /// br (LHS pred RHS), label IfTrue, label IfFalse; ///; /// into its equivalent where `Pred` is something that we support for injected; /// invariants (so far it is limited to ult), LHS in canonicalized form is; /// non-invariant and RHS is an invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:183,Security,inject,injected,183,"/// Tries to canonicalize condition described by:; ///; /// br (LHS pred RHS), label IfTrue, label IfFalse; ///; /// into its equivalent where `Pred` is something that we support for injected; /// invariants (so far it is limited to ult), LHS in canonicalized form is; /// non-invariant and RHS is an invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:150,Integrability,inject,injecting,150,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:132,Performance,optimiz,optimized,132,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:150,Security,inject,injecting,150,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:57,Deployability,update,updates,57,"// FIXME: For some reason this causes problems with MSSA updates, need to; // investigate why. So far, just don't unswitch latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:98,Integrability,inject,injection,98,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,Performance,optimiz,optimize,52,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:98,Security,inject,injection,98,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Integrability,inject,injected,85,"/// Materialize pending invariant condition of the given candidate into IR. The; /// injected loop-invariant condition implies the original loop-variant branch; /// condition, so the materialization turns; ///; /// loop_block:; /// ...; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; ///; /// into; ///; /// preheader:; /// %invariant_cond = LHS pred RHS; /// ...; /// loop_block:; /// br i1 %invariant_cond, label InLoopSucc, label OriginalCheck; /// OriginalCheck:; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; /// ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Security,inject,injected,85,"/// Materialize pending invariant condition of the given candidate into IR. The; /// injected loop-invariant condition implies the original loop-variant branch; /// condition, so the materialization turns; ///; /// loop_block:; /// ...; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; ///; /// into; ///; /// preheader:; /// %invariant_cond = LHS pred RHS; /// ...; /// loop_block:; /// br i1 %invariant_cond, label InLoopSucc, label OriginalCheck; /// OriginalCheck:; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; /// ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:112,Performance,optimiz,optimize,112,// Do not use builder here: CreateICmp may simplify this into a constant and; // unswitching will break. Better optimize it away later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:43,Usability,simpl,simplify,43,// Do not use builder here: CreateICmp may simplify this into a constant and; // unswitching will break. Better optimize it away later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:176,Integrability,inject,injected,176,"// TODO: In fact, cost of unswitching a new invariant candidate is *slightly*; // higher because we have just inserted a new block. Need to think how to; // adjust the cost of injected candidates when it was first computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:176,Security,inject,injected,176,"// TODO: In fact, cost of unswitching a new invariant candidate is *slightly*; // higher because we have just inserted a new block. Need to think how to; // adjust the cost of injected candidates when it was first computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:389,Integrability,inject,inject,389,"/// Given chain of loop branch conditions looking like:; /// br (Variant < Invariant1); /// br (Variant < Invariant2); /// br (Variant < Invariant3); /// ...; /// collect set of invariant conditions on which we want to unswitch, which; /// look like:; /// Invariant1 <= Invariant2; /// Invariant2 <= Invariant3; /// ...; /// Though they might not immediately exist in the IR, we can still inject them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:389,Security,inject,inject,389,"/// Given chain of loop branch conditions looking like:; /// br (Variant < Invariant1); /// br (Variant < Invariant2); /// br (Variant < Invariant3); /// ...; /// collect set of invariant conditions on which we want to unswitch, which; /// look like:; /// Invariant1 <= Invariant2; /// Invariant2 <= Invariant3; /// ...; /// Though they might not immediately exist in the IR, we can still inject them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:128,Integrability,inject,injected,128,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:266,Performance,load,load,266,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:128,Security,inject,injected,128,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:220,Performance,cache,cache,220,"// Given that unswitching these terminators will require duplicating parts of; // the loop, so we need to be able to model that cost. Compute the ephemeral; // values and set up a data structure to hold per-BB costs. We cache each; // block's cost so that we don't recompute this when considering different; // subsets of the loop for duplication during unswitching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:245,Safety,safe,safely,245,"// Compute the cost of each block, as well as the total loop cost. Also, bail; // out if we see instructions which are incompatible with loop unswitching; // (convergent, noduplicate, or cross-basic-block tokens).; // FIXME: We might be able to safely handle some of these in non-duplicated; // regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:238,Availability,redundant,redundant,238,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:533,Availability,redundant,redundant,533,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:219,Safety,avoid,avoid,219,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:238,Safety,redund,redundant,238,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:527,Safety,avoid,avoid,527,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:533,Safety,redund,redundant,533,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:464,Deployability,update,updated,464,"/// Unswitch control flow predicated on loop invariant conditions.; ///; /// This first hoists all branches or switches which are trivial (IE, do not; /// require duplicating any part of the loop) out of the loop body. It then; /// looks at other loop invariant control flows and tries to unswitch those as; /// well by cloning the loop if the result is small enough.; ///; /// The `DT`, `LI`, `AC`, `AA`, `TTI` parameters are required analyses that are; /// also updated based on the unswitch. The `MSSA` analysis is also updated if; /// valid (i.e. its use is enabled).; ///; /// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is; /// true, we will attempt to do non-trivial unswitching as well as trivial; /// unswitching.; ///; /// The `postUnswitch` function will be run after unswitching is complete; /// with information on whether or not the provided loop remains a loop and; /// a list of new sibling loops created.; ///; /// If `SE` is non-null, we will update that analysis based on the unswitching; /// done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:523,Deployability,update,updated,523,"/// Unswitch control flow predicated on loop invariant conditions.; ///; /// This first hoists all branches or switches which are trivial (IE, do not; /// require duplicating any part of the loop) out of the loop body. It then; /// looks at other loop invariant control flows and tries to unswitch those as; /// well by cloning the loop if the result is small enough.; ///; /// The `DT`, `LI`, `AC`, `AA`, `TTI` parameters are required analyses that are; /// also updated based on the unswitch. The `MSSA` analysis is also updated if; /// valid (i.e. its use is enabled).; ///; /// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is; /// true, we will attempt to do non-trivial unswitching as well as trivial; /// unswitching.; ///; /// The `postUnswitch` function will be run after unswitching is complete; /// with information on whether or not the provided loop remains a loop and; /// a list of new sibling loops created.; ///; /// If `SE` is non-null, we will update that analysis based on the unswitching; /// done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:987,Deployability,update,update,987,"/// Unswitch control flow predicated on loop invariant conditions.; ///; /// This first hoists all branches or switches which are trivial (IE, do not; /// require duplicating any part of the loop) out of the loop body. It then; /// looks at other loop invariant control flows and tries to unswitch those as; /// well by cloning the loop if the result is small enough.; ///; /// The `DT`, `LI`, `AC`, `AA`, `TTI` parameters are required analyses that are; /// also updated based on the unswitch. The `MSSA` analysis is also updated if; /// valid (i.e. its use is enabled).; ///; /// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is; /// true, we will attempt to do non-trivial unswitching as well as trivial; /// unswitching.; ///; /// The `postUnswitch` function will be run after unswitching is complete; /// with information on whether or not the provided loop remains a loop and; /// a list of new sibling loops created.; ///; /// If `SE` is non-null, we will update that analysis based on the unswitching; /// done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Usability,simpl,simplified,19,// Must be in loop simplified form: we need a preheader and dedicated exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:2,Integrability,Inject,InjectedCondition,2,/*InjectedCondition*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:2,Security,Inject,InjectedCondition,2,/*InjectedCondition*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:404,Availability,avail,available,404,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:102,Modifiability,variab,variable,102,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:155,Testability,test,testing,155,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Performance,Perform,Perform,3,// Perform legality checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:278,Usability,simpl,simplified,278,"// For non-trivial unswitching, because it often creates new loops, we rely on; // the pass manager to iterate on the loops rather than trying to immediately; // reach a fixed point. There is no substantial advantage to iterating; // internally, and if any of the new loops are simplified enough to contain; // trivial unswitching we want to prefer those.; // Try to unswitch the best invariant condition. We prefer this full unswitch to; // a partial unswitch when possible below the threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Testability,assert,asserts,85,// Historically this pass has had issues with the dominator tree so verify it; // in asserts builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:510,Performance,optimiz,optimizations,510,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:7,Usability,Simpl,SimplifyCFGPass,7,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:33,Usability,Simpl,Simplification,33,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:45,Modifiability,rewrite,rewrite,45,"// If the canonical terminator has operands, rewrite it to take PHI's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:89,Modifiability,rewrite,rewrite,89,"// Now, go through each block (with the current terminator type); // we've recorded, and rewrite it to branch to the new common block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:31,Usability,resume,resume,31,// Fow now only support `ret`/`resume` function terminators.; // FIXME: lift this restriction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:9,Usability,Simpl,SimplifyCFG,9,"/// Call SimplifyCFG on all the blocks in the function,; /// iterating until no more changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:180,Performance,optimiz,optimizations,180,"// iterativelySimplifyCFG can (rarely) make some loops dead. If this happens,; // removeUnreachableBlocks is needed to nuke them, which means we should; // iterate between the two optimizations. We structure the code like this to; // avoid rerunning iterativelySimplifyCFG if the second pass of; // removeUnreachableBlocks doesn't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:234,Safety,avoid,avoid,234,"// iterativelySimplifyCFG can (rarely) make some loops dead. If this happens,; // removeUnreachableBlocks is needed to nuke them, which means we should; // iterate between the two optimizations. We structure the code like this to; // avoid rerunning iterativelySimplifyCFG if the second pass of; // removeUnreachableBlocks doesn't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:10,Integrability,interface,interface,10,// Public interface to the CFGSimplification pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:48,Integrability,depend,dependent,48,// Convergent operations cannot be made control-dependent on additional; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:20,Performance,load,load,20,// We cannot sink a load across a critical edge - there may be stores in; // other code paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:46,Safety,safe,safe,46,/// SinkInstruction - Determine whether it is safe to sink the specified machine; /// instruction out of its current block into a successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:245,Availability,down,down,245,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.; // SuccToSinkTo - This is the successor to sink this instruction to, once we; // decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:393,Availability,down,down,393,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.; // SuccToSinkTo - This is the successor to sink this instruction to, once we; // decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:2123,Deployability,pipeline,pipeline,2123,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:972,Performance,optimiz,optimized,972,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1153,Performance,optimiz,optimization,1153,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:539,Usability,simpl,simple,539,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1251,Usability,Simpl,SimplifyCFG,1251,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===---------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1264,Usability,Simpl,SimplifyCFG,1264,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1546,Usability,Simpl,SimplifyCFG,1546,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:7,Safety,risk,risk,7,"// The risk that speculation will not pay off increases with the; // number of instructions speculated, so we put a limit on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:218,Performance,optimiz,optimization,218,// Speculating just a few instructions from a larger block tends not; // to be profitable and this limit prevents that. A reason for that is; // that small basic blocks are more likely to be candidates for; // further optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:3,Modifiability,Variab,Variable,3,// Variable preserved purely for correct name printing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:9,Modifiability,variab,variable,9,// Debug variable has special operand to check it's not hoisted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:161,Safety,detect,detect,161,// Usially debug label intrinsic corresponds to label in LLVM IR. In these; // cases we should not move it here.; // TODO: Possible special processing needed to detect it is related to a; // hoisted instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:980,Performance,perform,performs,980,"//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This transformation implements the well known scalar replacement of; /// aggregates transformation. It tries to identify promotable elements of an; /// aggregate alloca, and promote them to registers. It will also try to; /// convert uses of an element (or set of elements) of an alloca into a vector; /// or bitfield-style integer scalar if appropriate.; ///; /// It works to do this with minimal slicing of the alloca so that regions; /// which are merely transferred in and out of external memory remain unchanged; /// and are not decomposed to scalar code.; ///; /// Because this also performs alloca promotion, it can be thought of as also; /// serving the purpose of SSA formation. The algorithm iterates on the; /// function until all opportunities for promotion have been realized.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:52,Testability,test,test,52,/// Disable running mem2reg during SROA in order to test or debug SROA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,Performance,optimiz,optimization,7,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:871,Safety,detect,detect,871,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:488,Security,access,accesses,488,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:552,Security,access,accesses,552,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:588,Security,access,accesses,588,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:891,Security,access,accesses,891,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:254,Modifiability,rewrite,rewrite,254,"/// Worklist of alloca instructions to simplify.; ///; /// Each alloca in the function is added to this. Each new alloca formed gets; /// added to it as well to recursively simplify unless that alloca can be; /// directly promoted. Finally, each time we rewrite a use of an alloca other; /// the one being actively rewritten, we add it back onto the list if not; /// already present to ensure it is re-visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:39,Usability,simpl,simplify,39,"/// Worklist of alloca instructions to simplify.; ///; /// Each alloca in the function is added to this. Each new alloca formed gets; /// added to it as well to recursively simplify unless that alloca can be; /// directly promoted. Finally, each time we rewrite a use of an alloca other; /// the one being actively rewritten, we add it back onto the list if not; /// already present to ensure it is re-visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:173,Usability,simpl,simplify,173,"/// Worklist of alloca instructions to simplify.; ///; /// Each alloca in the function is added to this. Each new alloca formed gets; /// added to it as well to recursively simplify unless that alloca can be; /// directly promoted. Finally, each time we rewrite a use of an alloca other; /// the one being actively rewritten, we add it back onto the list if not; /// already present to ensure it is re-visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:124,Energy Efficiency,efficient,efficient,124,/// A collection of instructions to delete.; /// We try to batch deletions to simplify code and make things a bit more; /// efficient. We also make sure there is no dangling pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:78,Usability,simpl,simplify,78,/// A collection of instructions to delete.; /// We try to batch deletions to simplify code and make things a bit more; /// efficient. We also make sure there is no dangling pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,Usability,clear,clear,291,"/// Post-promotion worklist.; ///; /// Sometimes we discover an alloca which has a high probability of becoming; /// viable for SROA after a round of promotion takes place. In those cases,; /// the alloca is enqueued here for re-processing.; ///; /// Note that we have to be very careful to clear allocas out of this list in; /// the event they are deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:231,Performance,queue,queue,231,/// A worklist of PHIs to speculate prior to promoting allocas.; ///; /// All of these PHIs have been checked for the safety of speculation and by; /// being speculated will allow promoting allocas currently in the promotable; /// queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:118,Safety,safe,safety,118,/// A worklist of PHIs to speculate prior to promoting allocas.; ///; /// All of these PHIs have been checked for the safety of speculation and by; /// being speculated will allow promoting allocas currently in the promotable; /// queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Modifiability,rewrite,rewrite,41,/// A worklist of select instructions to rewrite prior to promoting; /// allocas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:64,Performance,load,loaded,64,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:96,Performance,load,load,96,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:175,Performance,load,load,175,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:288,Performance,load,load,288,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:329,Performance,load,load,329,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:386,Performance,load,load,386,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:518,Performance,load,loads,518,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:576,Performance,load,loaded,576,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:629,Performance,perform,perform,629,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:718,Performance,load,load,718,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:60,Modifiability,variab,variable,60,"// end anonymous namespace; /// Calculate the fragment of a variable to use when slicing a store; /// based on the slice dimensions, existing fragment, and base storage; /// fragment.; /// Results:; /// UseFrag - Use Target as the new fragment.; /// UseNoFrag - The new slice already covers the whole variable.; /// Skip - The new alloca slice doesn't include this variable.; /// FIXME: Can we use calculateFragmentIntersect instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:301,Modifiability,variab,variable,301,"// end anonymous namespace; /// Calculate the fragment of a variable to use when slicing a store; /// based on the slice dimensions, existing fragment, and base storage; /// fragment.; /// Results:; /// UseFrag - Use Target as the new fragment.; /// UseNoFrag - The new slice already covers the whole variable.; /// Skip - The new alloca slice doesn't include this variable.; /// FIXME: Can we use calculateFragmentIntersect instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:365,Modifiability,variab,variable,365,"// end anonymous namespace; /// Calculate the fragment of a variable to use when slicing a store; /// based on the slice dimensions, existing fragment, and base storage; /// fragment.; /// Results:; /// UseFrag - Use Target as the new fragment.; /// UseNoFrag - The new slice already covers the whole variable.; /// Skip - The new alloca slice doesn't include this variable.; /// FIXME: Can we use calculateFragmentIntersect instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:45,Modifiability,variab,variable,45,// If the base storage describes part of the variable apply the offset and; // the size constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:57,Modifiability,variab,variable,57,"// If this slice extracts the entirety of an independent variable from a; // larger alloca, do not produce a fragment expression, as the variable is; // not fragmented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:137,Modifiability,variab,variable,137,"// If this slice extracts the entirety of an independent variable from a; // larger alloca, do not produce a fragment expression, as the variable is; // not fragmented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:52,Modifiability,variab,variable,52,// Treat the current fragment as covering the whole variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:247,Modifiability,variab,variable,247,/// Find linked dbg.assign and generate a new one with the correct; /// FragmentInfo. Link Inst to the new dbg.assign. If Value is nullptr the; /// value component is copied from the old dbg.assign to the new.; /// \param OldAlloca Alloca for the variable before splitting.; /// \param IsSplit True if the store (not necessarily alloca); /// is being split.; /// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.; /// \param SliceSizeInBits New number of bits being written to.; /// \param OldInst Instruction that is being split.; /// \param Inst New instruction performing this part of the; /// split store.; /// \param Dest Store destination.; /// \param Value Stored value.; /// \param DL Datalayout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:585,Performance,perform,performing,585,/// Find linked dbg.assign and generate a new one with the correct; /// FragmentInfo. Link Inst to the new dbg.assign. If Value is nullptr the; /// value component is copied from the old dbg.assign to the new.; /// \param OldAlloca Alloca for the variable before splitting.; /// \param IsSplit True if the store (not necessarily alloca); /// is being split.; /// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.; /// \param SliceSizeInBits New number of bits being written to.; /// \param OldInst Instruction that is being split.; /// \param Inst New instruction performing this part of the; /// split store.; /// \param Dest Store destination.; /// \param Value Stored value.; /// \param DL Datalayout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Modifiability,variab,variables,21,/// Map of aggregate variables to their fragment associated with OldAlloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:112,Testability,assert,assert,112,// The new inst needs a DIAssignID unique metadata tag (if OldInst has; // one). It shouldn't already have one: assert this assumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite NewFragment to be relative to the existing one (this is; // what createFragmentExpression wants). CalculateFragment has; // already resolved the size for us. FIXME: Should it return the; // relative fragment too?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Deployability,update,updated,12,"// If we've updated the value but the original dbg.assign has an arglist; // then kill it now - we can't use the requested new value.; // We can't replace the DIArgList with the new value as it'd leave; // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without; // an arglist). And we can't keep the DIArgList in case the linked store; // is being split - in which case the DIArgList + expression may no longer; // be computing the correct value.; // This should be a very rare situation as it requires the value being; // stored to differ from the dbg.assign (i.e., the value has been; // represented differently in the debug intrinsic for some reason).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:75,Testability,Assert,Assert,75,"/// A custom IRBuilder inserter which prefixes all names, but only in; /// Assert builds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Deployability,release,release,53,/// Provide a type for IRBuilder that drops names in release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether a pointer to the allocation escapes our analysis.; ///; /// If this is true, the slices are never fully built and should be; /// ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Security,access,accessor,42,// Forward declare the iterator and range accessor for walking the; // partitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Security,Access,Access,4,/// Access the dead users for this alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Security,Access,Access,4,/// Access Uses that should be dropped if the alloca is promotable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Security,Access,Access,4,/// Access the dead operands referring to this alloca.; ///; /// These are operands which have cannot actually be used to refer to the; /// alloca as they are outside its range and the user doesn't correct for; /// that. These mostly consist of PHI node inputs and the like which we just; /// need to replace with undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:52,Integrability,interface,interfaces,52,/// Handle to alloca instruction to simplify method interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:36,Usability,simpl,simplify,36,/// Handle to alloca instruction to simplify method interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:207,Safety,abort,abort,207,"/// The instruction responsible for this alloca not having a known set; /// of slices.; ///; /// When an instruction (potentially) escapes the pointer to the alloca, we; /// store a pointer to that here and abort trying to form slices of the; /// alloca. This will be null if the alloca slices are analyzed successfully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:340,Energy Efficiency,allocate,allocated,340,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,Modifiability,rewrite,rewrite,46,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:259,Usability,simpl,simply,259,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Modifiability,rewrite,rewrite,42,"/// Operands which will become dead if we rewrite the alloca.; ///; /// These are operands that in their particular use can be replaced with; /// poison when we rewrite the alloca. These show up in out-of-bounds inputs; /// to PHI nodes and the like. They aren't entirely dead (there might be; /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we; /// want to swap this particular input for poison to simplify the use lists of; /// the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:161,Modifiability,rewrite,rewrite,161,"/// Operands which will become dead if we rewrite the alloca.; ///; /// These are operands that in their particular use can be replaced with; /// poison when we rewrite the alloca. These show up in out-of-bounds inputs; /// to PHI nodes and the like. They aren't entirely dead (there might be; /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we; /// want to swap this particular input for poison to simplify the use lists of; /// the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:426,Usability,simpl,simplify,426,"/// Operands which will become dead if we rewrite the alloca.; ///; /// These are operands that in their particular use can be replaced with; /// poison when we rewrite the alloca. These show up in out-of-bounds inputs; /// to PHI nodes and the like. They aren't entirely dead (there might be; /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we; /// want to swap this particular input for poison to simplify the use lists of; /// the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:239,Security,access,access,239,"/// A partition of the slices.; ///; /// An ephemeral representation for a range of slices which can be viewed as; /// a partition of the alloca. This range represents a span of the alloca's; /// memory which cannot be split, and provides access to all of the slices; /// overlapping some part of the partition.; ///; /// Objects of this type are produced by traversing the alloca's slices, but; /// are only ephemeral and not persistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether this partition contains no slices, and merely spans; /// a region occupied by split slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:396,Integrability,interface,interface,396,"/// \name Iterate slices that start within the partition.; /// These may be splittable or unsplittable. They have a begin offset >= the; /// partition begin offset.; /// @{; // FIXME: We should probably define a ""concat_iterator"" helper and use that; // to stitch together pointee_iterators over the split tails and the; // contiguous iterators of the partition. That would give a much nicer; // interface here. We could then additionally expose filtered iterators for; // split, unsplit, and unsplittable splices based on the usage patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:439,Security,expose,expose,439,"/// \name Iterate slices that start within the partition.; /// These may be splittable or unsplittable. They have a begin offset >= the; /// partition begin offset.; /// @{; // FIXME: We should probably define a ""concat_iterator"" helper and use that; // to stitch together pointee_iterators over the split tails and the; // contiguous iterators of the partition. That would give a much nicer; // interface here. We could then additionally expose filtered iterators for; // split, unsplit, and unsplittable splices based on the usage patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:85,Integrability,interface,interface,85,/// Most of the state for walking the partitions is held in a class; /// with a nice interface for examining them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Usability,Clear,Clear,3,// Clear out any split uses which have ended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:45,Usability,clear,cleared,45,"// If P.SI is already at the end, then we've cleared the split tail and; // now have an end iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:99,Modifiability,extend,extend,99,"// When we're forming an unsplittable region, it must always start at; // the first slice and will extend through its end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:79,Security,access,accesses,79,"/// A forward range over the partitions of the alloca's slices.; ///; /// This accesses an iterator range over the partitions of the alloca's; /// slices. It computes these partitions on the fly based on the overlapping; /// offsets of the slices and the ability to split them. It will visit ""empty""; /// partitions to cover regions of the alloca only accessed via split; /// slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:352,Security,access,accessed,352,"/// A forward range over the partitions of the alloca's slices.; ///; /// This accesses an iterator range over the partitions of the alloca's; /// slices. It computes these partitions on the fly based on the overlapping; /// offsets of the slices and the ability to split them. It will visit ""empty""; /// partitions to cover regions of the alloca only accessed via split; /// slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:165,Performance,load,load,165,/// Builder for the alloca slices.; ///; /// This class builds a set of alloca slices by recursively visiting the uses; /// of an alloca and making a slice for each load and store at each offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:270,Performance,load,loads,270,"// Clamp the end offset to the end of the allocation. Note that this is; // formulated to handle even the case where ""BeginOffset + Size"" overflows.; // This may appear superficially to be something we could ignore entirely,; // but that is not so! There may be widened loads or PHI-node uses where; // some instructions are dead but not others. We can't completely ignore; // them, and so have to record at least the information here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:435,Availability,avail,available,435,"// FIXME: This is a manually un-factored variant of the basic code inside; // of GEPs with checking of the inbounds invariant specified in the; // langref in a very strict sense. If we ever want to enable; // SROAStrictInbounds, this code should be factored cleanly into; // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds; // by writing out the code here where we have the underlying allocation; // size readily available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:38,Performance,load,loads,38,"// We allow splitting of non-volatile loads and stores where the type is an; // integer type. These may be used to implement 'memcpy' or other ""transfer; // of bits"" patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:54,Modifiability,extend,extend,54,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:441,Performance,race condition,race conditions,441,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,Safety,risk,risk,291,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:18,Security,access,access,18,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:134,Usability,simpl,simply,134,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:58,Performance,load,load,58,// We consider any PHI or select that results in a direct load or store of; // the same offset to be a viable use for slicing purposes. These uses; // are considered unsplittable and the size is the maximum loaded or stored; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:207,Performance,load,loaded,207,// We consider any PHI or select that results in a direct load or store of; // the same offset to be a viable use for slicing purposes. These uses; // are considered unsplittable and the size is the maximum loaded or stored; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:19,Performance,load,loads,19,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Security,access,access,40,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:88,Security,access,access,88,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:201,Performance,load,loading,201,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:245,Performance,load,load,245,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:404,Performance,load,load,404,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:22,Usability,simpl,simplifyInstruction,22,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:319,Usability,simpl,simply,319,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Safety,unsafe,unsafe,42,"// This is a new PHI/Select, check for an unsafe use of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:365,Security,sanitiz,sanitization,365,"// For PHI and select operands outside the alloca, we can't nuke the entire; // phi or select -- the other side might still be relevant, so we special; // case them here and use a separate structure to track the operands; // themselves which should be replaced with poison.; // FIXME: This should instead be escaped in the event we're instrumenting; // for address sanitization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Safety,abort,abort,40,"// FIXME: We should sink the escape vs. abort info into the caller nicely,; // possibly by just storing the PtrInfo in the AllocaSlices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Integrability,depend,depending,12,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:77,Integrability,depend,depend,77,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:6,Safety,avoid,avoid,6,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:61,Performance,load,loaded,61,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:93,Performance,load,load,93,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:181,Performance,load,load,181,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:285,Performance,load,load,285,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:319,Performance,load,load,319,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:378,Performance,load,load,378,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:495,Performance,load,loads,495,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:547,Performance,load,loaded,547,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:49,Performance,load,load,49,"// For now, we can only do this promotion if the load is in the same block; // as the PHI, and if there are no stores between the phi and load.; // TODO: Allow recursive phi users.; // TODO: Allow stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:138,Performance,load,load,138,"// For now, we can only do this promotion if the load is in the same block; // as the PHI, and if there are no stores between the phi and load.; // TODO: Allow recursive phi users.; // TODO: Allow stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:25,Performance,load,loads,25,// For now we only allow loads in the same block as the PHI. This is; // a common case that happens when instcombine merges two loads through; // a PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:128,Performance,load,loads,128,// For now we only allow loads in the same block as the PHI. This is; // a common case that happens when instcombine merges two loads through; // a PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:65,Performance,load,load,65,// Ensure that there are no instructions between the PHI and the load that; // could store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Performance,load,loads,56,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:172,Performance,load,load,172,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:39,Safety,safe,safe,39,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:138,Performance,load,load,138,"// If the value is produced by the terminator of the predecessor (an; // invoke) or it has side-effects, there is no valid place to put a load; // in the predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:37,Performance,load,load,37,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:90,Performance,load,load,90,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:130,Performance,load,load,130,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:29,Safety,safe,safe,29,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Performance,load,loads,56,// Get the AA tags and alignment to use from one of the loads. It does not; // matter which one we get and if any differ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all loads of the PN to use the new PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Performance,load,loads,15,// Rewrite all loads of the PN to use the new PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Integrability,Inject,Inject,3,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:10,Performance,load,loads,10,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Security,Inject,Inject,3,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:144,Integrability,inject,injected,144,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:159,Performance,load,load,159,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:214,Performance,load,load,214,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:144,Security,inject,injected,144,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:20,Performance,load,loads,20,// Note that atomic loads can be transformed;; // atomic semantics do not have any meaning for a local alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:11,Performance,load,load,11,"// If the `load` is not simple, we can't speculatively execute it,; // but we could handle this via a CFG modification. But can we?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:24,Usability,simpl,simple,24,"// If the `load` is not simple, we can't speculatively execute it,; // but we could handle this via a CFG modification. But can we?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Performance,load,load,21,// Replace the given load of the select with a select of two loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:61,Performance,load,loads,61,// Replace the given load of the select with a select of two loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,load,41,/// Compute the adjusted alignment for a load or store from an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:283,Integrability,wrap,wrappings,283,"/// Test whether we can convert a value from the old to the new type.; ///; /// This predicate should be used to guard calls to convertValue in order to; /// ensure that we only try to convert viable values. The strategy is that we; /// will peel off single element struct and array wrappings to get to an; /// underlying value, and convert that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether we can convert a value from the old to the new type.; ///; /// This predicate should be used to guard calls to convertValue in order to; /// ensure that we only try to convert viable values. The strategy is that we; /// will peel off single element struct and array wrappings to get to an; /// underlying value, and convert that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:186,Performance,load,loads,186,"// For integer types, we can't handle any bit-width differences. This would; // break both vector conversions with extension and introduce endianness; // issues when in conjunction with loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Integrability,rout,routine,12,"/// Generic routine to convert an SSA value to a value of a different; /// type.; ///; /// This will try various different casting techniques, such as bitcasts,; /// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test; /// two types for viability with this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:280,Integrability,rout,routine,280,"/// Generic routine to convert an SSA value to a value of a different; /// type.; ///; /// This will try various different casting techniques, such as bitcasts,; /// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test; /// two types for viability with this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:236,Testability,test,test,236,"/// Generic routine to convert an SSA value to a value of a different; /// type.; ///; /// This will try various different casting techniques, such as bitcasts,; /// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test; /// two types for viability with this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether the given slice use can be promoted to a vector.; ///; /// This function is called to test each entry in a partition which is slated; /// for a single slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:103,Testability,test,test,103,/// Test whether the given slice use can be promoted to a vector.; ///; /// This function is called to test each entry in a partition which is slated; /// for a single slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:9,Security,validat,validate,9,// First validate the slice offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Performance,load,loads,43,// Disable vector promotion when there are loads or stores of an FCA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Performance,load,loads,43,// Disable vector promotion when there are loads or stores of an FCA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether a vector type is viable for promotion.; ///; /// This implements the necessary checking for \c checkVectorTypesForPromotion; /// (and thus isVectorPromotionViable) over all slices of the alloca for the; /// given VectorType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether any vector type in \p CandidateTys is viable for promotion.; ///; /// This implements the necessary checking for \c isVectorPromotionViable over; /// all slices of the alloca for the given VectorType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:150,Performance,perform,perform,150,"// Pointer-ness is sticky, if we had a vector-of-pointers candidate type,; // then we should choose it, not some other alternative.; // But, we can't perform a no-op pointer address space change via bitcast,; // so if we didn't have a common pointer element type, bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:85,Performance,load,load,85,// Consider additional vector types where the element type size is a; // multiple of load/store element size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:156,Modifiability,rewrite,rewrite,156,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:444,Modifiability,rewrite,rewrites,444,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:278,Performance,load,loads,278,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:127,Testability,test,test,127,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:538,Testability,test,test,538,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,Performance,load,load,7,// Put load and store types into a set for de-duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,Performance,load,loads,16,// Consider any loads or stores that are the exact size of the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether a slice of an alloca is valid for integer widening.; ///; /// This implements the necessary checking for the \c isIntegerWideningViable; /// test below on a single slice of the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:158,Testability,test,test,158,/// Test whether a slice of an alloca is valid for integer widening.; ///; /// This implements the necessary checking for the \c isIntegerWideningViable; /// test below on a single slice of the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:99,Performance,load,load,99,// Lifetime intrinsics operate over the whole alloca whose sizes are usually; // larger than other load/store slices (RelEnd > Size). But lifetime are; // always promotable and should not impact other slices' promotability of the; // partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:60,Modifiability,extend,extends,60,// We can't reasonably handle cases where the load or store extends past; // the end of the alloca's type and into its padding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,Performance,load,load,46,// We can't reasonably handle cases where the load or store extends past; // the end of the alloca's type and into its padding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,Energy Efficiency,allocate,allocated,46,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Modifiability,extend,extend,30,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:19,Performance,load,loads,19,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,Modifiability,rewrite,rewriteIntegerLoad,82,"// So far, AllocaSliceRewriter does not support widening split slice tails; // in rewriteIntegerLoad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:35,Performance,load,loads,35,// Note that we don't count vector loads or stores as whole-alloca; // operations which enable integer widening because we would prefer to use; // vector widening instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Performance,load,loads,15,// Non-integer loads need to be convertible from the alloca type so that; // they are promotable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,Energy Efficiency,allocate,allocated,47,// We can't handle stores that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:31,Modifiability,extend,extend,31,// We can't handle stores that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,Modifiability,rewrite,rewriteIntegerStore,82,"// So far, AllocaSliceRewriter does not support widening split slice tails; // in rewriteIntegerStore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:35,Performance,load,loads,35,// Note that we don't count vector loads or stores as whole-alloca; // operations which enable integer widening because we would prefer to use; // vector widening instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:160,Modifiability,rewrite,rewrite,160,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:180,Performance,load,loads,180,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:236,Performance,load,loads,236,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:131,Testability,test,test,131,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:66,Performance,load,load,66,"// While examining uses, we ensure that the alloca has a covering load or; // store. We don't want to widen the integer operations only to fail to; // promote due to some other unsplittable entry (which we may make splittable; // later). However, if there are only splittable uses, go ahead and assume; // that we cover the alloca.; // FIXME: We shouldn't consider split slices that happen to start in the; // partition here...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:187,Performance,load,loaded,187,"// When inserting a smaller vector into the larger to store, we first; // use a shuffle vector to widen it with undef elements, and then; // a second shuffle vector to select between the loaded vector and the; // incoming vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Modifiability,rewrite,rewrite,15,/// Visitor to rewrite instructions using p particular slice of an alloca; /// to use a new alloca.; ///; /// Also implements the rewriting to vector-based accesses when the partition; /// passes the isVectorPromotionViable predicate. Most of the rewriting logic; /// lives here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:156,Security,access,accesses,156,/// Visitor to rewrite instructions using p particular slice of an alloca; /// to use a new alloca.; ///; /// Also implements the rewriting to vector-based accesses when the partition; /// passes the isVectorPromotionViable predicate. Most of the rewriting logic; /// lives here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:257,Testability,log,logic,257,/// Visitor to rewrite instructions using p particular slice of an alloca; /// to use a new alloca.; ///; /// Also implements the rewriting to vector-based accesses when the partition; /// passes the isVectorPromotionViable predicate. Most of the rewriting logic; /// lives here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Modifiability,variab,variable,34,"// This is a convenience and flag variable that will be null unless the new; // alloca's integer operations should be widened to this integer type due to; // passing isIntegerWideningViable above. If it is non-null, the desired; // integer type will be stored here for easy access during rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:274,Security,access,access,274,"// This is a convenience and flag variable that will be null unless the new; // alloca's integer operations should be widened to this integer type due to; // passing isIntegerWideningViable above. If it is non-null, the desired; // integer type will be stored here for easy access during rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,Security,access,accesses,291,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:381,Security,access,accessing,381,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:500,Security,access,access,500,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Modifiability,rewrite,rewrite,14,// Track post-rewrite users which are PHI nodes and Selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:57,Safety,avoid,avoid,57,"// Return the new alloca, addrspacecasted if required to avoid changing the; // addrspace of a volatile access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:104,Security,access,access,104,"// Return the new alloca, addrspacecasted if required to avoid changing the; // addrspace of a volatile access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:60,Modifiability,rewrite,rewrite,60,// Every instruction which can end up as a user must have a rewrite rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:127,Integrability,rout,routine,127,"/// Compute suitable alignment to access this slice of the *new*; /// alloca.; ///; /// You can optionally pass a type to this routine and if that type's ABI; /// alignment is itself suitable, this will return zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Security,access,access,34,"/// Compute suitable alignment to access this slice of the *new*; /// alloca.; ///; /// You can optionally pass a type to this routine and if that type's ABI; /// alignment is itself suitable, this will return zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:257,Modifiability,extend,extend,257,"// It is possible that the extracted type is not the load type. This; // happens if there is a load past the end of the alloca, and as; // a consequence the slice is narrower but still a candidate for integer; // lowering. To handle this case, we just zero extend the extracted; // integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Performance,load,load,53,"// It is possible that the extracted type is not the load type. This; // happens if there is a load past the end of the alloca, and as; // a consequence the slice is narrower but still a candidate for integer; // lowering. To handle this case, we just zero extend the extracted; // integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:95,Performance,load,load,95,"// It is possible that the extracted type is not the load type. This; // happens if there is a load past the end of the alloca, and as; // a consequence the slice is narrower but still a candidate for integer; // lowering. To handle this case, we just zero extend the extracted; // integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,Performance,load,load,47,"// Copy any metadata that is valid for the new load. This may require; // conversion to a different kind of metadata, e.g. !nonnull might change; // to !range or vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:25,Performance,load,load,25,// If this is an integer load past the end of the slice (which means the; // bytes outside the slice are undef or this load is dead) just forcibly; // fix the integer size with correct handling of endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:119,Performance,load,load,119,// If this is an integer load past the end of the slice (which means the; // bytes outside the slice are undef or this load is dead) just forcibly; // fix the integer size with correct handling of endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Performance,load,load,42,// Move the insertion point just past the load so that we can refer to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:114,Integrability,rout,routine,114,"/// Compute an integer value from splatting an i8 across the given; /// number of bytes.; ///; /// Note that this routine assumes an i8 is a byte. If that isn't true, don't; /// call this routine.; /// FIXME: Heed the advice above.; ///; /// \param V The i8 value to splat.; /// \param Size The number of bytes in the output (assuming i8 is one byte)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:188,Integrability,rout,routine,188,"/// Compute an integer value from splatting an i8 across the given; /// number of bytes.; ///; /// Note that this routine assumes an i8 is a byte. If that isn't true, don't; /// call this routine.; /// FIXME: Heed the advice above.; ///; /// \param V The i8 value to splat.; /// \param Size The number of bytes in the output (assuming i8 is one byte)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:23,Modifiability,variab,variable,23,"// If the memset has a variable size, it cannot be split, just adjust the; // pointer to the new alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:173,Modifiability,variab,variable,173,"// In theory we should call migrateDebugInfo here. However, we do not; // emit dbg.assign intrinsics for mem intrinsics storing through non-; // constant geps, or storing a variable number of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:33,Usability,simpl,simple,33,"// If we can represent this as a simple value, we have to build the actual; // value to store, which requires expanding the byte present in memset to; // a sensible representation for the alloca type. This is essentially; // splatting the byte to a sufficiently wide integer, splatting it across; // any desired vector width, and bitcasting to the final type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:440,Deployability,update,update,440,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:297,Modifiability,variab,variable,297,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:113,Performance,optimiz,optimization,113,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Usability,simpl,simply,30,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:380,Usability,simpl,simply,380,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Deployability,Update,Update,3,// Update the address component of linked dbg.assigns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:295,Availability,down,downsides,295,"// For split transfer intrinsics we have an incredibly useful assurance:; // the source and destination do not reside within the same alloca, and at; // least one of them does not escape. This means that we can replace; // memmove with memcpy, and we don't need to worry about all manner of; // downsides to splitting and transforming the operations.; // If this doesn't map cleanly onto the alloca type, and that type isn't; // a single value type, just emit a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the size as needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:83,Usability,simpl,simple,83,"// Compute the other pointer, folding as much as possible to produce; // a single, simple GEP in most cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:115,Performance,load,load,115,"// This algorithm implements the same visitor loop as; // hasUnsafePHIOrSelectUse, and fixes the alignment of each load; // or store found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:28,Performance,load,loads,28,// Fix the alignment of any loads or stores using this PHI node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:113,Modifiability,rewrite,rewriter,113,"// PHIs can't be promoted on their own, but often can be speculated. We; // check the speculation outside of the rewriter so that we see the; // fully-rewritten alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:28,Performance,load,loads,28,// Fix the alignment of any loads or stores using this select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:116,Modifiability,rewrite,rewriter,116,"// Selects can't be promoted on their own, but often can be speculated. We; // check the speculation outside of the rewriter so that we see the; // fully-rewritten alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Modifiability,rewrite,rewrite,15,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:94,Modifiability,rewrite,rewrites,94,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:33,Performance,load,loads,33,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:117,Performance,load,loads,117,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:235,Performance,load,loads,235,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Modifiability,rewrite,rewrite,53,/// Queue of pointer uses to analyze and potentially rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Performance,Queue,Queue,4,/// Queue of pointer uses to analyze and potentially rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite loads and stores through a pointer and all pointers derived from; /// it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Performance,load,loads,12,/// Rewrite loads and stores through a pointer and all pointers derived from; /// it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Modifiability,rewrite,rewrite,34,// Conservative default is to not rewrite anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:37,Integrability,rout,routine,37,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:300,Integrability,rout,routine,300,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:607,Integrability,depend,depending,607,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:104,Performance,load,load,104,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:653,Performance,load,load,653,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:286,Testability,log,logic,286,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,Performance,load,load,16,/// Emit a leaf load of a single value. This is called at the leaves of the; /// recursive emission to actually load values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:112,Performance,load,load,112,/// Emit a leaf load of a single value. This is called at the leaves of the; /// recursive emission to actually load values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Performance,Load,Load,3,// Load the single value and insert it using the indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Performance,load,loaded,30,"// We have an aggregate being loaded, split it apart.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:240,Energy Efficiency,allocate,allocated,240,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Integrability,wrap,wrapping,53,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:108,Integrability,wrap,wrapping,108,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:164,Modifiability,layers,layers,164,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:389,Integrability,rout,routine,389,"/// Try to find a partition of the aggregate type passed in for a given; /// offset and size.; ///; /// This recurses through the aggregate type and tries to compute a subtype; /// based on the offset and size. When the offset and size span a sub-section; /// of an array, it will even compute a new array type for that sub-section,; /// and the same for structs.; ///; /// Note that this routine is very strict and tries to find a partition of the; /// type which produces the *exact* right offset and size. It is not forgiving; /// when the size or offset cause either end of type-based partition to be off.; /// Also, this is a best-effort routine. It is reasonable to give up and not; /// return a type if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:643,Integrability,rout,routine,643,"/// Try to find a partition of the aggregate type passed in for a given; /// offset and size.; ///; /// This recurses through the aggregate type and tries to compute a subtype; /// based on the offset and size. When the offset and size span a sub-section; /// of an array, it will even compute a new array type for that sub-section,; /// and the same for structs.; ///; /// Note that this routine is very strict and tries to find a partition of the; /// type which produces the *exact* right offset and size. It is not forgiving; /// when the size or offset cause either end of type-based partition to be off.; /// Also, this is a best-effort routine. It is reasonable to give up and not; /// return a type if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:70,Energy Efficiency,power,power-of-two,70,// FIXME: This isn't right for vectors with non-byte-sized or; // non-power-of-two sized elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:180,Availability,down,down,180,"// Within a single element and its padding.; // Don't try to form ""natural"" types if the elements don't line up with the; // expected size.; // FIXME: We could potentially recurse down through the last element in the; // sub-struct to find a natural end point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:920,Availability,recover,recover,920,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Performance,load,loads,14,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:99,Performance,load,load,99,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:335,Performance,load,loads,335,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:692,Performance,load,load,692,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:752,Performance,load,load,752,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:785,Performance,load,load,785,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:920,Safety,recover,recover,920,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:227,Security,access,accesses,227,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Usability,simpl,simplify,34,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:13,Performance,load,loads,13,"// Track the loads and stores which are candidates for pre-splitting here, in; // the order they first appear during the partition scan. These give stable; // iteration order and a basis for tracking which loads and stores we; // actually split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:206,Performance,load,loads,206,"// Track the loads and stores which are candidates for pre-splitting here, in; // the order they first appear during the partition scan. These give stable; // iteration order and a basis for tracking which loads and stores we; // actually split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Performance,load,load,53,// We need to accumulate the splits required of each load or store where we; // can find them via a direct lookup. This is important to cross-check loads; // and stores against each other. We also track the slice so that we can kill; // all the slices that end up split.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:148,Performance,load,loads,148,// We need to accumulate the splits required of each load or store where we; // can find them via a direct lookup. This is important to cross-check loads; // and stores against each other. We also track the slice so that we can kill; // all the slices that end up split.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:9,Performance,load,loads,9,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:144,Performance,load,loads,144,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:258,Performance,load,load,258,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:676,Performance,load,load,676,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,Performance,load,load,16,// If this is a load we have to track that it can't participate in any; // pre-splitting. If this is a store of a load we have to track that; // that load also can't participate in any pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:114,Performance,load,load,114,// If this is a load we have to track that it can't participate in any; // pre-splitting. If this is a store of a load we have to track that; // that load also can't participate in any pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:150,Performance,load,load,150,// If this is a load we have to track that it can't participate in any; // pre-splitting. If this is a store of a load we have to track that; // that load also can't participate in any pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,Performance,load,load,7,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:155,Safety,avoid,avoid,155,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:145,Usability,simpl,simple,145,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Performance,load,loads,21,"// We may have split loads where some of their stores are split stores. For; // such loads and stores, we can only pre-split them if their splits exactly; // match relative to their starting offset. We have to verify this prior to; // any rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:85,Performance,load,loads,85,"// We may have split loads where some of their stores are split stores. For; // such loads and stores, we can only pre-split them if their splits exactly; // match relative to their starting offset. We have to verify this prior to; // any rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Performance,load,load,14,// Lookup the load we are storing in our map of split; // offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:13,Performance,load,loads,13,// Unrelated loads are definitely safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Safety,safe,safe,34,// Unrelated loads are definitely safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:48,Performance,load,load,48,"// If the relative offsets of each split in the load and; // store match exactly, then we can split them and we; // don't need to remove them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:27,Performance,load,load,27,// We've found a store and load that we need to split; // with mismatched relative splits. Just give up on them; // and remove both instructions from our list of; // candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:113,Performance,load,load,113,"// Now we have to go *back* through all the stores, because a later store may; // have caused an earlier store's load to become unsplittable and if it is; // unsplittable for the later store, then we can't rely on it being split in; // the earlier store either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Performance,load,loads,34,"// Once we've established all the loads that can't be split for some reason,; // filter any that made it into our list out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:9,Performance,load,loads,9,"// If no loads or stores are left, there is no pre-splitting to be done for; // this alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Security,access,accesses,56,"// From here on, we can't fail and will be building new accesses, so rig up; // an IR builder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,loads,41,// Track any allocas we end up splitting loads and stores for so we iterate; // on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:286,Modifiability,rewrite,rewrite,286,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,Performance,load,loads,47,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:215,Performance,load,loads,215,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:311,Performance,load,loads,311,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:353,Performance,load,load,353,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:80,Modifiability,rewrite,rewrite,80,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Performance,load,load,15,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Performance,load,loads,43,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:88,Modifiability,rewrite,rewrite,88,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Performance,load,loads,30,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:79,Performance,load,load,79,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:136,Performance,load,loads,136,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:18,Performance,load,loads,18,// Save the split loads if there are deferred stores among the users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Performance,load,load,21,// Mark the original load as dead and kill the original slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Modifiability,rewrite,rewrite,14,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:83,Performance,load,loads,83,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:154,Performance,load,loads,154,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:206,Performance,load,loads,206,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:237,Performance,load,loads,237,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:259,Performance,load,loads,259,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:168,Usability,simpl,simply,168,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Performance,load,load,42,// Check whether we have an already split load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:25,Performance,load,load,25,// Either lookup a split load or create one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:80,Performance,load,load,80,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:123,Performance,load,load,123,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:184,Performance,load,loads,184,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:263,Performance,load,loads,263,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:302,Availability,redundant,redundant,302,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:118,Performance,load,load,118,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:218,Performance,load,load,218,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:273,Performance,load,load,273,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:312,Performance,load,loads,312,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:365,Performance,optimiz,optimizer,365,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:490,Performance,load,loads,490,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:302,Safety,redund,redundant,302,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Integrability,rout,routine,56,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:134,Modifiability,rewrite,rewrite,134,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:363,Modifiability,rewrite,rewrite,363,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:502,Modifiability,rewrite,rewrite,502,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:566,Performance,queue,queues,566,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:62,Energy Efficiency,allocate,allocated,62,"// If not, can we find an appropriate subtype in the original allocated type?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Modifiability,rewrite,rewrite,43,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:217,Modifiability,rewrite,rewriter,217,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:233,Performance,perform,perform,233,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:129,Security,access,access,129,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:362,Security,access,access,362,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:157,Energy Efficiency,schedul,scheduled,157,// Track the high watermark on the worklist as it is only relevant for; // promoted allocas. We will reset it to this point if the alloca is not in; // fact scheduled for promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:90,Performance,queue,queue,90,"// If we have either PHIs or Selects to speculate, add them to those; // worklists and re-queue the new alloca so that we promote in on the; // next iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,Security,expose,exposed,82,"// If we can't promote the alloca, iterate on it to check for new; // refinements exposed by splitting the current alloca. Don't iterate on an; // alloca which didn't actually change and didn't get promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:26,Performance,load,loads,26,// First try to pre-split loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:73,Performance,load,loads,73,"// Now that we have identified any pre-splitting opportunities,; // mark loads and stores unsplittable except for the following case.; // We leave a slice splittable if all other slices are disjoint or fully; // included in the slice, such as whole-alloca loads and stores.; // If we fail to split these during pre-splitting, we want to force them; // to be rewritten into a partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:256,Performance,load,loads,256,"// Now that we have identified any pre-splitting opportunities,; // mark loads and stores unsplittable except for the following case.; // We leave a slice splittable if all other slices are disjoint or fully; // included in the slice, such as whole-alloca loads and stores.; // If we fail to split these during pre-splitting, we want to force them; // to be rewritten into a partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,load,41,"// If a byte boundary is included in any load or store, a slice starting or; // ending at the boundary is not splittable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,loads,41,// We only allow whole-alloca splittable loads and stores; // for a large alloca to avoid creating too large BitVector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:84,Safety,avoid,avoid,84,// We only allow whole-alloca splittable loads and stores; // for a large alloca to avoid creating too large BitVector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Modifiability,rewrite,rewritePartition,40,/// Describes the allocas introduced by rewritePartition in order to migrate; /// the debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:37,Modifiability,variab,variable,37,// The alloca may be larger than the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:63,Modifiability,variab,variable,63,// Avoid creating a fragment expression that covers the entire variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating a fragment expression that covers the entire variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:71,Modifiability,variab,variable,71,// Remove any existing intrinsics on the new alloca describing; // the variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:24,Performance,load,loads,24,"// First, split any FCA loads and stores touching this alloca to promote; // better splitting and promotion opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Availability,avail,available,40,"/// Promote the allocas, using the best available technique.; ///; /// This attempts to promote whatever allocas have been identified as viable in; /// the PromotableAllocas list. If that list is empty, there is nothing to do.; /// This function returns whether any promotion occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:51,Integrability,wrap,wraps,51,/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:511,Energy Efficiency,reduce,reduce,511,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1066,Modifiability,variab,variable,1066,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1191,Modifiability,rewrite,rewrite,1191,"e https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the archite",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1933,Modifiability,rewrite,rewrite,1933,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:775,Performance,optimiz,optimizations,775,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:796,Performance,perform,perform,796,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1745,Performance,optimiz,optimized,1745,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:2382,Performance,perform,perform,2382,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:533,Safety,redund,redundancy,533,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:715,Testability,log,logic,715,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:621,Usability,simpl,simplifying,621,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:702,Usability,simpl,simplify,702,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1211,Usability,simpl,simpler,1211,"e https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the archite",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:156,Modifiability,extend,extended,156,"// Note that Index and Stride of a GEP candidate do not necessarily have the; // same integer type. In that case, during rewriting, Stride will be; // sign-extended or truncated to Index's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:194,Integrability,depend,depending,194,"// The instruction this candidate corresponds to. It helps us to rewrite a; // candidate with respect to its immediate basis. Note that one instruction; // can correspond to multiple candidates depending on how you associate the; // expression. For instance,; //; // (a + 1) * (b + 2); //; // can be treated as; //; // <Base: a, Index: 1, Stride: b + 2>; //; // or; //; // <Base: b, Index: 2, Stride: a + 1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:65,Modifiability,rewrite,rewrite,65,"// The instruction this candidate corresponds to. It helps us to rewrite a; // candidate with respect to its immediate basis. Note that one instruction; // can correspond to multiple candidates depending on how you associate the; // expression. For instance,; //; // (a + 1) * (b + 2); //; // can be treated as; //; // <Base: a, Index: 1, Stride: b + 2>; //; // or; //; // <Base: b, Index: 2, Stride: a + 1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:37,Usability,simpl,simplest,37,// Returns true if C is already in a simplest form and not worth being; // rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate candidates and find bases for Add instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate candidates and find bases for Mul instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:60,Energy Efficiency,allocate,allocateCandidatesAndFindBasis,60,"// Splits LHS into Base + Index and, if succeeds, calls; // allocateCandidatesAndFindBasis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate candidates and find bases for GetElementPtr instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:74,Energy Efficiency,allocate,allocateCandidatesAndFindBasis,74,// A helper function that scales Idx with ElementSize before invoking; // allocateCandidatesAndFindBasis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Modifiability,Rewrite,Rewrites,3,// Rewrites candidate C with respect to Basis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:106,Energy Efficiency,allocate,allocateCandidatesAndFindBasis,106,"// A helper function that factors ArrayIdx to a product of a stride and a; // constant index, and invokes allocateCandidatesAndFindBasis with the; // factorings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:81,Modifiability,rewrite,rewriteCandidateWithBasis,81,// Temporarily holds all instructions that are unlinked (but not deleted) by; // rewriteCandidateWithBasis. These instructions will be actually removed; // after all rewriting finishes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:37,Modifiability,rewrite,rewrite,37,// Basis must dominate C in order to rewrite C with respect to Basis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:475,Availability,down,down,475,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:346,Security,hash,hash,346,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:491,Security,hash,hash-table,491,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:196,Usability,simpl,simplest,196,"// SLSR can complicate an instruction in two cases:; //; // 1. If we can fold I into an addressing mode, computing I is likely free or; // takes only one instruction.; //; // 2. I is already in a simplest form. For example, when; // X = B + 8 * S; // Y = B + S,; // rewriting Y to X - 7 * S is probably a bad idea.; //; // In the above cases, we still add I to the candidate list so that I can be; // the basis of other candidates, but we leave I's basis blank so that I; // won't be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:28,Safety,avoid,avoid,28,// Limit the scan radius to avoid running in quadratice time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:48,Modifiability,extend,extend,48,// Try matching (B + i) * S.; // TODO: we could extend SLSR to float and vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:164,Safety,safe,safe,164,// I = B + sext(Idx *nsw S) * ElementSize; // = B + (sext(Idx) * sext(S)) * ElementSize; // = B + (sext(Idx) * ElementSize) * sext(S); // Casting to IntegerType is safe because we skipped vector GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:21,Safety,unsafe,unsafe,21,// SLSR is currently unsafe if i * S may overflow.; // GEP = Base + sext(LHS *nsw RHS) * ElementSize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:159,Modifiability,extend,extended,159,"// When ArrayIdx is the sext of a value, we try to factor that value as; // well. Handling this case is important because array indices are; // typically sign-extended to the pointer index size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:20,Energy Efficiency,power,power,20,"// If (i' - i) is a power of 2, Bump = sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:56,Testability,log,log,56,"// If (i' - i) is a power of 2, Bump = sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:20,Energy Efficiency,power,power,20,"// If (i - i') is a power of 2, Bump = -sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:57,Testability,log,log,57,"// If (i - i') is a power of 2, Bump = -sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:10,Modifiability,rewrite,rewriteCandidateWithBasis,10,"// We run rewriteCandidateWithBasis on all candidates in a post-order, so the; // basis of a candidate cannot be unlinked before the candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:122,Modifiability,rewrite,rewrite,122,"// An instruction can correspond to multiple candidates. Therefore, instead of; // simply deleting an instruction when we rewrite it, we mark its parent as; // nullptr (i.e. unlink it) so that we can skip the candidates whose; // instruction is already rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:83,Usability,simpl,simply,83,"// An instruction can correspond to multiple candidates. Therefore, instead of; // simply deleting an instruction when we rewrite it, we mark its parent as; // nullptr (i.e. unlink it) so that we can skip the candidates whose; // instruction is already rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:48,Energy Efficiency,Reduce,Reduced,48,"// It's tempting to preserve nsw on Bump and/or Reduced. However, it's; // usually unsound, e.g.,; //; // X = (-2 +nsw 1) *nsw INT_MAX; // Y = (-2 +nsw 3) *nsw INT_MAX; // =>; // Y = X + 2 * INT_MAX; //; // Neither + and * in the resultant expression are nsw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite candidates in the reverse depth-first order. This order makes sure; // a candidate being rewritten is not a basis for any other candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:8,Integrability,wrap,wraps,8,"// This wraps a set of Nodes into the iterator, so we know which edges to; // filter out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:44,Performance,perform,performing,44,"/// Build up the general order of nodes, by performing a topological sort of the; /// parent region's nodes, while ensuring that there is no outer cycle node; /// between any two inner cycle nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:38,Energy Efficiency,reduce,reduced,38,"// An SCC up to the size of 2, can be reduced to an entry (the last node),; // and a possible additional node. Therefore, it is already in order, and; // there is no need to add it to the work-list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Deployability,Update,Update,3,// Update the entry node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Testability,Test,Test,3,// Test for exit as back edge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Testability,Test,Test,3,// Test for successors as back edge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:4,Usability,Simpl,Simplify,4,/// Simplify any inverted conditions that were built by buildConditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:143,Availability,avail,available,143,"/// When we are reconstructing a PHI inside \p PHIBlock with incoming values; /// from predecessors \p Incomings, we have a chance to mark the available value; /// from some blocks as undefined. The function will find out all such blocks; /// and return in \p UndefBlks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:704,Safety,safe,safely,704,"// We may get a post-structured CFG like below:; //; // | P1; // |/; // F1; // |\; // | N; // |/; // F2; // |\; // | P2; // |/; // F3; // |\; // B; //; // B is the block that has a PHI being reconstructed. P1/P2 are predecessors; // of B before structurization. F1/F2/F3 are flow blocks inserted during; // structurization process. Block N is not a predecessor of B before; // structurization, but are placed between the predecessors(P1/P2) of B after; // structurization. This usually means that threads went to N never take the; // path N->F2->F3->B. For example, the threads take the branch F1->N may; // always take the branch F2->P2. So, when we are reconstructing a PHI; // originally in B, we can safely say the incoming value from N is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:153,Availability,avail,available,153,"// If this undef block is dominated by any predecessor(before; // structurization) of reconstructed PHI with constant incoming value,; // don't mark the available value as undefined. Setting undef to such; // block will stop us from getting optimal phi insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:37,Modifiability,extend,extend,37,"// Setting CanUseUndef to true might extend value liveness, set it to false; // to achieve better register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Deployability,Update,Update,3,// Update the region info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:31,Deployability,update,update,31,/// Create a new flow node and update dominator tree and region info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:19,Modifiability,variab,variable,19,// use a temporary variable to avoid a use-after-free if the map's storage is; // reallocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:31,Safety,avoid,avoid,31,// use a temporary variable to avoid a use-after-free if the map's storage is; // reallocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:11,Safety,predict,predict,11,/// Can we predict that this node will always be called?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1098,Energy Efficiency,efficient,efficient,1098,"//===- TailRecursionElimination.cpp - Eliminate Tail Calls ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry bloc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1012,Modifiability,variab,variable,1012,"//===- TailRecursionElimination.cpp - Eliminate Tail Calls ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry bloc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1128,Performance,perform,performed,1128,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2136,Performance,perform,performed,2136,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2664,Performance,perform,performed,2664,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1957,Safety,Safe,Safely,1957,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2578,Safety,safe,safe,2578,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2767,Safety,detect,detect,2767,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1574,Security,access,access,1574,"c; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2785,Security,access,access,2785,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2725,Testability,benchmark,benchmark,2725,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:74,Energy Efficiency,allocate,allocate,74,// TODO: We don't do TRE if dynamic allocas are used.; // Dynamic allocas allocate stack space which should be; // deallocated before new iteration started. That is; // currently not implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:19,Performance,load,load,19,"// The result of a load is not alloca-derived (unless an alloca has; // otherwise escaped, but this is a local analysis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:84,Security,access,accessing,84,// A PseudoProbeInst has the IntrInaccessibleMemOnly tag hence it is; // considered accessing memory and will be marked as a tail call if we; // don't bail out here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:202,Performance,load,load,202,"// A call to a readnone function whose arguments are all things computed; // outside this function can be marked tail. Even if you stored the; // alloca address into a global, a readnone function can't load the; // global anyhow.; //; // Note that this runs whether we know an alloca has escaped or not. If; // it has, then we can't trust Tracker.AllocaUsers to be accurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,Safety,safe,safe,25,"/// Return true if it is safe to move the specified; /// instruction from after the call to before the call, assuming that all; /// instructions between the call and this instruction are movable.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:22,Performance,load,load,22,// FIXME: We can move load/store/call/free instructions above the call if the; // call does not mod/ref the memory location being processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:30,Performance,load,loads,30,// This also handles volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:3,Performance,Load,Loads,3,// Loads may always be moved above calls without side effects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:16,Performance,load,loads,16,// Non-volatile loads may be moved above a call with side effects if it; // does not write to memory and the load provably won't trap.; // Writes to memory only matter if they may alias the pointer; // being loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:109,Performance,load,load,109,// Non-volatile loads may be moved above a call with side effects if it; // does not write to memory and the load provably won't trap.; // Writes to memory only matter if they may alias the pointer; // being loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:208,Performance,load,loaded,208,// Non-volatile loads may be moved above a call with side effects if it; // does not write to memory and the load provably won't trap.; // Writes to memory only matter if they may alias the pointer; // being loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:46,Availability,avail,available,46,// The below are shared state we want to have available when eliminating any; // calls in the function. There values should be populated by; // createTailRecurseLoopHeader the first time we find a call we can eliminate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:42,Performance,perform,performing,42,// The below are shared state needed when performing accumulator recursion.; // There values should be populated by insertAccumulator the first time we; // find an elimination that requires an accumulator.; // PHI node to store our current accumulated value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:22,Safety,detect,detect,22,"// As a special case, detect code like this:; // double fabs(double f) { return __builtin_fabs(f); } // a 'fabs' call; // and disable this xform in this case, because the code generator will; // lower the call to fabs into inline code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:122,Modifiability,variab,variable,122,// Creates a copy of contents of ByValue operand of the specified; // call instruction into the newly created temporarily variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:55,Modifiability,variab,variable,55,// Copy data from byvalue operand into the temporarily variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:35,Modifiability,variab,variable,35,// Creates a copy from temporarily variable(keeping value of ByVal argument); // into the corresponding function argument location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:34,Modifiability,variab,variable,34,// Copy data from the temporarily variable into corresponding; // function argument location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:56,Modifiability,variab,variables,56,// Copy values of ByVal operands into local temporarily variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:168,Safety,safe,safe,168,"// When eliminating a tail call, we modify the values of the arguments.; // Therefore, if the byval parameter has a readonly attribute, we have to; // remove it. It is safe because, from the perspective of a caller, the; // byval parameter is always treated as ""readonly,"" even if the readonly; // attribute is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the accumulator recursion instruction so that it does not use; // the result of the call anymore, instead, use the PHI node we just; // inserted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:3,Deployability,Update,Update,3,// Update our return value tracking,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:322,Safety,safe,safe,322,"// If all predecessors of Succ have been eliminated by; // FoldReturnIntoUncondBranch, delete it. It is important to empty it,; // because the ret instruction in there is still using a value which; // eliminateCall will attempt to remove. This block can only contain; // instructions that can't have uses, therefore it is safe to remove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:80,Deployability,Update,UpdateStrategy,80,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:156,Deployability,Update,UpdateStrategy,156,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,Performance,perform,performance,25,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:109,Testability,test,test,109,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:10,Integrability,interface,interface,10,// Public interface to the TailCallElimination pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:80,Deployability,Update,UpdateStrategy,80,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:156,Deployability,Update,UpdateStrategy,156,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,Performance,perform,performance,25,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:109,Testability,test,test,109,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:44,Availability,Redundant,Redundant,44,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:412,Availability,Redundant,Redundant,412,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:58,Performance,Load,Loads,58,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:426,Performance,Load,Loads,426,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:44,Safety,Redund,Redundant,44,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:412,Safety,Redund,Redundant,412,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:12,Modifiability,Variab,Variable,12,/// The TLS Variable hoist pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:20,Modifiability,Variab,Variable,20,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:4,Performance,Perform,Perform,4,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:35,Performance,optimiz,optimization,35,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:40,Modifiability,Variab,Variable,40,"// First, quickly check if there is TLS Variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:21,Modifiability,Variab,Variable,21,"// Then, collect TLS Variable info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:27,Modifiability,variab,variables,27,/// Optimize expensive TLS variables in the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize expensive TLS variables in the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:19,Modifiability,variab,variable,19,// Collect all TLS variable candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:441,Performance,perform,performed,441,"//===- LoopTransformWarning.cpp - ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Emit warnings if forced code transformations have not been performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:101,Performance,perform,performed,101,/// Emit warnings for forced (i.e. user-defined) loop transformations which have; /// still not been performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:52,Performance,optimiz,optimizations,52,// Do not warn about not applied transformations if optimizations are; // disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:1115,Performance,load,load,1115,"ache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd.org/index.php?title=Path_Discriminators; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:908,Safety,abort,abort,908,"//===- AddDiscriminators.cpp - Insert DWARF path discriminators -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:1299,Safety,abort,abort,1299,"ache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd.org/index.php?title=Path_Discriminators; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:876,Testability,ASSERT,ASSERT,876,"//===- AddDiscriminators.cpp - Insert DWARF path discriminators -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:955,Testability,ASSERT,ASSERT,955,"//===- AddDiscriminators.cpp - Insert DWARF path discriminators -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:508,Performance,load,load,508,"/// Assign DWARF discriminators.; ///; /// To assign discriminators, we examine the boundaries of every; /// basic block and its successors. Suppose there is a basic block B1; /// with successor B2. The last instruction I1 in B1 and the first; /// instruction I2 in B2 are located at the same file and line number.; /// This situation is illustrated in the following code snippet:; ///; /// if (i < 10) x = i;; ///; /// entry:; /// br i1 %cmp, label %if.then, label %if.end, !dbg !10; /// if.then:; /// %1 = load i32* %i.addr, align 4, !dbg !10; /// store i32 %1, i32* %x, align 4, !dbg !10; /// br label %if.end, !dbg !10; /// if.end:; /// ret void, !dbg !12; ///; /// Notice how the branch instruction in block 'entry' and all the; /// instructions in block 'if.then' have the exact same debug location; /// information (!dbg !10).; ///; /// To distinguish instructions in block 'entry' from instructions in; /// block 'if.then', we generate a new lexical block for all the; /// instruction in block 'if.then' that share the same file and line; /// location with the last instruction of block 'entry'.; ///; /// This new lexical block will have the same location information as; /// the previous one, but with a new DWARF discriminator value.; ///; /// One of the main uses of this discriminator value is in runtime; /// sample profilers. It allows the profiler to distinguish instructions; /// at location !dbg !10 that execute on different basic blocks. This is; /// important because while the predicate 'if (x < 10)' may have been; /// executed millions of times, the assignment 'x = i' may have only; /// executed a handful of times (meaning that the entry->if.then edge is; /// seldom taken).; ///; /// If we did not have discriminator information, the profiler would; /// assign the same weight to both blocks 'entry' and 'if.then', which; /// in turn will make it conclude that the entry->if.then edge is very; /// hot.; ///; /// To decide where to create new discriminator values, this func",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:279,Performance,load,loads,279,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:314,Performance,load,load,314,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:71,Safety,avoid,avoid,71,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:78,Safety,avoid,avoid,78,// We bypass intrinsic calls for the following two reasons:; // 1) We want to avoid a non-deterministic assignment of; // discriminators.; // 2) We want to minimize the number of base discriminators used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:67,Energy Efficiency,allocate,allocates,67,"// Calculates frame size required for current printf expansion and allocates; // space on printf buffer. Printf frame includes following contents; // [ ControlDWord , format string/Hash , Arguments (each aligned to 8 byte) ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:181,Security,Hash,Hash,181,"// Calculates frame size required for current printf expansion and allocates; // space on printf buffer. Printf frame includes following contents; // [ ControlDWord , format string/Hash , Arguments (each aligned to 8 byte) ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:24,Security,hash,hash,24,// First 8 bytes of MD5 hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:225,Safety,safe,safe,225,"// This copies the contents of the string, however the next offset; // is at aligned length, the extra space that might be created due; // to alignment padding is not populated with any specific value; // here. This would be safe as long as runtime is sync with; // the offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:115,Availability,failure,failure,115,"// The buffered version still follows OpenCL printf standards for; // printf return value, i.e 0 on success, -1 on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:14,Security,hash,hash,14,"// Create MD5 hash for costant format string, push low 64 bits of the; // same onto buffer and metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:28,Availability,failure,failure,28,"// End block, returns -1 on failure",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:21,Modifiability,variab,variables,21,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:149,Modifiability,variab,variables,149,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:182,Modifiability,variab,variables,182,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:318,Modifiability,variab,variables,318,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:430,Modifiability,variab,variables,430,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:443,Safety,avoid,avoid,443,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:45,Modifiability,variab,variable,45,// We want to add a full redzone after every variable.; // The larger the variable Size the larger is the redzone.; // The resulting frame size is a multiple of Alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:74,Modifiability,variab,variable,74,// We want to add a full redzone after every variable.; // The larger the variable Size the larger is the redzone.; // The resulting frame size is a multiple of Alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:16,Testability,assert,asserts,16,// Used only in asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AssumeBundleBuilder.cpp:123,Deployability,update,update,123,/// Remove knowledge stored in assume when it is already know by an attribute; /// or an other assume. This can when valid update an existing knowledge in an; /// attribute or an other assume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AssumeBundleBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AssumeBundleBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:408,Performance,perform,perform,408,"//===- BasicBlockUtils.cpp - BasicBlock Utilities --------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on basic blocks, and; // instructions contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:10,Deployability,update,updates,10,// Memdep updates AA itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:75,Deployability,Update,Update,75,"// Currently only allow PredBB to have two predecessors, one being BB.; // Update BI to branch to BB's only successor instead of BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:7,Deployability,update,update,7,// DTU update: Collect all the edges that exit BB.; // These dominator edges will be redirected from Pred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:6,Safety,avoid,avoid,6,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:206,Deployability,update,updates,206,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:353,Deployability,update,updates,353,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:431,Energy Efficiency,reduce,reduce,431,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update branch in the predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:30,Security,access,accessing,30,// Terminator may be a memory accessing instruction too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit predecessors name if it exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:36,Deployability,update,update,36,"// Finally, erase the old block and update dominator info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:184,Modifiability,variab,variable,184,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:673,Modifiability,variab,variable,673,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Safety,redund,redundant,11,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:15,Modifiability,variab,variable,15,// If the same variable fragment is described more than once it is enough; // to keep the last one (i.e. the first found since we for reverse; // iteration).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Availability,redundant,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Safety,redund,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:53,Usability,Clear,Clear,53,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:10,Modifiability,variab,variable,10,// If the variable fragment hasn't been seen before then we don't want; // to remove this dbg intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:15,Modifiability,variab,variable,15,// If the same variable fragment is described more than once it is enough; // to keep the last one (i.e. the first found since we for reverse; // iteration).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Availability,redundant,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Safety,redund,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:53,Usability,Clear,Clear,53,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:119,Availability,redundant,redundant,119,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:159,Modifiability,variab,variable,159,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:425,Modifiability,variab,variable,425,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:659,Modifiability,Variab,Variable,659,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Safety,redund,redundant,11,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:119,Safety,redund,redundant,119,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:72,Modifiability,variab,variable,72,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:92,Modifiability,variab,variable,92,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:72,Modifiability,variab,variable,72,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:92,Modifiability,variab,variable,92,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:271,Modifiability,variab,variable,271,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:430,Modifiability,variab,variable,430,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Safety,redund,redundant,11,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:30,Safety,avoid,avoid,30,// Remember visited blocks to avoid infinite loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:95,Testability,log,logic,95,"// If it is a critical edge, and the succesor is an exception block, handle; // the split edge logic in this specific function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:15,Deployability,update,update,15,"// We manually update the LandingPadReplacement PHINode and it is the last; // PHI Node. So, if we find it, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:66,Usability,simpl,simplify,66,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:199,Usability,simpl,simplify,199,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:51,Usability,simpl,simplify,51,"// Loop is not in LoopSimplify form, no need to re simplify after; // splitting edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:8,Usability,simpl,simplify,8,"// Loop-simplify form can be preserved, if we can split all in-loop; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:114,Deployability,update,updated,114,"// If one or the other blocks were not in a loop, the new block is not; // either, and thus LI doesn't need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:75,Deployability,update,update,75,"// If BB is in a loop and Succ is outside of that loop, we may need to; // update LoopSimplify form and LCSSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update LCSSA form in the newly created exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the original PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:70,Deployability,Update,Update,70,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:77,Security,access,accesses,77,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:70,Deployability,Update,Update,70,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:77,Security,access,accesses,77,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:4,Deployability,Update,Update,4,"/// Update DominatorTree, LoopInfo, and LCCSA analysis information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:28,Availability,avail,available,28,// Update dominator tree if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update dominator tree if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:56,Integrability,interface,interface,56,// The entry block was removed and there is no external interface for; // the dominator tree to be notified of this change. In this corner-case; // we recalculate the entire tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:49,Availability,avail,available,49,// Update MemoryPhis after split if MemorySSA is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update MemoryPhis after split if MemorySSA is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:19,Testability,log,logic,19,// The rest of the logic is only relevant for updating the loop structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:65,Safety,avoid,avoid,65,// Seek a loop which actually contains the block being split (to avoid; // adjacent loops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:117,Availability,avail,available,117,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:4,Deployability,Update,Update,4,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:91,Deployability,update,updates,91,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:185,Deployability,update,updated,185,// This is slightly more strict than necessary; the minimum requirement; // is that there be no more than one indirectbr branching to BB. And; // all BlockAddress uses would need to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update DominatorTree, LoopInfo, and LCCSA analysis information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHI nodes in BB with the values coming from NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:185,Deployability,update,updated,185,// This is slightly more strict than necessary; the minimum requirement; // is that there be no more than one indirectbr branching to BB. And; // all BlockAddress uses would need to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHI nodes in OrigBB with the values coming from NewBB1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update DominatorTree, LoopInfo, and LCCSA analysis information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHI nodes in OrigBB with the values coming from NewBB2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the returning block to realize that we no; // longer branch to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:19,Testability,log,logic,19,// Encapsulate the logic around creation/insertion/etc of a new block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:433,Performance,perform,performed,433,"// After creating a control flow hub, the operands of PHINodes in an outgoing; // block Out no longer match the predecessors of that block. Predecessors of Out; // that are incoming blocks to the hub are now replaced by just one edge from; // the hub. To match this new control flow, the corresponding values from each; // PHINode must now be moved a new PHINode in the first guard block of the hub.; //; // This operation cannot be performed with SSAUpdater, because it involves one; // new use: If the block Out is in the list of Incoming blocks, then the newly; // created PHI in the Hub will use itself along that edge from Out to Hub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:25,Usability,simpl,simple,25,"// To help keep the loop simple, temporarily append the last; // outgoing block to the list of guard blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:140,Usability,simpl,simple,140,"/// We are using one integer to represent the block we are branching to. Then at; /// each guard block, the predicate was calcuated using a simple `icmp eq`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization: Consider an incoming block A with both successors; // Succ0 and Succ1 in the set of outgoing blocks. The predicates; // for Succ0 and Succ1 complement each other. If Succ0 is visited; // first in the loop below, control will branch to Succ0 using the; // corresponding predicate. But if that branch is not taken, then; // control must reach Succ1, which means that the incoming value of; // the predicate from `In` is true for Succ1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization: When only one successor is an outgoing block,; // the incoming predicate from `In` is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHINodes in each outgoing block to match the new control flow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:95,Usability,simpl,simply,95,"// If this is a ""cmp"" instruction, only used for branching (and nowhere; // else), then we can simply invert the predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:679,Deployability,update,update,679,"//===- BreakCriticalEdges.cpp - Critical Edge Elimination Pass ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BreakCriticalEdges pass - Break all of the critical edges in the CFG by; // inserting a dummy basic block. This pass may be ""required"" by passes that; // cannot deal with critical edges. For this usage, the structure type is; // forward declared. This pass obviously invalidates the CFG, but can update; // dominator trees.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:20,Integrability,interface,interface,20,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:12,Security,expose,exposed,12,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:66,Usability,simpl,simplify,66,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:199,Usability,simpl,simplify,199,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:17,Usability,simpl,simplify,17,"// No need to re-simplify, it wasn't to start with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:8,Usability,simpl,simplify,8,"// Loop-simplify form can be preserved, if we can split all in-loop; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:52,Deployability,update,update,52,"// If there are any PHI nodes in DestBB, we need to update them so that they; // merge incoming values from NewBB instead of from TIBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:53,Deployability,update,update,53,"// If there are any other edges from TIBB to DestBB, update those to go; // through the split block, making those edges non-critical as well (and; // reducing the number of phi entries in the DestBB if relevant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:25,Deployability,update,update,25,"// If we have nothing to update, just return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:3,Deployability,Update,Update,3,"// Update the DominatorTree.; // ---> NewBB -----\; // / V; // TIBB -------\\------> DestBB; //; // First, inform the DT about the new path from TIBB to DestBB via NewBB,; // then delete the old edge from TIBB to DestBB. By doing this in that order; // DestBB stays reachable in the DT the whole time and its subtree doesn't; // get disconnected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:3,Deployability,Update,Update,3,// Update LoopInfo if it is around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:114,Deployability,update,updated,114,"// If one or the other blocks were not in a loop, the new block is not; // either, and thus LI doesn't need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:79,Deployability,update,update,79,"// If TIBB is in a loop and DestBB is outside of that loop, we may need; // to update LoopSimplify form and LCSSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:3,Deployability,Update,Update,3,// Update LCSSA form in the newly created exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:105,Deployability,update,updated,105,"// If the target is a loop to itself, then the terminator of the split; // block (BodyBlock) needs to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:32,Safety,avoid,avoid,32,"// Advance the pointer here, to avoid invalidation issues when the old; // PHI is erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:27,Integrability,depend,depend,27,"//; // Those functions may depend on the locale, which may be accessed through; // global memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:62,Security,access,accessed,62,"//; // Those functions may depend on the locale, which may be accessed through; // global memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:88,Availability,reliab,reliably,88,// We have to do this step after AllocKind has been inferred on functions so; // we can reliably identify free-like and realloc-like functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:282,Performance,optimiz,optimizer,282,// Make sure any mandatory argument attributes are added.; // Any outgoing i32 argument should be handled with setArgExtAttr() which; // will add an extension attribute if the target ABI requires it. Adding; // argument extensions is typically done by the front end but when an; // optimizer is building a library call on its own it has to take care of; // this. Each such generated function must be handled here with sign or; // zero extensions as needed. F is retreived with cast<> because we demand; // of the caller to have called isLibFuncEmittable() first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:175,Testability,assert,assert,175,// These are functions that are known to not need any argument extension; // on any target: A size_t argument (which may be an i32 on some targets); // should not trigger the assert below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:405,Performance,optimiz,optimization,405,"//===- BypassSlowDivision.cpp - Bypass slow division ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an optimization for div and rem on architectures that; // execute short instructions significantly faster than longer instructions.; // For example, on Intel Atom 32-bit divides are slow enough that during; // runtime it is profitable to check the value of the operands, and if they are; // positive and less than 256 use an unsigned 8-bit divide.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:56,Testability,log,logically,56,"/// A quotient and remainder, plus a BB from which they logically ""originate"".; /// If you use Quotient or Remainder in a Phi node, you should use BB as its; /// corresponding predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:39,Performance,optimiz,optimize,39,// Skip division on vector types. Only optimize integer instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:163,Performance,perform,perform,163,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:175,Performance,optimiz,optimization,175,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:192,Performance,cache,caches,192,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:29,Performance,Cache,Cache,29,"// Then, look for a value in Cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:54,Integrability,rout,routine,54,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:77,Safety,detect,detect,77,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:453,Safety,detect,detect,453,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:34,Security,hash,hash,34,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:122,Security,hash,hash,122,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:155,Security,hash,hash,155,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:359,Security,hash,hash,359,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:467,Security,hash,hash,467,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:617,Security,hash,hash-like,617,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:140,Security,hash,hash-like,140,// Do not visit nodes that have been visited already. We return true because; // it means that we couldn't find any value that doesn't look hash-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:216,Safety,detect,detect,216,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:44,Security,hash,hashtable,44,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:123,Security,hash,hash,123,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:281,Security,hash,hashes,281,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:26,Performance,optimiz,optimization,26,// udiv/urem because this optimization only handles positive numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:31,Testability,test,test,31,/// Creates a runtime check to test whether both the divisor and dividend fit; /// into BypassType. The check is inserted at the end of MainBB. True return; /// value means that the operands fit. Either of the operands may be NULL if it; /// doesn't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:119,Usability,clear,clear,119,"// If the divisor is not a constant, DAGCombiner will convert it to a; // multiplication by a magic constant. It isn't clear if it is worth; // introducing control flow to get a narrower multiply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:508,Safety,avoid,avoid,508,"// If the division is unsigned and Dividend is known to be short, then; // either; // 1) Divisor is less or equal to Dividend, and the result can be computed; // with a short division.; // 2) Divisor is greater than Dividend. In this case, no division is needed; // at all: The quotient is 0 and the remainder is equal to Dividend.; //; // So instead of checking at runtime whether Divisor fits into BypassType,; // we emit a runtime check to differentiate between these two cases. This; // lets us entirely avoid a long div.; // Split the basic block before the div/rem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:9,Performance,optimiz,optimization,9,"/// This optimization identifies DIV/REM instructions in a BB that can be; /// profitably bypassed and carried out with a shorter, faster divide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:37,Safety,avoid,avoid,37,// Ignore dead code to save time and avoid bugs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:67,Energy Efficiency,efficient,efficiently,67,"// Above we eagerly create divs and rems, as pairs, so that we can efficiently; // create divrem machine instructions. Now erase any unused divs / rems so we; // don't leave extra instructions sitting around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:50,Deployability,update,update,50,"//===- CallGraphUpdater.cpp - A (lazy) call graph update helper -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to manipulate a call graph, regardless; /// if it is a ""old style"" CallGraph or an ""new style"" LazyCallGraph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:415,Integrability,interface,interfaces,415,"//===- CallGraphUpdater.cpp - A (lazy) call graph update helper -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to manipulate a call graph, regardless; /// if it is a ""old style"" CallGraph or an ""new style"" LazyCallGraph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:3,Deployability,Update,Update,3,// Update the call graph for the newly promoted function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:7,Deployability,update,update,7,// And update the SCC we're iterating as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:276,Integrability,depend,depends,276,"/// Cast a call or invoke instruction to the given type.; ///; /// When promoting a call site, the return type of the call site might not match; /// that of the callee. If this is the case, we have to cast the returned value; /// to the correct type. The location of the cast depends on if we have a call; /// or invoke instruction.; ///; /// For example, if the call instruction below requires a bitcast after; /// promotion:; ///; /// orig_bb:; /// %t0 = call i32 @func(); /// ...; ///; /// The bitcast is placed after the call instruction:; ///; /// orig_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t0 = call i32 @func(); /// %t1 = bitcast i32 %t0 to ...; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, a new block is created for the bitcast. For; /// example, if the invoke instruction below requires a bitcast after promotion:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %normal_dst unwind label %unwind_dst; ///; /// The edge between the original block and the invoke's normal destination is; /// split, and the bitcast is placed there:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %split_bb unwind label %unwind_dst; ///; /// split_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t1 = bitcast i32 %t0 to ...; /// br label %normal_dst; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:749,Performance,perform,performed,749,"/// Cast a call or invoke instruction to the given type.; ///; /// When promoting a call site, the return type of the call site might not match; /// that of the callee. If this is the case, we have to cast the returned value; /// to the correct type. The location of the cast depends on if we have a call; /// or invoke instruction.; ///; /// For example, if the call instruction below requires a bitcast after; /// promotion:; ///; /// orig_bb:; /// %t0 = call i32 @func(); /// ...; ///; /// The bitcast is placed after the call instruction:; ///; /// orig_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t0 = call i32 @func(); /// %t1 = bitcast i32 %t0 to ...; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, a new block is created for the bitcast. For; /// example, if the invoke instruction below requires a bitcast after promotion:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %normal_dst unwind label %unwind_dst; ///; /// The edge between the original block and the invoke's normal destination is; /// split, and the bitcast is placed there:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %split_bb unwind label %unwind_dst; ///; /// split_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t1 = bitcast i32 %t0 to ...; /// br label %normal_dst; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:98,Integrability,depend,depends,98,// Determine an appropriate location to create the bitcast for the return; // value. The location depends on if we have a call or invoke instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:1146,Performance,perform,performed,1146,"he ""if"" condition compares the call site's called value to the given; /// callee. The original call site is moved into the ""else"" block, and a clone; /// of the call site is placed in the ""then"" block. The cloned instruction is; /// returned.; ///; /// For example, the call instruction below:; ///; /// orig_bb:; /// %t0 = call i32 %ptr(); /// ...; ///; /// Is replace by the following:; ///; /// orig_bb:; /// %cond = icmp eq i32 ()* %ptr, @func; /// br i1 %cond, %then_bb, %else_bb; ///; /// then_bb:; /// ; The clone of the original call instruction is placed in the ""then""; /// ; block. It is not yet promoted.; /// %t1 = call i32 %ptr(); /// br merge_bb; ///; /// else_bb:; /// ; The original call instruction is moved to the ""else"" block.; /// %t0 = call i32 %ptr(); /// br merge_bb; ///; /// merge_bb:; /// ; Uses of the original call instruction are replaced by uses of the phi; /// ; node.; /// %t2 = phi i32 [ %t0, %else_bb ], [ %t1, %then_bb ]; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, more work is required. For example, the; /// invoke instruction below:; ///; /// orig_bb:; /// %t0 = invoke %ptr() to label %normal_dst unwind label %unwind_dst; ///; /// Is replace by the following:; ///; /// orig_bb:; /// %cond = icmp eq i32 ()* %ptr, @func; /// br i1 %cond, %then_bb, %else_bb; ///; /// then_bb:; /// ; The clone of the original invoke instruction is placed in the ""then""; /// ; block, and its normal destination is set to the ""merge"" block. It is; /// ; not yet promoted.; /// %t1 = invoke i32 %ptr() to label %merge_bb unwind label %unwind_dst; ///; /// else_bb:; /// ; The original invoke instruction is moved into the ""else"" block, and; /// ; its normal destination is set to the ""merge"" block.; /// %t0 = invoke i32 %ptr() to label %merge_bb unwind label %unwind_dst; ///; /// merge_bb:; /// ; Uses of the original invoke instruction are replaced by uses of the; /// ; phi node, and the merge ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:57,Usability,clear,clear,57,"// Since the call site will no longer be direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and !callees; // metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:22,Performance,load,load,22,// Not a vtable entry load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:16,Performance,load,load,16,// Not a vtable load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:40,Modifiability,variab,variable,40,// Not in the form of a global constant variable with an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp:1027,Performance,optimiz,optimization,1027,"//===- CanonicalizeAliases.cpp - ThinLTO Support: Canonicalize Aliases ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Currently this file implements partial alias canonicalization, to; // flatten chains of aliases (also done by GlobalOpt, but not on for; // O0 compiles). E.g.; // @a = alias i8, i8 *@b; // @b = alias i8, i8 *@g; //; // will be converted to:; // @a = alias i8, i8 *@g <-- @a is now an alias to base object @g; // @b = alias i8, i8 *@g; //; // Eventually this file will implement full alias canonicalization, so that; // all aliasees are private anonymous values. E.g.; // @a = alias i8, i8 *@g; // @g = global i8 0; //; // will be converted to:; // @0 = private global; // @a = alias i8, i8* @0; // @g = alias i8, i8* @0; //; // This simplifies optimization and ThinLTO linking of the original symbols.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp:1016,Usability,simpl,simplifies,1016,"//===- CanonicalizeAliases.cpp - ThinLTO Support: Canonicalize Aliases ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Currently this file implements partial alias canonicalization, to; // flatten chains of aliases (also done by GlobalOpt, but not on for; // O0 compiles). E.g.; // @a = alias i8, i8 *@b; // @b = alias i8, i8 *@g; //; // will be converted to:; // @a = alias i8, i8 *@g <-- @a is now an alias to base object @g; // @b = alias i8, i8 *@g; //; // Eventually this file will implement full alias canonicalization, so that; // all aliasees are private anonymous values. E.g.; // @a = alias i8, i8 *@g; // @g = global i8 0; //; // will be converted to:; // @0 = private global; // @a = alias i8, i8* @0; // @g = alias i8, i8* @0; //; // This simplifies optimization and ThinLTO linking of the original symbols.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:426,Integrability,interface,interface,426,"//===- CloneFunction.cpp - Clone a function into another function ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CloneFunctionInto interface, which is used as the; // low-level function cloner. This is used by the CloneFunction and function; // inliner to do the dirty work of copying the body of a function around.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:65,Safety,avoid,avoid,65,"// When we remap instructions within the same module, we want to avoid; // duplicating inlined DISubprograms, so record all subprograms we find as we; // duplicate instructions and then freeze them in the MD map. We also record; // information about dbg.value and dbg.declare to avoid duplicating the; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:279,Safety,avoid,avoid,279,"// When we remap instructions within the same module, we want to avoid; // duplicating inlined DISubprograms, so record all subprograms we find as we; // duplicate instructions and then freeze them in the MD map. We also record; // information about dbg.value and dbg.declare to avoid duplicating the; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:67,Performance,tune,tune,67,// Track the subprogram attachment that needs to be cloned to fine-tune the; // mapping within the same module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Safety,Avoid,Avoid,3,// Avoid clobbering an existing mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Safety,Avoid,Avoid,3,"// Avoid cloning types, compile units, and (other) subprograms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:8,Deployability,update,update,8,"// Only update !llvm.dbg.cu for DifferentModule (not CloneModule). In the; // same module, the compile unit will already be listed (or not). When; // cloning a module, CloneModule() will handle creating the named metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,"// Update !llvm.dbg.cu with compile units added to the new module if this; // function is being cloned in isolation.; //; // FIXME: This is making global / module-level changes, which doesn't seem; // like the right encapsulation Consider dropping the requirement to update; // !llvm.dbg.cu (either obsoleting the node, or restricting it to; // non-discardable compile units) instead of discovering compile units by; // visiting the metadata attached to global values, which would allow this; // code to be deleted. Alternatively, perhaps give responsibility for this; // update to CloneFunctionInto's callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:267,Deployability,update,update,267,"// Update !llvm.dbg.cu with compile units added to the new module if this; // function is being cloned in isolation.; //; // FIXME: This is making global / module-level changes, which doesn't seem; // like the right encapsulation Consider dropping the requirement to update; // !llvm.dbg.cu (either obsoleting the node, or restricting it to; // non-discardable compile units) instead of discovering compile units by; // visiting the metadata attached to global values, which would allow this; // code to be deleted. Alternatively, perhaps give responsibility for this; // update to CloneFunctionInto's callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:572,Deployability,update,update,572,"// Update !llvm.dbg.cu with compile units added to the new module if this; // function is being cloned in isolation.; //; // FIXME: This is making global / module-level changes, which doesn't seem; // like the right encapsulation Consider dropping the requirement to update; // !llvm.dbg.cu (either obsoleting the node, or restricting it to; // non-discardable compile units) instead of discovering compile units by; // visiting the metadata attached to global values, which would allow this; // code to be deleted. Alternatively, perhaps give responsibility for this; // update to CloneFunctionInto's callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiple insertions of the same DICompileUnit to NMD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:341,Deployability,update,updated,341,"/// Return a copy of the specified function and add it to that function's; /// module. Also, any references specified in the VMap are changed to refer to; /// their mapped value instead of the original one. If any of the arguments to; /// the function are in the VMap, the arguments are deleted from the resultant; /// function. The VMap is updated to include mappings from all of the; /// instructions and basicblocks in the function from their old to new values.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:481,Safety,safe,safe,481,"// It is only legal to clone a function if a block address within that; // function is never referenced outside of the function. Given that, we; // want to map block addresses from the old function to block addresses in; // the clone. (This is different from the generic ValueMapper; // implementation, which generates an invalid blockaddress when; // cloning a function.); //; // Note that we don't need to fix the mapping for unreachable blocks;; // the default mapping there is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:103,Performance,optimiz,optimizations,103,// All function calls in the inlined function must get 'strictfp'; // attribute to prevent undesirable optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:123,Deployability,update,update,123,"// Eagerly remap operands to the newly cloned instruction, except for PHI; // nodes for which we defer processing until we update the CFG. Also defer; // debug intrinsic processing because they may contain use-before-defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:13,Usability,simpl,simplify,13,"// If we can simplify this instruction to some other value, simply add; // a mapping to that value rather than inserting a new instruction into; // the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:60,Usability,simpl,simply,60,"// If we can simplify this instruction to some other value, simply add; // a mapping to that value rather than inserting a new instruction into; // the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:31,Usability,simpl,simplifies,31,"// On the off-chance that this simplifies to an instruction in the old; // function, map it back into the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:85,Deployability,update,updated,85,"// The loop above has removed PHI entries for those blocks that are dead; // and has updated others. However, if a block is live (i.e. copied over); // but its terminator has been changed to not go to this block, then our; // phi nodes will have invalid entries. Update the PHI nodes in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:263,Deployability,Update,Update,263,"// The loop above has removed PHI entries for those blocks that are dead; // and has updated others. However, if a block is live (i.e. copied over); // but its terminator has been changed to not go to this block, then our; // phi nodes will have invalid entries. Update the PHI nodes in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:213,Deployability,update,update,213,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:135,Performance,perform,performing,135,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:180,Security,expose,exposed,180,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:107,Usability,simpl,simplifying,107,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:164,Usability,simpl,simplifications,164,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:21,Testability,test,test,21,"// Note that we must test the size on each iteration, the worklist can grow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:27,Usability,simpl,simplifies,27,// See if this instruction simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:89,Usability,simpl,simplifications,89,// Stash away all the uses of the old instruction so we can check them for; // recursive simplifications after a RAUW. This is cheaper than checking all; // uses of To on the recursive step in most cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:196,Availability,avail,available,196,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Usability,Simpl,Simplify,3,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:126,Usability,simpl,simplification,126,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:77,Usability,simpl,simple,77,"/// This works exactly like CloneFunctionInto,; /// except that it does some simple constant prop and DCE on the fly. The; /// effect of this is to copy significantly less code in cases where (for; /// example) a function call with constant arguments is inlined, and those; /// constant arguments cause a significant amount of code in the callee to be; /// dead. Since this doesn't produce an exact copy of the input, it can't be; /// used for things like CloneFunction or CloneModule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the code to refer to itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:92,Deployability,Update,Updates,92,/// Clones a loop \p OrigLoop. Returns the loop and the blocks in \p; /// Blocks.; ///; /// Updates LoopInfo and DominatorTree assuming the loop is dominated by block; /// \p LoopDomBB. Insert the new blocks before block specified in \p Before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update LoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update DominatorTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update LoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:52,Deployability,update,update,52,"// Add DominatorTree node. After seeing all blocks, update to correct; // IDom.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update loop headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update DominatorTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:85,Deployability,update,update,85,"// FIXME: SplitEdge does not yet take a DTU, so we include the split edge; // in the update set here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:21,Deployability,patch,patch,21,// Remap operands to patch up intra-block references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Energy Efficiency,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Modifiability,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Energy Efficiency,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Modifiability,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:420,Integrability,interface,interface,420,"//===- CloneModule.cpp - Clone an entire module ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CloneModule interface which makes a copy of an; // entire module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:101,Modifiability,variab,variables,101,"/// This is not as easy as it might seem because we have to worry about making; /// copies of global variables and functions, and making their (initializers and; /// references, respectively) refer to the right globals.; ///; /// Cloning un-materialized modules is not currently supported, so any; /// modules initialized via lazy loading should be materialized before cloning",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:331,Performance,load,loading,331,"/// This is not as easy as it might seem because we have to worry about making; /// copies of global variables and functions, and making their (initializers and; /// references, respectively) refer to the right globals.; ///; /// Cloning un-materialized modules is not currently supported, so any; /// modules initialized via lazy loading should be materialized before cloning",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:31,Modifiability,variab,variables,31,"// Loop over all of the global variables, making corresponding globals in the; // new module. Here we add them to the VMap and to the new Module. We; // don't worry about attributes or initializers, they will come later.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:113,Integrability,depend,depending,113,"// An alias cannot act as an external reference, so we need to create; // either a function or a global variable depending on the value type.; // FIXME: Once pointee types are gone we can probably pick one or the; // other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:104,Modifiability,variab,variable,104,"// An alias cannot act as an external reference, so we need to create; // either a function or a global variable depending on the value type.; // FIXME: Once pointee types are gone we can probably pick one or the; // other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:42,Modifiability,variab,variable,42,"// Now that all of the things that global variable initializer can refer to; // have been created, loop through and copy the global variable referrers; // over... We also set the attributes on the global now.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:132,Modifiability,variab,variable,132,"// Now that all of the things that global variable initializer can refer to; // have been created, loop through and copy the global variable referrers; // over... We also set the attributes on the global now.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:408,Integrability,interface,interface,408,"//===- CodeExtractor.cpp - Pull code region into a new function -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface to tear out a code region, such as an; // individual loop or a parallel section, into a new function, replacing it with; // a call to the new function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:4,Testability,Test,Test,4,/// Test whether a block is valid for extraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:60,Safety,abort,aborting,60,"// Loop over the blocks, adding them to our set-vector, and aborting with an; // empty set if we encounter invalid blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Modifiability,variab,variable,10,// Global variable can not be aliased with locals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:167,Safety,avoid,avoid,167,// Find bitcasts in the outlined region that have lifetime marker users; // outside that region. Replace the lifetime marker use with an; // outside region bitcast to avoid unnecessary alloca/reload instructions; // and extra lifetime markers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:95,Deployability,update,update,95,"// Okay, everything within the region is now branching to the right block, we; // just have to update the PHI nodes now, inserting PHI nodes into NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:205,Safety,safe,safe,205,"// Do not process PHI if there is one (or fewer) predecessor from region.; // If PHI has exactly one predecessor from region, only this one incoming; // will be replaced on codeRepl block, so it should be safe to skip PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:29,Integrability,depend,dependent,29,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,Inherit,Inherit,3,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:385,Modifiability,inherit,inherited,385,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:41,Safety,safe,safely,41,// Those attributes cannot be propagated safely. Explicitly list them; // here so we get a warning if new attributes are added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:30,Safety,safe,safe,30,// Those attributes should be safe to propagate to the extracted function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all users of the inputs in the extracted region to use the; // arguments (or appropriate addressing into struct) instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite branches to basic blocks outside of the loop to new dummy blocks; // within the new function. This must be done before we lose track of which; // blocks were originally in the code region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:119,Energy Efficiency,allocate,allocated,119,"// Emit a call to the new function, passing in: *pointer to struct (if; // aggregating parameters), or plan inputs and allocated memory for outputs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a struct at the beginning of this function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:36,Testability,stub,stub,36,"// If we don't already have an exit stub for this non-extracted; // destination, create one now!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the switch instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,rewrite,rewrite,3,// rewrite the original branch instruction with this new target,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:116,Testability,stub,stubs,116,// Store the arguments right after the definition of output value.; // This should be proceeded after creating exit stubs to be ensure that invoke; // result restore will be placed in the outlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:33,Usability,simpl,simplify,33,"// Now that we've done the deed, simplify the switch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Availability,redundant,redundant,10,// Remove redundant case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Safety,redund,redundant,10,// Remove redundant case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the branch weights for the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:22,Deployability,update,update,22,// Get the weight and update the current BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:51,Deployability,update,updated,51,"// Debug intrinsics in the new function need to be updated in one of two; // ways:; // 1) They need to be deleted, because they describe a value in the old; // function.; // 2) They need to point to fresh metadata, e.g. because they currently; // point to a variable in the wrong scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:258,Modifiability,variab,variable,258,"// Debug intrinsics in the new function need to be updated in one of two; // ways:; // 1) They need to be deleted, because they describe a value in the old; // function.; // 2) They need to point to fresh metadata, e.g. because they currently; // point to a variable in the wrong scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:17,Deployability,update,updates,17,"// Apply the two updates that dbg.values get: invalid operands, and; // variable metadata fixup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:72,Modifiability,variab,variable,72,"// Apply the two updates that dbg.values get: invalid operands, and; // variable metadata fixup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Modifiability,variab,variable,10,"// If the variable was in the scope of the old function, i.e. it was not; // inlined, point the intrinsic to a fresh variable within the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:117,Modifiability,variab,variable,117,"// If the variable was in the scope of the old function, i.e. it was not; // inlined, point the intrinsic to a fresh variable within the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:107,Performance,cache,cache,107,// Remove @llvm.assume calls that will be moved to the new function from the; // old function's assumption cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the branch weight for this successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the entry count of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the branch weights for the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:156,Safety,avoid,avoid,156,// Mark the new function `noreturn` if applicable. Terminators which resume; // exception propagation are treated as returning instructions. This is to; // avoid inserting traps after calls to outlined functions which unwind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:69,Usability,resume,resume,69,// Mark the new function `noreturn` if applicable. Terminators which resume; // exception propagation are treated as returning instructions. This is to; // avoid inserting traps after calls to outlined functions which unwind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:66,Performance,cache,cache,66,"// There shouldn't be any stale affected values in the assumption cache; // that were previously in the old function, but that have now been moved; // to the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:818,Modifiability,Extend,Extended-TSP,818,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:404,Performance,cache,cache-aware,404,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:570,Performance,optimiz,optimizing,570,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:616,Performance,cache,cache,616,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:796,Performance,optimiz,optimization,796,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:1200,Performance,cache,cache,1200,"LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation sufficiently fast.; //; // Reference:; // * A. Newell and S. Pupyrev, Improved Basic Block Reordering,; // IEEE Transactions on Computers, 2020; // http",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:76,Performance,tune,tuned,76,// namespace llvm; // Algorithm-specific params for Ext-TSP. The values are tuned for the best; // performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:99,Performance,perform,performance,99,// namespace llvm; // Algorithm-specific params for Ext-TSP. The values are tuned for the best; // performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:107,Energy Efficiency,efficient,efficiently,107,// The maximum size of a chain created by the algorithm. The size is bounded; // so that the algorithm can efficiently process extremely large instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update the current gain if Other is preferred over this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update the chain's data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update the node's data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cached,3,// Cached ext-tsp score for the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:125,Safety,avoid,avoid,125,"// The total execution count of the chain. Since the execution count of; // a basic block is uint64_t, using doubles here to avoid overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cached,3,// Cached gain value for merging the pair of chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cached,3,"// Cached gain values for merging the pair of chains. Since the gain of; // merging (Src, Dst) and (Dst, Src) might be different, we store both values; // here and a flag indicating which of the options results in a higher gain.; // Cached gain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:233,Performance,Cache,Cached,233,"// Cached gain values for merging the pair of chains. Since the gain of; // merging (Src, Dst) and (Dst, Src) might be different, we store both values; // here and a flag indicating which of the options results in a higher gain.; // Cached gain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:15,Performance,cache,cached,15,// Whether the cached value must be recomputed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update edges adjacent to chain Other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around three concatenated vectors (chains) of nodes; it is used; /// to avoid extra instantiation of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:86,Safety,avoid,avoid,86,/// A wrapper around three concatenated vectors (chains) of nodes; it is used; /// to avoid extra instantiation of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around two concatenated vectors (chains) of jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:36,Performance,optimiz,optimized,36,/// Run the algorithm and return an optimized ordering of nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:31,Energy Efficiency,reduce,reduce,31,// Pass 3: Merge cold nodes to reduce code size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:41,Integrability,depend,dependencies,41,"// There might be 'cycles' in the forced dependencies, since profile; // data isn't 100% accurate. Typically this is observed in loops, when the; // loop edges are the hottest successors for the basic blocks of the loop.; // Break the cycles by choosing the node with the smallest index as the; // head. This helps to keep the original order of the loops, which likely; // have already been rotated in the optimized manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:406,Performance,optimiz,optimized,406,"// There might be 'cycles' in the forced dependencies, since profile; // data isn't 100% accurate. Typically this is observed in loops, when the; // loop edges are the hottest successors for the basic blocks of the loop.; // Break the cycles by choosing the node with the smallest index as the; // head. This helps to keep the original order of the loops, which likely; // have already been rotated in the optimized manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:85,Deployability,update,update,85,"/// Given a merge offset and a list of merge types, try to merge two chains; /// and update Gain with a better alternative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:56,Deployability,update,update,56,"// Apply the merge, compute the corresponding gain, and update the best; // value, if the merge is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:119,Energy Efficiency,reduce,reduce,119,"// In practice, applying X2_Y_X1 merging almost never provides benefits;; // thus, we exclude it from consideration to reduce the search space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:38,Deployability,update,update,38,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:122,Performance,cache,cached,122,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update cached ext-tsp score for the new chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:10,Performance,cache,cached,10,// Update cached ext-tsp score for the new chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:14,Performance,cache,caches,14,// Invalidate caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:35,Deployability,update,updated,35,/// Active chains. The vector gets updated at runtime when chains are merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:30,Performance,Cache,Cache-Directed,30,/// The implementation of the Cache-Directed Sort (CDSort) algorithm for; /// ordering functions represented by a call graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:21,Performance,queue,queue,21,// Create a priority queue containing all edges ordered by the merge gain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:29,Performance,queue,queue,29,// Insert the edges into the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:34,Performance,queue,queue,34,// Remove outdated edges from the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:39,Performance,queue,queue,39,// Insert newly created edges into the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:61,Deployability,update,update,61,"/// Given a list of merge types, try to merge two chains and update Gain; /// with a better alternative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:56,Deployability,update,update,56,"// Apply the merge, compute the corresponding gain, and update the best; // value, if the merge is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:16,Integrability,depend,depend,16,// This doesn't depend on the ordering of the nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cache,3,// Cache misses on the chains before merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cache,3,// Cache misses on the merged chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:38,Deployability,update,update,38,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:122,Performance,cache,cached,122,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:20,Safety,avoid,avoid,20,// Using doubles to avoid overflow of ExecutionCounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:4,Modifiability,Config,Config,4,/// Config for the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:16,Modifiability,config,config,16,// Populate the config from the command-line options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:408,Performance,perform,perform,408,"//===- CodeMoverUtils.cpp - CodeMover Utilities ----------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform movements on basic blocks, and instructions; // contained within a function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:37,Testability,log,logic,37,"// FIXME: Use SCEV and reuse GVN/CSE logic to check for equivalence between; // Values.; // Currently, isEquivalent rely on other passes to ensure equivalent conditions; // have the same value, e.g. GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:8,Testability,test,tests,8,// Skip tests when we don't have PDT or DI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:128,Availability,avail,available,128,"// If OpInst is an instruction that appears earlier in the same BB as; // I, then it is okay to move since OpInst will still be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:39,Integrability,depend,dependences,39,// Check if I has any output/flow/anti dependences with instructions from \p; // StartInst to \p EndInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:93,Performance,optimiz,optimize,93,// Verify that the initializer is simple enough for us to handle. We are; // only allowed to optimize the initializer if it is unique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:34,Usability,simpl,simple,34,// Verify that the initializer is simple enough for us to handle. We are; // only allowed to optimize the initializer if it is unique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:27,Performance,optimiz,optimizing,27,"// Loop over global ctors, optimizing them when we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:55,Performance,optimiz,optimizations,55,"//===- Debugify.cpp - Check debug info preservation in optimizations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file In the `synthetic` mode, the `-debugify` attaches synthetic debug info; /// to everything. It can be used to create targeted tests for debug info; /// preservation. In addition, when using the `original` mode, it can check; /// original debug info preservation. The `synthetic` mode is default one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:516,Testability,test,tests,516,"//===- Debugify.cpp - Check debug info preservation in optimizations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file In the `synthetic` mode, the `-debugify` attaches synthetic debug info; /// to everything. It can be used to create targeted tests for debug info; /// preservation. In addition, when using the `original` mode, it can check; /// original debug info preservation. The `synthetic` mode is default one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:63,Deployability,update,updates,63,// Maintain an insertion point which can't be invalidated when updates; // are made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:174,Testability,test,tests,174,"// Make sure we emit at least one dbg.value, otherwise MachineDebugify may; // not have anything to work with as it goes about inserting DBG_VALUEs.; // (It's common for MIR tests to be written containing skeletal IR with; // empty functions -- we're still interested in debugifying the MIR within; // those tests, and this helps with that.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:308,Testability,test,tests,308,"// Make sure we emit at least one dbg.value, otherwise MachineDebugify may; // not have anything to work with as it goes about inserting DBG_VALUEs.; // (It's common for MIR tests to be written containing skeletal IR with; // empty functions -- we're still interested in debugifying the MIR within; // those tests, and this helps with that.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:42,Modifiability,variab,variables,42,// Track the number of distinct lines and variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:22,Modifiability,variab,variables,22,// Original number of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:83,Modifiability,variab,variables,83,"// Strip out all debug intrinsics and supporting metadata (subprograms, types,; // variables, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:44,Modifiability,variab,variable,44,// Collect debug locations (!dbg) and debug variable intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:16,Modifiability,variab,variables,16,// Skip inlined variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:15,Safety,avoid,avoid,15,"// In order to avoid pointer reuse/recycling, skip the values that might; // have been deleted during a pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:50,Modifiability,variab,variable,50,// This checks the preservation of original debug variable intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:44,Modifiability,variab,variable,44,// Collect debug locations (!dbg) and debug variable intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:16,Modifiability,variab,variables,16,// Skip inlined variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:207,Availability,failure,failures,207,"// The size of a dbg.value's value operand should match the size of the; // variable it corresponds to.; //; // TODO: This, along with a check for non-null value operands, should be; // promoted to verifier failures.; // For now, don't try to interpret anything more complicated than an empty; // DIExpression. Eventually we should try to handle OP_deref and fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:76,Modifiability,variab,variable,76,"// The size of a dbg.value's value operand should match the size of the; // variable it corresponds to.; //; // TODO: This, along with a check for non-null value operands, should be; // promoted to verifier failures.; // For now, don't try to interpret anything more complicated than an empty; // DIExpression. Eventually we should try to handle OP_deref and fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:16,Modifiability,variab,variables,16,// Find missing variables and mis-sized debug values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:3,Deployability,Update,Update,3,// Update DI loss statistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:142,Energy Efficiency,allocate,allocated,142,"/// DemoteRegToStack - This function takes a virtual register computed by an; /// Instruction and replaces it with a slot in the stack frame, allocated via; /// alloca. This allows the CFG to be changed around without fear of; /// invalidating the SSA information for the value. It returns the pointer to; /// the alloca inserted to create a stack slot for I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:44,Performance,load,load,44,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:101,Performance,load,load,101,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:287,Performance,load,loads,287,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:378,Performance,load,load,378,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:494,Performance,load,loads,494,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:14,Performance,load,load,14,// Insert the load into the predecessor block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:50,Performance,load,load,50,"// If this is a normal instruction, just insert a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:137,Energy Efficiency,allocate,allocated,137,/// DemotePHIToStack - This function takes a virtual register computed by a PHI; /// node and replaces it with a slot in the stack frame allocated via alloca.; /// The PHI node is deleted. It returns the pointer to the alloca inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:12,Performance,load,load,12,// Insert a load in place of the PHI and replace all uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:22,Performance,load,load,22,// We need a separate load before each actual use of the PHI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp:25,Deployability,Upgrade,Upgrade,25,"//===- DXILUpgrade.cpp - Upgrade DXIL metadata to LLVM constructs ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp:21,Security,validat,validation,21,"// We don't need the validation version internally, so we drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp:197,Usability,Simpl,Simply,197,// The asm in a naked function may reasonably expect the argument registers; // and the return address register (if present) to be live. An inserted; // function call will clobber these registers. Simply skip naked functions for; // all targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp:23,Usability,resume,resume,23,"// Find all 'return', 'resume', and 'unwind' instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp:52,Usability,resume,resume,52,"// Branches and invokes do not escape, only unwind, resume, and return; // do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:340,Safety,avoid,avoid,340,/// Return true if the specified constant can be handled by the code generator.; /// We don't want to generate something like:; /// void *X = &X/42;; /// because the code generator doesn't have a relocation that can handle that.; ///; /// This function should be called if C was not found (but just got inserted); /// in SimpleConstants to avoid having to rescan the same constants all the; /// time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:321,Usability,Simpl,SimpleConstants,321,/// Return true if the specified constant can be handled by the code generator.; /// We don't want to generate something like:; /// void *X = &X/42;; /// because the code generator doesn't have a relocation that can handle that.; ///; /// This function should be called if C was not found (but just got inserted); /// in SimpleConstants to avoid having to rescan the same constants all the; /// time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Usability,Simpl,Simple,3,"// Simple global addresses are supported, do not allow dllimport or; // thread-local globals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Usability,Simpl,Simple,3,"// Simple integer, undef, constant aggregate zero, etc are all supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:24,Safety,safe,safe,24,// Aggregate values are safe if all their elements are.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:128,Safety,safe,safe,128,"// We don't know exactly what relocations are allowed in constant expressions,; // so we allow &global+constantoffset, which is safe and uniformly supported; // across targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:24,Usability,simpl,simple,24,// GEP is fine if it is simple + constant offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:12,Usability,simpl,simple,12,// We allow simple+cst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:49,Performance,load,load,49,"/// Return the value that would be computed by a load from P after the stores; /// reflected by 'memory' have been performed. If we can't decide, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:115,Performance,perform,performed,115,"/// Return the value that would be computed by a load from P after the stores; /// reflected by 'memory' have been performed. If we can't decide, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:15,Security,access,accesses,15,// no volatile accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:93,Modifiability,variab,variable,93,// If this might be too difficult for the backend to handle (e.g. the addr; // of one global variable divided by another) then we can't commit it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:15,Security,access,accesses,15,// no volatile accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:22,Performance,load,load,22,// Could not evaluate load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:18,Safety,safe,safely,18,// Debug info can safely be ignored here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Safety,Avoid,Avoid,3,// Avoid the byte-per-byte scan if we're memseting a zeroinitializer; // to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:19,Usability,resume,resume,19,"// invoke, unwind, resume, unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:196,Safety,detect,detect,196,"// ExecutedBlocks - We only handle non-looping, non-recursive code. As such,; // we can only evaluate any one basic block at most once. This set keeps; // track of what we have executed so we can detect recursive cases etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:18,Safety,avoid,avoid,18,// Initialized to avoid compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:151,Security,access,accesses,151,"// The Evaluator can look through pointer casts as long as alias; // analysis holds because it's just a simple interpreter and doesn't; // skip memory accesses due to invariant group metadata, but we can't; // let users of Evaluator use a value that's been gleaned looking; // through stripping pointer casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:104,Usability,simpl,simple,104,"// The Evaluator can look through pointer casts as long as alias; // analysis holds because it's just a simple interpreter and doesn't; // skip memory accesses due to invariant group metadata, but we can't; // let users of Evaluator use a value that's been gleaned looking; // through stripping pointer casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:33,Integrability,wrap,wrappers,33,// namespace llvm; // Overloaded wrappers to go with the function template below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:9,Performance,optimiz,optimization,9,"// Minor optimization: The SCC blocks are usually discovered in an order; // that is the opposite of the order in which these blocks appear as branch; // targets. This results in a lot of condition inversions in the control; // flow out of the new ControlFlowHub, which can be mitigated if the orders; // match. So we discover the headers using the reverse of the block order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:12,Energy Efficiency,reduce,reduced,12,"// Any SCCs reduced are now already in the list of top-level loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:71,Usability,simpl,simply,71,"// Any SCCs reduced are now already in the list of top-level loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:12,Energy Efficiency,reduce,reduced,12,"// Any SCCs reduced are now already in the list of child loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:67,Usability,simpl,simply,67,"// Any SCCs reduced are now already in the list of child loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:383,Energy Efficiency,Reduce,Reduce,383,"//===- FlatternCFG.cpp - Code to perform CFG flattening -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Reduce conditional branches in CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:33,Performance,perform,perform,33,"//===- FlatternCFG.cpp - Code to perform CFG flattening -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Reduce conditional branches in CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:19,Safety,avoid,avoid,19,"// For simplicity, avoid cases containing PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, avoid cases containing PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:59,Safety,safe,safe,59,// Instructions in the internal condition blocks should be safe; // to hoist up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:31,Availability,down,downstream,31,// make CB unreachable and let downstream to delete the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:34,Integrability,depend,dependency,34,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:62,Safety,avoid,avoided,62,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:7,Usability,simpl,simplicity,7,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:64,Safety,safe,safe,64,// Check whether \param SecondEntryBlock has side-effect and is safe to; // speculate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:23,Integrability,rout,routine,23,"// TODO: the following routine coerce the metadata contents into constants; // or MDStrings before comparison.; // It ignores any other cases, so that the metadata nodes are considered; // equal even though this is not correct.; // We should structurally compare the metadata nodes to be perfect here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:37,Performance,optimiz,optimization,37,/// These metadata affects the other optimization passes by making assertions; /// or constraints.; /// Values that carry different expectations should be considered different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:67,Testability,assert,assertions,67,/// These metadata affects the other optimization passes by making assertions; /// or constraints.; /// Values that carry different expectations should be considered different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:127,Integrability,depend,depending,127,"// This handles ConstantDataArray and ConstantDataVector. Note that we; // compare the two raw data arrays, which might differ depending on the host; // endianness. This isn't a problem though, because the endiness of a module; // will affect the order of the constants, but this order is the same; // for a given input module and host platform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:21,Safety,abort,abort,21,"// Unknown constant, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:115,Testability,test,test,115,"// Differences from Instruction::isSameOperationAs:; // * replace type comparison with calls to cmpTypes.; // * we test for I->getRawSubclassOptionalData (nuw/nsw/tail) at the top.; // * because of the above, we don't test for the tail bit on calls later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:218,Testability,test,test,218,"// Differences from Instruction::isSameOperationAs:; // * replace type comparison with calls to cmpTypes.; // * we test for I->getRawSubclassOptionalData (nuw/nsw/tail) at the top.; // * because of the above, we don't test for the tail bit on calls later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:40,Performance,perform,perform,40,// Determine whether two GEP operations perform the same underlying arithmetic.; // Read method declaration comments for more details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:51,Availability,down,down,51,"// When we have target data, we can reduce the GEP down to the value in bytes; // added to the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:36,Energy Efficiency,reduce,reduce,36,"// When we have target data, we can reduce the GEP down to the value in bytes; // added to the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:179,Safety,detect,detect,179,"/// Compare two values used by the two functions under pair-wise comparison. If; /// this is the first time the values are seen, they're added to the mapping so; /// that we will detect mismatches on next use.; /// See comments in declaration for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:3,Testability,Test,Test,3,// Test whether two basic blocks have equivalent behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:3,Testability,Test,Test,3,// Test whether the two functions have equivalent behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:458,Performance,perform,perform,458,"//===- lib/Transforms/Utils/FunctionImportUtils.cpp - Importing utilities -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the FunctionImportGlobalProcessing class, used; // to perform the necessary global value handling for function importing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:188,Safety,avoid,avoid,188,"/// Uses the ""source_filename"" instead of a Module hash ID for the suffix of; /// promoted locals during LTO. NOTE: This requires that the source filename; /// has a unique name / path to avoid name collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:51,Security,hash,hash,51,"/// Uses the ""source_filename"" instead of a Module hash ID for the suffix of; /// promoted locals during LTO. NOTE: This requires that the source filename; /// has a unique name / path to avoid name collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:55,Modifiability,variab,variable,55,// Both the imported references and the original local variable must; // be promoted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:112,Usability,simpl,simply,112,"// We don't know for sure yet if we are importing this value (as either; // a reference or a def), since we are simply walking all values in the; // module. But by necessity if we end up importing it and it is local,; // it must be promoted, so unconditionally promote all values in the; // importing module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:88,Usability,GUID,GUID,88,"// When exporting, consult the index. We can have more than one local; // with the same GUID, in the case of same-named locals in different but; // same-named source files that were compiled in their respective directories; // (so the source file name and resulting GUID is the same). Find the one; // in this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:266,Usability,GUID,GUID,266,"// When exporting, consult the index. We can have more than one local; // with the same GUID, in the case of same-named locals in different but; // same-named source files that were compiled in their respective directories; // (so the source file name and resulting GUID is the same). Find the one; // in this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:39,Testability,log,logic,39,// This needs to stay in sync with the logic in buildModuleSummaryIndex.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:13,Modifiability,variab,variable,13,"// Any local variable that is referenced by an exported function needs; // to be promoted to global scope. Since we don't currently know which; // functions reference which local variables/functions, we must treat; // all as potentially exported if this module is exporting anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:179,Modifiability,variab,variables,179,"// Any local variable that is referenced by an exported function needs; // to be promoted to global scope. Since we don't currently know which; // functions reference which local variables/functions, we must treat; // all as potentially exported if this module is exporting anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:121,Availability,avail,available,121,"// External and linkonce definitions are converted to available_externally; // definitions upon import, so that they are available for inlining; // and/or optimization, but are turned into declarations later; // during the EliminateAvailableExternally pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:155,Performance,optimiz,optimization,155,"// External and linkonce definitions are converted to available_externally; // definitions upon import, so that they are available for inlining; // and/or optimization, but are turned into declarations later; // during the EliminateAvailableExternally pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:56,Modifiability,variab,variable,56,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:229,Testability,assert,assert,229,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:291,Usability,simpl,simply,291,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:24,Modifiability,variab,variables,24,"// Mark read/write-only variables which can be imported with specific; // attribute. We can't internalize them now because IRMover will fail; // to link variable definitions to their external declarations during; // ThinLTO import. We'll internalize read-only variables later, after; // import is finished. See internalizeGVsAfterImport.; //; // If global value dead stripping is not enabled in summary then; // propagateConstants hasn't been run. We can't internalize GV; // in such case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:153,Modifiability,variab,variable,153,"// Mark read/write-only variables which can be imported with specific; // attribute. We can't internalize them now because IRMover will fail; // to link variable definitions to their external declarations during; // ThinLTO import. We'll internalize read-only variables later, after; // import is finished. See internalizeGVsAfterImport.; //; // If global value dead stripping is not enabled in summary then; // propagateConstants hasn't been run. We can't internalize GV; // in such case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:260,Modifiability,variab,variables,260,"// Mark read/write-only variables which can be imported with specific; // attribute. We can't internalize them now because IRMover will fail; // to link variable definitions to their external declarations during; // ThinLTO import. We'll internalize read-only variables later, after; // import is finished. See internalizeGVsAfterImport.; //; // If global value dead stripping is not enabled in summary then; // propagateConstants hasn't been run. We can't internalize GV; // in such case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:49,Usability,GUID,GUID,49,"// We can have more than one local with the same GUID, in the case of; // same-named locals in different but same-named source files that were; // compiled in their respective directories (so the source file name; // and resulting GUID is the same). Find the one in this module.; // Handle the case where there is no summary found in this module. That; // can happen in the distributed ThinLTO backend, because the index only; // contains summaries from the source modules if they are being imported.; // We might have a non-null VI and get here even in that case if the name; // matches one in this module (e.g. weak or appending linkage).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:231,Usability,GUID,GUID,231,"// We can have more than one local with the same GUID, in the case of; // same-named locals in different but same-named source files that were; // compiled in their respective directories (so the source file name; // and resulting GUID is the same). Find the one in this module.; // Handle the case where there is no summary found in this module. That; // can happen in the distributed ThinLTO backend, because the index only; // contains summaries from the source modules if they are being imported.; // We might have a non-null VI and get here even in that case if the name; // matches one in this module (e.g. weak or appending linkage).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:169,Safety,avoid,avoid,169,"// Objects referenced by writeonly GV initializer should not be; // promoted, because there is no any kind of read access to them; // on behalf of this writeonly GV. To avoid promotion we convert; // GV initializer to 'zeroinitializer'. This effectively drops; // references in IR module (not in combined index), so we can; // ignore them when computing import. We do not export references; // of writeonly object. See computeImportForReferencedGlobals",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:115,Security,access,access,115,"// Objects referenced by writeonly GV initializer should not be; // promoted, because there is no any kind of read access to them; // on behalf of this writeonly GV. To avoid promotion we convert; // GV initializer to 'zeroinitializer'. This effectively drops; // references in IR module (not in combined index), so we can; // ignore them when computing import. We do not export references; // of writeonly object. See computeImportForReferencedGlobals",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:120,Security,access,access,120,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:8,Usability,Clear,ClearDSOLocalOnDeclarations,8,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:45,Usability,clear,clear,45,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:32,Availability,avail,available,32,"// Remove functions imported as available externally defs from comdats,; // as this is a declaration for the linker, and will be dropped eventually.; // It is illegal for comdats to contain declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:87,Deployability,release,release,87,"/// Return the stronger of the two ordering. If the two orderings are acquire; /// and release, then return AcquireRelease.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:10,Safety,safe,safe,10,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that while constants cannot be cyclic, they can be tree-like, so we; /// should keep a visited set to avoid exponential runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:190,Safety,avoid,avoid,190,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that while constants cannot be cyclic, they can be tree-like, so we; /// should keep a visited set to avoid exponential runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:26,Performance,load,loads,26,// Don't hack on volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:77,Security,access,accessed,77,"// Look through selects and PHIs to find if the pointer is; // conditionally accessed. Make sure we only visit an instruction; // once; otherwise, we can get infinite recursion or exponential; // compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:17,Performance,load,load,17,// Any other non-load instruction might take address!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp:402,Performance,perform,perform,402,"//===-- GuardUtils.cpp - Utils for work with guards -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform transformations related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:7,Integrability,Inject,InjectTLIMAppings,7,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:54,Integrability,inject,injection,54,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:7,Security,Inject,InjectTLIMAppings,7,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:54,Security,inject,injection,54,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:26,Energy Efficiency,power,powers,26,// All VFs in the TLI are powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:36,Performance,perform,perform,36,"//===- InlineFunction.cpp - Code to perform function inlining -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements inlining of a function into a call site, resolving; // parameters and the return value as appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:104,Performance,optimiz,optimizations,104,"// Disabled by default, because the added alignment assumptions may increase; // compile-time and block optimizations. This option is not suitable for use; // with frontends that emit comprehensive parameter alignment annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:33,Usability,resume,resume,33,/// Destination for the callee's resume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:17,Usability,resume,resume,17,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is; /// a simple branch. When there is more than one predecessor, we need to; /// split the landing pad block after the landingpad instruction and jump; /// to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:145,Usability,simpl,simple,145,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is; /// a simple branch. When there is more than one predecessor, we need to; /// split the landing pad block after the landingpad instruction and jump; /// to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:75,Usability,Resume,ResumeInsts,75,// end anonymous namespace; /// Get or create a target for the branch from ResumeInsts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:17,Usability,resume,resume,17,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is a simple; /// branch. When there is more than one predecessor, we need to split the; /// landing pad block after the landingpad instruction and jump to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:140,Usability,simpl,simple,140,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is a simple; /// branch. When there is more than one predecessor, we need to split the; /// landing pad block after the landingpad instruction and jump to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update the PHIs in the destination. They were inserted in an order which; // makes this work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:113,Deployability,update,update,113,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:241,Deployability,update,updated,241,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:147,Performance,queue,queue,147,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:255,Performance,queue,queued,255,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:144,Usability,Simpl,SimplifyCFGOpt,144,"// Catchswitch doesn't have a 'nounwind' variant, and one might be; // annotated as ""unwinds to caller"" when really it's nounwind (see; // e.g. SimplifyCFGOpt::SimplifyUnreachable), so we can't infer the; // parent's unwind dest from this. We can check its catchpads'; // descendants, since they might include a cleanuppad with an; // ""unwinds to caller"" cleanupret, which can be trusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:160,Usability,Simpl,SimplifyUnreachable,160,"// Catchswitch doesn't have a 'nounwind' variant, and one might be; // annotated as ""unwinds to caller"" when really it's nounwind (see; // e.g. SimplifyCFGOpt::SimplifyUnreachable), so we can't infer the; // parent's unwind dest from this. We can check its catchpads'; // descendants, since they might include a cleanuppad with an; // ""unwinds to caller"" cleanupret, which can be trusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:119,Availability,error,error,119,"// Intentionally ignore invokes here -- since the catchswitch is; // marked ""unwind to caller"", it would be a verifier error if it; // contained an invoke which unwinds out of it, so any invoke we'd; // encounter must unwind to some child of the catch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:43,Performance,queue,queue,43,// Haven't figured out this child pad yet; queue it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:36,Performance,queue,queue,36,// Haven't resolved this child yet; queue it and keep searching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:66,Performance,queue,queued,66,"// If we haven't found an unwind dest for CurrentPad, we may have queued its; // children, so move on to the next in the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:717,Availability,avail,available,717,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:809,Availability,down,down,809,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:251,Integrability,rout,routine,251,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:783,Integrability,rout,routine,783,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:990,Modifiability,rewrite,rewrite,990,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:849,Safety,avoid,avoid,849,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:933,Safety,avoid,avoid,933,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:21,Availability,avail,available,21,"// No information is available for this EHPad from itself or any of its; // descendants. An unwind all the way out to a pad in the caller would; // need also to agree with the unwind dest of the parent funclet, so; // search up the chain to try to find a funclet with information. Put; // null entries in the memo map to avoid re-processing as we go up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:321,Safety,avoid,avoid,321,"// No information is available for this EHPad from itself or any of its; // descendants. An unwind all the way out to a pad in the caller would; // need also to agree with the unwind dest of the parent funclet, so; // search up the chain to try to find a funclet with information. Put; // null entries in the memo map to avoid re-processing as we go up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:413,Testability,assert,assert,413,"// If the MemoMap had an entry mapping AncestorPad to nullptr, since we; // haven't yet called getUnwindDestTokenHelper for AncestorPad in this; // call to getUnwindDestToken, that would mean that AncestorPad had no; // information in itself, its descendants, or its ancestors. If that; // were the case, then we should also have recorded the lack of information; // for the descendant that we're coming from. So assert that we don't; // find a null entry in the MemoMap for AncestorPad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:276,Availability,down,downward,276,"// We know that getUnwindDestTokenHelper was called on LastUselessPad and; // returned nullptr (and likewise for EHPad and any of its ancestors up to; // LastUselessPad), so LastUselessPad has no information from below. Since; // getUnwindDestTokenHelper must investigate all downward paths through; // no-information nodes to prove that a node has no information like this,; // and since any time it finds information it records it in the MemoMap for; // not just the immediately-containing funclet but also any ancestors also; // exited, it must be the case that, walking downward from LastUselessPad,; // visiting just those nodes which have not been mapped to an unwind dest; // by getUnwindDestTokenHelper (the nullptr TempMemos notwithstanding, since; // they are just used to keep getUnwindDestTokenHelper from repeating work),; // any node visited must have been exhaustively searched with no information; // for it found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:574,Availability,down,downward,574,"// We know that getUnwindDestTokenHelper was called on LastUselessPad and; // returned nullptr (and likewise for EHPad and any of its ancestors up to; // LastUselessPad), so LastUselessPad has no information from below. Since; // getUnwindDestTokenHelper must investigate all downward paths through; // no-information nodes to prove that a node has no information like this,; // and since any time it finds information it records it in the MemoMap for; // not just the immediately-containing funclet but also any ancestors also; // exited, it must be the case that, walking downward from LastUselessPad,; // visiting just those nodes which have not been mapped to an unwind dest; // by getUnwindDestTokenHelper (the nullptr TempMemos notwithstanding, since; // they are just used to keep getUnwindDestTokenHelper from repeating work),; // any node visited must have been exhaustively searched with no information; // for it found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:302,Availability,down,downward,302,// Assert as we enumerate users that 'UselessPad' doesn't have any unwind; // information that we'd be contradicting by making a map entry for it; // (which is something that getUnwindDestTokenHelper must have proved for; // us to get here). Just assert on is direct users here; the checks in; // this downward walk at its descendants will verify that they don't have; // any unwind edges that exit 'UselessPad' either (i.e. they either have no; // unwind edges or unwind to a sibling).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Testability,Assert,Assert,3,// Assert as we enumerate users that 'UselessPad' doesn't have any unwind; // information that we'd be contradicting by making a map entry for it; // (which is something that getUnwindDestTokenHelper must have proved for; // us to get here). Just assert on is direct users here; the checks in; // this downward walk at its descendants will verify that they don't have; // any unwind edges that exit 'UselessPad' either (i.e. they either have no; // unwind edges or unwind to a sibling).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:247,Testability,assert,assert,247,// Assert as we enumerate users that 'UselessPad' doesn't have any unwind; // information that we'd be contradicting by making a map entry for it; // (which is something that getUnwindDestTokenHelper must have proved for; // us to get here). Just assert on is direct users here; the checks in; // this downward walk at its descendants will verify that they don't have; // any unwind edges that exit 'UselessPad' either (i.e. they either have no; // unwind edges or unwind to a sibling).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:196,Modifiability,rewrite,rewrites,196,"/// When we inline a basic block into an invoke,; /// we have to turn all of the calls that can throw into invokes.; /// This function analyze BB to see if there are any calls, and if so,; /// it rewrites them to be invokes that jump to InvokeDest and fills in the PHI; /// nodes in that block with the values specified in InvokeDestPHIValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:369,Testability,log,logic,369,"// We do not need to (and in fact, cannot) convert possibly throwing calls; // to @llvm.experimental_deoptimize (resp. @llvm.experimental.guard) into; // invokes. The caller's ""segment"" of the deoptimization continuation; // attached to the newly inlined @llvm.experimental_deoptimize; // (resp. @llvm.experimental.guard) call should contain the exception; // handling logic, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:151,Modifiability,rewrite,rewrite,151,"// The inlined code is currently at the end of the function, scan from the; // start of the inlined code to its end, checking for stuff we need to; // rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the exceptional block to indicate that there; // is now a new entry in them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:15,Usability,resume,resumes,15,// Forward any resumes that are remaining here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:351,Integrability,rout,routed,351,"// This catchswitch has no parent to inherit constraints from, and; // none of its descendants can have an unwind edge that exits it and; // targets another funclet in the inlinee. It may or may not have a; // descendant that definitively has an unwind to caller. In either; // case, we'll have to assume that any unwinds out of it may need to; // be routed to the caller, so treat it as though it has a definitive; // unwind to caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,Modifiability,inherit,inherit,37,"// This catchswitch has no parent to inherit constraints from, and; // none of its descendants can have an unwind edge that exits it and; // targets another funclet in the inlinee. It may or may not have a; // descendant that definitively has an unwind to caller. In either; // case, we'll have to assume that any unwinds out of it may need to; // be routed to the caller, so treat it as though it has a definitive; // unwind to caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the exceptional block to indicate that there; // is now a new entry in them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:35,Performance,perform,performed,35,"// Because of the context trimming performed during matching, the callsite; // context could have more stack ids than the MIB. We match up to the end of; // the shortest stack context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,"// Update the metadata on the inlined copy ClonedCall of a call OrigCall in the; // inlined callee body, based on the callsite metadata InlinedCallsiteMD from; // the call that was inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:59,Deployability,update,update,59,"// Check if the call originally had callsite metadata, and update it for the; // new call in the inlined body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update any memprof metadata on the cloned call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,"// Update memprof related metadata (!memprof and !callsite) based on the; // inlining of Callee into the callsite at CB. The updates include merging the; // inlined callee's callsite metadata with that of the inlined call,; // and moving the subset of any memprof contexts to the inlined callee; // allocations if they match the new inlined call stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:125,Deployability,update,updates,125,"// Update memprof related metadata (!memprof and !callsite) based on the; // inlining of Callee into the callsite at CB. The updates include merging the; // inlined callee's callsite metadata with that of the inlined call,; // and moving the subset of any memprof contexts to the inlined callee; // allocations if they match the new inlined call stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:16,Deployability,update,update,16,"// Only need to update if the inlined callsite had callsite metadata, or if; // there was any memprof metadata inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:73,Usability,simpl,simplified,73,"// See if this is a call that has been inlined and remapped, and not; // simplified away in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:82,Security,access,access,82,"/// When inlining a call site that has !llvm.mem.parallel_loop_access,; /// !llvm.access.group, !alias.scope or !noalias metadata, that metadata should; /// be propagated to all memory-accessing cloned instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:185,Security,access,accessing,185,"/// When inlining a call site that has !llvm.mem.parallel_loop_access,; /// !llvm.access.group, !alias.scope or !noalias metadata, that metadata should; /// be propagated to all memory-accessing cloned instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:56,Security,access,access,56,// This metadata is only relevant for instructions that access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:225,Performance,load,loads,225,"/// If the inlined function has noalias arguments,; /// then add new alias scopes for each noalias argument, tag the mapped noalias; /// parameters with noalias metadata specifying the new scope, and tag all; /// non-derived loads, stores and memory intrinsics with the new alias scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:34,Modifiability,variab,variable,34,"// To do a good job, if a noalias variable is captured, we need to know if; // the capture point dominates the particular use we're considering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:186,Security,Access,Accesses,186,"// noalias indicates that pointer values based on the argument do not alias; // pointer values which are not based on it. So we add a new ""scope"" for each; // noalias function argument. Accesses using pointers based on that argument; // become part of that alias scope, accesses using pointers not based on that; // argument are tagged as noalias with that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:270,Security,access,accesses,270,"// noalias indicates that pointer values based on the argument do not alias; // pointer values which are not based on it. So we add a new ""scope"" for each; // noalias function argument. Accesses using pointers based on that argument; // become part of that alias scope, accesses using pointers not based on that; // argument are tagged as noalias with that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:202,Integrability,depend,dependencies,202,"// Note: We always create a new anonymous root here. This is true regardless; // of the linkage of the callee because the aliasing ""scope"" is not just a; // property of the callee, but also all control dependencies in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:64,Security,access,access,64,"// Iterate over all new instructions in the map; for all memory-access; // instructions, add the alias scope metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,Security,access,access,37,"// If we know that the call does not access memory, then we'll still; // know that about the inlined clone of this call site, and we don't; // need to add metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:67,Security,access,accessed,67,"// Only care about pointer arguments. If a noalias argument is; // accessed through a non-pointer argument, it must be captured; // first (e.g. via ptrtoint), and we protect against captures below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:61,Availability,reliab,reliably,61,// Nothing we can do if the used underlying object cannot be reliably; // determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:331,Performance,load,load,331,"// First, we want to figure out all of the sets with which we definitely; // don't alias. Iterate over all noalias set, and add those for which:; // 1. The noalias argument is not in the set of objects from which we; // definitely derive.; // 2. The noalias argument has not yet been captured.; // An arbitrary function that might load pointers could see captured; // noalias arguments via other noalias arguments or globals, and so we; // must always check for prior capture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:528,Integrability,depend,depend,528,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:302,Security,access,access,302,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:423,Security,access,access,423,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:510,Security,access,access,510,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:632,Security,access,access,632,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:119,Usability,Simpl,Simplification,119,"// Check that the cloned RetVal exists and is a call, otherwise we cannot; // add the attributes on the cloned RetVal. Simplification during inlining; // could have transformed the cloned instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:103,Integrability,depend,dependent,103,"// Backward propagation of attributes to the returned value may be incorrect; // if it is control flow dependent.; // Consider:; // @callee {; // %rv = call @foo(); // %rv2 = call @bar(); // if (%rv2 != null); // return %rv2; // if (%rv == null); // exit(); // return %rv; // }; // caller() {; // %val = call nonnull @callee(); // }; // Here we cannot add the nonnull attribute on either foo or bar. So, we; // limit the check to both RetVal and RI are in the same basic block and; // there are no throwing/exiting instructions between these instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:515,Deployability,Update,Update,515,"// Three checks.; // If the callsite has `noundef`, then a poison due to violating the; // return attribute will create UB anyways so we can always propagate.; // Otherwise, if the return value (callee to be inlined) has `noundef`, we; // can't propagate as a new poison return will cause UB.; // Finally, check if the return value has no uses whose behavior may; // change/may cause UB if we potentially return poison. At the moment this; // is implemented overly conservatively with a single-use check.; // TODO: Update the single-use check to iterate through uses and only bail; // if we have a potentially dangerous use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:22,Availability,redundant,redundant,22,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:6,Safety,avoid,avoid,6,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:22,Safety,redund,redundant,22,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:31,Testability,assert,asserted,31,"// If we can already prove the asserted alignment in the context of the; // caller, then don't bother inserting the assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:114,Performance,optimiz,optimizations,114,// Always generate a memcpy of alignment 1 here because we don't know; // the alignment of the src pointer. Other optimizations can infer; // better alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:129,Safety,safe,safe,129,"// If the called function is readonly, then it could not mutate the caller's; // copy of the byval'd memory. In this case, it is safe to elide the copy and; // temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:48,Safety,safe,safe,48,"// Otherwise, we have to make a memcpy to get a safe alignment. This is bad; // for code quality, but rarely happens and is required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:132,Performance,cache,cache,132,/// Returns a DebugLoc for a new DILocation which is a clone of \p OrigDL; /// inlined at \p InlinedAt. \p IANodes is an inlined-at cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update inlined instructions' line numbers to; /// to encode location where these instructions are inlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Performance,Cache,Cache,3,"// Cache the inlined-at nodes as they're built so they are reused, without; // this every instruction's inlined-at chain would become distinct from each; // other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,Deployability,update,updated,29,// Loop metadata needs to be updated so that the start and end locs; // reference inlined-at locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:316,Deployability,update,update,316,"// If the inlined instruction has no line number, or if inline info; // is not being generated, make it look as if it originates from the call; // location. This is important for ((__always_inline, __nodebug__)); // functions which must use caller location for all instructions in their; // function body.; // Don't update static allocas, as they may get moved later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:18,Modifiability,variab,variables,18,// Find all local variables associated with the backing storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:8,Modifiability,variab,variables,8,// Skip variables from inlined functions - they are not local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:62,Modifiability,variab,variables,62,// Skip variables from inlined functions - they are not local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update inlined instructions' DIAssignID metadata. We need to do this; /// otherwise a function inlined more than once into the same function; /// will cause DIAssignID to be shared by many instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update the block frequencies of the caller after a callee has been inlined.; ///; /// Each block cloned into the caller has its block frequency scaled by the; /// ratio of CallSiteFreq/CalleeEntryFreq. This ensures that the cloned copy of; /// callee's entry block gets the same frequency as the callsite block and the; /// relative frequencies of all cloned blocks remain the same after cloning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update the branch metadata for cloned call instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:14,Deployability,update,update,14,// No need to update the callsite if it is pruned during inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,Availability,redundant,redundant,29,"// FIXME: The check below is redundant and incomplete. According to spec, if a; // convergent call is missing a token, then the caller is using uncontrolled; // convergence. If the callee has an entry intrinsic, then the callee is using; // controlled convergence, and the call cannot be inlined. A proper; // implemenation of this check requires a whole new analysis that identifies; // convergence in every function. For now, we skip that and just do this one; // cursory check. The underlying assumption is that in a compiler flow that; // fully implements convergence control tokens, there is no mixing of; // controlled and uncontrolled convergent operations in the whole program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,Safety,redund,redundant,29,"// FIXME: The check below is redundant and incomplete. According to spec, if a; // convergent call is missing a token, then the caller is using uncontrolled; // convergence. If the callee has an entry intrinsic, then the callee is using; // controlled convergence, and the call cannot be inlined. A proper; // implemenation of this check requires a whole new analysis that identifies; // convergence in every function. For now, we skip that and just do this one; // cursory check. The underlying assumption is that in a compiler flow that; // fully implements convergence control tokens, there is no mixing of; // controlled and uncontrolled convergent operations in the whole program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:16,Safety,hazard,hazards,16,"// GC poses two hazards to inlining, which only occur when the callee has GC:; // 1. If the caller has no GC, then the callee's GC must be propagated to the; // caller.; // 2. If the caller has a differing GC, it is invalid to inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:51,Performance,perform,perform,51,"// If the personality functions match, then we can perform the; // inlining. Otherwise, we can't inline.; // TODO: This isn't 100% true. Some personality functions are proper; // supersets of others and can be used in place of the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:31,Availability,toler,tolerate,31,// The MSVC personality cannot tolerate catches getting inlined into; // cleanup funclets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:20,Availability,toler,tolerant,20,"// SEH is even less tolerant, there may not be any sort of exceptional; // funclet in the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:42,Deployability,update,updated,42,// TODO: Remove this when users have been updated to the assume bundles.; // Add alignment assumptions if necessary. We do this before the inlined; // instructions are actually cloned into the caller so that we can easily; // check what will be known at the start of the inlined code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Updated,3,"// Updated caller/callee profiles only when requested. For sample loader; // inlining, the context-sensitive inlinee profile doesn't need to be; // subtracted from callee profile, and the inlined clone also doesn't need; // to be scaled based on call site count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:66,Performance,load,loader,66,"// Updated caller/callee profiles only when requested. For sample loader; // inlining, the context-sensitive inlinee profile doesn't need to be; // subtracted from callee profile, and the inlined clone also doesn't need; // to be scaled based on call site count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update the BFI of blocks cloned into the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Integrability,Inject,Inject,3,// Inject byval arguments initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Security,Inject,Inject,3,// Inject byval arguments initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,Testability,log,logic,37,"// It may be useful to separate this logic (of handling operand; // bundles) out to a separate ""policy"" component if this gets crowded.; // Prepend the parent's deoptimization continuation to the newly; // inlined call's deoptimization continuation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:91,Safety,avoid,avoid,91,"// For 'nodebug' functions, the associated DISubprogram is always null.; // Conservatively avoid propagating the callsite debug location to; // instructions inlined from a function whose DISubprogram is not null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:44,Modifiability,variab,variables,44,// Interpret inlined stores to caller-local variables as assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update DIAssignID metadata attachments and uses so that they are; // unique to this inlined instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:14,Energy Efficiency,reduce,reduce,14,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:90,Safety,avoid,avoid,90,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:458,Safety,safe,safe,458,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:96,Safety,avoid,avoid,96,"// Call sites inlined through a 'nounwind' call site should be; // 'nounwind' as well. However, avoid marking call sites explicitly; // where possible. This helps expose more opportunities for CSE after; // inlining, commonly when the callee is an intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:163,Security,expose,expose,163,"// Call sites inlined through a 'nounwind' call site should be; // 'nounwind' as well. However, avoid marking call sites explicitly; // where possible. This helps expose more opportunities for CSE after; // inlining, commonly when the callee is an intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:157,Safety,avoid,avoid,157,"// Leave lifetime markers for the static alloca's, scoping them to the; // function we just inlined.; // We need to insert lifetime intrinsics even at O0 to avoid invalid; // access caused by multithreaded coroutines. The check; // `Caller->isPresplitCoroutine()` would affect AlwaysInliner at O0 only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:175,Security,access,access,175,"// Leave lifetime markers for the static alloca's, scoping them to the; // function we just inlined.; // We need to insert lifetime intrinsics even at O0 to avoid invalid; // access caused by multithreaded coroutines. The check; // `Caller->isPresplitCoroutine()` would affect AlwaysInliner at O0 only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:112,Availability,redundant,redundant,112,"// If the alloca is already scoped to something smaller than the whole; // function then there's no need to add redundant, less accurate markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:112,Safety,redund,redundant,112,"// If the alloca is already scoped to something smaller than the whole; // function then there's no need to add redundant, less accurate markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:62,Integrability,wrap,wrap,62,"// If the inlined code contained dynamic alloca instructions, wrap the inlined; // code with llvm.stacksave/llvm.stackrestore intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:70,Modifiability,rewrite,rewrite,70,"// If we are inlining for an invoke instruction, we must make sure to rewrite; // any call instructions into invoke instructions. This is sensitive to which; // funclet pads were top-level in the inlinee, so must be done before; // rewriting the ""parent pad"" links.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update the lexical scopes of the new funclets and callsites.; // Anything that had 'none' as its parent is now nested inside the callsite's; // EHPad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:186,Safety,safe,safe,186,"// Handle any inlined musttail call sites. In order for a new call site to be; // musttail, the source of the clone and the inlined call site must have been; // musttail. Therefore it's safe to return without merging control into the; // phi below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:242,Deployability,update,updates,242,"// Now that all of the transforms on the inlined code have taken place but; // before we splice the inlined code into the CFG and lose track of which; // blocks were actually inlined, collect the call sites. We only do this if; // call graph updates weren't requested, as those provide value handle based; // tracking of inlined call sites instead. Calls to intrinsics are not; // collected because they are not inlineable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:233,Integrability,depend,depends,233,"// Otherwise, we have the normal case, of more than one block to inline or; // multiple return sites.; // We want to clone the entire callee function into the hole between the; // ""starter"" and ""ender"" blocks. How we accomplish this depends on whether; // this is an invoke instruction or a call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:80,Deployability,update,updated,80,"// Split the basic block. This guarantees that no PHI nodes will have to be; // updated due to new incoming edges, and make the invoke case more; // symmetric to the call case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update PHI nodes that use the ReturnBB to use the AfterCallBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update PHI nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:170,Performance,optimiz,optimizations,170,"// If we inserted a phi node, check to see if it has a single value (e.g. all; // the entries are the same or undef). If so, remove the PHI so it doesn't; // block other optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp:500,Performance,optimiz,optimization,500,"//===- InstructionNamer.cpp - Give anonymous instructions names -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that gives instructions names, this is mostly; // useful when diffing the effect of an optimization because deleting an; // unnamed instruction can change all other instruction numbering, making the; // diff very noisy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:615,Performance,tune,tuned,615,"//===-- IntegerDivision.cpp - Expand integer division ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an implementation of 32bit and 64bit scalar integer; // division for targets that don't have native support. It's largely derived; // from compiler-rt's implementations of __udivsi3 and __udivmoddi4,; // but hand-tuned for targets that prefer less control flow.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:165,Performance,tune,tuned,165,"// The basic algorithm can be found in the compiler-rt project's; // implementation of __udivsi3.c. Here, we do a lower-level IR based approach; // that's been hand-tuned to lessen the amount of control flow involved.; // Some helper values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:106,Integrability,rout,routines,106,"/// Generate code to compute the remainder of two integers of bitwidth up to; /// 32 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 32 bits; that is, these routines are good for targets; /// that have no or very little suppport for smaller than 32 bit integer; /// arithmetic.; ///; /// Replace Rem with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:203,Integrability,rout,routines,203,"/// Generate code to compute the remainder of two integers of bitwidth up to; /// 32 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 32 bits; that is, these routines are good for targets; /// that have no or very little suppport for smaller than 32 bit integer; /// arithmetic.; ///; /// Replace Rem with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:119,Modifiability,extend,extends,119,"/// Generate code to compute the remainder of two integers of bitwidth up to; /// 32 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 32 bits; that is, these routines are good for targets; /// that have no or very little suppport for smaller than 32 bit integer; /// arithmetic.; ///; /// Replace Rem with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:106,Integrability,rout,routines,106,/// Generate code to compute the remainder of two integers of bitwidth up to; /// 64 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 64 bits.; ///; /// Replace Rem with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:119,Modifiability,extend,extends,119,/// Generate code to compute the remainder of two integers of bitwidth up to; /// 64 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 64 bits.; ///; /// Replace Rem with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:88,Integrability,rout,routines,88,"/// Generate code to divide two integers of bitwidth up to 32 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 32 bits; that is, these routines are good for targets that have no; /// or very little support for smaller than 32 bit integer arithmetic.; ///; /// Replace Div with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:185,Integrability,rout,routines,185,"/// Generate code to divide two integers of bitwidth up to 32 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 32 bits; that is, these routines are good for targets that have no; /// or very little support for smaller than 32 bit integer arithmetic.; ///; /// Replace Div with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:101,Modifiability,extend,extends,101,"/// Generate code to divide two integers of bitwidth up to 32 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 32 bits; that is, these routines are good for targets that have no; /// or very little support for smaller than 32 bit integer arithmetic.; ///; /// Replace Div with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:88,Integrability,rout,routines,88,/// Generate code to divide two integers of bitwidth up to 64 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 64 bits.; ///; /// Replace Div with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:101,Modifiability,extend,extends,101,/// Generate code to divide two integers of bitwidth up to 64 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 64 bits.; ///; /// Replace Div with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:824,Availability,redundant,redundant,824,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:966,Performance,optimiz,optimizations,966,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:824,Safety,redund,redundant,824,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:1010,Usability,simpl,simpler,1010,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:156,Modifiability,rewrite,rewrite,156,"/// For every instruction from the worklist, check to see if it has any uses; /// that are outside the current loop. If so, insert LCSSA PHI nodes and; /// rewrite the uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Performance,Cache,Cache,3,"// Cache the Loop ExitBlocks across this loop. We expect to get a lot of; // instructions within the same loops, computing the exit blocks is; // expensive, and we're not mutating the loop structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:112,Availability,avail,available,112,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:162,Testability,test,tests,162,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:313,Usability,usab,usable,313,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:42,Availability,alive,alive,42,// Remember that this phi makes the value alive in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:30,Usability,simpl,simplify,30,"// LoopSimplify might fail to simplify some loops (e.g. when indirect; // branches are involved). In such situations, it might happen that an; // exit for Loop L1 is the header of a disjoint Loop L2. Thus, when we; // create PHIs in such an exit block, we are also inserting PHIs into L2's; // header. This could break LCSSA form for L2 because these inserted PHIs; // can also have uses outside of L2. Remember all PHIs in such situation; // as to revisit than later on. FIXME: Remove this if indirectbr support; // into LoopSimplify gets improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:16,Performance,cache,cached,16,"// If we have a cached SCEV for the original instruction, make sure the; // new LCSSA phi node is also cached. This makes sures that BECounts; // based on it will be invalidated when the LCSSA phi node is invalidated,; // which some passes rely on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:103,Performance,cache,cached,103,"// If we have a cached SCEV for the original instruction, make sure the; // new LCSSA phi node is also cached. This makes sures that BECounts; // based on it will be invalidated when the LCSSA phi node is invalidated,; // which some passes rely on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all uses outside the loop in terms of the new PHIs we just; // inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:36,Modifiability,rewrite,rewrite,36,"// If this use is in an exit block, rewrite to use the newly inserted PHI.; // This is required for correctness because SSAUpdate doesn't handle uses; // in the same block. It assumes the PHI we inserted is at the end of the; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Deployability,Update,Update,3,// Update pre-existing debug value uses that reside outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:87,Deployability,update,update,87,// Post process PHI instructions that were inserted into another disjoint; // loop and update their exits properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:539,Availability,redundant,redundant,539,"// Remove PHI nodes that did not have any uses rewritten or add them to; // PHIsToRemove, so the caller can remove them after some additional cleanup.; // We need to redo the use_empty() check here, because even if the PHI node; // wasn't used when added to LocalPHIsToRemove, later added PHI nodes can be; // using it. This cleanup is not guaranteed to handle trees/cycles of PHI; // nodes that only are used by each other. Such situations has only been; // noticed when the input IR contains unreachable code, and leaving some extra; // redundant PHI nodes in such situations is considered a minor problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:539,Safety,redund,redundant,539,"// Remove PHI nodes that did not have any uses rewritten or add them to; // PHIsToRemove, so the caller can remove them after some additional cleanup.; // We need to redo the use_empty() check here, because even if the PHI node; // wasn't used when added to LocalPHIsToRemove, later added PHI nodes can be; // using it. This cleanup is not guaranteed to handle trees/cycles of PHI; // nodes that only are used by each other. Such situations has only been; // noticed when the input IR contains unreachable code, and leaving some extra; // redundant PHI nodes in such situations is considered a minor problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:14,Safety,avoid,avoid,14,"// We want to avoid use-scanning leveraging dominance informations.; // If a block doesn't dominate any of the loop exits, the none of the values; // defined in the loop can be used outside.; // We compute the set of blocks fullfilling the conditions in advance; // walking the dominator tree upwards until we hit a loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:138,Modifiability,rewrite,rewrite,138,"// Look at all the instructions in the loop, checking to see if they have uses; // outside the loop. If so, put them into the worklist to rewrite those uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Performance,Cache,Cached,3,// Cached analysis information for the current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:21,Performance,perform,perform,21,// This is needed to perform LCSSA verification inside LPPassManager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:80,Deployability,update,updates,80,"// BPI maps terminators to probabilities, since we don't modify the CFG, no; // updates are needed to preserve it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:739,Availability,error,error,739,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:793,Availability,error,error,793,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:991,Availability,error,error,991,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:400,Integrability,wrap,wraps,400,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:816,Integrability,depend,depends,816,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:943,Integrability,wrap,wrap,943,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:863,Performance,optimiz,optimization,863,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:678,Safety,safe,safely,678,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:1149,Security,expose,exposed,1149,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:92,Availability,error,error,92,// end anonymous namespace; // Perform the transformation to calls with errno set by domain error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:31,Performance,Perform,Perform,31,// end anonymous namespace; // Perform the transformation to calls with errno set by domain error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:63,Availability,error,error,63,// Perform the transformation to calls with errno set by range error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Performance,Perform,Perform,3,// Perform the transformation to calls with errno set by range error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:72,Availability,error,errors,72,// Perform the transformation to calls with errno set by combination of errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Performance,Perform,Perform,3,// Perform the transformation to calls with errno set by combination of errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:243,Availability,error,error,243,"// A possible improvement is to handle the calls with the return value being; // used. If there is API for fast libcall implementation without setting; // errno, we can use the same framework to direct/wrap the call to the fast; // API in the error free path, and leave the original call in the slow path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:202,Integrability,wrap,wrap,202,"// A possible improvement is to handle the calls with the return value being; // used. If there is API for fast libcall implementation without setting; // errno, we can use the same framework to direct/wrap the call to the fast; // API in the error free path, and leave the original call in the slow path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Integrability,Wrap,Wrap,3,// Wrap conditions that can potentially generate errno to the library call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Performance,Perform,Perform,3,// Perform the transformation to a single candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:36,Deployability,update,updated,36,// Verify the dominator after we've updated it locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:32,Performance,perform,perform,32,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:408,Performance,perform,perform,408,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:53,Safety,detect,detecting,53,// Max recursion depth for collectBitParts used when detecting bswap and; // bitreverse idioms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:394,Deployability,update,updated,394,"//===----------------------------------------------------------------------===//; // Local constant propagation.; //; /// ConstantFoldTerminator - If a terminator instruction is predicated on a; /// constant value, convert it into an unconditional branch to the constant; /// destination. This is a nontrivial operation because the successors of this; /// basic block must have their PHI nodes updated.; /// Also calls RecursivelyDeleteTriviallyDeadInstructions() on any branch/switch; /// conditions and indirectbr addresses this might make dead if; /// DeleteDeadConditions is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:9,Performance,optimiz,optimize,9,// Can't optimize uncond branch,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:78,Deployability,update,update,78,"// Removing this case may have made the condition constant. In that; // case, update CI and restart iteration through the cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update make.implicit metadata to the newly-created conditional branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:191,Usability,simpl,simple,191,"// Guards on true are operationally no-ops. In the future we can; // consider more sophisticated tradeoffs for guards considering potential; // for check widening, but for now we keep things simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:34,Safety,safe,safe,34,"// TODO: These intrinsics are not safe to remove, because this may remove; // a well-defined trap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Safe,Safe,3,// Safe to delete llvm.stacksave and launder.invariant.group if dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:23,Performance,load,loads,23,// Non-volatile atomic loads from constants can be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:4,Usability,Simpl,SimplifyInstructionsInBlock,4,"/// SimplifyInstructionsInBlock - Scan the specified basic block and try to; /// simplify any instructions in it and recursively delete dead instructions.; ///; /// This returns true if it changed the code, note that it can delete; /// instructions in other blocks as well in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:81,Usability,simpl,simplify,81,"/// SimplifyInstructionsInBlock - Scan the specified basic block and try to; /// simplify any instructions in it and recursively delete dead instructions.; ///; /// This returns true if it changed the code, note that it can delete; /// instructions in other blocks as well in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:102,Usability,simpl,simplifications,102,"// In debug builds, ensure that the terminator of the block is never replaced; // or deleted by these simplifications. The idea of simplification is that it; // cannot introduce new instructions, and there is no way to replace the; // terminator of a block without introducing a new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:131,Usability,simpl,simplification,131,"// In debug builds, ensure that the terminator of the block is never replaced; // or deleted by these simplifications. The idea of simplification is that it; // cannot introduce new instructions, and there is no way to replace the; // terminator of a block without introducing a new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:121,Safety,avoid,avoids,121,"// Iterate over the original function, only adding insts to the worklist; // if they actually need to be revisited. This avoids having to pre-init; // the worklist with the entire function's worth of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:7,Deployability,update,updates,7,// DTU updates: Collect all the edges that enter; // PredBB. These dominator edges will be redirected to DestBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:6,Safety,avoid,avoid,6,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,Integrability,interface,interface,56,// The entry block was removed and there is no external interface for; // the dominator tree to be notified of this change. In this corner-case; // we recalculate the entire tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:91,Safety,safe,safe,91,"// Shortcut, if there is only a single predecessor it must be BB and merging; // is always safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:224,Deployability,Update,Update,224,/// Determines the value to use as the phi node input for a block.; ///; /// Select between \p OldVal any value that we know flows from \p BB; /// to a particular phi on the basis of which one (if either) is not; /// undef. Update IncomingValues based on the selected value.; ///; /// \param OldVal The value we are considering selecting.; /// \param BB The block that the value flows in from.; /// \param IncomingValues A map from block-to-value for other phi inputs; /// that we have examined.; ///; /// \returns the selected value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:181,Deployability,update,update,181,"// We are merging two blocks - BB, and the block containing PN - and; // as a result we need to redirect edges from the predecessors of BB; // to go to the block containing PN, and update PN; // accordingly. Since we allow merging blocks in the case where the; // predecessor and successor blocks both share some predecessors,; // and where some of those common predecessors might have undef; // values flowing into PN, we want to rewrite those values to be; // consistent with the non-undef values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:431,Modifiability,rewrite,rewrite,431,"// We are merging two blocks - BB, and the block containing PN - and; // as a result we need to redirect edges from the predecessors of BB; // to go to the block containing PN, and update PN; // accordingly. Since we allow merging blocks in the case where the; // predecessor and successor blocks both share some predecessors,; // and where some of those common predecessors might have undef; // values flowing into PN, we want to rewrite those values to be; // consistent with the non-undef values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:219,Testability,assert,asserts,219,"// Note that, since we are merging phi nodes and BB and Succ might; // have common predecessors, we could end up with a phi node with; // identical incoming branches. This will be cleaned up later (and; // will trigger asserts if we try to clean it up now, without also; // simplifying the corresponding conditional branch).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:274,Usability,simpl,simplifying,274,"// Note that, since we are merging phi nodes and BB and Succ might; // have common predecessors, we could end up with a phi node with; // identical incoming branches. This will be cleaned up later (and; // will trigger asserts if we try to clean it up now, without also; // simplifying the corresponding conditional branch).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update existing incoming values in PN for this; // predecessor of BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:12,Usability,simpl,simplify,12,// We can't simplify infinite loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:126,Safety,safe,safely,126,"// Check to see if merging these blocks/phis would cause conflicts for any of; // the phi nodes in BB or Succ. If not, we can safely merge.; // Check for cases where Succ has multiple predecessors and a PHI node in BB; // has uses which will not disappear when the PHI nodes are merged. It is; // possible to handle such cases, but difficult: it requires checking whether; // BB dominates Succ, which is non-trivial to calculate in the case where; // Succ has multiple predecessors. Also, it requires checking whether; // constructing the necessary self-referential PHI node doesn't introduce any; // conflicts; this isn't too difficult, but the previous code for doing this; // was incorrect.; //; // Note that if this check finds a live use, BB dominates Succ, so BB is; // something like a loop pre-header (or rarely, a part of an irreducible CFG);; // folding the branch isn't profitable in that case anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:6,Safety,avoid,avoid,6,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:43,Deployability,update,updates,43,// Clear the successor list of BB to match updates applying to DTU later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Usability,Clear,Clear,3,// Clear the successor list of BB to match updates applying to DTU later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:17,Testability,log,logic,17,// WARNING: this logic must be kept in sync with; // Instruction::isIdenticalToWhenDefined()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:166,Safety,safe,safe,166,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:13,Security,hash,hash,13,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:99,Security,expose,expose,99,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:20,Security,hash,hash,20,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:85,Security,hash,hashing,85,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:243,Security,hash,hash,243,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:169,Testability,assert,assertion,169,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:73,Security,hash,hash,73,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:40,Testability,assert,assert,40,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:104,Safety,avoid,avoids,104,// If the preferred alignment is greater than the natural stack alignment; // then don't round up. This avoids dynamic stack realignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:222,Availability,reliab,reliably,222,"// If there is a large requested alignment and we can, bump up the alignment; // of the global. If the memory we set aside for the global may not be the; // memory used by the final program then it is impossible for us to reliably; // enforce the preferred alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Avoid,Avoid,3,"// Avoid trouble with ridiculously large TrailZ values, such as; // those computed from a null pointer.; // LLVM doesn't support alignments larger than (1 << MaxAlignmentExponent).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:48,Modifiability,variab,variable,48,// We can't always calculate the size of the DI variable (e.g. if it is a; // VLA). Try to use the size of the alloca that the dbg intrinsic describes; // intead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,// Could not determine size of variable. Conservatively return false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:48,Modifiability,variab,variable,48,// We can't always calculate the size of the DI variable (e.g. if it is a; // VLA). Try to use the size of the alloca that the dbg intrinsic describes; // intead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,// Could not determine size of variable. Conservatively return false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,Energy Efficiency,allocate,allocate,56,"// RemoveDIs: if we're using the new debug-info format, allocate a; // DPValue directly instead of a dbg.value intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,Energy Efficiency,allocate,allocate,56,"// RemoveDIs: if we're using the new debug-info format, allocate a; // DPValue directly instead of a dbg.value intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:601,Modifiability,variab,variable,601,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:666,Modifiability,variab,variable,666,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:132,Performance,perform,perform,132,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:38,Modifiability,variab,variable,38,"// FIXME: If storing to a part of the variable described by the dbg.declare,; // then we want to insert a dbg.value for the corresponding fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:50,Modifiability,variab,variable,50,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:175,Modifiability,variab,variable,175,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a dbg.value for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:27,Performance,load,loaded,27,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:181,Performance,load,loaded,181,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:601,Modifiability,variab,variable,601,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:666,Modifiability,variab,variable,666,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:132,Performance,perform,perform,132,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:38,Modifiability,variab,variable,38,"// FIXME: If storing to a part of the variable described by the dbg.declare,; // then we want to insert a dbg.value for the corresponding fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:50,Modifiability,variab,variable,50,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:175,Modifiability,variab,variable,175,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a dbg.value for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a DPValue for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:27,Performance,load,loaded,27,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:181,Performance,load,loaded,181,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a DPValue for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:37,Modifiability,variab,variable,37,"// If this is an alloca for a scalar variable, insert a dbg.value; // at each load and store to the alloca and erase the dbg.declare.; // The dbg.values allow tracking a variable even if it is not; // stored on the stack, while the dbg.declare can only describe; // the stack slot (and at a lexical-scope granularity). Later; // passes will attempt to elide the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:170,Modifiability,variab,variable,170,"// If this is an alloca for a scalar variable, insert a dbg.value; // at each load and store to the alloca and erase the dbg.declare.; // The dbg.values allow tracking a variable even if it is not; // stored on the stack, while the dbg.declare can only describe; // the stack slot (and at a lexical-scope granularity). Later; // passes will attempt to elide the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:78,Performance,load,load,78,"// If this is an alloca for a scalar variable, insert a dbg.value; // at each load and store to the alloca and erase the dbg.declare.; // The dbg.values allow tracking a variable even if it is not; // stored on the stack, while the dbg.declare can only describe; // the stack slot (and at a lexical-scope granularity). Later; // passes will attempt to elide the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:14,Performance,load,load,14,// A volatile load/store means that the alloca can't be elided anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:85,Modifiability,variab,variable,85,// This is a call by-value or some other instruction that takes a; // pointer to the variable. Insert a *value* intrinsic that describes; // the variable by dereferencing the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:145,Modifiability,variab,variable,145,// This is a call by-value or some other instruction that takes a; // pointer to the variable. Insert a *value* intrinsic that describes; // the variable by dereferencing the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:197,Deployability,update,update,197,"// Map a pair of the destination BB and old DPValue to the new DPValue,; // so that if a DPValue is being rewritten to use more than one of the; // inserted PHIs in the same destination BB, we can update the same DPValue; // with all the new PHIs instead of creating one copy for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:288,Deployability,update,updates,288,"// Then iterate through the new PHIs and look to see if they use one of the; // previously mapped PHIs. If so, create a new DPValue that will propagate; // the info through the new PHI. If we use more than one new PHI in a single; // destination BB with the same old dbg.value, merge the updates so that we; // get a single new DPValue with all the new PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Avoid,Avoid,3,// Avoid inserting a debug-info record into an EH block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:203,Deployability,update,update,203,"// Map a pair of the destination BB and old dbg.value to the new dbg.value,; // so that if a dbg.value is being rewritten to use more than one of the; // inserted PHIs in the same destination BB, we can update the same dbg.value; // with all the new PHIs instead of creating one copy for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:300,Deployability,update,updates,300,"// Then iterate through the new PHIs and look to see if they use one of the; // previously mapped PHIs. If so, create a new dbg.value intrinsic that will; // propagate the info through the new PHI. If we use more than one new PHI in; // a single destination BB with the same old dbg.value, merge the updates so; // that we get a single new dbg.value with all the new PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Avoid,Avoid,3,// Avoid inserting an intrinsic into an EH block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:151,Performance,perform,performance,151,"// These are arbitrary chosen limits on the maximum number of values and the; // maximum size of a debug expression we can salvage up to, used for; // performance reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:88,Deployability,update,updated,88,"// `I` may appear more than once in DII's location ops, and each use of `I`; // must be updated in the DIExpression and potentially have additional; // values added; thus we call salvageDebugInfoImpl for each `I` instance in; // DIILocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:88,Deployability,update,updated,88,"// 'I' may appear more than once in DPV's location ops, and each use of 'I'; // must be updated in the DIExpression and potentially have additional; // values added; thus we call salvageDebugInfoImpl for each 'I' instance in; // DPVLocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite a GEP into a DIExpression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:74,Usability,simpl,simplified,74,// Add or Sub Instructions with a constant operand can potentially be; // simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:49,Performance,load,load,49,"// *Not* to do: we should not attempt to salvage load instructions,; // because the validity and lifetime of a dbg.value containing; // DW_OP_deref becomes difficult to analyze. See PR40628 for examples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:114,Deployability,update,update,114,// It's common to see a debug user between From and DomPoint. Move it; // after DomPoint to preserve the variable update without any reordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:105,Modifiability,variab,variable,105,// It's common to see a debug user between From and DomPoint. Move it; // after DomPoint to preserve the variable update without any reordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update debug users without use-before-def risk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Safety,risk,risk,45,// Update debug users without use-before-def risk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:92,Availability,avail,available,92,// Handle integer-to-integer widening and narrowing.; // FIXME: Use DW_OP_convert when it's available everywhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:134,Modifiability,variab,variable,134,"// When the width of the result grows, assume that a debugger will only; // access the low `FromBits` bits when inspecting the source variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:76,Security,access,access,76,"// When the width of the result grows, assume that a debugger will only; // access the low `FromBits` bits when inspecting the source variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:90,Modifiability,variab,variable,90,// The width of the result has shrunk. Use sign/zero extension to describe; // the source variable's high bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update PHI nodes in the unwind destination,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:99,Safety,avoid,avoided,99,"// Note: we're round tripping operand bundles through memory here, and that; // can potentially be avoided with a cleverer API design that we do not have; // as of this time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:77,Deployability,update,updates,77,"// Make sure that anything using the call now uses the invoke! This also; // updates the CallGraph if present, because it uses a WeakTrackingVH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:165,Performance,optimiz,optimizer,165,"// Assumptions that are known to be false are equivalent to; // unreachable. Also, if the condition is undefined, then we make the; // choice most beneficial to the optimizer, and choose that to also be; // unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:39,Performance,load,load,39,"// If K moves, only set the !invariant.load if it is present in both; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:22,Security,access,access,22,// Preserve !preserve.access.index in K.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:171,Performance,load,load,171,"// Set !invariant.group from J if J has it. If both instructions have it; // then we will just pick it from J - even when they are different.; // Also make sure that K is load or store - f.e. combining bitcast with load; // could produce bitcast with invariant.group metadata, which is invalid.; // FIXME: we should try to preserve both invariant.group md if they are; // different, but right now instruction can only have one invariant.group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:215,Performance,load,load,215,"// Set !invariant.group from J if J has it. If both instructions have it; // then we will just pick it from J - even when they are different.; // Also make sure that K is load or store - f.e. combining bitcast with load; // could produce bitcast with invariant.group metadata, which is invalid.; // FIXME: we should try to preserve both invariant.group md if they are; // different, but right now instruction can only have one invariant.group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:79,Integrability,rout,routine,79,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:110,Performance,load,load,110,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:462,Performance,load,loads,462,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Patch,Patch,3,// Patch the replacement so that it is not more restrictive than the value; // being replaced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:25,Performance,load,load,25,"// Note that if 'I' is a load being replaced by some operation,; // for example, by an arithmetic operation, then andIRFlags(); // would just erase all math flags from the original arithmetic; // operation, which is clearly not wanted and not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:216,Usability,clear,clearly,216,"// Note that if 'I' is a load being replaced by some operation,; // for example, by an arithmetic operation, then andIRFlags(); // would just erase all math flags from the original arithmetic; // operation, which is clearly not wanted and not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:36,Safety,safe,safepoints,36,// Most LLVM intrinsics do not take safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:100,Availability,avail,available,100,"// Lib calls can be materialized by some passes, and won't be; // marked as 'gc-leaf-function.' All available Libcalls are; // GC-leaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:55,Performance,load,loads,55,// The only other translation we can do is to integral loads with !range; // metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Usability,Simpl,Simply,3,// Simply copy the metadata if the type did not change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:107,Availability,reliab,reliably,107,"// Give up unless it is converted to a pointer where there is a single very; // valuable mapping we can do reliably.; // FIXME: It would be nice to propagate this in more ways, but the type; // conversions make it hard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:863,Modifiability,Extend,Extend,863,"// Since we are moving the instructions out of its basic block, we do not; // retain their original debug locations (DILocations) and debug intrinsic; // instructions.; //; // Doing so would degrade the debugging experience and adversely affect the; // accuracy of profiling information.; //; // Currently, when hoisting the instructions, we take the following actions:; // - Remove their debug intrinsic instructions.; // - Set their debug locations to the values from the insertion point.; //; // As per PR39141 (comment #8), the more fundamental reason why the dbg.values; // need to be deleted, is because there will not be any instructions with a; // DILocation in either branch left after performing the transformation. We; // can only insert a dbg.value after the two branches are joined again.; //; // See PR38762, PR39243 for more details.; //; // TODO: Extend llvm.dbg.value to take more than one SSA Value (PR39141) to; // encode predicated DIExpressions that yield different results on different; // code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:695,Performance,perform,performing,695,"// Since we are moving the instructions out of its basic block, we do not; // retain their original debug locations (DILocations) and debug intrinsic; // instructions.; //; // Doing so would degrade the debugging experience and adversely affect the; // accuracy of profiling information.; //; // Currently, when hoisting the instructions, we take the following actions:; // - Remove their debug intrinsic instructions.; // - Set their debug locations to the values from the insertion point.; //; // As per PR39141 (comment #8), the more fundamental reason why the dbg.values; // need to be deleted, is because there will not be any instructions with a; // DILocation in either branch left after performing the transformation. We; // can only insert a dbg.value after the two branches are joined again.; //; // See PR38762, PR39243 for more details.; //; // TODO: Extend llvm.dbg.value to take more than one SSA Value (PR39141) to; // encode predicated DIExpressions that yield different results on different; // code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:16,Testability,log,logical,16,"// If this is a logical shift by a constant, recurse then shift the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Performance,Perform,Perform,3,"// Perform the ""shift"" on BitProvenance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:37,Availability,mask,mask,37,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:16,Testability,log,logical,16,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:47,Usability,clear,clears,47,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:18,Availability,mask,mask,18,"// Check that the mask allows a multiple of 8 bits for a bswap, for an; // early exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:40,Usability,clear,clear,40,"// If the AndMask is zero for this bit, clear the bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:38,Modifiability,extend,extend,38,// If this is a zext instruction zero extend the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:47,Performance,perform,perform,47,"// If the upper bits are zero, then attempt to perform as a truncated op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:105,Usability,simpl,simple,105,"// gcroot is a special case, since it requires a constant argument which; // isn't also required to be a simple ConstantInt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:17,Availability,mask,masks,17,// Shufflevector masks are constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:130,Testability,log,logic,130,// Note: We explicitly check for attributes rather than using cover functions; // because some of the cover functions include the logic being implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:47,Modifiability,variab,variable,47,"/// Given a loop with an deccreasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:80,Safety,safe,safely,80,"/// Given a loop with an deccreasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:58,Modifiability,variab,variable,58,// The predicate that we need to check that the induction variable lies; // within bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:46,Modifiability,variab,variable,46,"/// Given a loop with an increasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:79,Safety,safe,safely,79,"/// Given a loop with an increasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:58,Modifiability,variab,variable,58,// The predicate that we need to check that the induction variable lies; // within bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:81,Availability,avail,available,81,"/// Returns estimate for max latch taken count of the loop of the narrowest; /// available type. If the latch block has such estimate, it is returned.; /// Otherwise, we use max exit count of whole loop (that is potentially of wider; /// type than latch check itself), which is still better than no estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:88,Modifiability,variab,variable,88,// `ICI` is interpreted as taking the backedge if the *next* value of the; // induction variable satisfies some constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:46,Performance,optimiz,optimizations,46,// Add metadata to the loop L to disable loop optimizations. Callers need to; // confirm that optimizing loop L is not beneficial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:94,Performance,optimiz,optimizing,94,// Add metadata to the loop L to disable loop optimizations. Callers need to; // confirm that optimizing loop L is not beneficial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:108,Modifiability,variab,variable,108,"// IterationsLeft - are there any more iterations left, given the original; // upper bound on the induction variable? If not, we branch to the ""real""; // exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:111,Deployability,update,updated,111,// The latch exit now has a branch from `RRI.ExitSelector' instead of; // `LS.Latch'. The PHI nodes need to be updated to reflect that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:135,Deployability,update,update,135,"// We need to first add all the pre and post loop blocks into the loop; // structures (as part of createClonedLoopStructure), and then update the; // LCSSA form and LoopSimplifyForm. This is necessary for correctly updating; // LI when LoopSimplifyForm is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:50,Usability,Simpl,Simplify,50,// This function canonicalizes the loop into Loop-Simplify and LCSSA forms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:52,Performance,perform,perform,52,"// Pre/post loops are slow paths, we do not need to perform any loop; // optimizations on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:73,Performance,optimiz,optimizations,73,"// Pre/post loops are slow paths, we do not need to perform any loop; // optimizations on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:128,Modifiability,variab,variable,128,"/// At this point:; /// - We've broken a ""main loop"" out of the loop in a way that the ""main loop""; /// runs with the induction variable in a subset of [Begin, End).; /// - There is no overflow when computing ""main loop"" exit limit.; /// - Max latch taken count of the loop is limited.; /// It guarantees that induction variable will not overflow iterating in the; /// ""main loop"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:320,Modifiability,variab,variable,320,"/// At this point:; /// - We've broken a ""main loop"" out of the loop in a way that the ""main loop""; /// runs with the induction variable in a subset of [Begin, End).; /// - There is no overflow when computing ""main loop"" exit limit.; /// - Max latch taken count of the loop is limited.; /// It guarantees that induction variable will not overflow iterating in the; /// ""main loop"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:28,Usability,simpl,simplified,28,// Make sure the loop is in simplified form,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:429,Deployability,update,update,429,"// The latch must either be the only exiting block or all non-latch exit; // blocks have either a deopt or unreachable terminator or compose a chain of; // blocks where the last one is either deopt or unreachable terminated. Both; // deopt and unreachable terminators are a strong indication they are not; // taken. Note that this is a profitability check, not a legality check. Also; // note that LoopPeeling currently can only update the branch weights of latch; // blocks and branch weights to blocks with deopt or unreachable do not need; // updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:1745,Modifiability,variab,variable,1745," {; // int x = 0;; // int y = 0;; // int a = 0;; // for(int i = 0; i <100000; ++i) {; // g(x);; // x = y;; // g(a);; // y = a + 1;; // a = 5;; // }; // }; // Peeling 3 iterations is beneficial because the values for x, y and a; // become known. The IR for this loop looks something like the following:; //; // %i = phi i32 [ 0, %entry ], [ %inc, %if.end ]; // %a = phi i32 [ 0, %entry ], [ 5, %if.end ]; // %y = phi i32 [ 0, %entry ], [ %add, %if.end ]; // %x = phi i32 [ 0, %entry ], [ %y, %if.end ]; // ...; // tail call void @_Z1gi(i32 signext %x); // tail call void @_Z1gi(i32 signext %a); // %add = add nuw nsw i32 %a, 1; // %inc = add nuw nsw i32 %i, 1; // %exitcond = icmp eq i32 %inc, 100000; // br i1 %exitcond, label %for.cond.cleanup, label %for.body; //; // The arguments for the calls to g will become known after 3 iterations; // of the loop, because the phi nodes values become known after 3 iterations; // of the loop (ie, they are known on the 4th iteration, so peel 3 iterations).; // The first iteration has g(0), g(0); the second has g(0), g(5); the; // third has g(1), g(5) and the fourth (and all subsequent) have g(6), g(5).; // Now consider the phi nodes:; // %a is a phi with constants so it is determined after iteration 1.; // %y is a phi based on a constant and %a so it is determined on; // the iteration after %a is determined, so iteration 2.; // %x is a phi based on a constant and %y so it is determined on; // the iteration after %y, so iteration 3.; // %i is based on itself (and is an induction variable) so it is; // never determined.; // This means that peeling off 3 iterations will result in being able to; // remove the phi nodes for %a, %y, and %x. The arguments for the; // corresponding calls to g are determined and the code for computing; // x, y, and a can be removed.; //; // The PhiAnalyzer class calculates how many times a loop should be; // peeled based on the above analysis of the phi nodes in the loop while; // respecting the maximum specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:27,Safety,avoid,avoid,27,// Place Unknown to map to avoid infinite recursion. Such; // cycles can never stop on an invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:142,Performance,load,load,142,// unnamed namespace; // Try to find any invariant memory reads that will become dereferenceable in; // the remainder loop after peeling. The load must also be used (transitively); // by an exit condition. Returns the number of iterations to peel off (at the; // moment either 0 or 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:26,Performance,load,loads,26,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:119,Performance,load,loads,119,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:287,Performance,load,loads,287,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:356,Performance,load,load,356,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Safety,Avoid,Avoid,3,"// Avoid huge SCEV computations in the loop below, make sure we only; // consider AddRecs of the loop we are trying to peel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:12,Modifiability,extend,extending,12,// Check if extending the current DesiredPeelCount lets us evaluate Pred; // or !Pred in the loop body statically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:298,Availability,reliab,reliable,298,"// If we don't know the trip count, but have reason to believe the average; // trip count is low, peeling should be beneficial, since we will usually; // hit the peeled section.; // We only do this in the presence of profile information, since otherwise; // our estimates of the trip count are not reliable enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:4,Deployability,Update,Update,4,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:617,Energy Efficiency,reduce,reduces,617,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:639,Safety,avoid,avoid,639,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:186,Energy Efficiency,reduce,reduce,186,"// Don't set the probability of taking the edge from latch to loop header; // to less than 1:1 ratio (meaning Weight should not be lower than; // SubWeight), as this could significantly reduce the loop's hotness,; // which would be incorrect in the case of underestimating the trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:22,Deployability,update,updateBranchWeights,22,// See the comment on updateBranchWeights() for an explanation of what we; // do here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:16,Deployability,update,update,16,// Don't try to update weights for degenerate case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:67,Deployability,update,update,67,"// For each block in the original loop, create a new copy,; // and update the value map with the newly created values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:24,Availability,avail,available,24,"// If dominator tree is available, insert nodes to represent cloned blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:32,Integrability,depend,depends,32,"// Identify what other metadata depends on the cloned version. After; // cloning, replace the metadata with the corrected version for both; // memory instructions and noalias intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:19,Deployability,update,updated,19,// LastValueMap is updated with the values for the current loop; // which are used the next time this function is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:470,Performance,optimiz,optimizations,470,"/// Peel off the first \p PeelCount iterations of loop \p L.; ///; /// Note that this does not peel them off as a single straight-line block.; /// Rather, each iteration is peeled off separately, and needs to check the; /// exit condition.; /// For loops that dynamically execute \p PeelCount iterations or less; /// this provides a benefit, since the peeled off iterations, which account; /// for the bulk of dynamic execution, can be further simplified by scalar; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:444,Usability,simpl,simplified,444,"/// Peel off the first \p PeelCount iterations of loop \p L.; ///; /// Note that this does not peel them off as a single straight-line block.; /// Rather, each iteration is peeled off separately, and needs to check the; /// exit condition.; /// For loops that dynamically execute \p PeelCount iterations or less; /// this provides a benefit, since the peeled off iterations, which account; /// for the bulk of dynamic execution, can be further simplified by scalar; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:160,Integrability,rout,routes,160,"// Remember dominators of blocks we might reach through exits to change them; // later. Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can reach it from the peeled; // iterations too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:55,Deployability,update,update,55,"// If we have branch weight information, we'll want to update it for the; // newly created branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Deployability,Update,Update,3,// Update IDoms of the blocks reachable through exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Deployability,Update,Update,3,// Update Metadata for count of peeled off iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:25,Deployability,update,update,25,"// We modified the loop, update SE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:24,Deployability,update,update,24,// FIXME: Incrementally update loop-simplify,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:36,Usability,simpl,simplify,36,// FIXME: Incrementally update loop-simplify,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:453,Testability,test,test,453,"//===----------------- LoopRotationUtils.cpp -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides utilities to convert a loop into a loop with bottom test.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:6,Usability,simpl,simple,6,/// A simple loop rotation transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:4,Modifiability,Rewrite,RewriteUsesOfClonedInstructions,4,"/// RewriteUsesOfClonedInstructions - We just cloned the instructions from the; /// old header into the preheader. If there were uses of the values produced by; /// these instruction that were outside of the loop, we have to insert PHI nodes; /// to merge the two values. Do this now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:93,Modifiability,rewrite,rewrite,93,"// If there are no uses of the value (e.g. because it returns void), there; // is nothing to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:209,Availability,avail,available,209,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:160,Safety,avoid,avoid,160,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:209,Availability,avail,available,209,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:160,Safety,avoid,avoid,160,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:227,Availability,down,down,227,"// There is at least one non-deoptimizing exit.; //; // Note, that BasicBlock::getPostdominatingDeoptimizeCall is not exact,; // as it can conservatively return false for deoptimizing exits with; // complex enough control flow down to deoptimize call.; //; // That means here we can report success for a case where; // all exits are deoptimizing but one of them has complex enough; // control flow (e.g. with loops).; //; // That should be a very rare case and false positives for this function; // have compile-time effect only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Deployability,Update,Update,3,"// Update branch weights. Consider the following edge-counts:; //; // | |-------- |; // V V | V; // Br i1 ... | Br i1 ...; // | | | | |; // x| y| | becomes: | y0| |-----; // V V | | V V |; // Exit Loop | | Loop |; // | | | Br i1 ... |; // ----- | | | |; // x0| x1| y1 | |; // V V ----; // Exit; //; // The following must hold:; // - x == x0 + x1 # counts to ""exit"" must stay the same.; // - y0 == x - x0 == x1 # how often loop was entered at all.; // - y1 == y - y0 # How often loop was repeated (after first iter.).; //; // We cannot generally deduce how often we had a zero-trip count loop so we; // have to make a guess for how to distribute x among the new x0 and x1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:369,Safety,avoid,avoid,369,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:423,Safety,avoid,avoid,423,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:73,Usability,Simpl,SimplifiedLatch,73,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:311,Usability,simpl,simplified,311,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:335,Usability,Simpl,SimplifiedLatch,335,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:571,Usability,simpl,simplifying,571,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:95,Usability,simpl,simplified,95,"// Rotate if either the loop latch does *not* exit the loop, or if the loop; // latch was just simplified. Or if we think it will be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:27,Safety,avoid,avoid,27,"// When preparing for LTO, avoid rotating loops with calls that could be; // inlined during the LTO stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:68,Performance,cache,cached,68,"// We may hoist some instructions out of loop. In case if they were cached; // as ""loop variant"" or ""loop computable"", these caches must be dropped.; // We also may fold basic blocks, so cached block dispositions also need; // to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:125,Performance,cache,caches,125,"// We may hoist some instructions out of loop. In case if they were cached; // as ""loop variant"" or ""loop computable"", these caches must be dropped.; // We also may fold basic blocks, so cached block dispositions also need; // to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:187,Performance,cache,cached,187,"// We may hoist some instructions out of loop. In case if they were cached; // as ""loop variant"" or ""loop computable"", these caches must be dropped.; // We also may fold basic blocks, so cached block dispositions also need; // to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:28,Availability,avail,available,28,"// For PHI nodes, the value available in OldPreHeader is just the; // incoming value from OldPreHeader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:60,Safety,avoid,avoid,60,// Record all debug intrinsics preceding LoopEntryBranch to avoid; // duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:17,Security,hash,hashes,17,"// Build DPValue hashes for DPValues attached to the terminator, which isn't; // considered in the loop above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:151,Safety,avoid,avoids,151,"// Remember the local noalias scope declarations in the header. After the; // rotation, they must be duplicated and the scope must be cloned. This; // avoids unwanted interaction across iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:347,Availability,down,down,347,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:508,Safety,avoid,avoid,508,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:812,Safety,avoid,avoids,812,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:99,Safety,safe,safe,99,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:285,Safety,safe,safe,285,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:340,Safety,safe,safe,340,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Safety,Avoid,Avoid,3,// Avoid inserting the same intrinsic twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:89,Usability,simpl,simplifyable,89,"// With the operands remapped, see if the instruction constant folds or is; // otherwise simplifyable. This commonly occurs because the entry from PHI; // nodes allows icmps and other instructions to fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:115,Usability,simpl,simplified,115,"// MemorySSA cares whether the cloned instruction was inserted or not, and; // not whether it can be remapped to a simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:267,Integrability,depend,depending,267,"// There are noalias scope declarations:; // (general):; // Original: OrigPre { OrigHeader NewHeader ... Latch }; // after: (OrigPre+OrigHeader') { NewHeader ... Latch OrigHeader }; //; // with D: llvm.experimental.noalias.scope.decl,; // U: !noalias or !alias.scope depending on D; // ... { D U1 U2 } can transform into:; // (0) : ... { D U1 U2 } // no relevant rotation for this part; // (1) : ... D' { U1 U2 D } // D is part of OrigHeader; // (2) : ... D' U1' { U2 D U1 } // D, U1 are part of OrigHeader; //; // We now want to transform:; // (1) -> : ... D' { D U1 U2 D'' }; // (2) -> : ... D' U1' { D U2 D'' U1'' }; // D: original llvm.experimental.noalias.scope.decl; // D', U1': duplicate with replaced scopes; // D'', U1'': different duplicate with replaced scopes; // This ensures a safe fallback to 'may_alias' introduced by the rotate,; // as U1'' and U1' scopes will not be compatible wrt to the local restrict; // Clone the llvm.experimental.noalias.decl again for the NewHeader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:791,Safety,safe,safe,791,"// There are noalias scope declarations:; // (general):; // Original: OrigPre { OrigHeader NewHeader ... Latch }; // after: (OrigPre+OrigHeader') { NewHeader ... Latch OrigHeader }; //; // with D: llvm.experimental.noalias.scope.decl,; // U: !noalias or !alias.scope depending on D; // ... { D U1 U2 } can transform into:; // (0) : ... { D U1 U2 } // no relevant rotation for this part; // (1) : ... D' { U1 U2 D } // D is part of OrigHeader; // (2) : ... D' U1' { U2 D U1 } // D, U1 are part of OrigHeader; //; // We now want to transform:; // (1) -> : ... D' { D U1 U2 D'' }; // (2) -> : ... D' U1' { D U2 D'' U1'' }; // D: original llvm.experimental.noalias.scope.decl; // D', U1': duplicate with replaced scopes; // D'', U1'': different duplicate with replaced scopes; // This ensures a safe fallback to 'may_alias' introduced by the rotate,; // as U1'' and U1' scopes will not be compatible wrt to the local restrict; // Clone the llvm.experimental.noalias.decl again for the NewHeader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:44,Energy Efficiency,adapt,adapting,44,"// Keep the compile time impact low by only adapting the inserted block; // of instructions in the OrigPreHeader. This might result in slightly; // more aliasing between these instructions and those that were already; // present, but it will be much faster when the original PreHeader is; // large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:44,Modifiability,adapt,adapting,44,"// Keep the compile time impact low by only adapting the inserted block; // of instructions in the OrigPreHeader. This might result in slightly; // more aliasing between these instructions and those that were already; // present, but it will be much faster when the original PreHeader is; // large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Deployability,Update,Update,3,// Update MemorySSA before the rewrite call below changes the 1:1; // instruction:cloned_instruction_or_value mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:31,Modifiability,rewrite,rewrite,31,// Update MemorySSA before the rewrite call below changes the 1:1; // instruction:cloned_instruction_or_value mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:88,Deployability,update,update,88,"// If there were any uses of instructions in the duplicated block outside the; // loop, update them, inserting PHI nodes as required",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:113,Usability,simpl,simplified,113,"// At this point, we've finished our major CFG changes. As part of cloning; // the loop into the preheader we've simplified instructions and the; // duplicated conditional branch may now be branching on a constant. If it is; // branching on a constant and if that constant means that we enter the loop,; // then we fold away the cond branch to an uncond branch. This simplifies the; // loop in cases important for nested loops, and it also means we don't have; // to split as many edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:367,Usability,simpl,simplifies,367,"// At this point, we've finished our major CFG changes. As part of cloning; // the loop into the preheader we've simplified instructions and the; // duplicated conditional branch may now be branching on a constant. If it is; // branching on a constant and if that constant means that we enter the loop,; // then we fold away the cond branch to an uncond branch. This simplifies the; // loop in cases important for nested loops, and it also means we don't have; // to split as many edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:78,Usability,simpl,simpler,78,"// We can fold the conditional branch in the preheader, this makes things; // simpler. The first step is to remove the extra edge to the Exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:51,Availability,avail,available,51,"// With our CFG finalized, update DomTree if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:27,Deployability,update,update,27,"// With our CFG finalized, update DomTree if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:23,Availability,avail,available,23,"// Update MSSA too, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Deployability,Update,Update,3,"// Update MSSA too, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:217,Modifiability,extend,extend,217,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:194,Performance,perform,performance,194,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:206,Performance,bottleneck,bottleneck,206,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:60,Safety,safe,safely,60,/// Determine whether the instructions in this range may be safely and cheaply; /// speculated. This is not an important enough situation to develop complex; /// heuristics. We handle a single arithmetic instruction along with any type; /// conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:406,Availability,down,downstream,406,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:156,Usability,simpl,simple,156,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:344,Usability,simpl,simplifyLoopLatch,344,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:71,Performance,cache,cache,71,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:88,Performance,cache,cache,88,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:78,Usability,Clear,Clear,78,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Usability,Simpl,Simplify,3,// Simplify the loop latch before attempting to rotate the header; // upward. Rotation may not be needed if the loop tail can be folded into the; // loop exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:58,Testability,test,test,58,/// The utility to convert a loop into a loop with bottom test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:1859,Deployability,update,updates,1859,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:393,Performance,perform,performs,393,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:464,Usability,simpl,simpler,464,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:530,Usability,simpl,simpler,530,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:709,Usability,simpl,simplifies,709,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:1050,Usability,simpl,simplifies,1050,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:1654,Usability,simpl,simplifycfg,1654,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:588,Availability,avail,available,588,"// Treat the presence of convergent functions conservatively. The; // transformation is invalid if calls to certain convergent; // functions (like an AMDGPU barrier) get included in the resulting; // inner loop. But blocks meant for the inner loop will be; // identified later at a point where it's too late to abort the; // transformation. Also, the convergent attribute is not really; // sufficient to express the semantics of functions that are; // affected by this transformation. So we choose to back off if such; // a function call is present until a better alternative becomes; // available. This is similar to the conservative treatment of; // convergent function calls in GVNHoist and JumpThreading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:311,Safety,abort,abort,311,"// Treat the presence of convergent functions conservatively. The; // transformation is invalid if calls to certain convergent; // functions (like an AMDGPU barrier) get included in the resulting; // inner loop. But blocks meant for the inner loop will be; // identified later at a point where it's too late to abort the; // transformation. Also, the convergent attribute is not really; // sufficient to express the semantics of functions that are; // affected by this transformation. So we choose to back off if such; // a function call is present until a better alternative becomes; // available. This is similar to the conservative treatment of; // convergent function calls in GVNHoist and JumpThreading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:39,Integrability,depend,depends,39,// Unique backedge insertion currently depends on having a preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:9,Performance,optimiz,optimization,9,"// As an optimization, if all incoming values in the new PhiNode (which is a; // subset of the incoming values of the old PHI node) have the same value,; // eliminate the PHI Node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:9,Deployability,Update,Update,9,//===--- Update all analyses which we must preserve now -----------------===//; // Update Loop Information - we know that this block is now in the current; // loop and all parent loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:83,Deployability,Update,Update,83,//===--- Update all analyses which we must preserve now -----------------===//; // Update Loop Information - we know that this block is now in the current; // loop and all parent loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:3,Deployability,Update,Update,3,// Update dominator information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:26,Performance,queue,queue,26,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:4,Usability,Simpl,Simplify,4,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:50,Usability,simpl,simplification,50,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:135,Usability,simpl,simplify,135,"// If there are exiting blocks with branches on undef, resolve the undef in; // the direction which will exit the loop. This will help simplify loop; // trip count computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:66,Usability,clear,clear,66,// GCC doesn't tail recursion eliminate this.; // FIXME: It isn't clear we can't rely on LLVM to TRE this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:160,Availability,down,down,160,"// Scan over the PHI nodes in the loop header. Since they now have only two; // incoming values (the loop is canonicalized), we may have simplified the PHI; // down to 'X = phi [X, Y]', which should be replaced with 'Y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:137,Usability,simpl,simplified,137,"// Scan over the PHI nodes in the loop header. Since they now have only two; // incoming values (the loop is canonicalized), we may have simplified the PHI; // down to 'X = phi [X, Y]', which should be replaced with 'Y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:212,Usability,Simpl,SimplifyCFG,212,"// If this loop has multiple exits and the exits all go to the same; // block, attempt to merge the exits. This helps several passes, such; // as LoopRotation, which do not support loops with multiple exits.; // SimplifyCFG also does this (and this code uses the same utility; // function), however this code is loop-aware, where SimplifyCFG is; // not. That gives it the advantage of being able to hoist; // loop-invariant instructions out of the way to open up more; // opportunities, and the disadvantage of having the responsibility; // to preserve dominator information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:330,Usability,Simpl,SimplifyCFG,330,"// If this loop has multiple exits and the exits all go to the same; // block, attempt to merge the exits. This helps several passes, such; // as LoopRotation, which do not support loops with multiple exits.; // SimplifyCFG also does this (and this code uses the same utility; // function), however this code is loop-aware, where SimplifyCFG is; // not. That gives it the advantage of being able to hoist; // loop-invariant instructions out of the way to open up more; // opportunities, and the disadvantage of having the responsibility; // to preserve dominator information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:26,Usability,clear,cleared,26,// The block has now been cleared of all instructions except for; // a comparison and a conditional branch. SimplifyCFG may be able; // to fold it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:108,Usability,Simpl,SimplifyCFG,108,// The block has now been cleared of all instructions except for; // a comparison and a conditional branch. SimplifyCFG may be able; // to fold it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:67,Deployability,update,update,67,"// Success. The block is now dead, so remove it from the loop,; // update the dominator tree and delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:38,Performance,queue,queue,38,// Worklist maintains our depth-first queue of loops in this nest to process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:182,Usability,simpl,simple,182,"// Walk the worklist from front to back, pushing newly found sub loops onto; // the back. This will let us process loops from back to front in depth-first; // order. We can use this simple process because loops form a tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:203,Usability,simpl,simplifyOneLoop,203,"// Changing exit conditions for blocks may affect exit counts of this loop and; // any of its parents, so we must invalidate the entire subtree if we've made; // any changes. Do this here rather than in simplifyOneLoop() as the top-most; // loop is going to be the same for all child loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:20,Integrability,interface,interface,20,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:12,Security,expose,exposed,12,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:24,Availability,down,down,24,"/// runOnFunction - Run down all loops in the CFG (recursively, but we could do; /// it in any convenient order) inserting preheaders...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:3,Usability,Simpl,Simplify,3,// Simplify each loop nest in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:87,Usability,simpl,simplifying,87,"// Note that we don't preserve LCSSA in the new PM, if you need it run LCSSA; // after simplifying the loops. MemorySSA is preserved if it exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:34,Testability,assert,assert,34,"// It used to be possible to just assert L->isLoopSimplifyForm(), however; // with the introduction of indirectbr, there are now cases where it's; // not possible to transform a loop as necessary. We can at least check; // that there is an indirectbr near any time there's trouble.; // Indirectbr can interfere with preheader and unique backedge insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:15,Integrability,rout,routine,15,"// FIXME: This routine is being called mid-way through the loop pass manager; // as loop passes destroy this analysis. That's actually fine, but we have no; // way of expressing that here. Once all of the passes that destroy this are; // hoisted out of the loop pass manager we can add back verification here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:519,Performance,perform,perform,519,"//===-- UnrollLoop.cpp - Loop unrolling utilities -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements some loop unrolling utilities. It does not define any; // actual pass or policy, but provides a single function to perform loop; // unrolling.; //; // The process of unrolling can produce extraneous basic blocks linked with; // unconditional branches. This will be corrected in the future.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:4,Performance,Perform,Perform,4,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:29,Usability,simpl,simplifications,29,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:92,Usability,simpl,simplify,92,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:154,Usability,simpl,simplify,154,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:30,Modifiability,variab,variables,30,// Simplify any new induction variables in the partially unrolled loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Usability,Simpl,Simplify,3,// Simplify any new induction variables in the partially unrolled loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:48,Usability,simpl,simplifyLoopIVs,48,// Aggressively clean up dead instructions that simplifyLoopIVs already; // identified. Any remaining should be cleaned up below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:43,Performance,Perform,Perform,43,"// At this point, the code is well formed. Perform constprop, instsimplify,; // and dce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:163,Usability,simpl,simple,163,"// Fold ((add X, C1), C2) to (add X, C1+C2). This is very common in; // unrolled loops, and handling this early allows following code to; // identify the IV as a ""simple recurrence"" without first folding away; // a long chain of adds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:42,Safety,avoid,avoid,42,// The loop-rotate pass can be helpful to avoid this in many cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,Performance,perform,performing,23,// There's no point in performing runtime unrolling if this unroll count; // results in a full unroll.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:212,Modifiability,extend,extended,212,"// The current loop unroll pass can unroll loops that have; // (1) single latch; and; // (2a) latch is unconditional; or; // (2b) latch is conditional and is an exiting block; // FIXME: The implementation can be extended to work with more complicated; // cases, e.g. loops with multiple latches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:59,Performance,optimiz,optimized,59,"// A conditional branch which exits the loop, which can be optimized to an; // unconditional branch in the unrolled loop in some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:130,Integrability,depend,dependencies,130,"// Loops containing convergent instructions cannot use runtime unrolling,; // as the prologue/epilogue may add additional control-dependencies to; // convergent operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:66,Performance,cache,cached,66,"// We are going to make changes to this loop. SCEV may be keeping cached info; // about it, in particular about backedge taken count. The changes we make; // are guaranteed to invalidate this information for our loop. It is tempting; // to only invalidate the loop being unrolled, but it is incorrect as long as; // all exiting branches from all inner loops have impact on the outer loops,; // and if something changes inside them then any of outer loops may also; // change. When we forget outermost loop, we also forget all contained loops; // and this is what we need here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:30,Deployability,update,update,30,// The current on-the-fly SSA update requires blocks to be processed in; // reverse postorder so that LastValueMap contains the correct value at each; // exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:97,Usability,simpl,simplified,97,"// Loop Unrolling might create new loops. While we do preserve LoopInfo, we; // might break loop-simplified form for these loops (as they, e.g., would; // share the same exit blocks). We'll keep track of loops for which we can; // break this so that later we can re-simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:266,Usability,simpl,simplify,266,"// Loop Unrolling might create new loops. While we do preserve LoopInfo, we; // might break loop-simplified form for these loops (as they, e.g., would; // share the same exit blocks). We'll keep track of loops for which we can; // break this so that later we can re-simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,// Update our running map of newest clones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,"// Update DomTree: since we just copy the loop body, and each copy has a; // dedicated entry block (copy of the header block), this header's copy; // dominates all copied blocks. That means, dominance relations in the; // copied body are the same as in the original body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:32,Integrability,depend,depends,32,"// Identify what other metadata depends on the cloned version. After; // cloning, replace the metadata with the corrected version for both; // memory instructions and noalias intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,"// Update dominators of blocks we might reach through exits.; // Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can now reach it from the copied; // iterations too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:137,Integrability,rout,routes,137,"// Update dominators of blocks we might reach through exits.; // Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can now reach it from the copied; // iterations too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:57,Safety,safe,safely,57,"// If we know the trip count or a multiple of it, we can safely use an; // unconditional branch for some iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:259,Deployability,update,updates,259,"// We don't fold known-exiting branches for non-latch exits here,; // because this ensures that both all loop blocks and all exit blocks; // remain reachable in the CFG.; // TODO: We could fold these branches, but it would require much more; // sophisticated updates to LoopInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:12,Deployability,update,update,12,"// Manually update the DT if there's a single exiting node. In that case; // there's a single exit node and it is sufficient to update the nodes; // immediately dominated by the original exiting block. They will become; // dominated by the first exiting block that leaves the loop after; // unrolling. Note that the CFG inside the loop does not change, so there's; // no need to update the DT inside the unrolled loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:128,Deployability,update,update,128,"// Manually update the DT if there's a single exiting node. In that case; // there's a single exit node and it is sufficient to update the nodes; // immediately dominated by the original exiting block. They will become; // dominated by the first exiting block that leaves the loop after; // unrolling. Note that the CFG inside the loop does not change, so there's; // no need to update the DT inside the unrolled loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:379,Deployability,update,update,379,"// Manually update the DT if there's a single exiting node. In that case; // there's a single exit node and it is sufficient to update the nodes; // immediately dominated by the original exiting block. They will become; // dominated by the first exiting block that leaves the loop after; // unrolling. Note that the CFG inside the loop does not change, so there's; // no need to update the DT inside the unrolled loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,Deployability,update,update,23,"// There is no need to update the DT here, because there must be a unique; // latch. Hence if the latch is not exiting it must directly branch back to; // the original loop header and does not dominate any nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:35,Deployability,Update,Update,35,// Dest has been folded into Fold. Update our worklists accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:9,Deployability,update,updates,9,// Apply updates to the DomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:50,Usability,simpl,simplify,50,"// At this point, the code is well formed. We now simplify the unrolled loop,; // doing constant propagation and dead code elimination as we go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,// Update LoopInfo if the loop is completely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,// Update the trip count. Note that the remainder has already logic; // computing it in `UnrollRuntimeLoopRemainder`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:62,Testability,log,logic,62,// Update the trip count. Note that the remainder has already logic; // computing it in `UnrollRuntimeLoopRemainder`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:175,Security,expose,exposed,175,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,Usability,simpl,simplify,23,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:62,Usability,simpl,simplify,62,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:57,Usability,simpl,simplify,57,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:93,Usability,simpl,simplify,93,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:129,Usability,simpl,simplify,129,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:167,Deployability,update,updated,167,// LCSSA must be performed on the outermost affected loop. The unrolled; // loop's last loop latch is guaranteed to be in the outermost loop; // after LoopInfo's been updated by LoopInfo::erase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:17,Performance,perform,performed,17,// LCSSA must be performed on the outermost affected loop. The unrolled; // loop's last loop latch is guaranteed to be in the outermost loop; // after LoopInfo's been updated by LoopInfo::erase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:93,Usability,simpl,simplified,93,// TODO: That potentially might be compile-time expensive. We should try; // to fix the loop-simplified form incrementally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Usability,Simpl,Simplify,3,// Simplify loops for which we might've broken loop-simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:52,Usability,simpl,simplify,52,// Simplify loops for which we might've broken loop-simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:429,Integrability,rout,routine,429,"//===-- LoopUnrollAndJam.cpp - Loop unrolling utilities -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements loop unroll and jam as a routine, much like; // LoopUnroll.cpp implements loop unroll.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:16,Performance,perform,performs,16,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:445,Performance,load,loads,445,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:47,Usability,simpl,simple,47,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:64,Safety,safe,safe,64,// When we enter here we should have already checked that it is safe,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:30,Deployability,update,update,30,// The current on-the-fly SSA update requires blocks to be processed in; // reverse postorder so that LastValueMap contains the correct value at each; // exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update our running maps of newest clones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update DomTree:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:201,Deployability,Update,Update,201,"// Now that all the basic blocks for the unrolled iterations are in place,; // finish up connecting the blocks and phi nodes. At this point LastValueMap; // is the last unrolled iterations values.; // Update Phis in BB from OldBB to point to NewBB and use the latest value; // from LastValueMap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update the PHI values outside the loop to point to the last block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update ForeBlocks successors and phi nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update the PHI values to point to the last aft block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:9,Deployability,update,updates,9,// Apply updates to the DomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update LoopInfo if the loop is completely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:49,Usability,simpl,simplify,49,// We shouldn't have done anything to break loop simplify form or LCSSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:34,Performance,load,loads,34,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:84,Performance,load,loads,84,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:77,Usability,simpl,simple,77,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:31,Integrability,depend,dependency,31,// UnrollLevel might carry the dependency Src --> Dst; // Does a different loop after unrolling?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:31,Integrability,depend,dependency,31,// UnrollLevel might carry the dependency Dst --> Src,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:12,Integrability,depend,dependencies,12,// Backward dependencies are only preserved if not interleaved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:83,Integrability,depend,dependency,83,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:377,Integrability,depend,dependency,377,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:36,Safety,safe,safe,36,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:348,Safety,safe,safe,348,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:16,Integrability,depend,dependencies,16,// Ignore Input dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:46,Integrability,depend,dependency,46,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:85,Integrability,depend,dependency,85,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:352,Integrability,depend,dependence,352,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:380,Integrability,depend,dependence,380,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:484,Integrability,depend,dependency,484,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:122,Security,access,accessed,122,"// If outer levels (levels enclosing the loop being unroll-and-jammed) have a; // non-equal direction, then the locations accessed in the inner levels cannot; // overlap in memory. We assumes the indexes never overlap into neighboring; // dimensions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:143,Security,access,accesses,143,"// If the distance carried by the unrolled loop is 0, then after unrolling; // that distance will become non-zero resulting in non-overlapping accesses in; // the inner loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:35,Usability,simpl,simplify,35,// All loops in Root need to be in simplify and rotated form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:978,Safety,safe,safe,978,"/* We currently handle outer loops like this:; |; ForeFirst <------\ }; Blocks | } ForeBlocks of L; ForeLast | }; | |; ... |; | |; ForeFirst <----\ | }; Blocks | | } ForeBlocks of a inner loop of L; ForeLast | | }; | | |; JamLoopFirst <\ | | }; Blocks | | | } JamLoopBlocks of the innermost loop; JamLoopLast -/ | | }; | | |; AftFirst | | }; Blocks | | } AftBlocks of a inner loop of L; AftLast ------/ | }; | |; ... |; | |; AftFirst | }; Blocks | } AftBlocks of L; AftLast --------/ }; |. There are (theoretically) any number of blocks in ForeBlocks, SubLoopBlocks; and AftBlocks, providing that there is one edge from Fores to SubLoops,; one edge from SubLoops to Afts and a single outer loop exit (from Afts).; In practice we currently limit Aft blocks to a single block, and limit; things further in the profitablility checks of the unroll and jam pass. Because of the way we rearrange basic blocks, we also require that; the Fore blocks of L on all unrolled iterations are safe to move before the; blocks of the direct child of L of all iterations. So we require that the; phi node looping operands of ForeHeader can be moved to at least the end of; ForeEnd, so that we can arrange cloned Fore Blocks before the subloop and; match up Phi's correctly. i.e. The old order of blocks used to be; (F1)1 (F2)1 J1_1 J1_2 (A2)1 (A1)1 (F1)2 (F2)2 J2_1 J2_2 (A2)2 (A1)2.; It needs to be safe to transform this to; (F1)1 (F1)2 (F2)1 (F2)2 J1_1 J1_2 J2_1 J2_2 (A2)1 (A2)2 (A1)1 (A1)2. There are then a number of checks along the lines of no calls, no; exceptions, inner loop IV is consistent, etc. Note that for loops requiring; runtime unrolling, UnrollRuntimeLoopRemainder can also fail in; UnrollAndJamLoop if the trip count cannot be easily calculated.; */; // Split blocks into Fore/SubLoop/Aft based on dominators",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:1382,Safety,safe,safe,1382,"/* We currently handle outer loops like this:; |; ForeFirst <------\ }; Blocks | } ForeBlocks of L; ForeLast | }; | |; ... |; | |; ForeFirst <----\ | }; Blocks | | } ForeBlocks of a inner loop of L; ForeLast | | }; | | |; JamLoopFirst <\ | | }; Blocks | | | } JamLoopBlocks of the innermost loop; JamLoopLast -/ | | }; | | |; AftFirst | | }; Blocks | | } AftBlocks of a inner loop of L; AftLast ------/ | }; | |; ... |; | |; AftFirst | }; Blocks | } AftBlocks of L; AftLast --------/ }; |. There are (theoretically) any number of blocks in ForeBlocks, SubLoopBlocks; and AftBlocks, providing that there is one edge from Fores to SubLoops,; one edge from SubLoops to Afts and a single outer loop exit (from Afts).; In practice we currently limit Aft blocks to a single block, and limit; things further in the profitablility checks of the unroll and jam pass. Because of the way we rearrange basic blocks, we also require that; the Fore blocks of L on all unrolled iterations are safe to move before the; blocks of the direct child of L of all iterations. So we require that the; phi node looping operands of ForeHeader can be moved to at least the end of; ForeEnd, so that we can arrange cloned Fore Blocks before the subloop and; match up Phi's correctly. i.e. The old order of blocks used to be; (F1)1 (F2)1 J1_1 J1_2 (A2)1 (A1)1 (F1)2 (F2)2 J2_1 J2_2 (A2)2 (A1)2.; It needs to be safe to transform this to; (F1)1 (F1)2 (F2)1 (F2)2 J1_1 J1_2 J2_1 J2_2 (A2)1 (A2)2 (A1)1 (A1)2. There are then a number of checks along the lines of no calls, no; exceptions, inner loop IV is consistent, etc. Note that for loops requiring; runtime unrolling, UnrollRuntimeLoopRemainder can also fail in; UnrollAndJamLoop if the trip count cannot be easily calculated.; */; // Split blocks into Fore/SubLoop/Aft based on dominators",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:18,Safety,safe,safety,18,// Check the loop safety info for exceptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:20,Integrability,depend,dependencies,20,"// Check for memory dependencies which prohibit the unrolling we are doing.; // Because of the way we are unrolling Fore/Sub/Aft blocks, we need to check; // there are no dependencies between Fore-Sub, Fore-Aft, Sub-Aft and Sub-Sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:171,Integrability,depend,dependencies,171,"// Check for memory dependencies which prohibit the unrolling we are doing.; // Because of the way we are unrolling Fore/Sub/Aft blocks, we need to check; // there are no dependencies between Fore-Sub, Fore-Aft, Sub-Aft and Sub-Sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:250,Performance,tune,tuned,250,"// Probability that the loop trip count is so small that after the prolog; // we do not enter the unrolled loop at all.; // It is unlikely that the loop trip count is smaller than the unroll factor;; // other than that, the choice of constant is not tuned yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:269,Performance,tune,tuned,269,"// Probability that the loop trip count is so small that we skip the unrolled; // loop completely and immediately enter the epilogue loop.; // It is unlikely that the loop trip count is smaller than the unroll factor;; // other than that, the choice of constant is not tuned yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:237,Performance,perform,performs,237,/// Connect the unrolling prolog code to the original loop.; /// The unrolling prolog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Create PHI nodes at prolog end block to combine values; /// that exit the prolog code and jump around the prolog.; /// - Add a PHI operand to a PHI node at the loop exit block; /// for values that exit the prolog and go around the loop.; /// - Branch around the original loop if the trip count is less; /// than the unroll factor.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,"// Update the existing PHI node operand with the value from the; // new PHI node. How this is done depends on if the existing; // PHI node is in the original loop block, or the exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:99,Integrability,depend,depends,99,"// Update the existing PHI node operand with the value from the; // new PHI node. How this is done depends on if the existing; // PHI node is in the original loop block, or the exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:44,Usability,simpl,simplified,44,// Make sure that created prolog loop is in simplified form,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:268,Deployability,Update,Update,268,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:468,Deployability,Update,Update,468,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:237,Performance,perform,performs,237,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:209,Deployability,Update,Update,209,// Loop structure should be the following:; //; // PreHeader; // NewPreHeader; // Header; // ...; // Latch; // NewExit (PN); // EpilogPreHeader; // EpilogHeader; // ...; // EpilogLatch; // Exit (EpilogPN); // Update PHI nodes at NewExit and Exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:82,Deployability,Update,Update,82,// Create PHI nodes at NewExit (from the unrolling loop Latch and PreHeader).; // Update corresponding PHI nodes in epilog loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:27,Deployability,update,updated,27,// Skip this as we already updated phis in exit blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:48,Deployability,update,update,48,// Add new PHI nodes to the loop exit block and update epilog; // PHIs with the new PHI values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,// Update the existing PHI node operand with the value from the new PHI; // node. Corresponding instruction in epilog loop should be PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:195,Availability,down,down,195,"/// Create a clone of the blocks in a loop and connect them together. A new; /// loop will be created including all cloned blocks, and the iterator of the; /// new loop switched to count NewIter down to 0.; /// The cloned blocks should be inserted between InsertTop and InsertBot.; /// InsertTop should be new preheader, InsertBot new loop exit.; /// Returns the new cloned loop that is created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:67,Deployability,update,update,67,"// For each block in the original loop, create a new copy,; // and update the value map with the newly created values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:105,Integrability,wrap,wrapped,105,"// Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: NewIter can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:189,Integrability,wrap,wrapping,189,"// Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: NewIter can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:83,Performance,optimiz,optimized,83,"// Unnecessary backedge, should never be taken. The conditional; // jump should be optimized away later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:641,Safety,predict,predictability,641,"// The main pain point with multi-exit loop unrolling is that once unrolled,; // we will not be able to merge all blocks into a straight line code.; // There are branches within the unrolled loop that go to the OtherExits.; // The second point is the increase in code size, but this is true; // irrespective of multiple exits.; // Note: Both the heuristics below are coarse grained. We are essentially; // enabling unrolling of loops that have a single side exit other than the; // normal LatchExit (i.e. exiting into a deoptimize block).; // The heuristics considered are:; // 1. low number of branches in the unrolled version.; // 2. high predictability of these extra branches.; // We avoid unrolling loops that have more than two exiting blocks. This; // limits the total number of branches in the unrolled loop to be atmost; // the unroll factor (since one of the exiting blocks is the latch block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:688,Safety,avoid,avoid,688,"// The main pain point with multi-exit loop unrolling is that once unrolled,; // we will not be able to merge all blocks into a straight line code.; // There are branches within the unrolled loop that go to the OtherExits.; // The second point is the increase in code size, but this is true; // irrespective of multiple exits.; // Note: Both the heuristics below are coarse grained. We are essentially; // enabling unrolling of loops that have a single side exit other than the; // normal LatchExit (i.e. exiting into a deoptimize block).; // The heuristics considered are:; // 1. low number of branches in the unrolled version.; // 2. high predictability of these extra branches.; // We avoid unrolling loops that have more than two exiting blocks. This; // limits the total number of branches in the unrolled loop to be atmost; // the unroll factor (since one of the exiting blocks is the latch block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:242,Safety,predict,predictable,242,"// The second heuristic is that L has one exit other than the latchexit and; // that exit is a deoptimize block. We know that deoptimize blocks are rarely; // taken, which also implies the branch leading to the deoptimize block is; // highly predictable. When UnrollRuntimeOtherExitPredictable is specified, we; // assume the other exit branch is predictable even if it has no deoptimize; // call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:347,Safety,predict,predictable,347,"// The second heuristic is that L has one exit other than the latchexit and; // that exit is a deoptimize block. We know that deoptimize blocks are rarely; // taken, which also implies the branch leading to the deoptimize block is; // highly predictable. When UnrollRuntimeOtherExitPredictable is specified, we; // assume the other exit branch is predictable even if it has no deoptimize; // call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:148,Modifiability,extend,extend,148,"// TODO: These can be fine-tuned further to consider code size or deopt states; // that are captured by the deoptimize exit block.; // Also, we can extend this to support more cases, if we actually; // know of kinds of multiexit loops that would benefit from unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:27,Performance,tune,tuned,27,"// TODO: These can be fine-tuned further to consider code size or deopt states; // that are captured by the deoptimize exit block.; // Also, we can extend this to support more cases, if we actually; // know of kinds of multiexit loops that would benefit from unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:107,Safety,safe,safe,107,// As (BECount + 1) can potentially unsigned overflow we count; // (BECount % Count) + 1 which is overflow safe as BECount % Count < Count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:357,Energy Efficiency,power,power-of-two,357,"/// Insert code in the prolog/epilog code when unrolling a loop with a; /// run-time trip-count.; ///; /// This method assumes that the loop unroll factor is total number; /// of loop bodies in the loop after unrolling. (Some folks refer; /// to the unroll factor as the number of *extra* copies added).; /// We assume also that the loop unroll factor is a power-of-two. So, after; /// unrolling the loop, the number of loop bodies executed is 2,; /// 4, 8, etc. Note - LLVM converts the if-then-sequence to a switch; /// instruction in SimplifyCFG.cpp. Then, the backend decides how code for; /// the switch instruction is generated.; ///; /// ***Prolog case***; /// extraiters = tripcount % loopfactor; /// if (extraiters == 0) jump Loop:; /// else jump Prol:; /// Prol: LoopBody;; /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Prol: // Omitted if unroll factor is 2.; /// if (tripcount < loopfactor) jump End:; /// Loop:; /// ...; /// End:; ///; /// ***Epilog case***; /// extraiters = tripcount % loopfactor; /// if (tripcount < loopfactor) jump LoopExit:; /// unroll_iters = tripcount - extraiters; /// Loop: LoopBody; (executes unroll_iter times);; /// unroll_iter -= 1; /// if (unroll_iter != 0) jump Loop:; /// LoopExit:; /// if (extraiters == 0) jump EpilExit:; /// Epil: LoopBody; (executes extraiters times); /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Epil: // Omitted if unroll factor is 2.; /// EpilExit:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:537,Usability,Simpl,SimplifyCFG,537,"/// Insert code in the prolog/epilog code when unrolling a loop with a; /// run-time trip-count.; ///; /// This method assumes that the loop unroll factor is total number; /// of loop bodies in the loop after unrolling. (Some folks refer; /// to the unroll factor as the number of *extra* copies added).; /// We assume also that the loop unroll factor is a power-of-two. So, after; /// unrolling the loop, the number of loop bodies executed is 2,; /// 4, 8, etc. Note - LLVM converts the if-then-sequence to a switch; /// instruction in SimplifyCFG.cpp. Then, the backend decides how code for; /// the switch instruction is generated.; ///; /// ***Prolog case***; /// extraiters = tripcount % loopfactor; /// if (extraiters == 0) jump Loop:; /// else jump Prol:; /// Prol: LoopBody;; /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Prol: // Omitted if unroll factor is 2.; /// if (tripcount < loopfactor) jump End:; /// Loop:; /// ...; /// End:; ///; /// ***Epilog case***; /// extraiters = tripcount % loopfactor; /// if (tripcount < loopfactor) jump LoopExit:; /// unroll_iters = tripcount - extraiters; /// Loop: LoopBody; (executes unroll_iter times);; /// unroll_iter -= 1; /// if (unroll_iter != 0) jump Loop:; /// LoopExit:; /// if (extraiters == 0) jump EpilExit:; /// Epil: LoopBody; (executes extraiters times); /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Epil: // Omitted if unroll factor is 2.; /// EpilExit:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:42,Safety,avoid,avoid,42,// The loop-rotate pass can be helpful to avoid this in many cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:123,Usability,simpl,simplification,123,// Use Scalar Evolution to compute the trip count. This allows more loops to; // be unrolled than relying on induction var simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:134,Integrability,depend,depending,134,"//; // For each extra loop iteration, create a copy of the loop's basic blocks; // and generate a condition that branches to the copy depending on the; // number of 'left over' iterations.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:165,Deployability,update,update,165,"// Now the loop blocks are cloned and the other exiting blocks from the; // remainder are connected to the original Loop's exit blocks. The remaining; // work is to update the phi nodes in the original loop, and take in the; // values from the cloned region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,"// Update the immediate dominator of the exit blocks and blocks that are; // reachable from the exit blocks. This is needed because we now have paths; // from both the original loop and the remainder code reaching the exit; // blocks. While the IDom of these exit blocks were from the original loop,; // now the IDom is the preheader (which decides whether the original loop or; // remainder code should run).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:322,Modifiability,Rewrite,Rewrite,322,// Loop structure should be the following:; // Epilog Prolog; //; // PreHeader PreHeader; // NewPreHeader PrologPreHeader; // Header PrologHeader; // ... ...; // Latch PrologLatch; // NewExit PrologExit; // EpilogPreHeader NewPreHeader; // EpilogHeader Header; // ... ...; // EpilogLatch Latch; // LatchExit LatchExit; // Rewrite the cloned instruction operands to use the values created when the; // clone is created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:52,Deployability,update,update,52,// Connect the epilog code to the original loop and update the; // PHI functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:147,Integrability,wrap,wrapped,147,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:231,Integrability,wrap,wrapping,231,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:124,Testability,Test,TestVal,124,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:52,Deployability,update,update,52,// Connect the prolog code to the original loop and update the; // PHI functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Usability,Simpl,Simplify,3,// Simplify loop values after breaking the backedge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:13,Modifiability,rewrite,rewrite,13,// We cannot rewrite exiting edges from an indirectbr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:83,Energy Efficiency,adapt,adapted,83,// FIXME: I believe that this could use copy_if if the Inst reference could; // be adapted into a pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:83,Modifiability,adapt,adapted,83,// FIXME: I believe that this could use copy_if if the Inst reference could; // be adapted into a pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:91,Integrability,depend,depends,91,"// By definition, all loop passes need the LoopInfo analysis and the; // Dominator tree it depends on. Because they all participate in the loop; // pass manager, they must also preserve these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:60,Security,access,access,60,// We must also preserve LoopSimplify and LCSSA. We locally access their IDs; // here because users shouldn't directly get them from this header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Performance,perform,perform,40,// This is used in the LPPassManager to perform LCSSA verification on passes; // which preserve lcssa form,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:320,Availability,robust,robust,320,"// Loop passes are designed to run inside of a loop pass manager which means; // that any function analyses they require must be required by the first loop; // pass in the manager (so that it is computed before the loop pass manager; // runs) and preserved by all loop pasess in the manager. To make this; // reasonably robust, the set needed for most loop passes is maintained here.; // If your loop pass requires an analysis not listed here, you will need to; // carefully audit the loop pass manager nesting structure that results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:475,Security,audit,audit,475,"// Loop passes are designed to run inside of a loop pass manager which means; // that any function analyses they require must be required by the first loop; // pass in the manager (so that it is computed before the loop pass manager; // runs) and preserved by all loop pasess in the manager. To make this; // reasonably robust, the set needed for most loop passes is maintained here.; // If your loop pass requires an analysis not listed here, you will need to; // carefully audit the loop pass manager nesting structure that results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Integrability,depend,dependency,40,"/// Manually defined generic ""LoopPass"" dependency initialization. This is used; /// to initialize the exact set of passes from above in \c; /// getLoopAnalysisUsage. It can be used within a loop pass's initialization; /// with:; ///; /// INITIALIZE_PASS_DEPENDENCY(LoopPass); ///; /// As-if ""LoopPass"" were a pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:119,Deployability,update,update,119,/// Set input string into loop metadata by keeping other values intact.; /// If the string is already in loop metadata update value if it is; /// different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:14,Deployability,update,update,14,"// We need to update the value, so just skip it here and it will; // be added after copying other existed nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:10,Modifiability,inherit,inherit,10,// Do not inherit excluded attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:35,Safety,safe,safe,35,"// Now that we know the removal is safe, remove the loop by changing the; // branch from the preheader to go to the single exit block.; //; // Because we're deleting a large chunk of code at once, the sequence in which; // we remove things is very important to avoid invalidation issues.; // Tell ScalarEvolution that the loop is deleted. Do this before; // deleting the loop so that ScalarEvolution can look at the loop; // to determine what it needs to clean up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:261,Safety,avoid,avoid,261,"// Now that we know the removal is safe, remove the loop by changing the; // branch from the preheader to go to the single exit block.; //; // Because we're deleting a large chunk of code at once, the sequence in which; // we remove things is very important to avoid invalidation issues.; // Tell ScalarEvolution that the loop is deleted. Do this before; // deleting the loop so that ScalarEvolution can look at the loop; // to determine what it needs to clean up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:117,Deployability,update,update,117,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:576,Deployability,update,update,576,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:607,Deployability,update,update,607,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:90,Performance,perform,perform,90,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:545,Performance,perform,perform,545,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite phis in the exit block to get their inputs from the Preheader; // instead of the exiting block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:19,Modifiability,variab,variable,19,"// For one of each variable encountered, preserve a debug intrinsic (set; // to Poison) and transfer it to the loop exit. This terminates any; // variable locations that were set during the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:146,Modifiability,variab,variable,146,"// For one of each variable encountered, preserve a debug intrinsic (set; // to Poison) and transfer it to the loop exit. This terminates any; // variable locations that were set during the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:282,Availability,avail,available,282,"// After the loop has been deleted all the values defined and modified; // inside the loop are going to be unavailable. Values computed in the; // loop will have been deleted, automatically causing their debug uses; // be be replaced with undef. Loop invariant values will still be available.; // Move dbg.values out the loop so that earlier location ranges are still; // terminated and loop invariant assignments are preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:155,Safety,safe,safe,155,// Erase the instructions and the blocks without having to worry; // about ordering because we already dropped the references.; // NOTE: This iteration is safe because erasing the block does not remove; // its entry from the loop's block list. We do that in the next section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:23,Deployability,update,update,23,"// The last step is to update LoopInfo now that we've eliminated this loop.; // Note: LoopInfo::erase remove the given loop and relink its subloops with; // its parent. While removeLoop/removeChildLoop remove the given loop but; // not relink its subloops, which is what we want.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:3,Deployability,Update,Update,3,// Update the CFG and domtree. We chose to special case a couple of; // of common cases for code quality and test readability reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Testability,test,test,109,// Update the CFG and domtree. We chose to special case a couple of; // of common cases for code quality and test readability reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:153,Testability,test,test,153,"// If the loop we broke had a parent, then changeToUnreachable might have; // caused a block to be removed from the parent loop (see loop_nest_lcssa; // test case in zero-btc.ll for an example), thus changing the parent's; // exit blocks. If that happened, we need to rebuild LCSSA on the outermost; // loop which might have a had a block removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:111,Modifiability,extend,extend,111,"// At the moment, we currently support changing the estimate trip count of; // the latch branch only. We could extend this API to manipulate estimated; // trip counts for any exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:7,Deployability,Update,Update,7,// Set/Update profile metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:11,Energy Efficiency,power,power,11,"// VF is a power of 2 so we can emit the reduction using log2(VF) shuffles; // and vector ops, reducing the set of values being computed by half each; // round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:61,Deployability,configurat,configuration,61,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:245,Deployability,configurat,configuration,245,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:61,Modifiability,config,configuration,61,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:245,Modifiability,config,configuration,245,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:24,Availability,mask,mask,24,// Fill the rest of the mask with undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:90,Energy Efficiency,reduce,reduce,90,// Create a splat vector with the new value and compare this to the vector; // we want to reduce.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:102,Modifiability,inherit,inherit,102,// TODO: Support in-order reductions based on the recurrence descriptor.; // All ops in the reduction inherit fast-math-flags from the recurrence; // descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:167,Energy Efficiency,reduce,reduces,167,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:85,Modifiability,rewrite,rewriteLoopExitValues,85,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Performance,Optimiz,Optimize,109,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:71,Modifiability,rewrite,rewriteLoopExitValues,71,// Collect information about PHI nodes which can be transformed in; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:245,Modifiability,enhance,enhance,245,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:154,Testability,test,testcase,154,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:257,Testability,log,logic,257,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:122,Usability,simpl,simplicity,122,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:42,Modifiability,Rewrite,RewritePhiSet,42,"// If the Incoming value of P is found in RewritePhiSet, we know it; // could be rewritten to use a loop invariant value in transformation; // phase later. Skip it in the loop invariant check below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:20,Safety,safe,safe,20,"/// Checks if it is safe to call InductionDescriptor::isInductionPHI for \p Phi,; /// and returns true if this Phi is an induction phi in the loop. When; /// isInductionPHI returns true, \p ID will be also be set by isInductionPHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:174,Deployability,update,update,174,"// Find exit values which are induction variables in the loop, and are; // unused in the loop, with the only use being the exit block PhiNode,; // and the induction variable update binary operator.; // The exit value can be replaced with the final value when it is cheap; // to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Modifiability,variab,variables,40,"// Find exit values which are induction variables in the loop, and are; // unused in the loop, with the only use being the exit block PhiNode,; // and the induction variable update binary operator.; // The exit value can be replaced with the final value when it is cheap; // to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:165,Modifiability,variab,variable,165,"// Find exit values which are induction variables in the loop, and are; // unused in the loop, with the only use being the exit block PhiNode,; // and the induction variable update binary operator.; // The exit value can be replaced with the final value when it is cheap; // to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:97,Deployability,update,update,97,"// This is an induction PHI. Check that the only users are PHI; // nodes, and induction variable update binary operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:88,Modifiability,variab,variable,88,"// This is an induction PHI. Check that the only users are PHI; // nodes, and induction variable update binary operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:58,Deployability,update,update,58,"// If it is not an induction phi, it must be an induction update; // binary operator with an induction phi user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:80,Safety,predict,predictably,80,"// Okay, this instruction has a user outside of the current loop; // and varies predictably *inside* the loop. Evaluate the value it; // contains when the loop exits, if possible. We prefer to start with; // expressions which are true for all exits (so as to maximize; // expression reuse by the SCEVExpander), but resort to per-exit; // evaluation if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:132,Performance,optimiz,optimized,132,// Computing the value outside of the loop brings no benefit if it is; // definitely used inside the loop in a way which can not be optimized; // away. Avoid doing so unless we know we have a value which computes; // the ExitValue already. TODO: This should be merged into SCEV; // expander to leverage its knowledge of existing expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:152,Safety,Avoid,Avoid,152,// Computing the value outside of the loop brings no benefit if it is; // definitely used inside the loop in a way which can not be optimized; // away. Avoid doing so unless we know we have a value which computes; // the ExitValue already. TODO: This should be merged into SCEV; // expander to leverage its knowledge of existing expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:25,Performance,perform,perform,25,"// Note that we must not perform expansions until after; // we query *all* the costs, because if we perform temporary expansion; // inbetween, one that we might not intend to keep, said expansion; // *may* affect cost calculation of the next SCEV's we'll query,; // and next SCEV may errneously get smaller cost.; // Collect all the candidate PHINodes to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:100,Performance,perform,perform,100,"// Note that we must not perform expansions until after; // we query *all* the costs, because if we perform temporary expansion; // inbetween, one that we might not intend to keep, said expansion; // *may* affect cost calculation of the next SCEV's we'll query,; // and next SCEV may errneously get smaller cost.; // Collect all the candidate PHINodes to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:15,Modifiability,rewrite,rewrite,15,"// Only do the rewrite when the ExitValue can be expanded cheaply.; // If LoopCanBeDel is true, rewrite exit value aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:96,Modifiability,rewrite,rewrite,96,"// Only do the rewrite when the ExitValue can be expanded cheaply.; // If LoopCanBeDel is true, rewrite exit value aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:66,Safety,avoid,avoid,66,"// If this instruction is dead now, delete it. Don't do it now to avoid; // invalidating iterators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:87,Modifiability,rewrite,rewriter,87,// The insertion point instruction may have been deleted; clear it out; // so that the rewriter doesn't trip over it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:58,Usability,clear,clear,58,// The insertion point instruction may have been deleted; clear it out; // so that the rewriter doesn't trip over it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:337,Energy Efficiency,reduce,reduces,337,"// If the Low and High values are themselves loop-variant, then we may want; // to expand the range to include those covered by the outer loop as well.; // There is a trade-off here with the advantage being that creating checks; // using the expanded range permits the runtime memory checks to be hoisted; // out of the outer loop. This reduces the cost of entering the inner loop,; // which can be significant for low trip counts. The disadvantage is that; // there is a chance we may now never enter the vectorized inner loop,; // whereas using a restricted range check could have allowed us to enter at; // least once. This is why the behaviour is not currently the default and is; // controlled by the parameter 'HoistRuntimeChecks'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:45,Performance,cache,cache,45,// Here we're relying on the SCEV Expander's cache to only emit code for the; // same bounds once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:35,Security,access,accessed,35,"// [A|B].Start points to the first accessed byte under base [A|B].; // [A|B].End points to the last accessed byte, plus one.; // There is no conflict when the intervals are disjoint:; // NoConflict = (B.Start >= A.End) || (A.Start >= B.End); //; // bound0 = (B.Start < A.End); // bound1 = (A.Start < B.End); // IsConflict = bound0 & bound1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:100,Security,access,accessed,100,"// [A|B].Start points to the first accessed byte under base [A|B].; // [A|B].End points to the last accessed byte, plus one.; // There is no conflict when the intervals are disjoint:; // NoConflict = (B.Start >= A.End) || (A.Start >= B.End); //; // bound0 = (B.Start < A.End); // bound1 = (A.Start < B.End); // IsConflict = bound0 & bound1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:127,Availability,redundant,redundant,127,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:104,Safety,detect,detecting,104,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:127,Safety,redund,redundant,127,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:21,Security,Access,AccessSize,21,// Compute VF * IC * AccessSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Performance,load,loads,40,// Do not duplicate volatile and atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:3,Performance,Queue,Queue,3,// Queue the defining access to check for alias checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:22,Security,access,access,22,// Queue the defining access to check for alias checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:55,Deployability,patch,patch,55,"// First, collect all blocks in the loop that are on a patch from Succ; // to the header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:150,Security,Access,AccessedLocs,150,"// Next, check if there are any MemoryDefs that are on the path through; // the loop (in the Seen set) and they may-alias any of the locations in; // AccessedLocs. If that is the case, they may modify the condition and; // partial unswitching is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:27,Security,access,accesses,27,// MemoryUse are read-only accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Availability,avail,available,109,"// We could also allow loops with known trip counts without mustprogress,; // but ScalarEvolution may not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:420,Performance,perform,perform,420,"//===- LoopVersioning.cpp - Utility to version a loop ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:514,Security,access,accesses,514,"//===- LoopVersioning.cpp - Utility to version a loop ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:91,Usability,Simpl,SimplifyLoop,91,// Clone the loop including the preheader.; //; // FIXME: This does not currently preserve SimplifyLoop because the exit; // block is a join between the two loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:9,Energy Efficiency,allocate,allocate,9,"// First allocate an aliasing scope for each pointer checking group.; //; // While traversing through the checking groups in the loop, also create a; // reverse map from pointers to the pointer checking group they were assigned; // to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:473,Integrability,wrap,wrapper,473,"//===-- LowerGlobalDtors.cpp - Lower @llvm.global_dtors -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Lower @llvm.global_dtors.; ///; /// Implement @llvm.global_dtors by creating wrapper functions that are; /// registered in @llvm.global_ctors and which contain a call to; /// `__cxa_atexit` to register their destructor functions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:3,Security,Validat,Validate,3,// Validate @llvm.global_dtor's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:107,Testability,stub,stub,107,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:184,Usability,simpl,simply,184,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:208,Usability,clear,clear,208,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp:668,Usability,simpl,simplifycfg,668,"//===- LowerInvoke.cpp - Eliminate Invoke instructions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is designed for use by code generators which do not yet; // support stack unwinding. This pass converts 'invoke' instructions to 'call'; // instructions, so that any exception-handling 'landingpad' blocks become dead; // code (which can be removed by running the '-simplifycfg' pass afterwards).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp:10,Integrability,Interface,Interface,10,// Public Interface To the LowerInvoke pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:11,Deployability,update,update,11,"// Need to update the pre-loop basic block to branch to the correct place.; // branch to the main loop if the count is non-zero, branch to the residual; // loop if the copy size is smaller then 1 iteration of the main loop but; // non-zero and finally branch to after the residual loop if the memcpy; // size is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,load,38,// Copy the residual with single byte load/store loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:171,Deployability,patch,patch,171,"// In this case the loop operand type was a byte, and there is no need for a; // residual loop to copy the remaining memory after the main loop.; // We do however need to patch up the control flow by creating the; // terminators for the preloop block and the memcpy loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:414,Modifiability,rewrite,rewrites,414,"//===- LowerSwitch.cpp - Eliminate Switch instructions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LowerSwitch transformation rewrites switch instructions with a sequence; // of branches, which allows targets to get away with not implementing the; // switch instruction until it is convenient.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:4,Deployability,Update,Update,4,"/// Update the first occurrence of the ""switch statement"" BB in the PHI; /// node with the ""new"" BB. The other occurrences will:; ///; /// 1) Be updated by subsequent calls to this function. Switch statements may; /// have more than one outcoming edge into the same BB if they all have the same; /// value. When the switch statement is converted these incoming edges are now; /// coming from multiple BBs.; /// 2) Removed if subsequent incoming values now share the same case, i.e.,; /// multiple outcome edges are condensed into one. This is necessary to keep the; /// number of phi values equal to the number of branches to SuccBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:145,Deployability,update,updated,145,"/// Update the first occurrence of the ""switch statement"" BB in the PHI; /// node with the ""new"" BB. The other occurrences will:; ///; /// 1) Be updated by subsequent calls to this function. Switch statements may; /// have more than one outcoming edge into the same BB if they all have the same; /// value. When the switch statement is converted these incoming edges are now; /// coming from multiple BBs.; /// 2) Removed if subsequent incoming values now share the same case, i.e.,; /// multiple outcome edges are condensed into one. This is necessary to keep the; /// number of phi values equal to the number of branches to SuccBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:8,Deployability,update,update,8,// Only update the first occurrence if NewBB exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:12,Deployability,update,updated,12,// Skip the updated incoming block so that it will not be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:3,Deployability,Update,Update,3,// Update the PHI incoming value/block for the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:50,Modifiability,rewrite,rewrite,50,"// If there were any PHI nodes in this successor, rewrite one entry; // from OrigBlock to come from NewLeaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:125,Safety,avoid,avoid,125,// Check if the Case Range is perfectly squeezed in between; // already checked Upper and Lower bounds. If it is then we can avoid; // emitting the code that checks if the value actually falls in the range; // because the bounds already tell us so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:79,Safety,safe,safe,79,// Because NewLowerBound is never the smallest representable integer; // it is safe here to subtract one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:14,Usability,simpl,simple,14,/// Transform simple list of \p SI's cases into list of CaseRange's \p Cases.; /// \post \p Cases wouldn't contain references to \p SI's default BB.; /// \returns Number of \p SI's cases that do not reference \p SI's default BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:15,Usability,simpl,simple,15,"// Start with ""simple"" cases",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:54,Deployability,update,update,54,"// As the default block in the switch is unreachable, update the PHI nodes; // (remove all of the references to the default block) to reflect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:20,Integrability,interface,interface,20,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:12,Security,expose,exposed,12,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:27,Integrability,Interface,Interface,27,// createLowerSwitchPass - Interface to this file...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:42,Integrability,wrap,wrapper,42,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:410,Integrability,wrap,wrapper,410,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:463,Security,expose,exposed,463,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:398,Usability,simpl,simple,398,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:25,Safety,safe,safe,25,"// Find allocas that are safe to promote, by looking at all instructions in; // the entry node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:93,Safety,safe,safe,93,"// runOnFunction - To run this pass, first we calculate the alloca; // instructions that are safe for promotion, then we promote each one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:25,Usability,user-friendly,user-friendly,25,// For intrinsics:; // * user-friendly name; // * size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:80,Integrability,message,message,80,// Emit the false cases under ExtraArgs. This won't show them in the remark; // message but will end up in the serialized remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:118,Modifiability,variab,variable,118,"// Try to get an llvm.dbg.declare, which has a DILocalVariable giving us the; // real debug info name and size of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:26,Modifiability,variab,variable,26,// Find if Ptr is a known variable we can give more information on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:93,Safety,avoid,avoid,93,"// If there's a mix of covered and non-covered exits, just put the untag; // on exits, so we avoid the redundancy of untagging twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:103,Safety,redund,redundancy,103,"// If there's a mix of covered and non-covered exits, just put the untag; // on exits, so we avoid the redundancy of untagging twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:3,Safety,safe,safe,3,// safe allocas are not interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:57,Usability,simpl,simple,57,// This PRNG is from the ISO C spec. It is intentionally simple and; // unsuitable for cryptographic use. We're just looking for enough; // variety to surprise and delight users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:83,Safety,avoid,avoid,83,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:22,Usability,simpl,simple,22,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:76,Usability,simpl,simply,76,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:21,Modifiability,variab,variables,21,// Rename all global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:1430,Integrability,message,message,1430,"//===--- MisExpect.cpp - Check the use of llvm.expect with PGO data -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This contains code to emit warnings for potentially incorrect usage of the; // llvm.expect intrinsic. This utility extracts the threshold values from; // metadata associated with the instrumented Branch or Switch instruction. The; // threshold values are then used to determine if a warning should be emmited.; //; // MisExpect's implementation relies on two assumptions about how branch weights; // are managed in LLVM.; //; // 1) Frontend profiling weights are always in place before llvm.expect is; // lowered in LowerExpectIntrinsic.cpp. Frontend based instrumentation therefore; // needs to extract the branch weights and then compare them to the weights; // being added by the llvm.expect intrinsic lowering.; //; // 2) Sampling and IR based profiles will *only* have branch weight metadata; // before profiling data is consulted if they are from a lowered llvm.expect; // intrinsic. These profiles thus always extract the expected weights and then; // compare them to the weights collected during profiling to determine if a; // diagnostic message is warranted.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:61,Testability,assert,assertion,61,"// FIXME: When we've addressed sample profiling, restore the assertion; //; // We cannot calculate branch probability if either of these invariants aren't; // met. However, MisExpect diagnostics should not prevent code from compiling,; // so we simply forgo emitting diagnostics here, and return early.; // assert((TotalBranchWeight >= LikelyBranchWeight) && (TotalBranchWeight > 0); // && ""TotalBranchWeight is less than the Likely branch weight"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:307,Testability,assert,assert,307,"// FIXME: When we've addressed sample profiling, restore the assertion; //; // We cannot calculate branch probability if either of these invariants aren't; // met. However, MisExpect diagnostics should not prevent code from compiling,; // so we simply forgo emitting diagnostics here, and return early.; // assert((TotalBranchWeight >= LikelyBranchWeight) && (TotalBranchWeight > 0); // && ""TotalBranchWeight is less than the Likely branch weight"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:245,Usability,simpl,simply,245,"// FIXME: When we've addressed sample profiling, restore the assertion; //; // We cannot calculate branch probability if either of these invariants aren't; // met. However, MisExpect diagnostics should not prevent code from compiling,; // so we simply forgo emitting diagnostics here, and return early.; // assert((TotalBranchWeight >= LikelyBranchWeight) && (TotalBranchWeight > 0); // && ""TotalBranchWeight is less than the Likely branch weight"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:9,Availability,toler,tolerance,9,"// clamp tolerance range to [0, 100)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:62,Availability,toler,tolerance,62,"// Allow users to relax checking by N% i.e., if they use a 5% tolerance,; // then we check against 0.95*ScaledThreshold",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:408,Performance,perform,perform,408,"//===-- ModuleUtils.cpp - Functions to manipulate Modules -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on Modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:25,Modifiability,variab,variable,25,// Create the new global variable and replace all uses of; // the old global variable with the new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:77,Modifiability,variab,variable,77,// Create the new global variable and replace all uses of; // the old global variable with the new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:90,Deployability,patch,patchable-function-prefix,90,"// If the module was compiled with -fpatchable-function-entry, ensure; // we use the same patchable-function-prefix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:110,Performance,concurren,concurrent,110,"// FIXME: Sink this logic into the module, similar to the handling of; // globals. This will make moving to a concurrent model much easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:20,Testability,log,logic,20,"// FIXME: Sink this logic into the module, similar to the handling of; // globals. This will make moving to a concurrent model much easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:3,Deployability,Update,Update,3,// Update all users to load a pointer from the global table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:23,Performance,load,load,23,// Update all users to load a pointer from the global table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp:23,Safety,detect,detect,23,// Traverse the CFG to detect cycles `UsersDominator` would be part of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp:7,Performance,Perform,Perform,7,//; // Perform the actual substitution.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:22,Security,hash,hash,22,"// Compute a ""unique"" hash for the module based on the name of the public; // globals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:31,Security,hash,hash,31,/// Return the lazily computed hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:3,Performance,Cache,Cache,3,// Cache hit :),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:3,Performance,Perform,Perform,3,// Perform a strict weak ordering on instructions and arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:8,Performance,perform,performs,8,"// This performs the necessary local basic block ordering checks to tell; // whether A comes before B, where both are in the same basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:170,Safety,detect,detect,170,"// This stores info about each operand or comparison result we make copies; // of. The real ValueInfos start at index 1, index 0 is unused so that we; // can more easily detect invalid indexing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:45,Safety,detect,detect,45,// Push an empty operand info so that we can detect 0 as not finding one,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:95,Integrability,depend,depending,95,"// The maximum number of things we should be trying to materialize at once; // right now is 4, depending on if we had an assume, a branch, and both used; // and of conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:408,Safety,detect,detect,408,"// For edge predicates, we can just place the operand in the block before; // the terminator. For assume, we have to place it right before the assume; // to ensure we dominate all of our uses. Always insert right before the; // relevant instruction (terminator, assume), so that we insert in proper; // order in the case of multiple predicateinfo in the same block.; // The number of named values is used to detect if a new declaration was; // added. If so, that declaration is tracked so that it can be removed when; // the analysis is done. The corner case were a new declaration results in; // a name clash and the old name being renamed is not considered as that; // represents an invalid module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:1235,Modifiability,variab,variable,1235,"// Instead of the standard SSA renaming algorithm, which is O(Number of; // instructions), and walks the entire dominator tree, we walk only the defs +; // uses. The standard SSA renaming algorithm does not really rely on the; // dominator tree except to order the stack push/pops of the renaming stacks, so; // that defs end up getting pushed before hitting the correct uses. This does; // not require the dominator tree, only the *order* of the dominator tree. The; // complete and correct ordering of the defs and uses, in dominator tree is; // contained in the DFS numbering of the dominator tree. So we sort the defs and; // uses into the DFS ordering, and then just use the renaming stack as per; // normal, pushing when we hit a def (which is a predicateinfo instruction),; // popping when we are out of the dfs scope for that def, and replacing any uses; // with top of stack if it exists. In order to handle liveness without; // propagating liveness info, we don't actually insert the predicateinfo; // instruction def until we see a use that it would dominate. Once we see such; // a use, we materialize the predicateinfo instruction in the right place and; // use it.; //; // TODO: Use this algorithm to perform fast single-variable renaming in; // promotememtoreg and memoryssa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:1215,Performance,perform,perform,1215,"// Instead of the standard SSA renaming algorithm, which is O(Number of; // instructions), and walks the entire dominator tree, we walk only the defs +; // uses. The standard SSA renaming algorithm does not really rely on the; // dominator tree except to order the stack push/pops of the renaming stacks, so; // that defs end up getting pushed before hitting the correct uses. This does; // not require the dominator tree, only the *order* of the dominator tree. The; // complete and correct ordering of the defs and uses, in dominator tree is; // contained in the DFS numbering of the dominator tree. So we sort the defs and; // uses into the DFS ordering, and then just use the renaming stack as per; // normal, pushing when we hit a def (which is a predicateinfo instruction),; // popping when we are out of the dfs scope for that def, and replacing any uses; // with top of stack if it exists. In order to handle liveness without; // propagating liveness info, we don't actually insert the predicateinfo; // instruction def until we see a use that it would dominate. Once we see such; // a use, we materialize the predicateinfo instruction in the right place and; // use it.; //; // TODO: Use this algorithm to perform fast single-variable renaming in; // promotememtoreg and memoryssa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:56,Performance,perform,perform,56,"// Otherwise, we are in the split block (even though we perform; // insertion in the branch block).; // Insert a possible copy at the split block and before the branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:115,Testability,assert,asserting,115,"// Collect function pointers in set first, as SmallSet uses a SmallVector; // internally and we have to remove the asserting value handles first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:22,Testability,assert,assertion,22,// TODO: Make this an assertion once RenamedOp is fully accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:22,Testability,assert,assertion,22,// TODO: Make this an assertion once RenamedOp is fully accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:22,Testability,assert,assertion,22,// TODO: Make this an assertion once RenamedOp is fully accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:669,Modifiability,rewrite,rewrite,669,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:499,Performance,load,loads,499,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:677,Performance,load,loads,677,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:38,Performance,load,loads,38,// Only allow direct and non-volatile loads and stores...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,Performance,load,loads,20,// Note that atomic loads can be transformed; atomic semantics do; // not have any meaning for a local alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:66,Modifiability,variab,variable,66,/// DbgAssignIntrinsics linked to the alloca with at most one per variable; /// fragment. (i.e. not be a comprehensive set if there are multiple; /// dbg.assigns for one variable fragment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:170,Modifiability,variab,variable,170,/// DbgAssignIntrinsics linked to the alloca with at most one per variable; /// fragment. (i.e. not be a comprehensive set if there are multiple; /// dbg.assigns for one variable fragment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Deployability,Update,Update,4,/// Update assignment tracking debug info given for the to-be-deleted store; /// \p ToDelete that stores to this alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:56,Modifiability,variab,variables,56,// There's nothing to do if the alloca doesn't have any variables using; // assignment tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:169,Energy Efficiency,reduce,reduce,169,// Insert a dbg.value where the linked dbg.assign is and remember to delete; // the dbg.assign later. Demoting to dbg.value isn't necessary for; // correctness but does reduce compile time and memory usage by reducing; // unnecessary function-local metadata. Remember that we've seen a; // dbg.assign for each variable fragment for the untracked store handling; // (after this loop).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:310,Modifiability,variab,variable,310,// Insert a dbg.value where the linked dbg.assign is and remember to delete; // the dbg.assign later. Demoting to dbg.value isn't necessary for; // correctness but does reduce compile time and memory usage by reducing; // unnecessary function-local metadata. Remember that we've seen a; // dbg.assign for each variable fragment for the untracked store handling; // (after this loop).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:21,Modifiability,variab,variables,21,// It's possible for variables using assignment tracking to have no; // dbg.assign linked to this store. These are variables in DbgAssigns that; // are missing from VarHasDbgAssignForStore. Since there isn't a dbg.assign; // to mark the assignment - and the store is going to be deleted - insert a; // dbg.value to do that now. An untracked store may be either one that; // cannot be represented using assignment tracking (non-const offset or; // size) or one that is trackable but has had its DIAssignID attachment; // dropped accidentally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:115,Modifiability,variab,variables,115,// It's possible for variables using assignment tracking to have no; // dbg.assign linked to this store. These are variables in DbgAssigns that; // are missing from VarHasDbgAssignForStore. Since there isn't a dbg.assign; // to mark the assignment - and the store is going to be deleted - insert a; // dbg.value to do that now. An untracked store may be either one that; // cannot be represented using assignment tracking (non-const offset or; // size) or one that is trackable but has had its DIAssignID attachment; // dropped accidentally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Deployability,Update,Update,4,/// Update assignment tracking debug info given for the newly inserted PHI \p; /// NewPhi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:14,Deployability,update,update,14,/// Helper to update assignment tracking debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:106,Performance,load,loads,106,"// As we scan the uses of the alloca instruction, keep track of stores,; // and decide whether all of the loads and stores to the alloca are within; // the same basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:58,Modifiability,variab,variable,58,"// Otherwise it must be a load instruction, keep track of variable; // reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:26,Performance,load,load,26,"// Otherwise it must be a load instruction, keep track of variable; // reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:57,Performance,load,load,57,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:113,Performance,load,load,113,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:191,Safety,avoid,avoids,191,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:28,Security,access,accesses,28,/// This code only looks at accesses to allocas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:145,Safety,avoid,avoid,145,"// Scan the whole block to get the instruction. This accumulates; // information for every interesting instruction in the block, in order to; // avoid gratuitus rescans.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:6,Performance,cache,cache,6,/// A cache of @llvm.assume intrinsics used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:47,Usability,Simpl,SimplifyInstruction,47,/// A cache of @llvm.assume intrinsics used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:301,Energy Efficiency,efficient,efficient,301,"/// The PhiNodes we're adding.; ///; /// That map is used to simplify some Phi nodes as we iterate over it, so; /// it should have deterministic iterators. We could use a MapVector, but; /// since we already maintain a map from BasicBlock* to a stable numbering; /// (BBNumbers), the DenseMap is more efficient (also supports removal).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Usability,simpl,simplify,61,"/// The PhiNodes we're adding.; ///; /// That map is used to simplify some Phi nodes as we iterate over it, so; /// it should have deterministic iterators. We could use a MapVector, but; /// since we already maintain a map from BasicBlock* to a stable numbering; /// (BBNumbers), the DenseMap is more efficient (also supports removal).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:90,Deployability,update,update,90,"/// For each alloca, keep an instance of a helper class that gives us an easy; /// way to update assignment tracking debug info if the alloca is promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:51,Safety,avoid,avoid,51,/// Contains a stable numbering of basic blocks to avoid non-determinstic; /// behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:40,Performance,Load,LoadInst,40,// end anonymous namespace; /// Given a LoadInst LI this adds assume(LI != null) after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:10,Performance,load,load,10,"// If the load was marked as nonnull we don't want to lose that information; // when we erase this Load. So we preserve it with an assume. As !nonnull; // returns poison while assume violations are immediate undefined behavior,; // we can only do this if the value is known non-poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:99,Performance,Load,Load,99,"// If the load was marked as nonnull we don't want to lose that information; // when we erase this Load. So we preserve it with an assume. As !nonnull; // returns poison while assume violations are immediate undefined behavior,; // we can only do this if the value is known non-poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:106,Performance,load,load,106,"// Knowing that this alloca is promotable, we know that it's safe to kill all; // instructions except for load and store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Safety,safe,safe,61,"// Knowing that this alloca is promotable, we know that it's safe to kill all; // instructions except for load and store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,Performance,load,loads,20,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:175,Performance,load,loads,175,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:330,Performance,load,loads,330,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Usability,Clear,Clear,3,// Clear out UsingBlocks. We will reconstruct it here if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:22,Performance,load,load,22,"// Okay, if we have a load from the alloca, we want to replace it with the; // only value stored to the alloca. We can do this if the value is; // dominated by the store. If not, we use the rest of the mem2reg machinery; // to insert the phi nodes as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:148,Performance,load,load,148,"// If we have a use that is in the same block as the store, compare the; // indices of the two instructions to see which one came first. If the; // load came before the store, we can't handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:21,Performance,load,load,21,"// Can't handle this load, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:10,Performance,load,load,10,"// If the load and store are in different blocks, use BB dominance to; // check their relationships. If the store doesn't dom the use, bail; // out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:30,Modifiability,rewrite,rewrite,30,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:43,Performance,load,load,43,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:23,Safety,safe,safely,23,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:35,Performance,load,load,35,"// If the replacement value is the load, this must occur in unreachable; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Deployability,Update,Update,3,// Update assignment tracking info for the store we're going to delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Availability,redundant,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Safety,redund,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:177,Performance,perform,performing,177,"/// Many allocas are only used within a single basic block. If this is the; /// case, avoid traversing the CFG and inserting a lot of potentially useless; /// PHI nodes by just performing a single linear pass over the basic block; /// using the Alloca.; ///; /// If we cannot promote this alloca (because it is read before it is written),; /// return false. This is necessary in cases where, due to control flow, the; /// alloca is undefined only on some control flow paths. e.g. code like; /// this is correct in LLVM IR:; /// // A is an alloca with no stores so far; /// for (...) {; /// int t = *A;; /// if (!first_iteration); /// use(t);; /// *A = 42;; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:86,Safety,avoid,avoid,86,"/// Many allocas are only used within a single basic block. If this is the; /// case, avoid traversing the CFG and inserting a lot of potentially useless; /// PHI nodes by just performing a single linear pass over the basic block; /// using the Alloca.; ///; /// If we cannot promote this alloca (because it is read before it is written),; /// return false. This is necessary in cases where, due to control flow, the; /// alloca is undefined only on some control flow paths. e.g. code like; /// this is correct in LLVM IR:; /// // A is an alloca with no stores so far; /// for (...) {; /// int t = *A;; /// if (!first_iteration); /// use(t);; /// *A = 42;; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:245,Energy Efficiency,efficient,efficient,245,"// The trickiest case to handle is when we have large blocks. Because of this,; // this code is optimized assuming that large blocks happen. This does not; // significantly pessimize the small block case. This uses LargeBlockInfo to; // make it efficient to get the index of various operations in the block.; // Walk the use-def list of the alloca, getting the locations of all stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:96,Performance,optimiz,optimized,96,"// The trickiest case to handle is when we have large blocks. Because of this,; // this code is optimized assuming that large blocks happen. This does not; // significantly pessimize the small block case. This uses LargeBlockInfo to; // make it efficient to get the index of various operations in the block.; // Walk the use-def list of the alloca, getting the locations of all stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:45,Energy Efficiency,efficient,efficient,45,"// Sort the stores by their index, making it efficient to do a lookup with a; // binary search.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:19,Performance,load,loads,19,"// Walk all of the loads from this alloca, replacing them with the nearest; // store above them, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:59,Performance,load,load,59,// Find the nearest store that has a lower index than this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:31,Performance,load,load,31,"// If there are no stores, the load takes the undef value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:33,Performance,load,load,33,"// There is no store before this load, bail out (load may be affected; // by the following stores - see main comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:49,Performance,load,load,49,"// There is no store before this load, bail out (load may be affected; // by the following stores - see main comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:44,Performance,load,load,44,"// Otherwise, there was a store before this load, the load takes its; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:54,Performance,load,load,54,"// Otherwise, there was a store before this load, the load takes its; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:35,Performance,load,load,35,"// If the replacement value is the load, this must occur in unreachable; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Deployability,Update,Update,3,// Update assignment tracking info for the store we're going to delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Availability,redundant,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Safety,redund,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:136,Modifiability,variab,variable,136,// Calculate the set of read and write-locations for each alloca. This is; // analogous to finding the 'uses' and 'definitions' of each variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:62,Performance,load,loads,62,"// If there is only a single store to this value, replace any loads of; // it that are directly dominated by the definition with the value stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:67,Performance,perform,perform,67,"// If the alloca is only read and written in one basic block, just perform a; // linear sweep over the block to eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:41,Energy Efficiency,efficient,efficient,41,// Unique the set of defining blocks for efficient lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:180,Performance,optimiz,optimize,180,"// At this point, we're committed to promoting the alloca using IDF's, and; // the standard SSA construction algorithm. Determine which blocks need phi; // nodes and see if we can optimize out some work by avoiding insertion of; // dead phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:206,Safety,avoid,avoiding,206,"// At this point, we're committed to promoting the alloca using IDF's, and; // the standard SSA construction algorithm. Determine which blocks need phi; // nodes and see if we can optimize out some work by avoiding insertion of; // dead phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:124,Performance,load,load,124,"// Set the incoming values for the basic block to be null values for all of; // the alloca's. We do this in case there is a load of a value that has not; // been stored yet. In this case, it will get this null value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:42,Performance,perform,performing,42,// Walks all basic blocks in the function performing the SSA rename algorithm; // and inserting the phi nodes we marked as necessary,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:39,Safety,avoid,avoid,39,// The renamer uses the Visited set to avoid infinite loops. Clear it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Usability,Clear,Clear,61,// The renamer uses the Visited set to avoid infinite loops. Clear it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Availability,redundant,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Safety,redund,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:57,Safety,safe,safe,57,"// Iterating over NewPhiNodes is deterministic, so it is safe to try to; // simplify and RAUW them as we go. If it was not, we could add uses to; // the values we replace with in a non-deterministic order, thus creating; // non-deterministic def->use chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:76,Usability,simpl,simplify,76,"// Iterating over NewPhiNodes is deterministic, so it is safe to try to; // simplify and RAUW them as we go. If it was not, we could add uses to; // the values we replace with in a non-deterministic order, thus creating; // non-deterministic def->use chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:139,Energy Efficiency,efficient,efficient,139,"// Ok, now we know that all of the PHI nodes are missing entries for some; // basic blocks. Start by sorting the incoming predecessors for efficient; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:153,Security,access,access,153,"// Ok, now we know that all of the PHI nodes are missing entries for some; // basic blocks. Start by sorting the incoming predecessors for efficient; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:8,Testability,log,log,8,// Do a log(n) search of the Preds list for the entry we want.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:125,Deployability,Update,Update,125,"// At this point, the blocks left in the preds list must have dummy; // entries inserted into every PHI nodes for the block. Update all the phi; // nodes in this block that we are inserting (there could be phis before; // mem2reg runs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:122,Safety,avoid,avoid,122,"/// Determine which blocks the value is live in.; ///; /// These are blocks which lead to uses. Knowing this allows us to avoid; /// inserting PHI nodes into blocks which don't lead to uses (thus, the; /// inserted phi nodes would be dead).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:43,Performance,load,load,43,// We found a store to the alloca before a load. The alloca is not; // actually live-in here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,Performance,load,load,20,"// Okay, we found a load before a store to the alloca. It is actually; // live into this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:140,Modifiability,variab,variable,140,/// Queue a phi-node to be added to a basic-block for a specific Alloca.; ///; /// Returns true if there wasn't already a phi-node for that variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Performance,Queue,Queue,4,/// Queue a phi-node to be added to a basic-block for a specific Alloca.; ///; /// Returns true if there wasn't already a phi-node for that variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Deployability,Update,Update,4,"/// Update the debug location of a phi. \p ApplyMergedLoc indicates whether to; /// create a merged location incorporating \p DL, or to set \p DL directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:59,Performance,load,loads,59,"/// Recursively traverse the CFG of the function, renaming loads and; /// stores to the allocas which we are promoting.; ///; /// IncomingVals indicates what value each Alloca contains on exit from the; /// predecessor block Pred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:27,Deployability,update,update,27,"// If we have PHI nodes to update, compute the number of edges from Pred to; // BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Deployability,Update,Update,3,// Update the location of the phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:24,Modifiability,variab,variable,24,// The currently active variable for this block is now the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:22,Performance,load,load,22,// Anything using the load now uses the current value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:103,Usability,simpl,simplify,103,"// If lookup table has more than one user,; // do not generate a relative lookup table.; // This is to simplify the analysis that needs to be done for this pass.; // TODO: Add support for lookup tables with multiple uses.; // For ex, this can happen when a function that uses a lookup table gets; // inlined into multiple call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:136,Performance,optimiz,optimization,136,"// If the original lookup table does not have local linkage and is; // not dso_local, do not generate a relative lookup table.; // This optimization creates a relative lookup table that consists of; // offsets between the start of the lookup table and its elements.; // To be able to generate these offsets, relative lookup table and; // its elements should have internal linkage and be dso_local, which means; // that they should resolve to symbols within the same linkage unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:22,Performance,load,load,22,"// Insert the call to load.relative intrinsic before LOAD.; // GEP might not be immediately followed by a LOAD, like it can be hoisted; // outside the loop or another instruction might be inserted them in between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:53,Performance,LOAD,LOAD,53,"// Insert the call to load.relative intrinsic before LOAD.; // GEP might not be immediately followed by a LOAD, like it can be hoisted; // outside the loop or another instruction might be inserted them in between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:106,Performance,LOAD,LOAD,106,"// Insert the call to load.relative intrinsic before LOAD.; // GEP might not be immediately followed by a LOAD, like it can be hoisted; // outside the loop or another instruction might be inserted them in between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:20,Performance,load,load,20,// Create a call to load.relative intrinsic that computes the target address; // by adding base address (lookup table address) and relative offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:11,Performance,load,load,11,// Replace load instruction with the new generated instruction sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:10,Performance,Load,Load,10,// Remove Load and GEP instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update the distance and the parent node/edge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:23,Performance,queue,queue,23,"// Add the node to the queue, if it is not there yet",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:4,Deployability,Update,Update,4,/// Update the current flow along the augmenting path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:48,Safety,avoid,avoid,48,"// We use a stack based implemenation of DFS to avoid recursion.; // Defining DFS data structures:; // A pair (NodeIdx, EdgeIdx) at the top of the Stack denotes that; // - we are currently visiting Nodes[NodeIdx] and; // - the next edge to scan is Edges[NodeIdx][EdgeIdx]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:4,Deployability,Update,Update,4,"/// Update the current flow along the given (acyclic) subgraph specified by; /// the vertex order, AugmentingOrder. The objective is to send as much flow; /// as possible while evenly distributing flow among successors of each node.; /// After the update at least one edge is saturated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:248,Deployability,update,update,248,"/// Update the current flow along the given (acyclic) subgraph specified by; /// the vertex order, AugmentingOrder. The objective is to send as much flow; /// as possible while evenly distributing flow among successors of each node.; /// After the update at least one edge is saturated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:12,Deployability,Update,Update,12,// Phase 4: Update flow values along all edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update flow values along the edge and its reverse copy,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:53,Performance,queue,queue,53,/// An indicator of whether the current node is in a queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update reachability,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:131,Safety,avoid,avoid,131,"/// A distance of a path for a given jump.; /// In order to incite the path to use blocks/jumps with large positive flow,; /// and avoid changing branch probability of outgoing edges drastically,; /// set the jump distance so as:; /// - to minimize the number of unlikely jumps used and subject to that,; /// - to minimize the number of Flow == 0 jumps used and subject to that,; /// - minimizes total multiplicative Flow increase for the remaining edges.; /// To capture this objective with integer distances, we round off fractional; /// parts to a multiple of 1 / BaseDistance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:14,Performance,queue,queue,14,// Add to the queue all successors with zero local in-degree,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:35,Deployability,update,update,35,// Process all successor jumps and update corresponding flow values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:20,Integrability,depend,depending,20,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:20,Integrability,depend,depending,20,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:140,Safety,avoid,avoid,140,"// Verify that there are no isolated flow components; // One could modify FlowFunction to hold edges indexed by the sources, which; // will avoid a creation of the object",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:49,Performance,load,loader,49,"//===- SampleProfileLoaderBaseUtil.cpp - Profile loader Util func ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SampleProfileLoader base utility functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:1011,Performance,perform,performance,1011,"/// Return true if the given callsite is hot wrt to hot cutoff threshold.; ///; /// Functions that were inlined in the original binary will be represented; /// in the inline stack in the sample profile. If the profile shows that; /// the original inline decision was ""good"" (i.e., the callsite is executed; /// frequently), then we will recreate the inline decision and apply the; /// profile from the inlined callsite.; ///; /// To decide whether an inlined callsite is hot, we compare the callsite; /// sample count with the hot cutoff computed by ProfileSummaryInfo, it is; /// regarded as hot if the count is above the cutoff value.; ///; /// When ProfileAccurateForSymsInList is enabled and profile symbol list; /// is present, functions in the profile symbol list but without profile will; /// be regarded as cold and much less inlining will happen in CGSCC inlining; /// pass, so we tend to lower the hot criteria here to allow more early; /// inlining to happen for warm callsites and it is helpful for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:20,Modifiability,variab,variable,20,/// Create a global variable to flag FSDiscriminators are used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:14,Modifiability,variab,variable,14,// Place this variable to llvm.used so it won't be GC'ed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp:7,Security,Sanitiz,SanitizerStats,7,"//===- SanitizerStats.cpp - Sanitizer statistics gathering ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements code generation for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp:28,Security,Sanitiz,Sanitizer,28,"//===- SanitizerStats.cpp - Sanitizer statistics gathering ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements code generation for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp:414,Security,sanitiz,sanitizer,414,"//===- SanitizerStats.cpp - Sanitizer statistics gathering ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements code generation for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:6,Testability,assert,assert,6,// We assert at the end of the function since IP might point to an; // instruction with different dominance properties than a cast; // (an invoke for example) and not dominate BIP (but the cast does).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:126,Safety,Avoid,Avoid,126,"// Adjust insert point to be after instructions inserted by the expander, so; // we can re-use already inserted instructions. Avoid skipping past the; // original \p MustDominate, in case it is an inserted instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:159,Safety,safe,safe,159,"// inttoptr only works for integral pointers. For non-integral pointers, we; // can create a GEP on null with the integral value as index. Note that; // it is safe to use GEP of null instead of inttoptr here, because only; // expressions already based on a GEP of null should be converted to pointers; // during expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:122,Availability,redundant,redundant,122,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:93,Safety,avoid,avoid,93,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:122,Safety,redund,redundant,122,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:218,Safety,safe,safe,218,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:51,Safety,avoid,avoid,51,"// Don't count dbg.value against the ScanLimit, to avoid perturbing the; // generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:18,Integrability,wrap,wrap,18,// Ensure that no-wrap flags match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:79,Deployability,install,installed,79,"// Conservatively, do not use any instruction which has any of exact; // flags installed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1200,Availability,down,down,1200,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:399,Integrability,depend,depends,399,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:987,Performance,optimiz,optimization,987,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1055,Performance,optimiz,optimization,1055,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:543,Safety,safe,safely,543,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:949,Usability,simpl,simple,949,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1285,Usability,undo,undone,1285,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:51,Safety,avoid,avoid,51,"// Don't count dbg.value against the ScanLimit, to avoid perturbing the; // generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,Testability,Test,Test,3,// Test whether we've already computed the most relevant loop for this SCEV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:5,Usability,simpl,simple,5,// A simple add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:110,Energy Efficiency,power,powers,110,"// Expand the calculation of X pow N in the following manner:; // Let N = P1 + P2 + ... + PK, where all P are powers of 2. Then:; // X pow N = (X pow P1) * (X pow P2) * ... * (X pow PK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:90,Energy Efficiency,power,power,90,// Calculate how many times the same operand from the same loop is included; // into this power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:166,Energy Efficiency,power,power,166,"// No one sane will ever try to calculate such huge exponents, but if we; // need this, we stop on UINT64_MAX / 2 because we need to exit the loop; // below when the power of 2 exceeds our Exponent, and we want it to be; // 1u << 31 at most to not deal with unsigned overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:13,Energy Efficiency,power,powers,13,"// Calculate powers with exponents 1, 2, 4, 8 etc. and include those of them; // that are needed into the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:5,Usability,simpl,simple,5,// A simple mul.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,Usability,clear,clear,3,// clear nsw flag if shl will produce poison value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:41,Modifiability,variab,variable,41,"/// getIVIncOperand returns an induction variable increment's induction; /// variable operand.; ///; /// If allowScale is set, any type of GEP is allowed as long as the nonIV; /// operands dominate InsertPos.; ///; /// If allowScale is not set, ensure that a GEP increment conforms to one of the; /// simple patterns generated by getAddRecExprPHILiterally and; /// expandAddtoGEP. If the pattern isn't recognized, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
