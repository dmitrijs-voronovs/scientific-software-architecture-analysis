id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/TH3C.html:28823,Modifiability,variab,variable,28823,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3C(); Constructor. ~TH3C(); Destructor. TH3C(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const TH3C& h3c); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void SetBinContent(Int_t bin, Double_t content); Set bin content. void Streamer(TBuffer& ); Stream an object of class",MatchSource.WIKI,root/html534/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3C.html
https://root.cern/root/html534/TH3D.html:3512,Availability,error,error,3512,"ual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int",MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:3596,Availability,error,error,3596,"Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1:",MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:17099,Availability,error,error,17099,,MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:17169,Availability,error,error,17169,,MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:17251,Availability,error,error,17251,,MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:18791,Availability,error,error,18791,"nt_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBinErrorOption(TH1::EBinErrorOpt type); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:25811,Availability,error,errors,25811,,MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:29297,Availability,error,errors,29297,"nstructor for fix bin size 3-D histograms; *-* ==================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const TH3D& h3d); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& ); Stream an object of class TH3D. TH3D& operator=(const TH3D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}. » Author: Rene Brun 27/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:28568,Modifiability,variab,variable,28568,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3D(); Constructor. ~TH3D(); Destructor. TH3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const TH3D& h3d); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin",MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3D.html:28848,Modifiability,variab,variable,28848,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3D(); Constructor. ~TH3D(); Destructor. TH3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const TH3D& h3d); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& ); Stream an object of class TH3D. TH3D& operator=(const TH3D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) c",MatchSource.WIKI,root/html534/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3D.html
https://root.cern/root/html534/TH3F.html:3507,Availability,error,error,3507,"ual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int",MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:3591,Availability,error,error,3591,"Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1:",MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:17089,Availability,error,error,17089,,MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:17159,Availability,error,error,17159,,MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:17241,Availability,error,error,17241,,MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:18781,Availability,error,error,18781,"nt_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBinErrorOption(TH1::EBinErrorOpt type); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:25799,Availability,error,errors,25799,,MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:29285,Availability,error,errors,29285,"nstructor for fix bin size 3-D histograms; *-* ==================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const TH3F& h3f); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& ); Stream an object of class TH3F. TH3F& operator=(const TH3F& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}. » Author: Rene Brun 27/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:28556,Modifiability,variab,variable,28556,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3F(); Constructor. ~TH3F(); Destructor. TH3F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const TH3F& h3f); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin",MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3F.html:28836,Modifiability,variab,variable,28836,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3F(); Constructor. ~TH3F(); Destructor. TH3F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const TH3F& h3f); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& ); Stream an object of class TH3F. TH3F& operator=(const TH3F& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) c",MatchSource.WIKI,root/html534/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3F.html
https://root.cern/root/html534/TH3GL.html:2151,Performance,cache,cached,2151,"DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3GL.html
https://root.cern/root/html534/TH3GL.html:838,Testability,log,logx,838," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html534/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3GL.html
https://root.cern/root/html534/TH3GL.html:851,Testability,log,logy,851," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html534/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3GL.html
https://root.cern/root/html534/TH3GL.html:864,Testability,log,logz,864," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeSh",MatchSource.WIKI,root/html534/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3GL.html
https://root.cern/root/html534/TH3I.html:3511,Availability,error,error,3511,"ual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int",MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:3595,Availability,error,error,3595,"Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1:",MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:17083,Availability,error,error,17083,,MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:17153,Availability,error,error,17153,,MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:17235,Availability,error,error,17235,,MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:18775,Availability,error,error,18775,"nt_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBinErrorOption(TH1::EBinErrorOpt type); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:25800,Availability,error,errors,25800,,MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:29496,Availability,error,errors,29496,"===================. TH3I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const TH3I& h3i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH3I& operator=(const TH3I& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}. » Author: Rene Brun 27/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:28557,Modifiability,variab,variable,28557,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3I(); Constructor. ~TH3I(); Destructor. TH3I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const TH3I& h3i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ",MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3I.html:28837,Modifiability,variab,variable,28837,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3I(); Constructor. ~TH3I(); Destructor. TH3I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const TH3I& h3i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH3I& operator=(const TH3I& h1); Operator =. Double",MatchSource.WIKI,root/html534/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3I.html
https://root.cern/root/html534/TH3S.html:3514,Availability,error,error,3514,"ual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int",MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:3598,Availability,error,error,3598,"Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1:",MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:17096,Availability,error,error,17096,,MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:17166,Availability,error,error,17166,,MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:17248,Availability,error,error,17248,,MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:18788,Availability,error,error,18788,"nt_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBinErrorOption(TH1::EBinErrorOpt type); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:25806,Availability,error,errors,25806,,MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:29502,Availability,error,errors,29502,"tle, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const TH3S& h3s); Copy Constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& ); Stream an object of class TH3S. TH3S& operator=(const TH3S& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}. » Author: Rene Brun 27/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:28563,Modifiability,variab,variable,28563,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3S(); Constructor. ~TH3S(); Destructor. TH3S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const TH3S& h3s); Copy Constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ",MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/TH3S.html:28843,Modifiability,variab,variable,28843,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3S(); Constructor. ~TH3S(); Destructor. TH3S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const TH3S& h3s); Copy Constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& ); Stream an object of class",MatchSource.WIKI,root/html534/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TH3S.html
https://root.cern/root/html534/THaarMatrixT_double_.html:1648,Availability,error,error,1648,"); THaarMatrixT<double>(Int_t n, Int_t no_cols = 0); virtual~THaarMatrixT<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html534/THaarMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THaarMatrixT_double_.html
https://root.cern/root/html534/THaarMatrixT_double_.html:1732,Availability,error,error,1732," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html534/THaarMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THaarMatrixT_double_.html
https://root.cern/root/html534/THaarMatrixT_float_.html:1638,Availability,error,error,1638,">&); THaarMatrixT<float>(Int_t n, Int_t no_cols = 0); virtual~THaarMatrixT<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html534/THaarMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THaarMatrixT_float_.html
https://root.cern/root/html534/THaarMatrixT_float_.html:1722,Availability,error,error,1722," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html534/THaarMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THaarMatrixT_float_.html
https://root.cern/root/html534/THashList.html:2969,Availability,error,error,2969,"se(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObje",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:3053,Availability,error,error,3053,"const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Opti",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14740,Availability,avail,available,14740," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:11108,Energy Efficiency,reduce,reduce,11108,"ected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:616,Modifiability,inherit,inheriting,616,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollec",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:10173,Performance,cache,cache,10173,"TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. THashList(const THashList&); THashList&operator=(const THashList&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashin",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:15078,Performance,perform,performance,15078," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:361,Security,hash,hash,361,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollec",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:407,Security,hash,hash,407,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollec",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:437,Security,access,access,437,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollec",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:520,Security,hash,hash,520,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollec",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:10825,Security,hash,hashtable,10825,"Bits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:11066,Security,hash,hashtable,11066,"ected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:11408,Security,hash,hashlist,11408,"n::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an obje",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:11608,Security,hash,hashlist,11608,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddBefore(const TObject",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:13167,Security,hash,hashtable,13167,"t(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:13713,Security,access,access,13713," obj); Insert object before object before in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table.",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:13859,Security,hash,hash,13859,"ter, TObject* obj); Insert object after object after in the list. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14009,Security,hash,hash,14009," Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14181,Security,hash,hash,14181,"nger; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table t",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14353,Security,hash,hash,14353,"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14686,Security,hash,hash,14686," of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14704,Security,hash,hash,14704," of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14721,Security,hash,hash,14721," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:14862,Security,hash,hashlist,14862," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashList.html:15101,Security,hash,hashtable,15101," objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ). » Author: Fons Rademakers 10/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashList.html
https://root.cern/root/html534/THashTable.html:2332,Availability,error,error,2332,"rtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRehashLev",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:2416,Availability,error,error,2416,"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRehashLevel() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() con",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:8917,Energy Efficiency,reduce,reduce,8917,"elete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* optio",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:9820,Energy Efficiency,efficient,efficient,9820,"ists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corres",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:463,Modifiability,inherit,inheriting,463,". THashTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashTable. class THashTable: public TCollection. THashTable. THashTable implements a hash table to store TObject's. The hash; value is calculated using the value returned by the TObject's; Hash() function. Each class inheriting from TObject can override; Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects.; If the insertion order is important AND fast retrieval is needed; use THashList instead. /*. */. Function Members (Methods); public:. THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddBefore(const TObject* before, TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:11590,Performance,perform,performance,11590,"r converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » L",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:331,Security,hash,hash,331,". THashTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashTable. class THashTable: public TCollection. THashTable. THashTable implements a hash table to store TObject's. The hash; value is calculated using the value returned by the TObject's; Hash() function. Each class inheriting from TObject can override; Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects.; If the insertion order is important AND fast retrieval is needed; use THashList instead. /*. */. Function Members (Methods); public:. THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddBefore(const TObject* before, TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:366,Security,hash,hash,366,". THashTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashTable. class THashTable: public TCollection. THashTable. THashTable implements a hash table to store TObject's. The hash; value is calculated using the value returned by the TObject's; Hash() function. Each class inheriting from TObject can override; Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects.; If the insertion order is important AND fast retrieval is needed; use THashList instead. /*. */. Function Members (Methods); public:. THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidAddBefore(const TObject* before, TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual T",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:8624,Security,hash,hashtable,8624,"ue(TString& s) const; Int_tGetHashValue(const char* str) const; THashTable&operator=(const THashTable&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:8875,Security,hash,hashtable,8875,"elete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* optio",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:9175,Security,hash,hashtable,9175,"Sizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. ",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:9310,Security,hash,hash,9310,"e; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of ",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:9485,Security,hash,hash,9485,"ibraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap b",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:10151,Security,hash,hash,10151,"; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObj",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:10323,Security,hash,hash,10323,"hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(I",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:10552,Security,hash,hash,10552,"n.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To impro",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:10702,Security,hash,hash,10702,"e bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the tab",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:10850,Security,hash,hash,10850,"emented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all o",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:11038,Security,hash,hash,11038,". Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObjec",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:11276,Security,hash,hash,11276,"f collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() ",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:11373,Security,hash,hashtable,11373," length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). In",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:11613,Security,hash,hashtable,11613,"r converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » L",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:11958,Security,hash,hashtable,11958,"onding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:12028,Security,hash,hashtable,12028,"onding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTable.html:12056,Security,hash,hash,12056,"onding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTable.html
https://root.cern/root/html534/THashTableIter.html:2224,Integrability,depend,depending,2224,"ashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTableIter.html
https://root.cern/root/html534/THashTableIter.html:333,Security,hash,hash,333,". THashTableIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » THashTableIter. class THashTableIter: public TIterator. THashTableIter. Iterator of hash table. Function Members (Methods); public:. THashTableIter(const THashTableIter& iter); THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); virtual~THashTableIter(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const THashTableIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return ne",MatchSource.WIKI,root/html534/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTableIter.html
https://root.cern/root/html534/THashTableIter.html:1602,Security,hash,hashtable,1602,"ion*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator& aIter) const; Bool_toperator!=(const THashTableIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter();",MatchSource.WIKI,root/html534/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTableIter.html
https://root.cern/root/html534/THashTableIter.html:1954,Security,hash,hashtable,1954,"shTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTableIter.html
https://root.cern/root/html534/THashTableIter.html:2014,Security,hash,hashtable,2014,"ashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTableIter.html
https://root.cern/root/html534/THashTableIter.html:2176,Security,hash,hashtable,2176,"ashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THashTableIter.html
https://root.cern/root/html534/THbookBranch.html:1795,Availability,error,error,1795,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTBranch::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; const char*GetBlockName() const; virtual TList*TBranch::GetBrowsables(); virtua",MatchSource.WIKI,root/html534/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookBranch.html
https://root.cern/root/html534/THbookBranch.html:1879,Availability,error,error,1879,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTBranch::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; const char*GetBlockName() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() const; Int_tTBranch::GetCompressionAlgorithm() ",MatchSource.WIKI,root/html534/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookBranch.html
https://root.cern/root/html534/THbookBranch.html:7947,Deployability,update,updateSubBranches,7947,"Branch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBlockName(const char* name); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t n); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberIn",MatchSource.WIKI,root/html534/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookBranch.html
https://root.cern/root/html534/THbookBranch.html:13694,Integrability,interface,interface,13694,"BasketEntry! Next entry that will requires us to go to the next basket; Int_tTBranch::fNleaves! Number of leaves; Int_tTBranch::fOffsetOffset of this branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THbookBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1). THbookBranch(TBranch* branch, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1). ~THbookBranch(). void Browse(TBrowser* b); Browser interface. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); get one entry from hbook ntuple. void SetAddress(void* addobj); Set address of this branch; See important remark in the header of THbookTree. THbookBranch(); {;}. const char * GetBlockName() const; {return fBlockName.Data();}. void SetBlockName(const char* name); {fBlockName=name;}. void SetEntries(Long64_t n); {fEntries=n;}. » Author: Rene Brun 18/02/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/hbook:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookBranch.html
https://root.cern/root/html534/THbookBranch.html:10621,Modifiability,variab,variable,10621,"voidTObject::MakeZombie(); voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::ReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Length of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TStringfBlockNameHbook block name; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; G__p2memfuncTBranch::fFillLeaves! Pointer to the FillLeaves implementation to use. ; Style_tTAttFill::fF",MatchSource.WIKI,root/html534/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookBranch.html
https://root.cern/root/html534/THbookFile.html:2354,Availability,error,error,2354,"tual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; TObject*Get(Int_t id); const char*GetCurDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Int_tGetEntryBranch(Int_t entry, Int_t id); virtual const char*TObject::GetIconName() const; TList*GetList() const; TList*GetListOfKeys() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virt",MatchSource.WIKI,root/html534/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookFile.html
https://root.cern/root/html534/THbookFile.html:2438,Availability,error,error,2438,"_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; TObject*Get(Int_t id); const char*GetCurDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Int_tGetEntryBranch(Int_t entry, Int_t id); virtual const char*TObject::GetIconName() const; TList*GetList() const; TList*GetListOfKeys() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html534/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookFile.html
https://root.cern/root/html534/THbookFile.html:308,Integrability,interface,interface,308,". THbookFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookFile. class THbookFile: public TNamed. This class is an interface to the Hbook objects in Hbook files; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:; gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser. Function Members (Methods); public:. THbookFile(); THbookFile(const THbookFile&); THbookFile(const char* fname, Int_t lrecl = 1024); virtual~THbookFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Bool_tcd(const char* dirname = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); vi",MatchSource.WIKI,root/html534/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookFile.html
https://root.cern/root/html534/THbookFile.html:792,Modifiability,variab,variables,792,". THbookFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookFile. class THbookFile: public TNamed. This class is an interface to the Hbook objects in Hbook files; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:; gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser. Function Members (Methods); public:. THbookFile(); THbookFile(const THbookFile&); THbookFile(const char* fname, Int_t lrecl = 1024); virtual~THbookFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Bool_tcd(const char* dirname = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); vi",MatchSource.WIKI,root/html534/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookFile.html
https://root.cern/root/html534/THbookFile.html:8198,Modifiability,variab,variables,8198,"bookFile(); the constructor. THbookFile(const char* fname, Int_t lrecl = 1024); Constructor for an HBook file object. ~THbookFile(); destructor. void Browse(TBrowser* b); to be implemented. Bool_t cd(const char* dirname = """"); change directory to dirname. void Close(Option_t* option = """"); Close the Hbook file. void DeleteID(Int_t id); remove id from file and memory. TObject * FindObject(const char* name) const; return object with name in fList in memory. TObject * FindObject(const TObject* obj) const; return object with pointer obj in fList in memory. TObject * Get(Int_t id); import Hbook object with identifier idd in memory. Int_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Read in memory all columns of entry number of ntuple id from the Hbook file. Int_t GetEntryBranch(Int_t entry, Int_t id); Read in memory only the branch bname. void InitLeaves(Int_t id, Int_t var, TTreeFormula* formula); This function is called from the first entry in TTreePlayer::InitLoop; It analyzes the list of variables involved in the current query; and pre-process the internal Hbook tables to speed-up the search; at the next entries. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void SetBranchAddress(Int_t id, const char* bname, void* add); Set branch address. TFile * Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """"); Convert this Hbook file to a Root file with name rootname.; if rootname=""', rootname = hbook file name with .root instead of .hbook; By default, the Root file is connected and returned; option:; - ""NO"" do not connect the Root file; - ""C"" do not compress file (default is to compress); - ""L"" do not convert names to lower case (default is to convert). TObject * ConvertCWN(Int_t id); Convert the Column-Wise-Ntuple id to a Root Tree. TObject * ConvertRWN(Int_t id); Convert the Row-Wise-Ntuple id to a Root Tree. TObject * ConvertProfile(Int_t id); Convert an Hbook profile histogram into a Root ",MatchSource.WIKI,root/html534/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookFile.html
https://root.cern/root/html534/THbookFile.html:6943,Testability,log,logical,6943,"d, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfCurDirname of current directory; TList*fKeyslist of Hbook keys (Ids) on disk; TList*fListlist of objects in memory; Int_tfLreclRecord length in Hbook machine words; Int_tfLunFortran logical unit for this file; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Int_t*fgLuns; static Bool_tfgPawInit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THbookFile(); the constructor. THbookFile(const char* fname, Int_t lrecl = 1024); Constructor for an HBook file object. ~THbookFile(); destructor. void Browse(TBrowser* b); to be implemented. Bool_t cd(const char* dirname = """"); change directory to dirname. void Close(Option_t* option = """"); Close the Hbook file. void DeleteID(Int_t id); remove id from file and memory. TObject * FindObject(const char* name) const; return object with name in fList in memory. TObject * FindObject(const TObject* obj) const; return object with pointer obj in fList in memory. TObject * Get(Int_t id); import Hbook object with identifier idd in memory. Int_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Read in memory all columns of entry num",MatchSource.WIKI,root/html534/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookFile.html
https://root.cern/root/html534/THbookKey.html:1332,Availability,error,error,1332,"); THbookKey(const THbookKey&); THbookKey(Int_t id, THbookFile* file); virtual~THbookKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/THbookKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookKey.html
https://root.cern/root/html534/THbookKey.html:1416,Availability,error,error,1416,"kKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/THbookKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookKey.html
https://root.cern/root/html534/THbookTree.html:5420,Availability,error,error,5420,"ble_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTTree::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBra",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:5504,Availability,error,error,5504,"py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTTree::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tTTree::GetBranchStatus(const char*",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:16956,Deployability,update,updateExisting,16956,"Bit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THbookFile* file); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth)",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:25081,Energy Efficiency,allocate,allocated,25081,hich share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); THbookFile*fFilepointer to Hbook file; Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; Int_tfIDHbook identifier; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; Bool_tfInitflag to know if branches computed; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buf,MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:304,Integrability,wrap,wrapper,304,". THbookTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookTree. class THbookTree: public TTree. THbookTree. A wrapper class supporting Hbook ntuples (CWN and RWN).; The normal TTree calls can be used, including TTree::Draw().; Data read directly from the Hbook file via THbookFile. IMPORTANT NOTE; When setting the branch address (via THbookTree::SetBranchAddress); for a branch in an Hbook block containing several names, eg; Hbook block SELEVN with the following variables:. * 1 * R*4 * * * SELEVN * WGGS; * 2 * R*4 * * * SELEVN * AM12; * 3 * R*4 * * * SELEVN * AM34; * 4 * R*4 * * * SELEVN * AM14; * 5 * R*4 * * * SELEVN * AM32; * 6 * R*4 * * * SELEVN * PtPI(4); * 7 * R*4 * * * SELEVN * PHIPI(4); * 8 * R*4 * * * SELEVN * THTPI(4); one must define a C struct like:; struct {; Float_t Wggs;; Float_t Am12;; Float_t Am34;; Float_t Am14;; Float_t Am32;; Float_t Ptpi[4];; Float_t Phipi[4];; Float_t Thtpi[4];; } event;. and set ONLY the first variable address with:; h96->SetBranchAddress(""Wggs"",&event.Wggs);. Function Members (Methods); public:. THbookTree(); THbookTree(const char* name, Int_t id); virtual~THbookTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """,MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:659,Modifiability,variab,variables,659,". THbookTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookTree. class THbookTree: public TTree. THbookTree. A wrapper class supporting Hbook ntuples (CWN and RWN).; The normal TTree calls can be used, including TTree::Draw().; Data read directly from the Hbook file via THbookFile. IMPORTANT NOTE; When setting the branch address (via THbookTree::SetBranchAddress); for a branch in an Hbook block containing several names, eg; Hbook block SELEVN with the following variables:. * 1 * R*4 * * * SELEVN * WGGS; * 2 * R*4 * * * SELEVN * AM12; * 3 * R*4 * * * SELEVN * AM34; * 4 * R*4 * * * SELEVN * AM14; * 5 * R*4 * * * SELEVN * AM32; * 6 * R*4 * * * SELEVN * PtPI(4); * 7 * R*4 * * * SELEVN * PHIPI(4); * 8 * R*4 * * * SELEVN * THTPI(4); one must define a C struct like:; struct {; Float_t Wggs;; Float_t Am12;; Float_t Am34;; Float_t Am14;; Float_t Am32;; Float_t Ptpi[4];; Float_t Phipi[4];; Float_t Thtpi[4];; } event;. and set ONLY the first variable address with:; h96->SetBranchAddress(""Wggs"",&event.Wggs);. Function Members (Methods); public:. THbookTree(); THbookTree(const char* name, Int_t id); virtual~THbookTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """,MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:1138,Modifiability,variab,variable,1138,"class description; function members; data members; class charts. ROOT; » HIST; » HBOOK; » THbookTree. class THbookTree: public TTree. THbookTree. A wrapper class supporting Hbook ntuples (CWN and RWN).; The normal TTree calls can be used, including TTree::Draw().; Data read directly from the Hbook file via THbookFile. IMPORTANT NOTE; When setting the branch address (via THbookTree::SetBranchAddress); for a branch in an Hbook block containing several names, eg; Hbook block SELEVN with the following variables:. * 1 * R*4 * * * SELEVN * WGGS; * 2 * R*4 * * * SELEVN * AM12; * 3 * R*4 * * * SELEVN * AM34; * 4 * R*4 * * * SELEVN * AM14; * 5 * R*4 * * * SELEVN * AM32; * 6 * R*4 * * * SELEVN * PtPI(4); * 7 * R*4 * * * SELEVN * PHIPI(4); * 8 * R*4 * * * SELEVN * THTPI(4); one must define a C struct like:; struct {; Float_t Wggs;; Float_t Am12;; Float_t Am34;; Float_t Am14;; Float_t Am32;; Float_t Ptpi[4];; Float_t Phipi[4];; Float_t Thtpi[4];; } event;. and set ONLY the first variable address with:; h96->SetBranchAddress(""Wggs"",&event.Wggs);. Function Members (Methods); public:. THbookTree(); THbookTree(const char* name, Int_t id); virtual~THbookTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 3",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:16668,Performance,cache,cachesize,16668,"ual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THb",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:21828,Performance,cache,cacheSize,21828,"onst char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). Data Members; public:. enum TTree::ELockStatusBits { kFindBranch; kFindLeaf; kGetAlias; kGetBranch; kGetEntry; kGetEntryWithIndex; kGetFriend; kGetFriendAlias; kGetLeaf; kLoadTree; kPrint; kRemoveFriend; kSetBranchStatus; };; enum TTr",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:23010,Performance,cache,cache,23010,; enum TTree::ESetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum TTree::[unnamed] { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event select,MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:23154,Performance,cache,cache,23154,; enum TTree::ESetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum TTree::[unnamed] { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event select,MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:25566,Performance,load,loading,25566,s; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTypeRWN (0) or CWN (1); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); char*fXstorage area for RWN; Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static,MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THbookTree.html:3917,Usability,undo,undo,3917,"itlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root/html534/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THbookTree.html
https://root.cern/root/html534/THelix.html:2976,Availability,error,error,2976,"ual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& helix) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPolyLine3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidTPolyLine3D::DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTPolyLine3D::DrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyLine3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tTPolyLine3D::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine3D::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*TPolyLine3D::GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html534/THelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THelix.html
https://root.cern/root/html534/THelix.html:3060,Availability,error,error,3060,"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& helix) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPolyLine3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidTPolyLine3D::DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTPolyLine3D::DrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyLine3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tTPolyLine3D::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine3D::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*TPolyLine3D::GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_",MatchSource.WIKI,root/html534/THelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THelix.html
https://root.cern/root/html534/THelix.html:342,Energy Efficiency,charge,charge,342,". THelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » THelix. class THelix: public TPolyLine3D. THelix has two different constructors. If a particle with charge q passes through a point (x,y,z); with momentum (px,py,pz) with magnetic field B along an axis (nx,ny,nz),; this helix can be constrcuted like. THelix p(x,y,z, px,py,pz, q*B, nx,ny,nz);. (nx,ny,nz) defaults to (0,0,1). A helix in its own frame can be defined with a pivotal point; (x0,y0,z0), the velocity at that point (vx0,vy0,vz0), and; an angular frequency w. Combining vx0 and vy0 to a transverse; velocity vt0 one can parametrize the helix as. x(t) = x0 - vt0 / w * sin(-w * t + phi0); y(t) = y0 + vt0 / w * cos(-w * t + phi0); z(t) = z0 + vz0 * t. The second constructor has 6 parameters,. Example:; THelix pl1(xyz, v, w, range, rtype, axis);. where:; xyz : array of initial position; v : array of initial velocity; w : angular frequency; range: helix range; rtype: kHelixZ specifies allowed drawing range in helix Z direction, i.e., along B field.; kLabZ specifies drawing range in lab frame.; kHelixX, kHelixY, kLabX, kLabY, kUnchanged ... etc can also be specified; axis : helix axis. Example constructing a helix with several default values and drawing it:. This initializes a helix with its axis in Z direction (rtype=kHelixZ). Function Members (Methods); public:. THelix(); THelix(const THelix& helix); THelix(Double_t* xyz, Double_t* v, Double_t w, Double_t* range = 0, EHelixRangeType rtype = kHelixZ, Double_t* axis = 0); THelix(Double_t x, Double_t y, Double_t z, Double_t vx, Double_t vy, Double_t vz, Double_t w); virtual~THelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject",MatchSource.WIKI,root/html534/THelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THelix.html
https://root.cern/root/html534/THilbertMatrixTSym_double_.html:1756,Availability,error,error,1756,"rixTSym<double>(Int_t row_lwb, Int_t row_upb); virtual~THilbertMatrixTSym<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<double>::GetRowLwb() const; Int_tTMatrixTSymLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char*",MatchSource.WIKI,root/html534/THilbertMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixTSym_double_.html
https://root.cern/root/html534/THilbertMatrixTSym_double_.html:1840,Availability,error,error,1840," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<double>::GetRowLwb() const; Int_tTMatrixTSymLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* ",MatchSource.WIKI,root/html534/THilbertMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixTSym_double_.html
https://root.cern/root/html534/THilbertMatrixTSym_float_.html:1745,Availability,error,error,1745,"atrixTSym<float>(Int_t row_lwb, Int_t row_upb); virtual~THilbertMatrixTSym<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<float>::GetRowLwb() const; Int_tTMatrixTSymLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html534/THilbertMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixTSym_float_.html
https://root.cern/root/html534/THilbertMatrixTSym_float_.html:1829,Availability,error,error,1829," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<float>::GetRowLwb() const; Int_tTMatrixTSymLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html534/THilbertMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixTSym_float_.html
https://root.cern/root/html534/THilbertMatrixT_double_.html:1765,Availability,error,error,1765,"wb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~THilbertMatrixT<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html534/THilbertMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixT_double_.html
https://root.cern/root/html534/THilbertMatrixT_double_.html:1849,Availability,error,error,1849," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html534/THilbertMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixT_double_.html
https://root.cern/root/html534/THilbertMatrixT_float_.html:1754,Availability,error,error,1754,"lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~THilbertMatrixT<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html534/THilbertMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixT_float_.html
https://root.cern/root/html534/THilbertMatrixT_float_.html:1838,Availability,error,error,1838," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html534/THilbertMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THilbertMatrixT_float_.html
https://root.cern/root/html534/THistPainter.html:884,Availability,error,error,884,". THistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » THistPainter. class THistPainter: public TVirtualHistPainter. The histogram painter class. Introduction; Histograms' plotting options. Options supported for 1D and 2D histograms; Options supported for 1D histograms; Options supported for 2D histograms; Options supported for 3D histograms; Options supported for histograms' stacks (THStack). Setting the Style; Setting line, fill, marker, and text attributes; Setting Tick marks on the histogram axis; Giving titles to the X, Y and Z axis; The option ""SAME"". Limitations. Superimposing two histograms with different scales in the same pad; Statistics Display; Fit Statistics; The error bars options; The bar chart option; The ""BAR"" and ""HBAR"" options; The SCATter plot option (default for 2D histograms); The ARRow option; The BOX option; The COLor option; The CANDLE option; The VIOLIN option; The TEXT and TEXTnn Option; The CONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as color boxes; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box;",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:4571,Availability,error,error,4571,"new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:4695,Availability,error,error,4695,"new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:4866,Availability,error,error,4866,"n different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego plot with hidden surface removal, like LEGO1 but the border lines; of each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:4983,Availability,error,errors,4983,"of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego plot with hidden surface removal, like LEGO1 but the border lines; of each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents a",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:5023,Availability,error,error,5023,"of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego plot with hidden surface removal, like LEGO1 but the border lines; of each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents a",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:5060,Availability,error,errors,5060,"and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego plot with hidden surface removal, like LEGO1 but the border lines; of each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; T",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:6655,Availability,error,error,6655,"O3""; Draw a lego plot with hidden surface removal, like LEGO1 but the border lines; of each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:6722,Availability,error,error,6722," each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A bo",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:6783,Availability,error,error,6783," plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A box is drawn for each cell with surface proportional",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:6873,Availability,error,error,6873," the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A box is drawn for each cell with surface proportional to the content's; absolute value. A negative content is",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:6949,Availability,error,error,6949,"rmat set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A box is drawn for each cell with surface proportional to the content's; absolute value. A negative content is marked with a X. ""BOX1""; A button is drawn for each cell with surface prop",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:7123,Availability,error,error,7123,"ht side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A box is drawn for each cell with surface proportional to the content's; absolute value. A negative content is marked with a X. ""BOX1""; A button is drawn for each cell with surface proportional to content's absolute; value. A sunken button is drawn for negative values a raised one for positive. ""COL""; A box is drawn for each cell with a color scale varying with contents. All the;",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:13303,Availability,avail,available,13303," drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutorial transpad.C for a variant; of this example. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; // create/fill draw h1; gStyle->SetOptStat(kFALSE);; TH1F *h1 = new TH1F(""h1"",""Supe",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:15392,Availability,error,error,15392,"; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single nu",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:15461,Availability,error,error,15461,"; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single nu",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:15674,Availability,error,error,15674,"; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single nu",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:15737,Availability,error,error,15737,"; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single nu",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:16692,Availability,error,error,16692,"displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:16755,Availability,error,error,16755,"displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:16950,Availability,error,error,16950,"displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:17009,Availability,error,error,17009,"displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:19423,Availability,error,errors,19423," its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErro",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:19579,Availability,error,errors,19579,"SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through t",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:19798,Availability,error,error,19798,"at(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following examp",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:19847,Availability,error,error,19847,"bove).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new T",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:19919,Availability,error,error,19919,"stogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:20033,Availability,error,error,20033,"tatistics box (""Mean"", ""RMS"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:20122,Availability,error,error,20122,"; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRan",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:20293,Availability,error,error,20293,"ault = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the followi",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:20537,Availability,error,error,20537,"(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:20588,Availability,error,error,20588,"(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:20614,Availability,error,error,20614," the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; return c2e;; }; The bar ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:21283,Availability,error,error,21283,"rawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; return c2e;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Picture; Source. {; int i;; const Int_t nx = 8;; char *os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92,",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:32911,Availability,error,errors,32911,"x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; return c1;; }; The TEXT and TEXTnn Option; For each bin the content is printed. The text attributes are:. text font = current TStyle font (gStyle->SetTextFont()).; text size = 0.02*padheight*markersize (if h is the histogram drawn; with the option ""TEXT"" the marker size can be changed with; h->SetMarkerSize(markersize)).; text color = marker color. By default the format ""g"" is used. This format can be redefined; by calling gStyle->SetPaintTextFormat().; It is also possible to use ""TEXTnn"" in order to draw the text with; the angle nn (0 < nn < 90).; For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling gStyle->SetHistMinimumZero().; For 1D histogram the text is plotted at a y position equal to the bin content.; For 2D histograms when the option ""E"" (errors) is combined with the option; text (""TEXTE""), the error for each bin is also printed. Picture; Source. {; TCanvas *c01 = new TCanvas(""c01"",""c01"",700,400);; c01->Divide(2,1);; TH1F *htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; TH2F *htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; htext1->Fill(px,0.1);; htext2->Fill(px,5*py,0.1);; }; gStyle->SetPaintTextFormat(""4.1f m"");; htext2->SetMarkerSize(1.8);; c01->cd(1);; htext2->Draw(""TEXT45"");; c01->cd(2);; htext1->Draw();; htext1->Draw(""TEXT0 SAME"");; return c01;; }; In the case of profile histograms it is possible to print the number; of entries instead of the bin content. It is enough to combine the; option ""E"" (for entries) with the option ""TEXT"". Picture; Source. {; TCanvas *c02 = new TCanvas(""c02"",""c02"",700,400);; c02->Divide(2,1);; gStyle->SetPaintTextFormat(""g"");. TProfile *profile = new TProfile(""profile"",""profile"",10,0,",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:32968,Availability,error,error,32968,"x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; return c1;; }; The TEXT and TEXTnn Option; For each bin the content is printed. The text attributes are:. text font = current TStyle font (gStyle->SetTextFont()).; text size = 0.02*padheight*markersize (if h is the histogram drawn; with the option ""TEXT"" the marker size can be changed with; h->SetMarkerSize(markersize)).; text color = marker color. By default the format ""g"" is used. This format can be redefined; by calling gStyle->SetPaintTextFormat().; It is also possible to use ""TEXTnn"" in order to draw the text with; the angle nn (0 < nn < 90).; For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling gStyle->SetHistMinimumZero().; For 1D histogram the text is plotted at a y position equal to the bin content.; For 2D histograms when the option ""E"" (errors) is combined with the option; text (""TEXTE""), the error for each bin is also printed. Picture; Source. {; TCanvas *c01 = new TCanvas(""c01"",""c01"",700,400);; c01->Divide(2,1);; TH1F *htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; TH2F *htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; htext1->Fill(px,0.1);; htext2->Fill(px,5*py,0.1);; }; gStyle->SetPaintTextFormat(""4.1f m"");; htext2->SetMarkerSize(1.8);; c01->cd(1);; htext2->Draw(""TEXT45"");; c01->cd(2);; htext1->Draw();; htext1->Draw(""TEXT0 SAME"");; return c01;; }; In the case of profile histograms it is possible to print the number; of entries instead of the bin content. It is enough to combine the; option ""E"" (for entries) with the option ""TEXT"". Picture; Source. {; TCanvas *c02 = new TCanvas(""c02"",""c02"",700,400);; c02->Divide(2,1);; gStyle->SetPaintTextFormat(""g"");. TProfile *profile = new TProfile(""profile"",""profile"",10,0,",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:64294,Availability,avail,available,64294,"play the; palette axis values are taken from the Z axis of the object. For example, to; set the labels size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). WARNING: The palette axis is always drawn vertically.; Setting the color palette; To change the color palette TStyle::SetPalette should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option ""COL"" draws a 2D histogram with cells; represented by a box filled with a color index which is a function; of the cell content.; If the cell content is N, the color index used will be the color number; in colors[N], etc. If the maximum cell content is greater than; ncolors, all cell contents are scaled to ncolors.; If ncolors <= 0, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ...; if ncolors == 1 && colors == 0, then a Pretty Palette with a; Spectrum Violet->Red is created with 50 colors. That's the default rain bow; palette. Other prefined palettes with 255 colors are available when colors == 0.; The following value of ncolors give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be c",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:71204,Availability,error,errors,71204," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:72267,Availability,error,errors,72267," stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params);; TH2F *h2stb = new TH2F(""h2stb"",""h2stb"",20,-4,4,20,-4,4);; h2stb->SetFillColor(46);; h2stb->FillRandom(""f2"",3000);; a->Add(h2sta);; a->Add(h2stb);; a->Draw();; return cst;; }; If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option ""HIST"" should be used. Picture; Source. {; TCanvas *cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. TH1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Fro",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:72322,Availability,error,error,72322," stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params);; TH2F *h2stb = new TH2F(""h2stb"",""h2stb"",20,-4,4,20,-4,4);; h2stb->SetFillColor(46);; h2stb->FillRandom(""f2"",3000);; a->Add(h2sta);; a->Add(h2stb);; a->Draw();; return cst;; }; If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option ""HIST"" should be used. Picture; Source. {; TCanvas *cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. TH1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Fro",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:72358,Availability,error,errors,72358,"olor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params);; TH2F *h2stb = new TH2F(""h2stb"",""h2stb"",20,-4,4,20,-4,4);; h2stb->SetFillColor(46);; h2stb->FillRandom(""f2"",3000);; a->Add(h2sta);; a->Add(h2stb);; a->Draw();; return cst;; }; If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option ""HIST"" should be used. Picture; Source. {; TCanvas *cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. TH1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:80301,Availability,error,error,80301," virtual~THistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDefineColorLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static const char*GetBestFormat(Double_t v, Double_t e, const char* f); virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:80385,Availability,error,error,80385,"ual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDefineColorLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static const char*GetBestFormat(Double_t v, Double_t e, const char* f); virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*TVirtualHistPainter::HistPainter(TH1* obj); virtual ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:90729,Availability,error,error,90729,"the foreground of the pad.; ; . void PaintBar(Option_t* option). Draw a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:90801,Availability,error,errors,90801,"a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:95792,Availability,error,error,95792,"ather large, thus incorrectly giving the impression that, for example,; Greenland is larger than South America. In reality, the latter is about eight times the size of; Greenland. Also, the Former Soviet Union looks much bigger than Africa or South America. One may wonder; whether this illusion has had any influence on U.S. foreign policy.' (Source: GMT); code from Ernst-Jan Buis; ; . Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function code from Ernst-Jan Buis; ; . Int_t ProjectParabolic2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function code from Ernst-Jan Buis; ; . void RecalculateRange(). Recompute the histogram range following graphics operations.; ; . void SetHistogram(TH1* h). Set current histogram to ""h"".; ; . Int_t TableInit(). Initialize various options to draw 2D histograms.; ; . const char * GetBestFormat(Double_t v, Double_t e, const char* f). This function returns the best format to print the error value (e); knowing the parameter value (v) and the format (f) used to print it.; ; . void SetShowProjection(const char* option, Int_t nbins). Set projection.; ; . void ShowProjectionX(Int_t px, Int_t py). Show projection onto X.; ; . void ShowProjectionY(Int_t px, Int_t py). Show projection onto Y.; ; . void ShowProjection3(Int_t px, Int_t py). Show projection (specified by fShowProjection) of a TH3.; The drawing option for the projection is in fShowOption.; ; First implementation; R.Brun ; Full implementation: Tim Tran (timtran@jlab.org) April 2006; ; . THistPainter(). TList * GetStack() const; {return fStack;}. void RecursiveRemove(TObject* ); {;}. void SetStack(TList* stack); {fStack = stack;}. » Author: Rene Brun 26/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/histpainter:$Id$ » Last generated: 2015-05-26 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:3429,Deployability,update,updated,3429," a histogram ""h"" is enough to do:. h->Draw();. ""h"" can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a central singleton painter painting all histograms, allows; two histograms to be drawn in two threads without overwriting the painter's; values.; When a displayed histogram is filled again, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects; before drawing the new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:3448,Deployability,update,updated,3448,"ram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a central singleton painter painting all histograms, allows; two histograms to be drawn in two threads without overwriting the painter's; values.; When a displayed histogram is filled again, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects; before drawing the new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:17536,Deployability,update,updated,17536,"ations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:39393,Energy Efficiency,meter,meters,39393,"ours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }. for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }. // Create Histogram; TH2D *HistStreamFn = new TH2D(""HstreamFn"",; ""#splitline{Histogram with negative and positive contents. Six contours are defined.}{It is plotted with options CONT LIST to retrieve the contours points in TGraphs}"",; nZsamples, z[0], z[nZsamples-1], nPhiSamples, phi[0], phi[nPhiSamples-1]);. // Load Histogram Data; for (Int_t i = 0; i < nZsamples; i++) {; for(Int_t j = 0; j < nPhiSamples; j++){; HistStreamFn->SetBinContent(i,j, HofZ[i]*FofPhi[j]);; }; }. gStyle->SetPalette(1);; gStyle->SetOptStat(0);; gStyle->SetTitleW(0.99);; gStyle->SetTitleH(0.08);. Double_t contou",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:65239,Energy Efficiency,green,green,65239,"with 255 colors are available when colors == 0.; The following value of ncolors give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the Draw() option.; For example, with a TCutG named ""cutg"", one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a ""-"" in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts ("","" means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Picture; Source. #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h""; #include ""TCanvas.h""; #include ""TStyle.h"". //+ Fitting a 2-D histogram (a variant); // This tutorial illustrates :; // - how to create a 2-d function; // - fill a 2-d histogram randomly from this function; // - fit the histogram; // - display the fitted function on top of the histogram (lego-plot); // using a surface plot",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:76843,Energy Efficiency,green,green,76843," set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:78244,Energy Efficiency,green,green,78244,"atus bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal part of plot. This box; can be moved inside the plot's area (the full size of the box is; equal to the plot's surrounding box) by selecting one of the box; cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing. When back plane; is selected (and if it's highlighted in green) you can press and hold; left mouse button and shift key and move this back plane inside; plot's area, creating the slice. During this ""slicing"" plot becomes; semi-transparent. To remove all slices (and projected curves for; surfaces) double click with left mouse button in a plot's area.; Surface with option ""GLSURF""; The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3; The contour plot is drawn on the slicing plane. For TF3 the color; scheme can be changed by pressing 's' or 'S'.; Box; The contour plot corresponding to slice plane position is drawn in real time.; Iso; Slicing is similar to ""GLBOX"" option.; Parametric plot; No slicing. Additional keys: 's' or 'S' to change color scheme -; about 20 color schemes supported ('s' for ""scheme""); 'l' or 'L' to; increase number of polygons ('l' for ""level"" of details), 'w' or 'W'; to show outlines ('w' for ""wireframe"").; . Function Members (Methods); public:. THistPainter(); THistPain",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:62744,Integrability,interface,interface,62744,"748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };. Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Poly *p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);. TFile *f;; f = TFile::Open(""http://root.cern.ch/files/usa.root"");. TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }. for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);. gStyle->SetOptStat(11);; gStyle->SetPalette(1);; p->Draw(""COLZ L"");; return ch2p2;; }; TH2Poly histograms can also be plotted using the GL interface using; the option ""GLLEGO"".; The SPEC option; This option allows to use the TSpectrum2Painter tools. See the full; documentation in TSpectrum2Painter::PaintSpectrum.; Option ""Z"" : Adding the color palette on the right side of the pad; When this option is specified, a color palette with an axis indicating the value; of the corresponding color is drawn on the right side of the picture. In case,; not enough space is left, one can increase the size of the right margin by; calling TPad::SetRightMargin(). The attributes used to display the; palette axis values are taken from the Z axis of the object. For example, to; set the labels size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). WARNING: The palette axis is always drawn vertically.; Setting the color palette; To change the color palette TStyle::SetPalette should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option ""COL"" draws a 2D histogram with",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:89259,Integrability,rout,routine,89259,"with all histogram drawing options.; ; . void ExecuteEvent(Int_t event, Int_t px, Int_t py). Execute the actions corresponding to ""event"".; ; This function is called when a histogram is clicked with the locator at; the pixel position px,py.; ; . TList * GetContourList(Double_t contour) const. Get a contour (as a list of TGraphs) using the Delaunay triangulation.; ; . char * GetObjectInfo(Int_t px, Int_t py) const. Display the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py.; ; . Bool_t IsInside(Int_t x, Int_t y). Return kTRUE if the cell ix, iy is inside one of the graphical cuts.; ; . Bool_t IsInside(Double_t x, Double_t y). Return kTRUE if the point x,y is inside one of the graphical cuts.; ; . Int_t MakeChopt(Option_t* option). Decode string ""choptin"" and fill Hoption structure.; ; . Int_t MakeCuts(char* cutsopt). Decode string ""choptin"" and fill Graphical cuts structure.; ; . void Paint(Option_t* option = """"). Control routine to paint any kind of histograms.; . void PaintArrows(Option_t* option). Control function to draw a table as an arrow plot.; . void PaintAxis(Bool_t drawGridOnly = kFALSE). Draw axis (2D case) of an histogram.; ; If drawGridOnly is TRUE, only the grid is painted (if needed). This allows; to draw the grid and the axis separately. In THistPainter::Paint this; feature is used to make sure that the grid is drawn in the background and; the axis tick marks in the foreground of the pad.; ; . void PaintBar(Option_t* option). Draw a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control f",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:91005,Integrability,rout,routine,91005,". void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or h",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:91189,Integrability,rout,routines,91189,"rol function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or histogramming; system.; ; . void PaintStat(Int_t dostat, TF1* fit). Draw the statistics box for 1D and profile histograms.; . void PaintStat2(Int_t dostat",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:91273,Integrability,rout,routines,91273,"on). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or histogramming; system.; ; . void PaintStat(Int_t dostat, TF1* fit). Draw the statistics box for 1D and profile histograms.; . void PaintStat2(Int_t dostat, TF1* fit). Draw the statistics box for 2D histograms.; . void PaintStat3(Int_t dostat, TF1*",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:91985,Integrability,depend,dependency,91985," void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or histogramming; system.; ; . void PaintStat(Int_t dostat, TF1* fit). Draw the statistics box for 1D and profile histograms.; . void PaintStat2(Int_t dostat, TF1* fit). Draw the statistics box for 2D histograms.; . void PaintStat3(Int_t dostat, TF1* fit). Draw the statistics box for 3D histograms.; . void PaintSurface(Option_t* option). Control function to draw a 2D histogram as a surface plot.; . void PaintTriangles(Option_t* option). Control function to draw a table using Delaunay triangles.; ; . void DefineColorLevels(Int_t ndivz). Define the color levels used to paint legos, surfaces etc..; ; . void PaintTable(Option_t* option). Control function to draw 2D/3D histograms (tables).; . void PaintTH2PolyBins(Option_t* option). Control function to draw a TH2Poly bins' contours.; option = ""F"" draw the bins as filled areas.; option = ""L"" draw the bins as line.; option = ""P"" draw the bins as markers.; ; . void PaintTH2PolyColorLevels(Option",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:93884,Integrability,message,message,93884,"ion = ""P"" draw the bins as markers.; ; . void PaintTH2PolyColorLevels(Option_t* option). Control function to draw a TH2Poly as a color plot.; . void PaintTH2PolyScatterPlot(Option_t* option). Control function to draw a TH2Poly as a scatter plot.; . void PaintTH2PolyText(Option_t* option). Control function to draw a TH2Poly as a text plot.; . void PaintText(Option_t* option). Control function to draw a 1D/2D histograms with the bin values.; . void PaintTF3(). Control function to draw a 3D implicit functions.; . void PaintTitle(). Draw the histogram title; ; The title is drawn according to the title alignment returned by; GetTitleAlign(). It is a 2 digits integer): hv; ; where ""h"" is the horizontal alignment and ""v"" is the; vertical alignment.; ; ""h"" can get the values 1 2 3 for left, center, and right; ""v"" can get the values 1 2 3 for bottom, middle and top; ; for instance the default alignment is: 13 (left top); ; . void ProcessMessage(const char* mess, const TObject* obj). Process message ""mess"".; ; . Int_t ProjectAitoff2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function.; Convert Right Ascension, Declination to X,Y using an AITOFF projection.; This procedure can be used to create an all-sky map in Galactic; coordinates with an equal-area Aitoff projection. Output map; coordinates are zero longitude centered.; Also called Hammer-Aitoff projection (first presented by Ernst von Hammer in 1892); ; source: GMT; code from Ernst-Jan Buis; ; . Int_t ProjectMercator2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function ; Probably the most famous of the various map projections, the Mercator projection; takes its name from Mercator who presented it in 1569. It is a cylindrical, conformal projection; with no distortion along the equator.; The Mercator projection has been used extensively for world maps in which the distortion towards; the polar regions grows rather large, thus incorrectly giving the impression that, for example,; Greenla",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:11876,Modifiability,inherit,inherit,11876,"sZ). ""BOX""; Draw a for each cell with volume proportional to the content's absolute value. ""LEGO""; Same as BOX. Options supported for histograms' stacks (THStack). "" ""; Default, the histograms are drawn on top of each other (as lego plots for 2D; histograms). ""NOSTACK""; Histograms in the stack are all paint in the same pad as if the option; ""SAME"" had been specified. ""PADS""; The current pad/canvas is subdivided into a number of pads equal to the number; of histograms in the stack and each histogram is paint into a separate pad. Setting the Style; Histograms use the current style (gStyle). When one changes the current; style and would like to propagate the changes to the histogram,; TH1::UseCurrentStyle should be called. Call UseCurrentStyle on; each histogram is needed. To force all the histogram to use the current style use:. gROOT->ForceStyle();. All the histograms read after this call will use the current style.; Setting line, fill, marker, and text attributes; The histogram classes inherit from the attribute classes:; TAttLine, TAttFill and TAttMarker.; See the description of these classes for the list of options.; Setting Tick marks on the histogram axis; The TPad::SetTicks method specifies the type of tick marks on the axis.; If tx = gPad->GetTickx() and ty = gPad->GetTicky() then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:24309,Performance,scalab,scalable,24309,"; The percentage of the bar drawn with either the light or dark color is:. 0% for option ""(h)bar"" or ""(h)bar0""; 10% for option ""(h)bar1""; 20% for option ""(h)bar2""; 30% for option ""(h)bar3""; 40% for option ""(h)bar4"". To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:24385,Performance,scalab,scalable,24385,"h)bar"" or ""(h)bar0""; 10% for option ""(h)bar1""; 20% for option ""(h)bar2""; 30% for option ""(h)bar3""; 40% for option ""(h)bar4"". To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option; For each cell (i,j) a box is drawn. The size (surface) of the box is; proportional to the ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:38246,Performance,perform,performed,38246,"ace; colors to distinguish contours (""SURF"" option at theta = 0). Combined; with the option ""CONT"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(1);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:76691,Performance,perform,performed,76691,"TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametr",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:42312,Safety,avoid,avoid,42312,"s += contLevel->GetSize();; }. nGraphs = 0;. TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);. hr->Draw();; Double_t x0, y0, z0;; TLatex l;; l.SetTextSize(0.03);; char val[20];. for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) z0 = contours[2-i];; else z0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", z0);. // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, x0, y0);; if (z0<0) curv->SetLineColor(kRed);; if (z0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());. // Draw clones of the graphs to avoid deletions in case the 1st; // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");. sprintf(val,""%g"",z0);; l.DrawLatex(x0,y0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }. Double_t SawTooth(Double_t x, Double_t WaveLen){. // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //. Double_t y;; if ( (x < -WaveLen/2) || (x > WaveLen/2)) y = -99999999; // Error X out of bounds; if (x <= -WaveLen/4) {; y = x + 2.0;; } else if ((x > -WaveLen/4) && (x <= WaveLen/4)) {; y = -x ;; } else if (( x > WaveLen/4) && (x <= WaveLen/2)) {; y = x - 2.0;; }; return y;; }; The following opti",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:74050,Safety,avoid,avoid,74050,"ing example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:17639,Security,access,accessed,17639,"sSiIourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:31374,Security,hash,hashed,31374,"Q3 (top of the box).; The maximum value of the distribution D (top dashed line). The mean value of the distribution D is also represented as a circle. In this implementation a TH2 is considered as a collection of TH1 along; X (option CANDLE or CANDLEX) or Y (option CANDLEY).; Each TH1 is represented as a candle plot. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcandle = new TH2F(""hcandle"",""Option CANDLE example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcandle->Fill(px,5*py);; }; hcandle->SetMarkerSize(0.5);; hcandle->Draw(""CANDLE"");; return c1;; }; The VIOLIN option; A violin plot is a box plot; that also encodes the pdf information at each point. Quartiles and mean are also represented at each point, with a marker; and two lines. In this implementation a TH2 is considered as a collection of TH1 along; X (option VIOLIN or VIOLINX) or Y (option VIOLINY). A solid fill style is recommended for this plot (as opposed to a hollow or; hashed style). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; Double_t xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; TH2F* hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; Double_t x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++iBin) {; Double_t xc = hviolin->GetXaxis()->GetBinCenter(iBin);; f1.SetParameters(1, 2.0+TMath::Sin(1.0+xc), 0.2+0.1*(xc-xmin)/xmax);; for(Int_t i=0; i<10000; ++i){; x = xc;; y = f1.GetRandom();; hviolin->Fill(x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; return c1;; }; The TEXT and TEXTnn Option; For each bin the content is printed. The text attributes are:. text font = current TStyle font (gStyle->SetTextFont()).; text size = 0.02*padheight*markersize (if h is the histogram drawn; with the option ""TEXT"" the ma",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:38327,Security,access,accessible,38327,"T"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(1);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsampl",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:38733,Security,access,access,38733,"NT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavele",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:64359,Security,access,access,64359,"he object. For example, to; set the labels size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). WARNING: The palette axis is always drawn vertically.; Setting the color palette; To change the color palette TStyle::SetPalette should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option ""COL"" draws a 2D histogram with cells; represented by a box filled with a color index which is a function; of the cell content.; If the cell content is N, the color index used will be the color number; in colors[N], etc. If the maximum cell content is greater than; ncolors, all cell contents are scaled to ncolors.; If ncolors <= 0, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ...; if ncolors == 1 && colors == 0, then a Pretty Palette with a; Spectrum Violet->Red is created with 50 colors. That's the default rain bow; palette. Other prefined palettes with 255 colors are available when colors == 0.; The following value of ncolors give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:65805,Testability,log,logical,65805,"Body Radiator palette is used. If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the Draw() option.; For example, with a TCutG named ""cutg"", one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a ""-"" in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts ("","" means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Picture; Source. #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h""; #include ""TCanvas.h""; #include ""TStyle.h"". //+ Fitting a 2-D histogram (a variant); // This tutorial illustrates :; // - how to create a 2-d function; // - fill a 2-d histogram randomly from this function; // - fit the histogram; // - display the fitted function on top of the histogram (lego-plot); // using a surface plot in a sub-range of the histogram.; //; // This example can be executed via the interpreter or/and the compiler; // root > .x fit2a.C; // root > .x fit2a.C++; //Author: Rene Brun; ; Double_t g2(Double_t *x, Double_t *par) {; Double_t r1 = Double_t((x[0]-par[1])/par[2]);; Double_t r2 = Double_t((x[1]-par[3])/par[4]);; return par[0]*TMath::Exp(-0.5*(r1*r1+r2*r2));; } ; Double_t fun2(Double_t *x, Double_t *par) {; Double_t *p1 = &par[0];; Double_t *p2 = &par[5];; Double_t *p3 = &par[10];; Double_t result = g2(x,p",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:70417,Testability,test,test,70417," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:70604,Testability,test,test,70604," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:70793,Testability,test,test,70793," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:74807,Testability,log,logarithmic,74807,"(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:74868,Testability,log,logarithmic,74868,"o:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a se",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:75301,Testability,log,logarithmic,75301,"rary. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Inte",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:75385,Testability,log,logarithmic,75385,"enGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as color boxes; The supported option is:. ""GLCOL"" ; H3 is drawn using semi-transparent colored boxes.; See $ROOTSYS/tutorials/gl/glvox1.C. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimi",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:2143,Usability,usab,usable,2143,"ONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as color boxes; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box; Iso; Parametric plot. Introduction; Histograms are drawn via the THistPainter class. Each histogram has a; pointer to its own painter (to be usable in a multithreaded program). When the; canvas has to be redrawn, the Paint function of each objects in the; pad is called. In case of histograms, TH1::Paint invokes directly; THistPainter::Paint.; To draw a histogram ""h"" is enough to do:. h->Draw();. ""h"" can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a cen",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:3619,Usability,clear,clears,3619,"rs many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a central singleton painter painting all histograms, allows; two histograms to be drawn in two threads without overwriting the painter's; values.; When a displayed histogram is filled again, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects; before drawing the new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing ",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:13112,Usability,clear,cleared,13112,"ifies the type of tick marks on the axis.; If tx = gPad->GetTickx() and ty = gPad->GetTicky() then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutor",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:21662,Usability,simpl,simple,21662,"3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; 2D histograms can be drawn with error bars as shown is the following example:. Picture; Source. {; TCanvas *c2e = new TCanvas(""c2e"",""c2e"",600,400);; TH2F *h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; return c2e;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Picture; Source. {; int i;; const Int_t nx = 8;; char *os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. TCanvas *cb = new TCanvas(""cb"",""cb"",600,400);; cb->SetGrid();. gStyle->SetHistMinimumZero();. TH1F *h1b = new TH1F(""h1b"",""Option B example"",nx,0,nx);; h1b->SetFillColor(4);; h1b->SetBarWidth(0.4);; h1b->SetBarOffset(0.1);; h1b->SetStats(0);; h1b->SetMinimum(-5);; h1b->SetMaximum(5);. for (i=1; i<=nx; i++) {; h1b->Fill(os_X[i-1",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:29820,Usability,simpl,simply,29820," ""Z"" allows to; display the color palette defined by gStyle->SetPalette().; In the following example, the histogram has only positive bins; the empty; bins (containing 0) are not drawn. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcol1 = new TH2F(""hcol1"",""Option COLor example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,5*py);; }; gStyle->SetPalette(1);; hcol1->Draw(""COLZ"");; return c1;; }; In the following example, the histogram has some negative bins; the empty; bins (containing 0) are drawn. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcol2 = new TH2F(""hcol2"",""Option COLor example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol2->Fill(px,5*py);; }; hcol2->Fill(0.,0.,-200.);; gStyle->SetPalette(1);; hcol2->Draw(""COLZ"");; return c1;; }; The CANDLE option; A Candle plot (also known as; a ""box-and whisker plot"" or simply ""box plot"") is a convenient way to describe; graphically a data distribution (D) with only the five numbers. It was invented; in 1977 by John Tukey. With the option CANDLEX five numbers are:. The minimum value of the distribution D (bottom dashed line).; The lower quartile (Q1): 25% of the data points in D are less than; Q1 (bottom of the box).; The median (M): 50% of the data points in D are less than M; (thick line segment inside the box).; The upper quartile (Q3): 75% of the data points in D are less; than Q3 (top of the box).; The maximum value of the distribution D (top dashed line). The mean value of the distribution D is also represented as a circle. In this implementation a TH2 is considered as a collection of TH1 along; X (option CANDLE or CANDLEX) or Y (option CANDLEY).; Each TH1 is represented as a candle plot. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcandle = new TH2F(""hcandle"",""Option CANDLE example "",40,-4,4,40,-20,20);",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:59031,Usability,simpl,simple,59031,"BarOffset(0.5);; h2bh->SetStats(0);; for (i=1;i<=nx;i++) h2bh->Fill(os_X[i-1], d_35_1[i-1]);. h2bh->Draw(""hbar same"");. return cbh;; }; TH2Poly Drawing; The following options are supported:. ""SCAT""; Draw a scatter plot (default). ""COL""; Draw a color plot. All the none empty bins are painted. Empty bins are not; painted. ""COLZ""; Same as ""COL"". In addition the color palette is also drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTN""; Draw bin names as text. ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""L""; Draw the bins boundaries as lines.; The lines attibutes are the TGraphs ones. ""P""; Draw the bins boundaries as markers.; The markers attibutes are the TGraphs ones. ""F""; Draw the bins boundaries as filled polygons.; The filled polygons attibutes are the TGraphs ones. TH2Poly can; be drawn as a color plot (option COL). TH2Poly bins can have any; shapes. The bins are defined as graphs. The following macro is a very simple; example showing how to book a TH2Poly and draw it. Picture; Source. {; TCanvas *ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; Double_t px1[] = {0, 5, 6};; Double_t py1[] = {0, 0, 5};; Double_t px2[] = {0, -1, -1, 0};; Double_t py2[] = {0, 0, -1, 3};; Double_t px3[] = {4, 3, 0, 1, 2.4};; Double_t py3[] = {4, 3.7, 1, 3.7, 2.5};; h2p->AddBin(3, px1, py1);; h2p->AddBin(4, px2, py2);; h2p->AddBin(5, px3, py3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; Double_t fx[] = {0.1, -0.5, -0.7, 1};; Double_t fy[] = {0.01, -0.5, -0.5, 3};; Double_t fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; gStyle->SetPalette(1);; h2p->Draw(""col"");; return ch2p1;; }; Rectangular bins are a frequent case. The special version of; the AddBin method allows to define them more easily like; shown in the following example. Picture; Source. //This tutorial illustrates h",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:73722,Usability,simpl,simply,73722,"new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:88153,Usability,simpl,simple,88153,"raph2DPainter object; TH1*fHpointer to histogram to paint; TPainter3dAlgorithms*fLegopointer to a TPainter3dAlgorithms object; Int_tfNcutsNumber of graphical cuts; TPie*fPiepointer to a TPie in case of option PIE; TStringfShowOptionOption to draw the projection; Int_tfShowProjectionTrue if a projection must be drawn; TList*fStackPointer to stack of histograms (if any); TAxis*fXaxispointer to X axis; Double_t*fXbufX buffer coordinates; TAxis*fYaxispointer to Y axis; Double_t*fYbufY buffer coordinates; TAxis*fZaxispointer to Z axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THistPainter(). Default constructor.; ; . ~THistPainter(). Default destructor.; ; . Int_t DistancetoPrimitive(Int_t px, Int_t py). Compute the distance from the point px,py to a line.; ; Compute the closest distance of approach from point px,py to elements of; an histogram. The distance is computed in pixels units.; ; Algorithm:; Currently, this simple model computes the distance from the mouse to the; histogram contour only.; ; . void DrawPanel(). Display a panel with all histogram drawing options.; ; . void ExecuteEvent(Int_t event, Int_t px, Int_t py). Execute the actions corresponding to ""event"".; ; This function is called when a histogram is clicked with the locator at; the pixel position px,py.; ; . TList * GetContourList(Double_t contour) const. Get a contour (as a list of TGraphs) using the Delaunay triangulation.; ; . char * GetObjectInfo(Int_t px, Int_t py) const. Display the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py.; ; . Bool_t IsInside(Int_t x, Int_t y). Return kTRUE if the cell ix, iy is inside one of the graphical cuts.; ; . Bool_t IsInside(Double_t x, Double_t y). Return kTRUE if the point x,y is inside one of the graphical cuts.; ; . Int_t MakeChopt(Option_t* option). Decode string ""choptin"" and fill Hoption structure.; ; . Int_t MakeCuts(char* cutsopt). Decode string ""choptin"" an",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THistPainter.html:90853,Usability,clear,clear,90853,"ption). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint specia",MatchSource.WIKI,root/html534/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THistPainter.html
https://root.cern/root/html534/THLimitsFinder.html:1563,Availability,error,error,1563," THLimitsFinder(); THLimitsFinder(const THLimitsFinder&); virtual~THLimitsFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); virtual Int_tFindGoodLimits(TH1* h, ",MatchSource.WIKI,root/html534/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THLimitsFinder.html
https://root.cern/root/html534/THLimitsFinder.html:1647,Availability,error,error,1647," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static THLimitsFinder*GetLimitsFinder(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObjec",MatchSource.WIKI,root/html534/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THLimitsFinder.html
https://root.cern/root/html534/THLimitsFinder.html:6403,Performance,optimiz,optimized,6403,"har* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder deri",MatchSource.WIKI,root/html534/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THLimitsFinder.html
https://root.cern/root/html534/THLimitsFinder.html:6827,Performance,optimiz,optimized,6827,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Original axis limits; Bin",MatchSource.WIKI,root/html534/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THLimitsFinder.html
https://root.cern/root/html534/THLimitsFinder.html:7138,Performance,optimiz,optimized,7138,"ion documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Original axis limits; BinLow,BinHigh : Optimized axis limits. They should be initialized by the; calling method for instance to 0.; nold : Original number of divisions.; nbins : Optimized number of divisions.; BinWidth : Optimized bin width. It should be initialized by the; calling method for instance to 0.; option : ""T"" means Time ax",MatchSource.WIKI,root/html534/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THLimitsFinder.html
https://root.cern/root/html534/THn.html:1634,Availability,error,errors,1634," RAM!. To construct a THn object you must use one of its templated, derived; classes:; THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long_t>): bin content held by a Long_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, min, max);. * Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. * Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call; hn->GetAxis(12)->SetRange(from_bin, to_bin);. * Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THn(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist,",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:2476,Availability,avail,available,2476,"""hn"", 2, bins, min, max);. * Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. * Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call; hn->GetAxis(12)->SetRange(from_bin, to_bin);. * Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THn(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*CreateHn(const char* name, const char* title, const TH1* h1); static THn*CreateHn(const char* name, const char* title, const THnBase* hn)",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:4175,Availability,error,error,4175,"ct*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*CreateHn(const char* name, const char* title, const TH1* h1); static THn*CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tGetBin(const Int_t* idx) const; virtual Long64_tGetBin(const Double_t* x) const; virtual Long64_tGetBin(const char** name) const; virtual Long64_tGetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long64_tGetBin(const Dou",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:4259,Availability,error,error,4259,"ct*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*CreateHn(const char* name, const char* title, const TH1* h1); static THn*CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tGetBin(const Int_t* idx) const; virtual Long64_tGetBin(const Double_t* x) const; virtual Long64_tGetBin(const char** name) const; virtual Long64_tGetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long64_tGetBin(const Dou",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:12937,Availability,error,error,12937,"const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). private:. THn&operator=(const THn&). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THn(); Destruct a THn. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all bins. Public interface is THnIter. void Sumw2(); Enable calculation of errors. void AllocCoordBuf() const; Create the coordinate buffer. Outlined to hide allocation; from inlined functions. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void Reset(Option_t* option = """"); Reset the contents of a THn. THn& operator=(const THn& ). void Fill",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:13125,Availability,error,errors,13125,"const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). private:. THn&operator=(const THn&). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THn(); Destruct a THn. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all bins. Public interface is THnIter. void Sumw2(); Enable calculation of errors. void AllocCoordBuf() const; Create the coordinate buffer. Outlined to hide allocation; from inlined functions. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void Reset(Option_t* option = """"); Reset the contents of a THn. THn& operator=(const THn& ). void Fill",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:13560,Availability,error,errors,13560,"bjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THn(); Destruct a THn. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all bins. Public interface is THnIter. void Sumw2(); Enable calculation of errors. void AllocCoordBuf() const; Create the coordinate buffer. Outlined to hide allocation; from inlined functions. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void Reset(Option_t* option = """"); Reset the contents of a THn. THn& operator=(const THn& ). void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. GetArray(). THn* CreateHn(const char* name, const char* title, const TH1* h1). THn* CreateHn(const char* name, const char* title, const THnBase* hn). Long64_t GetNbins() const; { return GetArray().GetNbins(); }. Long64_t GetBin(const Int_t* idx) const. return GetArray(). Long64_t GetBin(const Double_t* x) const. Long64_t GetBin(const char** name) const. Long64_t GetBin(const Int_t* idx, Bool_t = kTRUE). Long64_t GetBin(const Double_t* x, Bool_t = kTRUE). Long64_t GetBin(const char** name, Bool_t = kTRUE). void SetBinContent(const Int_t* idx, Double_t v);",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:1721,Energy Efficiency,allocate,allocated,1721,"ved; classes:; THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long_t>): bin content held by a Long_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, min, max);. * Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. * Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call; hn->GetAxis(12)->SetRange(from_bin, to_bin);. * Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THn(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.);",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:1819,Energy Efficiency,reduce,reduced,1819,"t_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long_t>): bin content held by a Long_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, min, max);. * Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. * Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call; hn->GetAxis(12)->SetRange(from_bin, to_bin);. * Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THn(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2);",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THn.html:13502,Integrability,interface,interface,13502,"nBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THn(); Destruct a THn. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all bins. Public interface is THnIter. void Sumw2(); Enable calculation of errors. void AllocCoordBuf() const; Create the coordinate buffer. Outlined to hide allocation; from inlined functions. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void Reset(Option_t* option = """"); Reset the contents of a THn. THn& operator=(const THn& ). void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. GetArray(). THn* CreateHn(const char* name, const char* title, const TH1* h1). THn* CreateHn(const char* name, const char* title, const THnBase* hn). Long64_t GetNbins() const; { return GetArray().GetNbins(); }. Long64_t GetBin(const Int_t* idx) const. return GetArray(). Long64_t GetBin(const Double_t* x) const. Long64_t GetBin(const char** name) const. Long64_t GetBin(const Int_t* idx, Bool_t = kTRUE). Long64_t GetBin(const Double_t* x, Bool_t = kTRUE). Long64_t GetBin(const char** name, Bool_t = kTRUE). void SetBinCo",MatchSource.WIKI,root/html534/THn.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THn.html
https://root.cern/root/html534/THnBase.html:512,Availability,avail,available,512,". THnBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnBase. class THnBase: public TNamed. Multidimensional histogram base. Defines common functionality and interfaces for THn, THnSparse. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnBase(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnBase* h, Double_t c = 1.); voidAdd(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnBase* h); voidDivide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:2000,Availability,error,error,2000,"* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnBase* h); voidDivide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tFill(const Double_t* x, Double_t w = 1.); Long64_tFill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """"); TAxis*GetAxis(Int_t dim) const; virtual Long64_tGetBin(const Int_t* idx) const; virtual Long64_tGetBin(const Double_t* x) const; virtual Long64_tGetBin(const char** name) const; virtual Long64_tGetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long64_tGetBin(const Double_t* x, Bool_t = kTRUE); virtual Long64_tGetBin(const char** name, Bool_t = kTRUE); Double_tGetBinC",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:2084,Availability,error,error,2084,"* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnBase* h); voidDivide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tFill(const Double_t* x, Double_t w = 1.); Long64_tFill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """"); TAxis*GetAxis(Int_t dim) const; virtual Long64_tGetBin(const Int_t* idx) const; virtual Long64_tGetBin(const Double_t* x) const; virtual Long64_tGetBin(const char** name) const; virtual Long64_tGetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long64_tGetBin(const Double_t* x, Bool_t = kTRUE); virtual Long64_tGetBin(const char** name, Bool_t = kTRUE); Double_tGetBinC",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:10060,Availability,error,errors,10060,"ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*RebinBase(Int_t group) const; THnBase*RebinBase(const Int_t* group) const; virtual voidReserve(Long64_t); voidResetBase(Option_t* option = """"); virtual voidSetFilledBins(Long64_t); voidUpdateXStat(const Double_t* x, Double_t w = 1.). private:. THnBase&operator=(const THnBase&). Data Members; public:. enum { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAxesaxes of the histogram; TObjArrayfBrowsables! browser-helpers for each axis; Double_tfEntriesnumber of entries, spread over chunks; Double_t*fIntegral! array with bin weight sums; enum THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tfNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tfTsumwtotal sum of weights; Double_tfTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDfTsumwxtotal sum of weight*X for each dimension; TArrayDfTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnBase(); Destruct a THnBase. THnBase* CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create a new THnBase object that is of the same type as *this,; but with dimensions and bins given by axes.; If keepTargetAxis is true, the axes will keep their original xmin / xmax,; else they will be restricted to the range selected (first / last). void Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, ",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:11579,Availability,error,error,11579,"tAxis is true, the axes will keep their original xmin / xmax,; else they will be restricted to the range selected (first / last). void Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnBase* CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = ",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:13195,Availability,error,errors,13195,"t is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange(). TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; Project all bins into a ndim-dimensional THn / THnSparse (whatever; *this is) or if (ndim < 4 and !wantNDim) a TH1/2/3 histogram,; keeping only axes in dim (specifying ndim dimensions).; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. void Scale(Double_t c); Scale contents and errors of this histogram by c:; this = this * c; It does not modify the histogram's number of entries. void AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Add() implementation for both rebinned histograms and those with identical; binning. See THnBase::Add(). void Add(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consistent binning of",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:13427,Availability,error,errors,13427," the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange(). TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; Project all bins into a ndim-dimensional THn / THnSparse (whatever; *this is) or if (ndim < 4 and !wantNDim) a TH1/2/3 histogram,; keeping only axes in dim (specifying ndim dimensions).; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. void Scale(Double_t c); Scale contents and errors of this histogram by c:; this = this * c; It does not modify the histogram's number of entries. void AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Add() implementation for both rebinned histograms and those with identical; binning. See THnBase::Add(). void Add(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consistent binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnBase's. All THnBase's provided; in the list must have the same bin layout!. void Multiply(const THnBase* h); Multiply t",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:14678,Availability,error,errors,14678,". See THnBase::Add(). void Add(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consistent binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnBase's. All THnBase's provided; in the list must have the same bin layout!. void Multiply(const THnBase* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:14698,Availability,error,errors,14698,". See THnBase::Add(). void Add(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consistent binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnBase's. All THnBase's provided; in the list must have the same bin layout!. void Multiply(const THnBase* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:14822,Availability,error,errors,14822,"et, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnBase* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consistent binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnBase's. All THnBase's provided; in the list must have the same bin layout!. void Multiply(const THnBase* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnBase* h, const char* tag) const; Consistency check on (some of) the parameters of",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:15171,Availability,error,errors,15171,"ing of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnBase's. All THnBase's provided; in the list must have the same bin layout!. void Multiply(const THnBase* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnBase* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:15537,Availability,error,errors,15537," called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnBase* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnBase* RebinBase(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnBase.; For group=2 and a 3 dimensional histogram, all ""blocks""; of ",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:15638,Availability,error,errors,15638," c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after; calling Multiply(). void Divide(const THnBase* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnBase* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnBase* RebinBase(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnBase.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. THnBase* RebinBase(const Int_t* gr",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:17377,Availability,error,error,17377,"const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnBase.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. THnBase* RebinBase(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnBase.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void ResetBase(Option_t* option = """"); Clear the histogram. Double_t ComputeIntegral(); Calculate the integral of the histogram. void PrintBin(Long64_t idx, Option_t* options) const; Print bin with linex index ""idx"".; For valid options see PrintBin(Long64_t idx, Int_t* bin, Option_t* options). Bool_t PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; Print one bin. If ""idx"" is != -1 use that to determine the bin,; otherwise (if ""idx"" == -1) use the coordinate in ""bin"".; If ""options"" contains:; '0': only print bins with an error or content != 0; Return whether the bin was printed (depends on options). void PrintEntries(Long64_t from = 0, Long64_t howmany = -1, Option_t* options = 0) const; Print ""howmany"" entries starting at ""from"". If ""howmany"" is -1, print all.; If ""options"" contains:; 'x': print in the order of axis bins, i.e. (0,0,...,0), (0,0,...,1),...; '0': only print bins with content != 0. void Print(Option_t* option = """") const; Print a THnBase. If ""option"" contains:; 'a': print axis details; 'm': print memory usage; 's': print statistics; 'c': print its content, too (this can generate a LOT of output!); Other options are forwarded to PrintEntries(). void Browse(TBrowser* b); Browse a THnSparse: create an entry (ROOT::THnSparseBrowsable) for each; dimension. THnBase& operator=(const THnBase& ). void UpdateXStat(const Double_t* x, Double_t w = 1.). void FillBin(Long64_t bin, Double_t w). void FillBinBase(Double_t w); Increment the statistics due to filled weight ""w"",. void InitStorage(Int_t* nbins, Int_t ch",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:19115,Availability,error,errors,19115,"rowsable) for each; dimension. THnBase& operator=(const THnBase& ). void UpdateXStat(const Double_t* x, Double_t w = 1.). void FillBin(Long64_t bin, Double_t w). void FillBinBase(Double_t w); Increment the statistics due to filled weight ""w"",. void InitStorage(Int_t* nbins, Int_t chunkSize). void Reserve(Long64_t ); {}. void SetFilledBins(Long64_t ); {}. Bool_t PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const. TObjArray* GetListOfAxes(); { return &fAxes; }. const TObjArray* GetListOfAxes() const; { return &fAxes; }. TAxis* GetAxis(Int_t dim) const; { return (TAxis*)fAxes[dim]; }. TList* GetListOfFunctions(); { return 0; }. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const. Long64_t GetNbins() const. Double_t GetEntries() const; { return fEntries; }. Double_t GetWeightSum() const; { return fTsumw; }. Int_t GetNdimensions() const; { return fNdimensions; }. Bool_t GetCalculateErrors() const; { return fTsumw2 >= 0.; }. void CalculateErrors(Bool_t calc = kTRUE); Calculate errors (or not if ""calc"" == kFALSE). Long64_t Fill(const Double_t* x, Double_t w = 1.). Long64_t Fill(const char** name, Double_t w = 1.). Double_t GetBinError(const Int_t* idx) const; { return GetBinError(GetBin(idx)); }. Double_t GetBinError(Long64_t linidx) const; { return TMath::Sqrt(GetBinError2(linidx)); }. void SetBinError(const Int_t* idx, Double_t e); { SetBinError(GetBin(idx), e); }. void SetBinError(Long64_t bin, Double_t e); { SetBinError2(bin, e*e); }. void AddBinContent(const Int_t* x, Double_t v = 1.); { AddBinContent(GetBin(x), v); }. void SetEntries(Double_t entries); { fEntries = entries; }. Double_t GetBinContent(const Int_t* idx) const; { return GetBinContent(GetBin(idx)); }. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const. Double_t GetBinError2(Long64_t linidx) const. Long64_t GetBin(const Int_t* idx) const. Long64_t GetBin(const Double_t* x) const. Long64_t GetBin(const char** name) const. Long64_t GetBin(const Int_t* idx, Bool_t = kTRUE). Long",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:20862,Availability,error,errors,20862,"t* idx = 0) const. Double_t GetBinError2(Long64_t linidx) const. Long64_t GetBin(const Int_t* idx) const. Long64_t GetBin(const Double_t* x) const. Long64_t GetBin(const char** name) const. Long64_t GetBin(const Int_t* idx, Bool_t = kTRUE). Long64_t GetBin(const Double_t* x, Bool_t = kTRUE). Long64_t GetBin(const char** name, Bool_t = kTRUE). void SetBinContent(const Int_t* idx, Double_t v); { SetBinContent(GetBin(idx), v); }. void SetBinContent(Long64_t bin, Double_t v). void SetBinError2(Long64_t bin, Double_t e2). void AddBinError2(Long64_t bin, Double_t e2). void AddBinContent(Long64_t bin, Double_t v = 1.). Double_t GetSumw() const; { return fTsumw; }. Double_t GetSumw2() const; { return fTsumw2; }. Double_t GetSumwx(Int_t dim) const; { return fTsumwx[dim]; }. Double_t GetSumwx2(Int_t dim) const; { return fTsumwx2[dim]; }. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. {xDim, yDim}. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; wil",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:21393,Availability,error,errors,21393,"AddBinError2(Long64_t bin, Double_t e2). void AddBinContent(Long64_t bin, Double_t v = 1.). Double_t GetSumw() const; { return fTsumw; }. Double_t GetSumw2() const; { return fTsumw2; }. Double_t GetSumwx(Int_t dim) const; { return fTsumwx[dim]; }. Double_t GetSumwx2(Int_t dim) const; { return fTsumwx2[dim]; }. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. {xDim, yDim}. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. {xDim, yDim, zDim}. THnBase* ProjectionND(Int_t ndim, const Int_t* dim, Option_t* option = """") const. void Reset(Option_t* option = """"). void Sumw2(). Bool_t IsFolder() const; { return kTRUE; }. » Author: Axel Naumann (2011-12-20) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:21686,Availability,error,errors,21686,"AddBinError2(Long64_t bin, Double_t e2). void AddBinContent(Long64_t bin, Double_t v = 1.). Double_t GetSumw() const; { return fTsumw; }. Double_t GetSumw2() const; { return fTsumw2; }. Double_t GetSumwx(Int_t dim) const; { return fTsumwx[dim]; }. Double_t GetSumwx2(Int_t dim) const; { return fTsumwx2[dim]; }. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. {xDim, yDim}. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. {xDim, yDim, zDim}. THnBase* ProjectionND(Int_t ndim, const Int_t* dim, Option_t* option = """") const. void Reset(Option_t* option = """"). void Sumw2(). Bool_t IsFolder() const; { return kTRUE; }. » Author: Axel Naumann (2011-12-20) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:347,Integrability,interface,interfaces,347,". THnBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnBase. class THnBase: public TNamed. Multidimensional histogram base. Defines common functionality and interfaces for THn, THnSparse. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnBase(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnBase* h, Double_t c = 1.); voidAdd(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnBase* h); voidDivide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:11033,Integrability,depend,depending,11033,"squared; -1 if no errors are calculated; TArrayDfTsumwxtotal sum of weight*X for each dimension; TArrayDfTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnBase(); Destruct a THnBase. THnBase* CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create a new THnBase object that is of the same type as *this,; but with dimensions and bins given by axes.; If keepTargetAxis is true, the axes will keep their original xmin / xmax,; else they will be restricted to the range selected (first / last). void Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnBase* CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (defaul",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:17436,Integrability,depend,depends,17436,"const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnBase.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. THnBase* RebinBase(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnBase.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void ResetBase(Option_t* option = """"); Clear the histogram. Double_t ComputeIntegral(); Calculate the integral of the histogram. void PrintBin(Long64_t idx, Option_t* options) const; Print bin with linex index ""idx"".; For valid options see PrintBin(Long64_t idx, Int_t* bin, Option_t* options). Bool_t PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; Print one bin. If ""idx"" is != -1 use that to determine the bin,; otherwise (if ""idx"" == -1) use the coordinate in ""bin"".; If ""options"" contains:; '0': only print bins with an error or content != 0; Return whether the bin was printed (depends on options). void PrintEntries(Long64_t from = 0, Long64_t howmany = -1, Option_t* options = 0) const; Print ""howmany"" entries starting at ""from"". If ""howmany"" is -1, print all.; If ""options"" contains:; 'x': print in the order of axis bins, i.e. (0,0,...,0), (0,0,...,1),...; '0': only print bins with content != 0. void Print(Option_t* option = """") const; Print a THnBase. If ""option"" contains:; 'a': print axis details; 'm': print memory usage; 's': print statistics; 'c': print its content, too (this can generate a LOT of output!); Other options are forwarded to PrintEntries(). void Browse(TBrowser* b); Browse a THnSparse: create an entry (ROOT::THnSparseBrowsable) for each; dimension. THnBase& operator=(const THnBase& ). void UpdateXStat(const Double_t* x, Double_t w = 1.). void FillBin(Long64_t bin, Double_t w). void FillBinBase(Double_t w); Increment the statistics due to filled weight ""w"",. void InitStorage(Int_t* nbins, Int_t ch",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:11755,Performance,perform,performed,11755,"Axis, Int_t chunkSize = 1024*16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnBase* CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribu",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:11817,Performance,perform,performance,11817,"Axis, Int_t chunkSize = 1024*16); Initialize axes and name. TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnBase* CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribu",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnBase.html:12048,Testability,log,log-likelihood,12048,"kSize = 1024*16); Create a THn / THnSparse object from a histogram deriving from TH1. THnBase* CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); Create a THnSparse (if ""sparse"") or THn from ""hn"", possibly; converting THn <-> THnSparse. void Add(const TH1* hist, Double_t c = 1.); Fill the THnBase with the bins of hist that have content; or error != 0. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange(). TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; Project all bins into a ndim-dimensional THn / THnSparse (whatever; *this is) or if (ndim < 4 and !wantNDim) a TH1/2/3 histogram,; keeping only axes in dim (specifying ndim dimensions).; If ""opti",MatchSource.WIKI,root/html534/THnBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnBase.html
https://root.cern/root/html534/THnIter.html:1367,Availability,error,error,1367,"; THnIter(const THnBase* hist, Bool_t respectAxisRange = kFALSE); virtual~THnIter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCoord(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHaveSkippedBin() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; ",MatchSource.WIKI,root/html534/THnIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnIter.html
https://root.cern/root/html534/THnIter.html:1451,Availability,error,error,1451," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCoord(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHaveSkippedBin() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/THnIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnIter.html
https://root.cern/root/html534/THnSparse.html:1772,Availability,error,errors,1772,"; THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparseT<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:4880,Availability,avail,available,4880,"THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; static THnSparse*CreateSparse(const char* name, const char* title, con",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:6659,Availability,error,error,6659,"pare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tGetBin(const Int_t* idx) const; virtual Long64_tGetBin(const Double_t* x) const; virtual Long64_tGetBin(const char** name) const; virtual Long64_tGetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Long64_tGetBin(const Double_t* x, Bool_t allocate = kTRUE); virtual Long64_tGetBin(co",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:6743,Availability,error,error,6743,"pare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*CreateIter(Bool_t respectAxisRange) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tGetBin(const Int_t* idx) const; virtual Long64_tGetBin(const Double_t* x) const; virtual Long64_tGetBin(const char** name) const; virtual Long64_tGetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Long64_tGetBin(const Double_t* x, Bool_t allocate = kTRUE); virtual Long64_tGetBin(co",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:15818,Availability,error,errors,15818,"tion = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidReserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. private:. TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nb",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17661,Availability,error,error,17661," chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17701,Availability,error,errors,17701,"e have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:18580,Availability,error,error,18580,"to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:18625,Availability,error,errors,18625,"to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:18700,Availability,error,error,18700,"If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. Long64_t GetBin(const Int_t* idx) const; { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }. Long64_t ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:18738,Availability,error,errors,18738,"If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. Long64_t GetBin(const Int_t* idx) const; { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }. Long64_t ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:18792,Availability,error,errors,18792,"Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. void FillBin(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. chunk-> AddBinContent(const Int_t* idx, Double_t v = 1.). THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16). THnSparse* CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16). Int_t GetChunkSize() const; { return fChunkSize; }. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. Long64_t GetNbins() const; { return fFilledBins; }. void SetFilledBins(Long64_t nbins); { fFilledBins = nbins; }. Long64_t GetBin(const Int_t* idx) const; { return const_cast<THnSparse*>(this)->GetBin(idx, kFALSE); }. Long64_t GetBin(const Double_t* x) const; { return const_cast<THnSparse*>(this)->GetBin",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:584,Energy Efficiency,allocate,allocates,584,". THnSparse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparse. class THnSparse: public THnBase. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparseT<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:1857,Energy Efficiency,allocate,allocated,1857,"nSparseT<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparseT<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSp",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:3057,Energy Efficiency,reduce,reduced,3057,"sing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate i",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:3725,Energy Efficiency,allocate,allocated,3725,"torial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Functio",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:7504,Energy Efficiency,allocate,allocate,7504,,MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:7572,Energy Efficiency,allocate,allocate,7572,,MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:7640,Energy Efficiency,allocate,allocate,7640,,MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:14147,Energy Efficiency,allocate,allocate,14147," 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidFillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidFillExMap(); virtual TArray*GenerateArray() const; Long64_tGetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*GetChunk(Int_t idx) const; THnSparseCompactBinCoord*GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidInitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidReserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObje",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:16874,Energy Efficiency,allocate,allocate,16874,"ase::fTsumwx2total sum of weight*X*X for each dimension. private:. TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:16943,Energy Efficiency,allocate,allocate,16943,"ase::fTsumwx2total sum of weight*X*X for each dimension. private:. TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:16985,Energy Efficiency,allocate,allocate,16985,"ase::fTsumwx2total sum of weight*X*X for each dimension. private:. TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17047,Energy Efficiency,allocate,allocate,17047,"-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of fil",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17140,Energy Efficiency,allocate,allocate,17140,"-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of fil",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17182,Energy Efficiency,allocate,allocate,17182,"-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of fil",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17242,Energy Efficiency,allocate,allocate,17242,"insnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approxi",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17321,Energy Efficiency,allocate,allocate,17321,"insnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approxi",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17363,Energy Efficiency,allocate,allocate,17363,"insnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approxi",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17818,Energy Efficiency,allocate,allocate,17818,"for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* o",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17908,Energy Efficiency,allocate,allocate,17908,"ndex for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseA",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:17930,Energy Efficiency,allocate,allocate,17930,"ndex for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError2(Long64_t linidx) const; Get square of the error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return contents. Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. ROOT::THnBaseBinIter* CreateIter(Bool_t respectAxisRange) const; Create an iterator over all filled bins of a THnSparse.; Use THnIter instead. void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError2(Long64_t bin, Double_t e2); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void AddBinError2(Long64_t bin, Double_t e2); Add ""e"" to error of bin with index ""bin"", enable errors if needed. void Sumw2(); Enable calculation of errors. void Reset(Option_t* option = """"); Clear the histogram. THnSparse& operator=(const THnSparse& ). THnSparseA",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:707,Security,access,access,707,". THnSparse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparse. class THnSparse: public THnBase. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparseT<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:4015,Security,hash,hash,4015," 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c =",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:4061,Security,hash,hash,4061," 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c =",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:4183,Security,hash,hash,4183,"GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); vi",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:4408,Security,hash,hash,4408,"e compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:4610,Security,hash,hash,4610,"esentation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* new",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparse.html:16109,Security,hash,hashes,16109,"tMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. private:. TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Long64_tfFilledBinsnumber of filled bins. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. void InitStorage(Int_t* nbins, Int_t chunkSize); Initialize the storage of a histogram created via Init(). void FillExMap(); We have been streamed; set up fBins. void Reserve(Long64_t nbins); Initialize storage for nbins. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate ",MatchSource.WIKI,root/html534/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparse.html
https://root.cern/root/html534/THnSparseArrayChunk.html:466,Availability,error,errors,466,". THnSparseArrayChunk. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseArrayChunk. class THnSparseArrayChunk: public TObject. THnSparseArrayChunk is used internally by THnSparse. THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time. Function Members (Methods); public:. THnSparseArrayChunk(); THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); virtual~THnSparseArrayChunk(); voidTObject::AbstractMethod(const char* method) const; voidAddBin(Int_t idx, const Char_t* idxbuf); voidAddBinContent(Int_t idx, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:818,Availability,error,errors,818,". THnSparseArrayChunk. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseArrayChunk. class THnSparseArrayChunk: public TObject. THnSparseArrayChunk is used internally by THnSparse. THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time. Function Members (Methods); public:. THnSparseArrayChunk(); THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); virtual~THnSparseArrayChunk(); voidTObject::AbstractMethod(const char* method) const; voidAddBin(Int_t idx, const Char_t* idxbuf); voidAddBinContent(Int_t idx, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:1876,Availability,error,error,1876,"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:1960,Availability,error,error,1960,"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:6157,Availability,error,errors,6157,"idTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:6298,Availability,error,errors,6298," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automat",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:6436,Availability,error,errors,6436,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:6447,Availability,error,errors,6447,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:6611,Availability,error,errors,6611,"ate:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseArrayChunk.html:5891,Energy Efficiency,allocate,allocated,5891,"idTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don",MatchSource.WIKI,root/html534/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:3676,Availability,error,error,3676,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:3760,Availability,error,error,3760,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:13205,Availability,error,errors,13205,"ual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArray* GenerateArray() const. » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:4603,Energy Efficiency,allocate,allocate,4603,,MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:4682,Energy Efficiency,allocate,allocate,4682,,MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:4761,Energy Efficiency,allocate,allocate,4761,,MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:11539,Energy Efficiency,allocate,allocate,11539,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayC_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayC>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseT<TArrayC>. class THnSparseT<TArrayC>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_t; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseC. Function Members (Methods); public:. THnSparseT<TArrayC>(); THnSparseT<TArrayC>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayC>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHn",MatchSource.WIKI,root/html534/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayC_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:3676,Availability,error,error,3676,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:3760,Availability,error,error,3760,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:13205,Availability,error,errors,13205,"ual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArray* GenerateArray() const. » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:4603,Energy Efficiency,allocate,allocate,4603,,MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:4682,Energy Efficiency,allocate,allocate,4682,,MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:4761,Energy Efficiency,allocate,allocate,4761,,MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:11539,Energy Efficiency,allocate,allocate,11539,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayD_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayD>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseT<TArrayD>. class THnSparseT<TArrayD>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_t; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseD. Function Members (Methods); public:. THnSparseT<TArrayD>(); THnSparseT<TArrayD>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayD>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHn",MatchSource.WIKI,root/html534/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayD_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:3676,Availability,error,error,3676,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:3760,Availability,error,error,3760,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:13205,Availability,error,errors,13205,"ual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArray* GenerateArray() const. » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:4603,Energy Efficiency,allocate,allocate,4603,,MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:4682,Energy Efficiency,allocate,allocate,4682,,MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:4761,Energy Efficiency,allocate,allocate,4761,,MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:11539,Energy Efficiency,allocate,allocate,11539,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayF_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayF>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseT<TArrayF>. class THnSparseT<TArrayF>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_t; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseF. Function Members (Methods); public:. THnSparseT<TArrayF>(); THnSparseT<TArrayF>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayF>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHn",MatchSource.WIKI,root/html534/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayF_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:3676,Availability,error,error,3676,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:3760,Availability,error,error,3760,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:13205,Availability,error,errors,13205,"ual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArray* GenerateArray() const. » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:4603,Energy Efficiency,allocate,allocate,4603,,MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:4682,Energy Efficiency,allocate,allocate,4682,,MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:4761,Energy Efficiency,allocate,allocate,4761,,MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:11539,Energy Efficiency,allocate,allocate,11539,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayI_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayI>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseT<TArrayI>. class THnSparseT<TArrayI>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_t; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseI. Function Members (Methods); public:. THnSparseT<TArrayI>(); THnSparseT<TArrayI>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayI>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHn",MatchSource.WIKI,root/html534/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayI_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:3676,Availability,error,error,3676,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:3760,Availability,error,error,3760,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:13205,Availability,error,errors,13205,"ual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArray* GenerateArray() const. » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:4603,Energy Efficiency,allocate,allocate,4603,,MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:4682,Energy Efficiency,allocate,allocate,4682,,MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:4761,Energy Efficiency,allocate,allocate,4761,,MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:11539,Energy Efficiency,allocate,allocate,11539,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayL_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayL>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseT<TArrayL>. class THnSparseT<TArrayL>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_t; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseL. Function Members (Methods); public:. THnSparseT<TArrayL>(); THnSparseT<TArrayL>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayL>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHn",MatchSource.WIKI,root/html534/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayL_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:3676,Availability,error,error,3676,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:3760,Availability,error,error,3760,"ouble_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; virtual ROOT::THnBaseBinIter*THnSparse::CreateIter(Bool_t respectAxisRange) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t chunkSize = 1024*16); static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const THnBase* hn, Int_t chunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx) const; virtual Long64_tTHnSparse::GetBin(const Double_t* x) const; virtual Long64_tTHnSparse::GetBin(const char** name) const; virtual Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); virtual Lon",MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:13205,Availability,error,errors,13205,"ual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArray* GenerateArray() const. » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:4603,Energy Efficiency,allocate,allocate,4603,,MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:4682,Energy Efficiency,allocate,allocate,4682,,MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:4761,Energy Efficiency,allocate,allocate,4761,,MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:11539,Energy Efficiency,allocate,allocate,11539,"_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnBase::AddInternal(const THnBase* h, Double_t c, Bool_t rebinned); Bool_tTHnBase::CheckConsistency(const THnBase* h, const char* tag) const; THnBase*THnBase::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; TH1*THnBase::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const TH1* h1, Bool_t sparse, Int_t chunkSize = 1024*16); static THnBase*THnBase::CreateHnAny(const char* name, const char* title, const THnBase* hn, Bool_t sparse, Int_t chunkSize = 1024*16); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTHnSparse::FillBin(Long64_t bin, Double_t w); voidTHnBase::FillBinBase(Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; voidTHnBase::Init(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis, Int_t chunkSize = 1024*16); virtual voidTHnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); voidTObject::MakeZombie(); Bool_tTHnBase::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnBase::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantNDim, Option_t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnSparse::Reserve(Long64_t nbins); voidTHnBase::ResetBase(Option_t* option = """"); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDe",MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnSparseT_TArrayS_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayS>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnSparseT<TArrayS>. class THnSparseT<TArrayS>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_t; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseS. Function Members (Methods); public:. THnSparseT<TArrayS>(); THnSparseT<TArrayS>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayS>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHn",MatchSource.WIKI,root/html534/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnSparseT_TArrayS_.html
https://root.cern/root/html534/THnT_char_.html:3321,Availability,error,error,3321,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_char_.html
https://root.cern/root/html534/THnT_char_.html:3405,Availability,error,error,3405,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_char_.html
https://root.cern/root/html534/THnT_char_.html:12255,Availability,error,error,12255,"* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<char>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_char_.html
https://root.cern/root/html534/THnT_char_.html:12443,Availability,error,errors,12443,"* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<char>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_char_.html
https://root.cern/root/html534/THnT_char_.html:341,Integrability,interface,interfaces,341,". THnT<char>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<char>. class THnT<char>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnC, THnT<Char_t>. Function Members (Methods); public:. THnT<char>(); THnT<char>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<char>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject:",MatchSource.WIKI,root/html534/THnT_char_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_char_.html
https://root.cern/root/html534/THnT_double_.html:3335,Availability,error,error,3335,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_double_.html
https://root.cern/root/html534/THnT_double_.html:3419,Availability,error,error,3419,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_double_.html
https://root.cern/root/html534/THnT_double_.html:12271,Availability,error,error,12271,"option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<double>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_double_.html
https://root.cern/root/html534/THnT_double_.html:12459,Availability,error,errors,12459,"option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<double>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_double_.html
https://root.cern/root/html534/THnT_double_.html:347,Integrability,interface,interfaces,347,". THnT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<double>. class THnT<double>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnD, THnT<Double_t>. Function Members (Methods); public:. THnT<double>(); THnT<double>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<double>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtua",MatchSource.WIKI,root/html534/THnT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_double_.html
https://root.cern/root/html534/THnT_float_.html:3328,Availability,error,error,3328,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_float_.html
https://root.cern/root/html534/THnT_float_.html:3412,Availability,error,error,3412,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_float_.html
https://root.cern/root/html534/THnT_float_.html:12263,Availability,error,error,12263," option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<float>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_float_.html
https://root.cern/root/html534/THnT_float_.html:12451,Availability,error,errors,12451," option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<float>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_float_.html
https://root.cern/root/html534/THnT_float_.html:344,Integrability,interface,interfaces,344,". THnT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<float>. class THnT<float>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnF, THnT<Float_t>. Function Members (Methods); public:. THnT<float>(); THnT<float>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<float>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidT",MatchSource.WIKI,root/html534/THnT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_float_.html
https://root.cern/root/html534/THnT_int_.html:3314,Availability,error,error,3314,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_int_.html
https://root.cern/root/html534/THnT_int_.html:3398,Availability,error,error,3398,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_int_.html
https://root.cern/root/html534/THnT_int_.html:12247,Availability,error,error,12247,"t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<int>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_int_.html
https://root.cern/root/html534/THnT_int_.html:12435,Availability,error,errors,12435,"t* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<int>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_int_.html
https://root.cern/root/html534/THnT_int_.html:338,Integrability,interface,interfaces,338,". THnT<int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<int>. class THnT<int>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnT<Int_t>, THnI. Function Members (Methods); public:. THnT<int>(); THnT<int>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<int>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::Append",MatchSource.WIKI,root/html534/THnT_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_int_.html
https://root.cern/root/html534/THnT_Long64_t_.html:3128,Availability,error,error,3128,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_Long64_t_.html
https://root.cern/root/html534/THnT_Long64_t_.html:3212,Availability,error,error,3212,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_Long64_t_.html
https://root.cern/root/html534/THnT_Long64_t_.html:12215,Availability,error,error,12215,"ion = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<long long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_Long64_t_.html
https://root.cern/root/html534/THnT_Long64_t_.html:12403,Availability,error,errors,12403,"ion = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<long long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_Long64_t_.html
https://root.cern/root/html534/THnT_Long64_t_.html:353,Integrability,interface,interfaces,353,". THnT<Long64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<Long64_t>. class THnT<Long64_t>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. Function Members (Methods); public:. ~THnT<long long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root/html534/THnT_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_Long64_t_.html
https://root.cern/root/html534/THnT_long_.html:3321,Availability,error,error,3321,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_long_.html
https://root.cern/root/html534/THnT_long_.html:3405,Availability,error,error,3405,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_long_.html
https://root.cern/root/html534/THnT_long_.html:12255,Availability,error,error,12255,"* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_long_.html
https://root.cern/root/html534/THnT_long_.html:12443,Availability,error,errors,12443,"* option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_long_.html
https://root.cern/root/html534/THnT_long_.html:341,Integrability,interface,interfaces,341,". THnT<long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<long>. class THnT<long>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnL, THnT<Long_t>. Function Members (Methods); public:. THnT<long>(); THnT<long>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject:",MatchSource.WIKI,root/html534/THnT_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_long_.html
https://root.cern/root/html534/THnT_short_.html:3328,Availability,error,error,3328,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_short_.html
https://root.cern/root/html534/THnT_short_.html:3412,Availability,error,error,3412,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_short_.html
https://root.cern/root/html534/THnT_short_.html:12263,Availability,error,error,12263," option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<short>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_short_.html
https://root.cern/root/html534/THnT_short_.html:12451,Availability,error,errors,12451," option = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<short>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_short_.html
https://root.cern/root/html534/THnT_short_.html:344,Integrability,interface,interfaces,344,". THnT<short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<short>. class THnT<short>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnT<Short_t>, THnS. Function Members (Methods); public:. THnT<short>(); THnT<short>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<short>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidT",MatchSource.WIKI,root/html534/THnT_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_short_.html
https://root.cern/root/html534/THnT_ULong64_t_.html:3140,Availability,error,error,3140,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html
https://root.cern/root/html534/THnT_ULong64_t_.html:3224,Availability,error,error,3224,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html
https://root.cern/root/html534/THnT_ULong64_t_.html:12254,Availability,error,error,12254," const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned long long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html
https://root.cern/root/html534/THnT_ULong64_t_.html:12442,Availability,error,errors,12442," const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned long long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html
https://root.cern/root/html534/THnT_ULong64_t_.html:356,Integrability,interface,interfaces,356,". THnT<ULong64_t>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<ULong64_t>. class THnT<ULong64_t>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. Function Members (Methods); public:. ~THnT<unsigned long long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::Cl",MatchSource.WIKI,root/html534/THnT_ULong64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_ULong64_t_.html
https://root.cern/root/html534/THnT_unsigned_int_.html:3363,Availability,error,error,3363,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_int_.html
https://root.cern/root/html534/THnT_unsigned_int_.html:3447,Availability,error,error,3447,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_int_.html
https://root.cern/root/html534/THnT_unsigned_int_.html:12305,Availability,error,error,12305," = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned int>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_int_.html
https://root.cern/root/html534/THnT_unsigned_int_.html:12493,Availability,error,errors,12493," = """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned int>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_int_.html
https://root.cern/root/html534/THnT_unsigned_int_.html:365,Integrability,interface,interfaces,365,". THnT<unsigned int>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<unsigned int>. class THnT<unsigned int>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnT<UInt_t>. Function Members (Methods); public:. THnT<unsigned int>(); THnT<unsigned int>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<unsigned int>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2(Long64",MatchSource.WIKI,root/html534/THnT_unsigned_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_int_.html
https://root.cern/root/html534/THnT_unsigned_long_.html:3370,Availability,error,error,3370,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_long_.html
https://root.cern/root/html534/THnT_unsigned_long_.html:3454,Availability,error,error,3454,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_long_.html
https://root.cern/root/html534/THnT_unsigned_long_.html:12313,Availability,error,error,12313,"= """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_long_.html
https://root.cern/root/html534/THnT_unsigned_long_.html:12501,Availability,error,errors,12501,"= """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned long>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_long_.html
https://root.cern/root/html534/THnT_unsigned_long_.html:368,Integrability,interface,interfaces,368,". THnT<unsigned long>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<unsigned long>. class THnT<unsigned long>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnT<ULong_t>. Function Members (Methods); public:. THnT<unsigned long>(); THnT<unsigned long>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<unsigned long>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBinError2",MatchSource.WIKI,root/html534/THnT_unsigned_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_long_.html
https://root.cern/root/html534/THnT_unsigned_short_.html:3377,Availability,error,error,3377,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_short_.html
https://root.cern/root/html534/THnT_unsigned_short_.html:3461,Availability,error,error,3461,"e(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnBase::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THn*THn::CreateHn(const char* name, const char* title, const TH1* h1); static THn*THn::CreateHn(const char* name, const char* title, const THnBase* hn); virtual ROOT::THnBaseBinIter*THn::CreateIter(Bool_t respectAxisRange) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnBase::Divide(const THnBase* h); voidTHnBase::Divide(const THnBase* h1, const THnBase* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnBase::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnBase::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnBase::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual const TNDArray&GetArray() const; virtual TNDArray&GetArray(); TAxis*THnBase::GetAxis(Int_t dim) const; virtual Long64_tTHn::GetBin(const Int_t* idx) const; virtual Long64_tTHn::GetBin(const Double_t* x) const; virtual Long64_tTHn::GetBin(const char** name) const; virtual Long64_tTHn::GetBin(const Int_t* idx, Bool_t = kTRUE); virtual Long",MatchSource.WIKI,root/html534/THnT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_short_.html
https://root.cern/root/html534/THnT_unsigned_short_.html:12321,Availability,error,error,12321," """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned short>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_short_.html
https://root.cern/root/html534/THnT_unsigned_short_.html:12509,Availability,error,errors,12509," """") const; THnBase*THnBase::RebinBase(Int_t group) const; THnBase*THnBase::RebinBase(const Int_t* group) const; virtual voidTHnBase::Reserve(Long64_t); voidTHnBase::ResetBase(Option_t* option = """"); virtual voidTHnBase::SetFilledBins(Long64_t); voidTHnBase::UpdateXStat(const Double_t* x, Double_t w = 1.). Data Members; public:. enum THnBase::[unnamed] { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TNDArrayT<unsigned short>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum THnBase::THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THnT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_short_.html
https://root.cern/root/html534/THnT_unsigned_short_.html:371,Integrability,interface,interfaces,371,". THnT<unsigned short>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THnT<unsigned short>. class THnT<unsigned short>: public THn. Templated implementation of the abstract base THn.; All functionality and the interfaces to be used are in THn!. THn does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. The actual storage is delegated to; TNDArrayT<T>. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnT<Char_t> THnC Char_t; THnT<Short_t> THnS Short_t; THnT<Int_t> THnI Int_t; THnT<Long_t> THnL Long_t; THnT<Float_t> THnF Float_t; THnT<Double_t> THnD Double_t. We recommend to use THnC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnS or even THnF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnT<UShort_t>. Function Members (Methods); public:. THnT<unsigned short>(); THnT<unsigned short>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin, const Double_t* xmax); ~THnT<unsigned short>(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidTHn::AddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidTHn::AddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTHn::AddBi",MatchSource.WIKI,root/html534/THnT_unsigned_short_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THnT_unsigned_short_.html
https://root.cern/root/html534/THostAuth.html:2327,Availability,error,error,2327,"t; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCountFailure(Int_t level); voidCountSuccess(Int_t level); TRootSecContext*CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); voidDeActivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; TList*Established() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDetails(Int_t level); const char*GetDetailsByIdx(Int_t idx) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFailure(Int_t idx) const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; Int_tGetMethod(Int_t idx) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetServer() const; Int_tGetSuccess(Int_t idx) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:2411,Availability,error,error,2411,"char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCountFailure(Int_t level); voidCountSuccess(Int_t level); TRootSecContext*CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); voidDeActivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; TList*Established() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDetails(Int_t level); const char*GetDetailsByIdx(Int_t idx) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFailure(Int_t idx) const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; Int_tGetMethod(Int_t idx) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetServer() const; Int_tGetSuccess(Int_t idx) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUser() const; virtual Bool_tTObject::HandleTimer(TTimer* tim",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:10778,Availability,failure,failures,10778," Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local list; Return pointer to it to be stored in TAuthenticate. void AsString(TString& out) const; Return a static string with all info in a serialized form. Int_t NumMethods() const; { return fNumMethods; }. Int_t GetMethod(Int_t idx) const; { return fMethods[idx]; }. Int_t GetFailure(Int_t idx) const; { return fFailure[idx]; }. Int_t GetSuccess(Int_t idx) const; { return fSuccess[idx]; }. Bool_t IsActive() const; { return fActive; }. void DeActivate(); { fActive = kFALSE; }. void Activate(); { fActive = kTRUE; }. const char * GetDetailsByIdx(Int_t idx) const; { return fDetails[idx]; }. const char * GetHost() const; { return fHost; }. Int_t GetServer() const; { return (Int_t)fServer; }. const char * GetUser() const; { r",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:335,Security,authenticat,authentication,335,". THostAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » THostAuth. class THostAuth: public TObject. THostAuth. Contains details about host-specific authentication methods and the; result of their application.; Used by TAuthenticate. Function Members (Methods); public:. THostAuth(); THostAuth(const char* asstring); THostAuth(THostAuth& ha); THostAuth(const char* host, const char* user, Int_t authmeth, const char* details); THostAuth(const char* host, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); THostAuth(const char* host, Int_t server, const char* user, Int_t authmeth, const char* details); THostAuth(const char* host, Int_t server, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); virtual~THostAuth(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); voidAddFirst(Int_t level, const char* details = 0); voidAddMethod(Int_t level, const char* details = 0); virtual voidTObject::AppendPad(Option_t* option = """"); voidAsString(TString& out) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCountFailure(Int_t level); voidCountSuccess(Int_t level); TRootSecContext*CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); voidDeActivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtua",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:9637,Security,authenticat,authentication,9637,"nst char* host, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); Create hostauth object.; 'host' may contain also the server for whicb these directives; are valid in the form 'host:server' or 'server://host'; with server either ""sock[d]"", ""root[d]"", ""proof[d]"" or; 0, 1, 2, respectively. THostAuth(const char* asstring); Create hostauth object from directives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFi",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:9889,Security,authenticat,authentication,9889,"or 'server://host'; with server either ""sock[d]"", ""root[d]"", ""proof[d]"" or; 0, 1, 2, respectively. THostAuth(const char* asstring); Create hostauth object from directives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth,",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:10056,Security,authenticat,authentication,10056,"rectives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THostAuth.html:10595,Security,authenticat,authentication,10595,"associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local list; Return pointer to it to be stored in TAuthenticate. void AsString(TString& out) const; Return a static string with all info in a serialized form. Int_t NumMethods() const; { return fNumMethods; }. Int_t GetMethod(Int_t idx) const; { return fMethods[idx]; }. Int_t GetFailure(Int_t idx) const; { return fFailure[idx]; }. Int_t GetSuccess(Int_t idx) const; { return fSuccess[idx]; }. Bool_t IsActive() const; { return fActive; }. void DeActivate(); { fActive = kFALSE; }. void Activate",MatchSource.WIKI,root/html534/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THostAuth.html
https://root.cern/root/html534/THStack.html:2516,Availability,error,error,2516,"j_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; TList*GetHists() const; virtual const char*TObject::GetIconName() const; virtual Double_tGetMaximum(Option_t* option = """"); virtual Double_tGetMinimum(Option_t* option = """"); virtual const char*TNamed::GetName() const; Int_tGetNhists() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObjArray*GetStack(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:2600,Availability,error,error,2600,"Method(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; TList*GetHists() const; virtual const char*TObject::GetIconName() const; virtual Double_tGetMaximum(Option_t* option = """"); virtual Double_tGetMinimum(Option_t* option = """"); virtual const char*TNamed::GetName() const; Int_tGetNhists() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObjArray*GetStack(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TAxis*GetXaxis() const; TAxis*GetYaxis() const; virtual Bool_tTOb",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:11133,Availability,error,error,11133,"m of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". Int_t GetNhists() const; Return the number of histograms in the stack. TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:9998,Integrability,depend,depends,9998,"tion = """"); add a new histogram to the list; Only 1-d and 2-d histograms currently supported.; A drawing option may be specified. void Browse(TBrowser* b); Browse. void BuildStack(); build sum of all histograms; Build a separate list fStack containing the running sum of all histograms. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to each graph. void Draw(Option_t* chopt = """"); Draw this multihist with its current attributes. Options to draw histograms are described in THistPainter::Paint; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other. TH1 * GetHistogram() const; Returns a pointer to the histogram used to draw the axis; Takes into account the two following cases.; 1- option 'A' was specified in THStack::Draw. Return fHistogram; 2- user had called TPad::DrawFrame. return pointer to hframe histogram. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". Int_t GetNhists() const; Return the number of histograms in the stack. TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* ",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:10645,Integrability,depend,depends,10645,"istogram() const; Returns a pointer to the histogram used to draw the axis; Takes into account the two following cases.; 1- option 'A' was specified in THStack::Draw. Return fHistogram; 2- user had called TPad::DrawFrame. return pointer to hframe histogram. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". Int_t GetNhists() const; Return the number of histograms in the stack. TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a s",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:10850,Integrability,depend,depends,10850,"TPad::DrawFrame. return pointer to hframe histogram. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". Int_t GetNhists() const; Return the number of histograms in the stack. TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot.",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:11771,Safety,avoid,avoid,11771," NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoid this behaviour. This is useful; when drawing a THStack on top of an other plot. If the patterns used to; draw the histograms in the stack are transparents, then the plot behind; will be visible. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set minimum. THStack& operator=(const THStack& ). TList * GetHists() const; { return fHists; }. void SetHistogram(TH1* h); {fHistogram = h;}. » Author: Rene Brun 10/12/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:41; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:576,Testability,test,test,576,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs.Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* o",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:630,Testability,test,test,630,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs.Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* o",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:750,Testability,test,test,750,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs.Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* o",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THStack.html:871,Testability,test,test,871,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs.Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* o",MatchSource.WIKI,root/html534/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THStack.html
https://root.cern/root/html534/THtml.html:18326,Availability,error,error,18326,,MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:18410,Availability,error,error,18410,,MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:27533,Availability,error,error,27533,"tml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive is run on. void CreateAuxiliaryFiles() const; copy CSS, javascript file, etc to the output dir. const char* GetEtcDir() const; Get the directory containing THtml's auxiliary files ($ROOTSYS/etc/html). TClassDocInfo * GetNextClass(); Return the next class to be generated for MakeClassThreaded. const char* GetURL(const char* lib = 0) const; Get the documentation URL for library lib.; If lib == 0 or no documentation URL has been set for lib, return the ROOT; documentation URL. The return value is always != 0. Bool_t HaveDot(); Check whether dot is available in $PATH or in the directory set; by SetDotPath(). void HelperDeleted(THtml::THelperBase* who); Inform the THtml object that ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:28410,Availability,avail,available,28410,"; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive is run on. void CreateAuxiliaryFiles() const; copy CSS, javascript file, etc to the output dir. const char* GetEtcDir() const; Get the directory containing THtml's auxiliary files ($ROOTSYS/etc/html). TClassDocInfo * GetNextClass(); Return the next class to be generated for MakeClassThreaded. const char* GetURL(const char* lib = 0) const; Get the documentation URL for library lib.; If lib == 0 or no documentation URL has been set for lib, return the ROOT; documentation URL. The return value is always != 0. Bool_t HaveDot(); Check whether dot is available in $PATH or in the directory set; by SetDotPath(). void HelperDeleted(THtml::THelperBase* who); Inform the THtml object that one of its helper objects was deleted.; Called by THtml::HelperBase::~HelperBase(). void Convert(const char* filename, const char* title, const char* dirname = """", const char* relpath = ""../"", Int_t includeOutput = kNoOutput, const char* context = """"); It converts a single text file to HTML. Input: filename - name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:33041,Availability,avail,available,33041,"n for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining obj",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:33516,Availability,avail,available,33516,"ass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining object to be used; can also be a user derived; object (a la traits). void SetInputDir(const char* dir); Set the directory containing the source files.; The source file for a class MyClass will be searched; by prepending dir to the value of; MyClass::Class()->GetImplFileName() - which can contain; directory information!; Also resets the class structure, in case new files can; be found after this call. void SetOutputDir(const char* dir); Set the directory where the H",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:33570,Availability,avail,available,33570,"t: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining object to be used; can also be a user derived; object (a la traits). void SetInputDir(const char* dir); Set the directory containing the source files.; The source file for a class MyClass will be searched; by prepending dir to the value of; MyClass::Class()->GetImplFileName() - which can contain; directory information!; Also resets the class structure, in case new files can; be found after this call. void SetOutputDir(const char* dir); Set the directory where the HTML pages shuold be written to.; If the directory does not exist it will be created when ne",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2014,Deployability,configurat,configuration,2014,"d documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set thes",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2508,Deployability,configurat,configuration,2508,"l.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2945,Deployability,configurat,configuration,2945,"se:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentatio",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:3621,Deployability,update,updated,3621,"tputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file,",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:5343,Deployability,configurat,configuration,5343,"name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Foote",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:6306,Deployability,configurat,configuration,6306,"TML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:7514,Deployability,update,update,7514,"to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by TClass::GetImplFileName(),; TClass::GetDeclFileName()).; If the header is not generated for a class, they will be replaced by """".; Root's footer starts with the tag <!--SIGNATURE-->. It includes the; author(s), last update, copyright, the links to the Root home page, to the; user home page, to the index file (ClassIndex.html), to the top of the page; and this page is automatically generated infomation. It ends with the; tags </body></html>. If you want to replace it,; THtml will search for some; tags in your footer: Occurrences of the strings %AUTHOR%, %UPDATE%, and; %COPYRIGHT% are replaced by their; corresponding values before writing the html file. The %AUTHOR% tag will be; replaced by the exact string that follows Root.Html.Author, no link; generation will occur.; II.7 Links to searches, home page, ViewVC; Additional parameters can be set by Root.Html.Homepage (address of the; user's home page), Root.Html.SearchEngine (search engine for the class; documentation), Root.Html.Search (search URL, where %u is replaced by the; referer and %s by the escaped search expression), and a ViewVC base URL; Root.Html.ViewCVS. For the latter, the file name is appended or, if; the URL contains %f, %f is replaced by the file name.; All values def",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15424,Deployability,install,install,15424,"asses.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15615,Deployability,configurat,configuration,15615,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15928,Deployability,update,update,15928," javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/people?) - URL of CERN's xWho; Root.Html.Charset (default: ISO-8859-1) - HTML character set. IX. Behind the scene; Internally, THtml is just an API class that sets up the list of known; classes, and forwards API invocations to the ""work horses"".; TDocOutput; generates the output by letting a; TDocP",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:26582,Deployability,configurat,configuration,26582,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:26766,Deployability,configurat,configuration,26766,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:27037,Deployability,configurat,configuration,27037,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:27158,Deployability,configurat,configuration,27158,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:3684,Integrability,depend,dependencies,3684,"tputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file,",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15345,Integrability,depend,dependencies,15345,"index,; either by linking it or by including it.; The files for modules are searched based on the source file directory of the; module's classes.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:31528,Integrability,depend,depending,31528,"d) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bool GetImplFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return implementation file name. bool GetDeclImplFileName(TClass* cl, bool filesys, bool decl, TString& out_name) const; Combined implementation for GetDeclFileName(), GetImplFileName():; Return declaration / implementation file name (depending on decl);; return the full path if filesys is true. const TString& GetOutputDir(Bool_t createDir = kTRUE) const; Return the output directory as set by SetOutputDir().; Create it if it doesn't exist and if createDir is kTRUE. Bool_t IsNamespace(const TClass* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the numbe",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:1384,Modifiability,variab,variables,1384,"ted text files (like change logs). It generates HTML; pages conforming to the XHTML 1.0 transitional specifications; an example of; these pages is ROOT's own ; reference guide. This page was verified to be valid XHTML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.So",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2014,Modifiability,config,configuration,2014,"d documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set thes",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2080,Modifiability,variab,variable,2080,"d documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set thes",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2508,Modifiability,config,configuration,2508,"l.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2522,Modifiability,variab,variable,2522,"l.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2945,Modifiability,config,configuration,2945,"se:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentatio",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:2959,Modifiability,variab,variable,2959,"se:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentatio",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:4784,Modifiability,variab,variables,4784,"LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:5343,Modifiability,config,configuration,5343,"name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Foote",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:5358,Modifiability,variab,variable,5358,"name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Foote",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:6306,Modifiability,config,configuration,6306,"TML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:6320,Modifiability,variab,variables,6320,"TML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:6416,Modifiability,variab,variables,6416,"f the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by TClass::GetImplFileName(),; TClass::GetDeclFileName()).; If the header is not generated for a class, they will be replaced by """".; Root's footer",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:9459,Modifiability,variab,variable,9459,"ame is appended or, if; the URL contains %f, %f is replaced by the file name.; All values default to """".; Examples:; Root.Html.Homepage: http://www.enricos-home.it; Root.Html.SearchEngine: http://root.cern.ch/root/Search.phtml; Root.Html.Search: http://www.google.com/search?q=%s+site%3A%u; II.8 HTML Charset; XHTML 1.0 transitional recommends the specification of the charset in the; content type meta tag, see e.g. http://www.w3.org/TR/2002/REC-xhtml1-20020801/; THtml generates it for the HTML output files. It defaults to ISO-8859-1, and; can be changed using Root.Html.Charset.; Example:; Root.Html.Charset: EUC-JP; III. Documentation syntax; III.1 Class description; A class description block, which must be placed before the first; member function, has a following form:. ////////////////////////////////////////////////////////////////; // //; // TMyClass //; // //; // This is the description block. //; // //; ////////////////////////////////////////////////////////////////. The environment variable Root.Html.Description; (see: TEnv) contains; the delimiter string (default value: //_________________). It means; that you can also write your class description block like this:. //_____________________________________________________________; // A description of the class starts with the line above, and; // will take place here !; //. Note that everything until the first non-commented line is considered; as a valid class description block.; III.2 Class index; All classes to be documented will have an entry in the ClassIndex.html,; showing their name with a link to their documentation page and a miniature; description. This discription for e.g. the class MyClass has to be given; in MyClass's header as a comment right after ClassDef(MyClass, n).; III.3 Method documentation; A member function description block starts immediately after '{'; and looks like this:. void TWorld::HelloWorldFunc(string *text); {; // This is an example of description for the; // TWorld member function;",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:10647,Modifiability,variab,variable,10647," //_____________________________________________________________; // A description of the class starts with the line above, and; // will take place here !; //. Note that everything until the first non-commented line is considered; as a valid class description block.; III.2 Class index; All classes to be documented will have an entry in the ClassIndex.html,; showing their name with a link to their documentation page and a miniature; description. This discription for e.g. the class MyClass has to be given; in MyClass's header as a comment right after ClassDef(MyClass, n).; III.3 Method documentation; A member function description block starts immediately after '{'; and looks like this:. void TWorld::HelloWorldFunc(string *text); {; // This is an example of description for the; // TWorld member function; helloWorld.Print( text );; }. Like in a class description block, everything until the first; non-commented line is considered as a valid member function; description block.; If the rootrc variable Root.Html.DescriptionStyle is set to; Doc++ THtml will also look for method documentation in front of; the function implementation. This feature is not recommended; source code; making use of this does not comply to the ROOT documentation standards, which; means future versions of THtml might not support it anymore.; III.4 Data member documentation; Data members are documented by putting a C++ comment behind their; declaration in the header file, e.g. int fIAmADataMember; // this is a data member. IV. Documentation directives; NOTE that THtml does not yet support nested directives; (i.e. latex inside html etc)!; IV.1 BEGIN_HTML END_HTML: include 'raw' HTML; You can insert pure html code into your documentation comments. During the; generation of the documentation, this code will be inserted as is; into the html file.; Pure html code must be surrounded by the keywords; BEGIN_HTML and END_HTML, where the; case is ignored.; An example of pure html code is this class description ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15249,Modifiability,inherit,inheritance,15249,"index,; either by linking it or by including it.; The files for modules are searched based on the source file directory of the; module's classes.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15262,Modifiability,inherit,inherited,15262,"index,; either by linking it or by including it.; The files for modules are searched based on the source file directory of the; module's classes.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; ",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15582,Modifiability,variab,variables,15582,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15615,Modifiability,config,configuration,15615,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:15629,Modifiability,variab,variables,15629,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:26582,Modifiability,config,configuration,26582,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:26766,Modifiability,config,configuration,26766,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:27037,Modifiability,config,configuration,27037,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:27158,Modifiability,config,configuration,27158,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:30215,Modifiability,inherit,inheritance,30215,"sed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer than the script. If kCompiledOutput is; passed, the script is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bo",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:30497,Modifiability,inherit,inheriting,30497,"cript is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bool GetImplFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return implementation file name. bool GetDeclImplFileName(TClass* cl, bool filesys, bool decl, TString& out_name) const; Combined implementation for GetDeclFileName(), GetImplFileNam",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:30526,Modifiability,inherit,inheritance,30526,"cript is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bool GetImplFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return implementation file name. bool GetDeclImplFileName(TClass* cl, bool filesys, bool decl, TString& out_name) const; Combined implementation for GetDeclFileName(), GetImplFileNam",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:33367,Modifiability,inherit,inheritance,33367,"ter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining object to be used; can also be a user derived; object (a la traits). void SetInputDir(const char* dir); Set the directory containing the source files.; The source file for a class MyClass will be searched; by prepending dir to the value of; MyClass::Class()->GetImplFileName() - which can contain; directory information!; Also res",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:26696,Performance,cache,cached,26696,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:29841,Performance,cache,cached,29841," name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer than the script. If kCompiledOutput is; passed, the script is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:32816,Performance,multi-thread,multi-threaded,32816,"ss* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFil",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:4338,Security,access,access,4338,"brary name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alph",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:372,Testability,log,logs,372,". THtml. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » THtml. class THtml: public TObject. The THtml class is designed to easily document; classes, code, and code related text files (like change logs). It generates HTML; pages conforming to the XHTML 1.0 transitional specifications; an example of; these pages is ROOT's own ; reference guide. This page was verified to be valid XHTML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configu",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml.html:514,Usability,guid,guide,514,". THtml. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HTML; » THtml. class THtml: public TObject. The THtml class is designed to easily document; classes, code, and code related text files (like change logs). It generates HTML; pages conforming to the XHTML 1.0 transitional specifications; an example of; these pages is ROOT's own ; reference guide. This page was verified to be valid XHTML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxiliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configu",MatchSource.WIKI,root/html534/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml.html
https://root.cern/root/html534/THtml__TFileDefinition.html:1363,Availability,error,error,1363," ~TFileDefinition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDeclFileName(const TClass* cl, TString& out_filename, TString& out_fsys, THtml::TFileSysEntry** fse = 0) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGe",MatchSource.WIKI,root/html534/THtml__TFileDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileDefinition.html
https://root.cern/root/html534/THtml__TFileDefinition.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDeclFileName(const TClass* cl, TString& out_filename, TString& out_fsys, THtml::TFileSysEntry** fse = 0) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGetImplFileName(const TClass* cl, TString& out_filename, TString& out_fsys, THtml::TFileSysEntry** fse = 0) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*THtml::THelperBase::GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bo",MatchSource.WIKI,root/html534/THtml__TFileDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileDefinition.html
https://root.cern/root/html534/THtml__TFileSysDB.html:1343,Availability,error,error,1343," ~TFileSysDB(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); THashTable&GetEntries(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() co",MatchSource.WIKI,root/html534/THtml__TFileSysDB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysDB.html
https://root.cern/root/html534/THtml__TFileSysDB.html:1427,Availability,error,error,1427," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); THashTable&GetEntries(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; const TString&GetIgnore() const; Int_tTHtml::TFileSysEntry::GetLevel() const; TExMap&GetMapIno(); Int_tGetMaxLevel() const; virtual const char*THtml::TFileSysEntry::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*THtml::TFileSysEntry::GetParent() const; const TList*THtml::TFileSysDir::Get",MatchSource.WIKI,root/html534/THtml__TFileSysDB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysDB.html
https://root.cern/root/html534/THtml__TFileSysDB.html:6466,Safety,detect,detect,6466,"TObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFill(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileSysDB(const char* path, const char* ignr, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. void Fill(). TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName(). » Author: Nenad Buncic 18/10/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/html:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/THtml__TFileSysDB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysDB.html
https://root.cern/root/html534/THtml__TFileSysDir.html:1349,Availability,error,error,1349," ~TFileSysDir(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLeve",MatchSource.WIKI,root/html534/THtml__TFileSysDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysDir.html
https://root.cern/root/html534/THtml__TFileSysDir.html:1433,Availability,error,error,1433," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLevel() const; virtual const char*THtml::TFileSysEntry::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*THtml::TFileSysEntry::GetParent() const; const TList*GetSubDirs() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TT",MatchSource.WIKI,root/html534/THtml__TFileSysDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysDir.html
https://root.cern/root/html534/THtml__TFileSysEntry.html:1344,Availability,error,error,1344," ~TFileSysEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual const char*GetName() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html534/THtml__TFileSysEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysEntry.html
https://root.cern/root/html534/THtml__TFileSysEntry.html:1428,Availability,error,error,1428," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*GetParent() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFro",MatchSource.WIKI,root/html534/THtml__TFileSysEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysEntry.html
https://root.cern/root/html534/THtml__TFileSysRoot.html:1351,Availability,error,error,1351," ~TFileSysRoot(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLeve",MatchSource.WIKI,root/html534/THtml__TFileSysRoot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysRoot.html
https://root.cern/root/html534/THtml__TFileSysRoot.html:1435,Availability,error,error,1435," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLevel() const; virtual const char*THtml::TFileSysEntry::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*THtml::TFileSysEntry::GetParent() const; const TList*THtml::TFileSysDir::GetSubDirs() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObje",MatchSource.WIKI,root/html534/THtml__TFileSysRoot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TFileSysRoot.html
https://root.cern/root/html534/THtml__THelperBase.html:1343,Availability,error,error,1343," virtual~THelperBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option",MatchSource.WIKI,root/html534/THtml__THelperBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__THelperBase.html
https://root.cern/root/html534/THtml__THelperBase.html:1427,Availability,error,error,1427," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root/html534/THtml__THelperBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__THelperBase.html
https://root.cern/root/html534/THtml__TModuleDefinition.html:1371,Availability,error,error,1371," ~TModuleDefinition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGetModule(TClass* cl, THtml::TFileSysEntry* fse, TString& out_modulename) const; virtual const char*TObject::GetName() co",MatchSource.WIKI,root/html534/THtml__TModuleDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TModuleDefinition.html
https://root.cern/root/html534/THtml__TModuleDefinition.html:1455,Availability,error,error,1455," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGetModule(TClass* cl, THtml::TFileSysEntry* fse, TString& out_modulename) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*THtml::THelperBase::GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html534/THtml__TModuleDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TModuleDefinition.html
https://root.cern/root/html534/THtml__TPathDefinition.html:1363,Availability,error,error,1363," ~TPathDefinition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDocDir(const TString& module, TString& doc_dir) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual boolGetFileNameFromInclude(const char* included, TString& out_fsname) const; virtual const char*TObject::GetIcon",MatchSource.WIKI,root/html534/THtml__TPathDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TPathDefinition.html
https://root.cern/root/html534/THtml__TPathDefinition.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDocDir(const TString& module, TString& doc_dir) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual boolGetFileNameFromInclude(const char* included, TString& out_fsname) const; virtual const char*TObject::GetIconName() const; virtual boolGetIncludeAs(TClass* cl, TString& out_include_as) const; virtual boolGetMacroPath(const TString& module, TString& out_dir) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*THtml::THelperBase::GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UIn",MatchSource.WIKI,root/html534/THtml__TPathDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THtml__TPathDefinition.html
https://root.cern/root/html534/THttpCallArg.html:1481,Availability,error,error,1481,"Arg(); voidTObject::AbstractMethod(const char* method) const; voidAddHeader(const char* name, const char* value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tCompressWithGzip(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillHttpHeader(TString& buf, const char* header = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const void*GetContent() const; Long_tGetContentLength() const; const char*GetContentType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFileName() const; TStringGetHeader(const char* name); TStringGetHeaderName(Int_t number) const; virtual const char*TObject::GetIconName() const; const char*GetMethod() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPath",MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:1565,Availability,error,error,1565,"ar* name, const char* value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tCompressWithGzip(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillHttpHeader(TString& buf, const char* header = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const void*GetContent() const; Long_tGetContentLength() const; const char*GetContentType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFileName() const; TStringGetHeader(const char* name); TStringGetHeaderName(Int_t number) const; virtual const char*TObject::GetIconName() const; const char*GetMethod() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPathName() const; void*GetPostData() const; Long_tGetPostDataLength() const; const char*",MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:10765,Availability,error,error,10765,"uest header. TString GetRequestHeaderName(Int_t number) const; returns field name in request header. TString GetRequestHeader(const char* name); get named field from request header. const char * GetTopName() const; returns engine-specific top-name. const char * GetMethod() const; returns request method like GET or POST. Bool_t IsPostMethod() const; returns kTRUE if post method is used. void* GetPostData() const; return pointer on posted with request data. Long_t GetPostDataLength() const; return length of posted with request data. const char * GetPathName() const; returns path name from request URL. const char * GetFileName() const; returns file name from request URL. const char * GetUserName() const; return authenticated user name (0 - when no authentication). const char * GetQuery() const; returns request query (string after ? in request URL). void SetContentType(const char* typ); these methods used in THttpServer to set results of request processing. void Set404(); mark reply as 404 error - page/request not exists. void SetFile(const char* filename = 0); indicate that http request should response with file content. void SetXml(); set content type as JSON. void SetJson(); set content type as JSON. Int_t NumHeader() const; returns number of fields in header. TString GetHeaderName(Int_t number) const; returns field name in header. void SetEncoding(const char* typ); Set Content-Encoding header like gzip. void SetContent(const char* c); Set content directly. void SetZipping(Int_t kind); Set kind of content zipping; 0 - none; 1 - only when supported in request header; 2 - if supported and content size bigger than 10K; 3 - always. Int_t GetZipping() const; return kind of content zipping. void SetExtraHeader(const char* name, const char* value). Bool_t IsContentType(const char* typ) const; these methods used to return results of http request processing. Bool_t Is404() const. Bool_t IsFile() const. const char * GetContentType() const. Long_t GetContentLength() const. cons",MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:8308,Energy Efficiency,allocate,allocated,8308,"post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, Long_t length); set data, posted with the request; buffer should be allocated with malloc(length+1) call,; while last byte will be set to 0; Than one could use post data as null-terminated string. void SetBinData(void* data, Long_t length); set binary data, which will be returned as reply body. void SetPathAndFileName(const char* fullpath); set complete path of requested http element; For instance, it could be ""/folder/subfolder/get.bin""; Here ""/folder/subfolder/"" is element path and ""get.bin"" requested file.; One could set path and file name separately. TString GetHeader(const char* name); return specified header. void AddHeader(const char* name, const char* value); Set name: value pair to reply header; Content-Type field handled separately - one should use SetContentType() method; Content-Length field cannot be set at all;. void FillHttpHeader(TString& buf, const char* header = 0); fill HTTP header. Bool_t CompressWithGzip(); compress reply data with gzip compression. Bool_t IsBinData() const. void SetMethod(const char* method); these methods used to set http reque",MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:7533,Security,authenticat,authenticated,7533,". protected:. TStringAccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); TStringCountHeader(const TString& buf, Int_t number = -1111) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tIsBinData() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fBinData! binary data, assigned with http call; Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfMethod! request method like GET or POST; TStringfPathName! item path; void*fPostData! binary data received with post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, L",MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:9562,Security,authenticat,authenticated,9562,"AndFileName(const char* fullpath); set complete path of requested http element; For instance, it could be ""/folder/subfolder/get.bin""; Here ""/folder/subfolder/"" is element path and ""get.bin"" requested file.; One could set path and file name separately. TString GetHeader(const char* name); return specified header. void AddHeader(const char* name, const char* value); Set name: value pair to reply header; Content-Type field handled separately - one should use SetContentType() method; Content-Length field cannot be set at all;. void FillHttpHeader(TString& buf, const char* header = 0); fill HTTP header. Bool_t CompressWithGzip(); compress reply data with gzip compression. Bool_t IsBinData() const. void SetMethod(const char* method); these methods used to set http request arguments. void SetTopName(const char* topname); set engine-specific top-name. void SetPathName(const char* p); set request path name. void SetFileName(const char* f); set request file name. void SetUserName(const char* n); set name of authenticated user. void SetQuery(const char* q); set request query. void SetRequestHeader(const char* h); set full set of request header. Int_t NumRequestHeader() const; returns number of fields in request header. TString GetRequestHeaderName(Int_t number) const; returns field name in request header. TString GetRequestHeader(const char* name); get named field from request header. const char * GetTopName() const; returns engine-specific top-name. const char * GetMethod() const; returns request method like GET or POST. Bool_t IsPostMethod() const; returns kTRUE if post method is used. void* GetPostData() const; return pointer on posted with request data. Long_t GetPostDataLength() const; return length of posted with request data. const char * GetPathName() const; returns path name from request URL. const char * GetFileName() const; returns file name from request URL. const char * GetUserName() const; return authenticated user name (0 - when no authentication). const char * ",MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:10482,Security,authenticat,authenticated,10482,r* f); set request file name. void SetUserName(const char* n); set name of authenticated user. void SetQuery(const char* q); set request query. void SetRequestHeader(const char* h); set full set of request header. Int_t NumRequestHeader() const; returns number of fields in request header. TString GetRequestHeaderName(Int_t number) const; returns field name in request header. TString GetRequestHeader(const char* name); get named field from request header. const char * GetTopName() const; returns engine-specific top-name. const char * GetMethod() const; returns request method like GET or POST. Bool_t IsPostMethod() const; returns kTRUE if post method is used. void* GetPostData() const; return pointer on posted with request data. Long_t GetPostDataLength() const; return length of posted with request data. const char * GetPathName() const; returns path name from request URL. const char * GetFileName() const; returns file name from request URL. const char * GetUserName() const; return authenticated user name (0 - when no authentication). const char * GetQuery() const; returns request query (string after ? in request URL). void SetContentType(const char* typ); these methods used in THttpServer to set results of request processing. void Set404(); mark reply as 404 error - page/request not exists. void SetFile(const char* filename = 0); indicate that http request should response with file content. void SetXml(); set content type as JSON. void SetJson(); set content type as JSON. Int_t NumHeader() const; returns number of fields in header. TString GetHeaderName(Int_t number) const; returns field name in header. void SetEncoding(const char* typ); Set Content-Encoding header like gzip. void SetContent(const char* c); Set content directly. void SetZipping(Int_t kind); Set kind of content zipping; 0 - none; 1 - only when supported in request header; 2 - if supported and content size bigger than 10K; 3 - always. Int_t GetZipping() const; return kind of content zipping. void SetExt,MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpCallArg.html:10519,Security,authenticat,authentication,10519,r* f); set request file name. void SetUserName(const char* n); set name of authenticated user. void SetQuery(const char* q); set request query. void SetRequestHeader(const char* h); set full set of request header. Int_t NumRequestHeader() const; returns number of fields in request header. TString GetRequestHeaderName(Int_t number) const; returns field name in request header. TString GetRequestHeader(const char* name); get named field from request header. const char * GetTopName() const; returns engine-specific top-name. const char * GetMethod() const; returns request method like GET or POST. Bool_t IsPostMethod() const; returns kTRUE if post method is used. void* GetPostData() const; return pointer on posted with request data. Long_t GetPostDataLength() const; return length of posted with request data. const char * GetPathName() const; returns path name from request URL. const char * GetFileName() const; returns file name from request URL. const char * GetUserName() const; return authenticated user name (0 - when no authentication). const char * GetQuery() const; returns request query (string after ? in request URL). void SetContentType(const char* typ); these methods used in THttpServer to set results of request processing. void Set404(); mark reply as 404 error - page/request not exists. void SetFile(const char* filename = 0); indicate that http request should response with file content. void SetXml(); set content type as JSON. void SetJson(); set content type as JSON. Int_t NumHeader() const; returns number of fields in header. TString GetHeaderName(Int_t number) const; returns field name in header. void SetEncoding(const char* typ); Set Content-Encoding header like gzip. void SetContent(const char* c); Set content directly. void SetZipping(Int_t kind); Set kind of content zipping; 0 - none; 1 - only when supported in request header; 2 - if supported and content size bigger than 10K; 3 - always. Int_t GetZipping() const; return kind of content zipping. void SetExt,MatchSource.WIKI,root/html534/THttpCallArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpCallArg.html
https://root.cern/root/html534/THttpEngine.html:1410,Availability,error,error,1410,"ine(const THttpEngine&); virtual~THttpEngine(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*GetServer() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* ms",MatchSource.WIKI,root/html534/THttpEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpEngine.html
https://root.cern/root/html534/THttpEngine.html:1494,Availability,error,error,1494,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*GetServer() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html534/THttpEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpEngine.html
https://root.cern/root/html534/THttpEngine.html:342,Integrability,protocol,protocol,342,". THttpEngine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpEngine. class THttpEngine: public TNamed. THttpEngine. Abstract class for implementing http protocol for THttpServer. Function Members (Methods); public:. THttpEngine(const THttpEngine&); virtual~THttpEngine(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; vir",MatchSource.WIKI,root/html534/THttpEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpEngine.html
https://root.cern/root/html534/THttpServer.html:2778,Availability,error,error,2778,"const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreateEngine(const char* engine); Bool_tCreateItem(const char* fullname, const char* title); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Bool_tExecuteHttp(THttpCallArg* arg); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*GetItemField(const char* fullname, const char* name); static const char*GetMimeType(const char* path); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TRootSniffer*GetSniffer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:2862,Availability,error,error,2862,"on = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreateEngine(const char* engine); Bool_tCreateItem(const char* fullname, const char* title); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Bool_tExecuteHttp(THttpCallArg* arg); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*GetItemField(const char* fullname, const char* name); static const char*GetMimeType(const char* path); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TRootSniffer*GetSniffer() const; virtual const char*TNamed::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* time",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:11112,Availability,avail,available,11112,"new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains pr",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:11227,Availability,avail,available,11227,"new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains pr",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:1524,Deployability,update,updated,1524,"pt user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreateEngine(const char* engine); Bool_tCreateItem(const char* fullname, const char* title); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t*",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:11132,Deployability,install,installed,11132,"new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains pr",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:11247,Deployability,install,installed,11247,"new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains pr",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:1454,Energy Efficiency,monitor,monitoring,1454,"pt user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreateEngine(const char* engine); Bool_tCreateItem(const char* fullname, const char* title); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t*",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:10031,Energy Efficiency,reduce,reduce,10031," SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects method via exe.json request. void AddLocation(const char* prefix, const char* path); add files location, which could be used in the server; one could map some system folder to the server like AddLocation(""mydir/"",""/home/user/specials"");; Than files from this directory could be addressed via server like; http://localhost:8080/mydir/myfile.root. void SetJSROOT(const char* location); Set location of JSROOT to use with the server; One could specify address like:; https://root.cern.ch/js/3.3; http://web-docs.gsi.de/~linev/js/3.3; This allows to get new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:466,Integrability,interface,interface,466,". THttpServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpServer. class THttpServer: public TNamed. THttpServer. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTN",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:607,Integrability,interface,interface,607,". THttpServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpServer. class THttpServer: public TNamed. THttpServer. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTN",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:693,Integrability,interface,interface,693,". THttpServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpServer. class THttpServer: public TNamed. THttpServer. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTN",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:13389,Integrability,interface,interface,13389,"one in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObject* obj); Unregister object in folders hierarchy. See TRootSniffer::UnregisterObject() for more details. void Restrict(const char* path, const char* options); Restrict access to specified object. See TRootSniffer::Restrict() for more details. Bool_t RegisterCommand(const char* cmdname, const char* method, const char* icon = 0); Register command which can be executed from web interface. As method one typically specifies string, which is executed with; gROOT->ProcessLine() method. For instance; serv->RegisterCommand(""Invoke"",""InvokeFunction()"");. Or one could specify any method of the object which is already registered; to the server. For instance:; serv->Register(""/"", hpx);; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; Here symbols '/->' separates item name from method to be executed. One could specify additional arguments in the command with; syntax like %arg1%, %arg2% and so on. For example:; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->SetTitle(\""%arg1%\"")"");; serv->RegisterCommand(""/RebinHPXPY"", ""/hpxpy/->Rebin2D(%arg1%,%arg2%)"");; Such parameter(s) will be requested when command clicked in the browser. Once command is registered, one could specify icon which will appear in the browser:; serv->SetIcon(""/ResetHPX"", ""rootsys/icons/ed_execute.png"");. One also can set extra property '_fa",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:10038,Performance,load,load,10038," SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects method via exe.json request. void AddLocation(const char* prefix, const char* path); add files location, which could be used in the server; one could map some system folder to the server like AddLocation(""mydir/"",""/home/user/specials"");; Than files from this directory could be addressed via server like; http://localhost:8080/mydir/myfile.root. void SetJSROOT(const char* location); Set location of JSROOT to use with the server; One could specify address like:; https://root.cern.ch/js/3.3; http://web-docs.gsi.de/~linev/js/3.3; This allows to get new JSROOT features with old server,; reduce load on THttpServer instance, also startup time can be improved; When empty string specified (default), local copy of JSROOT is used (distributed with ROOT). void SetDefaultPage(const char* filename); Set file name of HTML page, delivered by the server when; http address is opened in the browser.; By default, $ROOTSYS/etc/http/files/online.htm page is used; When empty filename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:11411,Performance,perform,perform,11411,"ilename is specified, default page will be used. void SetDrawPage(const char* filename); Set file name of HTML page, delivered by the server when; objects drawing page is requested from the browser; By default, $ROOTSYS/etc/http/files/draw.htm page is used; When empty filename is specified, default page will be used. Bool_t CreateEngine(const char* engine); factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Pro",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:12770,Performance,perform,performed,12770,"nst char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObject* obj); Unregister object in folders hierarchy. See TRootSniffer::UnregisterObject() for more details. void Restrict(const char* path, const char* options); Restrict access to specified object. See TRootSniffer::Restrict() for more details. Bool_t RegisterCommand(const char* cmdname, const char* method, const char* icon = 0); Register command which can be executed from web interface. As method one typically specifies string, which is executed with; gROOT->ProcessLine() method. For instance; serv->RegisterCommand(""Invoke"",""InvokeFunction()"");. Or one could specify any method of the object which is already registered; to the server. For instance:; serv->Register(""/"", hpx);; serv->Regist",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:12123,Safety,safe,safe,12123,":9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObj",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:398,Security,access,access,398,". THttpServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpServer. class THttpServer: public TNamed. THttpServer. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTN",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:673,Security,access,access,673,". THttpServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpServer. class THttpServer: public TNamed. THttpServer. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTN",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:1114,Security,access,access,1114," viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » HTTP; » THttpServer. class THttpServer: public TNamed. THttpServer. Online http server for arbitrary ROOT application. Idea of THttpServer - provide remote http access to running; ROOT application and enable HTML/JavaScript user interface.; Any registered object can be requested and displayed in the browser.; There are many benefits of such approach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(co",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:8482,Security,access,accessed,8482,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidProcessRequest(THttpCallArg* arg); static Bool_tVerifyFilePath(const char* fname). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListfCallArgs! submitted arguments; TStringfDefaultPage! file name for default page name; TStringfDefaultPageCont! content of the file content; TStringfDrawPage! file name for drawing of single element; TStringfDrawPageCont! content of draw page; TListfEngines! engines which runs http server; TStringfJSROOT! location of external JSROOT files; TStringfJSROOTSYS! location of local JSROOT files; TListfLocations! list of local directories, which could be accessed via server; Long_tfMainThrdId! id of the main ROOT process; TMutexfMutex! mutex to protect list with arguments; TStringTNamed::fNameobject identifier; TRootSniffer*fSniffer! sniffer provides access to ROOT objects hierarchy; THttpTimer*fTimer! timer used to access main thread; TStringTNamed::fTitleobject title; TStringfTopName! name of top folder, default - ""ROOT"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpServer(const char* engine = ""civetweb:8080""); constructor. ~THttpServer(); destructor; delete all http engines and sniffer. void SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:8682,Security,access,access,8682,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidProcessRequest(THttpCallArg* arg); static Bool_tVerifyFilePath(const char* fname). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListfCallArgs! submitted arguments; TStringfDefaultPage! file name for default page name; TStringfDefaultPageCont! content of the file content; TStringfDrawPage! file name for drawing of single element; TStringfDrawPageCont! content of draw page; TListfEngines! engines which runs http server; TStringfJSROOT! location of external JSROOT files; TStringfJSROOTSYS! location of local JSROOT files; TListfLocations! list of local directories, which could be accessed via server; Long_tfMainThrdId! id of the main ROOT process; TMutexfMutex! mutex to protect list with arguments; TStringTNamed::fNameobject identifier; TRootSniffer*fSniffer! sniffer provides access to ROOT objects hierarchy; THttpTimer*fTimer! timer used to access main thread; TStringTNamed::fTitleobject title; TStringfTopName! name of top folder, default - ""ROOT"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpServer(const char* engine = ""civetweb:8080""); constructor. ~THttpServer(); destructor; delete all http engines and sniffer. void SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:8749,Security,access,access,8749,"onst char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidProcessRequest(THttpCallArg* arg); static Bool_tVerifyFilePath(const char* fname). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListfCallArgs! submitted arguments; TStringfDefaultPage! file name for default page name; TStringfDefaultPageCont! content of the file content; TStringfDrawPage! file name for drawing of single element; TStringfDrawPageCont! content of draw page; TListfEngines! engines which runs http server; TStringfJSROOT! location of external JSROOT files; TStringfJSROOTSYS! location of local JSROOT files; TListfLocations! list of local directories, which could be accessed via server; Long_tfMainThrdId! id of the main ROOT process; TMutexfMutex! mutex to protect list with arguments; TStringTNamed::fNameobject identifier; TRootSniffer*fSniffer! sniffer provides access to ROOT objects hierarchy; THttpTimer*fTimer! timer used to access main thread; TStringTNamed::fTitleobject title; TStringfTopName! name of top folder, default - ""ROOT"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpServer(const char* engine = ""civetweb:8080""); constructor. ~THttpServer(); destructor; delete all http engines and sniffer. void SetSniffer(TRootSniffer* sniff); Set TRootSniffer to the server; Server takes ownership over sniffer. Bool_t IsReadOnly() const; returns read-only mode. void SetReadOnly(Bool_t readonly); Set read-only mode for the server (default on); In read-only server is not allowed to change any ROOT object, registered to the server; Server also cannot execute objects",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:11818,Security,access,access,11818," factory method to create different http engines; At the moment two engine kinds are supported:; civetweb (default) and fastcgi; Examples:; ""civetweb:8080"" or ""http:8080"" or "":8080"" - creates civetweb web server with http port 8080; ""fastcgi:9000"" - creates fastcgi server with port 9000; ""dabc:1237"" - create DABC server with port 1237 (only available with DABC installed); ""dabc:master_host:port"" - attach to DABC master, running on master_host:port (only available with DABC installed). void SetTimer(Long_t milliSec = 100, Bool_t mode = kTRUE); create timer which will invoke ProcessRequests() function periodically; Timer is required to perform all actions in main ROOT thread; Method arguments are the same as for TTimer constructor; By default, sync timer with 100 ms period is created. If milliSec == 0, no timer will be created.; In this case application should regularly call ProcessRequests() method. Bool_t VerifyFilePath(const char* fname); Checked that filename does not contains relative path below current directory; Used to prevent access to files below current directory. Bool_t IsFileRequested(const char* uri, TString& res) const; Verifies that request is just file name; File names typically contains prefix like ""jsrootsys/""; If true, method returns real name of the file,; which should be delivered to the client; Method is thread safe and can be called from any thread. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:13179,Security,access,access,13179,"d. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObject* obj); Unregister object in folders hierarchy. See TRootSniffer::UnregisterObject() for more details. void Restrict(const char* path, const char* options); Restrict access to specified object. See TRootSniffer::Restrict() for more details. Bool_t RegisterCommand(const char* cmdname, const char* method, const char* icon = 0); Register command which can be executed from web interface. As method one typically specifies string, which is executed with; gROOT->ProcessLine() method. For instance; serv->RegisterCommand(""Invoke"",""InvokeFunction()"");. Or one could specify any method of the object which is already registered; to the server. For instance:; serv->Register(""/"", hpx);; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; Here symbols '/->' separates item name from method to be executed. One could specify additional arguments in the command with; syntax like %arg1%, %arg2% and so on. For example:; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->SetTitle(\""%arg1%\"")"");; serv->RegisterCommand(""/RebinHPXPY"", ""/hpxpy/->Rebin2D(%arg1%,%arg2%)"");; Such parameter(s) will be requested when command clicked in the browser. Once command is re",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THttpServer.html:1592,Usability,guid,guide,1592,"roach:; * standard http interface to ROOT application; * no any temporary ROOT files when access data; * user interface running in all browsers. Starting HTTP server. To start http server, at any time create instance; of the THttpServer class like:; serv = new THttpServer(""http:8080"");. This will starts civetweb-based http server with http port 8080.; Than one should be able to open address ""http://localhost:8080""; in any modern browser (IE, Firefox, Chrome) and browse objects,; created in application. By default, server can access files,; canvases and histograms via gROOT pointer. All such objects; can be displayed with JSROOT graphics. At any time one could register other objects with the command:. TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);. If objects content is changing in the application, one could; enable monitoring flag in the browser - than objects view; will be regularly updated. More information: http://root.cern.ch/drupal/content/users-guide. Function Members (Methods); public:. THttpServer(const char* engine = ""civetweb:8080""); virtual~THttpServer(); voidTObject::AbstractMethod(const char* method) const; voidAddLocation(const char* prefix, const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Bool_tCreateEngine(const char* engine); Bool_tCreateItem(const char* fullname, const char* title); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constME",MatchSource.WIKI,root/html534/THttpServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THttpServer.html
https://root.cern/root/html534/THYPE.html:1771,Availability,error,error,1771,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html534/THYPE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THYPE.html
https://root.cern/root/html534/THYPE.html:1855,Availability,error,error,1855,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() con",MatchSource.WIKI,root/html534/THYPE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/THYPE.html
https://root.cern/root/html534/TImage.html:3885,Availability,error,error,3885,"nt_t = 16, UInt_t = 16); virtual voidDrawLine(UInt_t, UInt_t, UInt_t, UInt_t, const char* = ""#000000"", UInt_t = 1); virtual voidDrawPolyLine(UInt_t, TPoint*, const char* = ""#000000"", UInt_t = 1, TImage::ECoordMode = kCoordModeOrigin); virtual voidDrawRectangle(UInt_t, UInt_t, UInt_t, UInt_t, const char* = ""#000000"", UInt_t = 1); virtual voidDrawSegments(UInt_t, Segment_t*, const char* = ""#000000"", UInt_t = 1); virtual voidDrawStraightEllips(Int_t, Int_t, Int_t, Int_t, const char* = ""#000000"", Int_t = 1); virtual voidDrawText(TText*, Int_t = 0, Int_t = 0); virtual voidDrawText(Int_t = 0, Int_t = 0, const char* = """", Int_t = 12, const char* = 0, const char* = ""fixed"", TImage::EText3DType = TImage::kPlain, const char* = 0, Float_t = 0); virtual voidTObject::Dump() constMENU ; virtual voidTAttImage::EditorClosed(); virtual voidEndPaint(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(UInt_t, TPoint*, TImage*); virtual voidFillPolygon(UInt_t, TPoint*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual voidFillRectangle(const char* = 0, Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, TImage*); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlip(Int_t = 180); virtual voidFloodFill(Int_t, Int_t, const char*, const char*, const char* = 0); virtual voidFromGLBuffer(UChar_t*, UInt_t, UInt_t); virtu",MatchSource.WIKI,root/html534/TImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImage.html
https://root.cern/root/html534/TImage.html:3969,Availability,error,error,3969,"char* = ""#000000"", UInt_t = 1); virtual voidDrawPolyLine(UInt_t, TPoint*, const char* = ""#000000"", UInt_t = 1, TImage::ECoordMode = kCoordModeOrigin); virtual voidDrawRectangle(UInt_t, UInt_t, UInt_t, UInt_t, const char* = ""#000000"", UInt_t = 1); virtual voidDrawSegments(UInt_t, Segment_t*, const char* = ""#000000"", UInt_t = 1); virtual voidDrawStraightEllips(Int_t, Int_t, Int_t, Int_t, const char* = ""#000000"", Int_t = 1); virtual voidDrawText(TText*, Int_t = 0, Int_t = 0); virtual voidDrawText(Int_t = 0, Int_t = 0, const char* = """", Int_t = 12, const char* = 0, const char* = ""fixed"", TImage::EText3DType = TImage::kPlain, const char* = 0, Float_t = 0); virtual voidTObject::Dump() constMENU ; virtual voidTAttImage::EditorClosed(); virtual voidEndPaint(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(UInt_t, TPoint*, TImage*); virtual voidFillPolygon(UInt_t, TPoint*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual voidFillRectangle(const char* = 0, Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, TImage*); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlip(Int_t = 180); virtual voidFloodFill(Int_t, Int_t, const char*, const char*, const char* = 0); virtual voidFromGLBuffer(UChar_t*, UInt_t, UInt_t); virtual voidFromPad(TVirtualPad*, Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual ",MatchSource.WIKI,root/html534/TImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImage.html
https://root.cern/root/html534/TImage.html:333,Integrability,interface,interface,333,". TImage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImage. class TImage: public TNamed, public TAttImage. Image class; TImage is an abstract interface to image processing library.; It allows for the reading and writing of images in different formats, several; image manipulations (scaling, tiling, merging, etc.) and displaying in pads. The concrete implementation of this class is done by the; TASImage class. The ; methods are documented in that class.; . Function Members (Methods); public:. TImage(const TImage& img); TImage(UInt_t, UInt_t); virtual~TImage(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TImage*, const char* = ""+"", const char* = ""#00000000""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginPaint(Bool_t = kTRUE); virtual voidBevel(Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0, const char* = ""#ffdddddd"", const char* = ""#ff555555"", UShort_t = 1, Bool_t = kFALSE); virtual voidBlur(Double_t = 3, Double_t = 3); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char*) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(TImage*, Int_t, Int_t, UInt_t, UInt_t, Int_t = 0, Int_t = 0, Int_t = 3, TImage::EColorChan = kAllChan); static TImage*Create(); virtual voidCrop(Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual voidCropPolygon(UInt_t, TPoint*); virtual voidCropSpans(UInt_t, TPoint*, UInt_t*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Int_t, Int_t, In",MatchSource.WIKI,root/html534/TImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImage.html
https://root.cern/root/html534/TImageDump.html:2429,Availability,error,error,2429,":Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; TImage*GetImage() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virt",MatchSource.WIKI,root/html534/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImageDump.html
https://root.cern/root/html534/TImageDump.html:2513,Availability,error,error,2513,"y, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; TImage*GetImage() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Get",MatchSource.WIKI,root/html534/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImageDump.html
https://root.cern/root/html534/TImageDump.html:13339,Energy Efficiency,green,green,13339,"s it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void Text(Double_t x, Double_t y, const wchar_t* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }. » Author: Valeriy Onuchin 29/04/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/postscript:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImageDump.html
https://root.cern/root/html534/TImageDump.html:11417,Integrability,interface,interface,11417,"irtualPS::fLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypePostScript workstation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImageDump(); Default SVG constructor. TImageDump(const char* filename, Int_t type = -111); Initialize batch image interface. fname : image file name. The possible workstation types are:; 111 - Portrait; 112 - Landscape; 114 - preview, keep in memory (do not write on delete). void Open(const char* filename, Int_t type = -111); Open a image file. ~TImageDump(); destructor. void Close(Option_t* opt = """"); Close a image file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw",MatchSource.WIKI,root/html534/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImageDump.html
https://root.cern/root/html534/TImageDump.html:582,Testability,test,test,582,". TImageDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TImageDump. class TImageDump: public TVirtualPS. TImageDump. save canvas as an image (GIF, JPEG, PNG, XPM, TIFF etc.); in batch mode. Example:. $ root -b; root [0] .x hsimple.C; root [1] c1->Print(""c1.gif"");. TImageDump can be used in any mode (batch, interactive) as follows. TCanvas *c1;; TImageDump *imgdump = new TImageDump(""test.png"");; c1->Paint();; imgdump->Close();. Function Members (Methods); public:. TImageDump(); TImageDump(const char* filename, Int_t type = -111); virtual~TImageDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light)",MatchSource.WIKI,root/html534/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImageDump.html
https://root.cern/root/html534/TImagePalette.html:3783,Availability,error,error,3783,"_t numPoints); TImagePalette(Int_t ncolors, Int_t* colors); virtual~TImagePalette(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindColor(UShort_t r, UShort_t g, UShort_t b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t*GetRootColors(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:3867,Availability,error,error,3867," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindColor(UShort_t r, UShort_t g, UShort_t b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t*GetRootColors(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classna",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:1414,Energy Efficiency,allocate,allocated,1414,"rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : ",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:1767,Energy Efficiency,monitor,monitors,1767,"he size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors. TPaletteEditor. This class provides a way to edit the palette via a GUI. Function Members (Methods); public:. TImagePalette(); TImagePalette(const TImagePalette& palett",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:1823,Energy Efficiency,monitor,monitors,1823,"he size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors. TPaletteEditor. This class provides a way to edit the palette via a GUI. Function Members (Methods); public:. TImagePalette(); TImagePalette(const TImagePalette& palett",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:7821,Energy Efficiency,green,green,7821,"t char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:8269,Energy Efficiency,allocate,allocates,8269,"ar* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:SetPalette. » Author: Reiner Rohlfs 24/03/02 » Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *; » Last changed: root/graf:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:507,Integrability,depend,depends,507,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:751,Integrability,depend,depends,751,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:901,Modifiability,inherit,inheritance,901,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePalette.html:1241,Modifiability,variab,variables,1241,"te. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::C",MatchSource.WIKI,root/html534/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePalette.html
https://root.cern/root/html534/TImagePlugin.html:423,Availability,avail,available,423,". TImagePlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TImagePlugin. class TImagePlugin: public TObject. TImagePlugin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html534/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePlugin.html
https://root.cern/root/html534/TImagePlugin.html:1393,Availability,error,error,1393," virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html534/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePlugin.html
https://root.cern/root/html534/TImagePlugin.html:1477,Availability,error,error,1477," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html534/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TImagePlugin.html
https://root.cern/root/html534/timespec.html:306,Modifiability,extend,extends,306,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: R. Hatcher 30/9/2001 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/timespec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/timespec.html
https://root.cern/root/html534/timespec.html:698,Usability,simpl,simply,698,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: R. Hatcher 30/9/2001 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/timespec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/timespec.html
https://root.cern/root/html534/TIndexTable.html:3669,Availability,error,error,3669," named) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html534/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIndexTable.html
https://root.cern/root/html534/TIndexTable.html:3753,Availability,error,error,3753,"_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html534/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIndexTable.html
https://root.cern/root/html534/TIndexTable.html:16430,Testability,assert,assert,16430,"nst TTable*fRefTable; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }. » Author: Valery Fine(fine@bnl.gov) 01/03/2001 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIndexTable.html
https://root.cern/root/html534/TIndexTable.html:16527,Testability,assert,assert,16527,"nst TTable*fRefTable; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }. » Author: Valery Fine(fine@bnl.gov) 01/03/2001 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIndexTable.html
https://root.cern/root/html534/TInetAddress.html:1396,Availability,error,error,1396," TInetAddress(); TInetAddress(const TInetAddress& adr); virtual~TInetAddress(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root/html534/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInetAddress.html
https://root.cern/root/html534/TInetAddress.html:1480,Availability,error,error,1480," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFamily() const; const char*GetHostAddress() const; static const char*GetHostAddress(UInt_t addr); const char*GetHostName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html534/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInetAddress.html
https://root.cern/root/html534/TInetAddress.html:6717,Energy Efficiency,allocate,allocated,6717,"resses in host byte order; vector<TString>fAliaseslist of aliases; Int_tfFamilyaddress family; TStringfHostnamefully qualified hostname; Int_tfPortport through which we are connected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInetAddress(); Default ctor. Used in case of unknown host. Not a valid address. TInetAddress(const char* host, UInt_t addr, Int_t family, Int_t port = -1); Create TInetAddress. Private ctor. TInetAddress objects can only; be created via the friend classes TSystem, TServerSocket and TSocket.; Use the IsValid() method to check the validity of a TInetAddress. TInetAddress(const TInetAddress& adr); TInetAddress copy ctor. TInetAddress& operator=(const TInetAddress& rhs); TInetAddress assignment operator. UChar_t * GetAddressBytes() const; Returns the raw IP address in host byte order. The highest; order byte position is in addr[0]. To be prepared for 64-bit; IP addresses an array of bytes is returned.; User must delete allocated memory. const char * GetHostAddress(UInt_t addr); Returns the IP address string ""%d.%d.%d.%d"", use it to convert; alternative addresses obtained via GetAddresses().; Copy string immediately, it will be reused. Static function. const char * GetHostAddress() const; Returns the IP address string ""%d.%d.%d.%d"".; Copy string immediately, it will be reused. void Print(Option_t* option = """") const; Print internet address as string. void AddAddress(UInt_t addr); Add alternative address to list of addresses. void AddAlias(const char* alias); Add alias to list of aliases. void Streamer(TBuffer& ); Stream an object of class TInetAddress. virtual ~TInetAddress(); { }. UInt_t GetAddress() const; { return fAddresses[0]; }. const char * GetHostName() const; { return (const char *) fHostname; }. Int_t GetFamily() const; { return fFamily; }. Int_t GetPort() const; { return fPort; }. const AddressList_t & GetAddresses() const; { return fAddresses; }. const AliasList_t & GetAliases() const; { ",MatchSource.WIKI,root/html534/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInetAddress.html
https://root.cern/root/html534/TInspectCanvas.html:6175,Availability,error,error,6175,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargi",MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInspectCanvas.html:6259,Availability,error,error,6259,"ect::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas::GetCanvasI",MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInspectCanvas.html:29110,Availability,down,down,29110,,MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInspectCanvas.html:36915,Integrability,interface,interface,36915," fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tTCanvas::fgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInspectCanvas(); InspectCanvas default constructor. TInspectCanvas(UInt_t ww, UInt_t wh); InspectCanvas constructor. ~TInspectCanvas(); InspectCanvas default destructor. void InspectObject(TObject* obj); Dump contents of obj in a graphics canvas.; Same action as TObject::Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. void GoBackward(); static function , inspect previous object. void GoForward(); static function , inspect next object. void Inspector(TObject* obj); static function , interface to InspectObject.; Create the InspectCanvas if it does not exist yet. void RecursiveRemove(TObject* obj); Recursively remove object from the list of objects. void Divide(Int_t nx = 1, Int_t ny = 1, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); { }. void SetGrid(Int_t valuex = 1, Int_t valuey = 1); { }. void SetGridx(Int_t value = 1); { }. void SetGridy(Int_t value = 1); { }. void SetLogx(Int_t value = 1); { }. void SetLogy(Int_t value = 1); { }. void SetLogz(Int_t value = 1); { }. void SetTickx(Int_t value = 1); { }. void SetTicky(Int_t value = 1); { }. void x3d(Option_t* option = """"); { }. TButton * GetBackward() const; {return fBackward;}. TButton * GetForward() const; {return fForward;}. TObject * GetCurObject() const; {return fCurObject;}. TList * GetObjects() const; {return fObjects;}. » Author: Rene Brun 08/01/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-03-14 16:42",MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInspectCanvas.html:31613,Testability,log,log,31613,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInspectCanvas.html:31670,Testability,log,log,31670,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInspectCanvas.html:31727,Testability,log,log,31727,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html534/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html
https://root.cern/root/html534/TInterpreter.html:525,Availability,avail,available,525,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long64_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFu",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:1510,Availability,error,error,1510," virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long64_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFu",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:7046,Availability,error,error,7046,"nst; virtual Long_tDataMemberInfo_TypeProperty(DataMemberInfo_t*) const; virtual intDataMemberInfo_TypeSize(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual ",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:7149,Availability,error,error,7149,"Size(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual ",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:7248,Availability,error,error,7248,"nst; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInter",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:7403,Availability,error,error,7403,"teGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* method, const char* params); virtual void*GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* pr",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:10401,Availability,error,error,10401,"); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Int_tInitializeDictionaries(); virtual voidTObject::Inspect() constMENU ; static TInterpreter*&Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsErrorMessagesEnabled() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsLoaded(const char* filename) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsProcessLineLocked() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLoad(const char* filenam, Bool_t system = kFALSE); virtual intLoadFile(const char*) const; virtual Int_tLoadLibraryMap(const char* rootmapfile = 0); virtual voidLoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidLoadText(const char*) const; virtual voidTNamed::ls(Option_t* option = """") const; virtual const char*MapCppName(const char*) const; voidTObject::MayNotUse(const char* method) const; virtual const char*MethodArgInfo_DefaultValue(MethodArgInfo_t*) const; virtual voidMethodArgInfo_Delete(MethodArgInfo_t*) const; virtual MethodArgInfo_t*MethodArgInfo_Factory() const; virtual MethodArgInfo_t*MethodArgInfo_Factory(MethodInfo_t*) const; virtual MethodArgInfo_t*MethodArgInfo_FactoryCopy(MethodArgInfo_t*) const; virtual Bool_tMethodArgInfo_IsValid(MethodArgInfo_t*) const; virtual const char*MethodArgInfo_Name(MethodArgInfo_t*) const; virtual intMethodArgInfo_Next(MethodArgInfo_t*) const; virtual Long_tMethodArgInfo_Property(MethodArgInfo_t*) const; virtual const char*MethodArgInfo_TypeName(MethodArgInfo_t*) const; virtual stringMethodArgInfo_TypeNormalizedName(MethodArgInfo_t*) const; virtual voidMethodInfo_CreateSignature(MethodInfo_t*, TString&) const; virtual voidMethodI",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:13184,Availability,error,error,13184," const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t*) const; virtual const char*MethodInfo_TypeName(MethodInfo_t*) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual Int_tSetClassSharedLibs(const char* cls, con",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:13271,Availability,error,error,13271,"hodInfo_TypeName(MethodInfo_t*) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual Int_tSetClassSharedLibs(const char* cls, const char* libs); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static ",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:17336,Availability,error,error,17336,"virtual const char*TypeInfo_Name(TypeInfo_t*) const; virtual Long_tTypeInfo_Property(TypeInfo_t*) const; virtual intTypeInfo_RefType(TypeInfo_t*) const; virtual intTypeInfo_Size(TypeInfo_t*) const; virtual const char*TypeInfo_TrueName(TypeInfo_t*) const; virtual const char*TypeName(const char* s); virtual Int_tUnloadAllSharedLibraryMaps(); virtual intUnloadFile(const char*) const; virtual Int_tUnloadLibraryMap(const char* library); virtual voidUpdateListOfGlobalFunctions(); virtual voidUpdateListOfGlobals(); virtual voidUpdateListOfMethods(TClass* cl); virtual voidUpdateListOfTypes(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidExecute(TMethod* method, TObjArray* params, int* error = 0); voidTObject::MakeZombie(). Data Members; public:. enum EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile()",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:18018,Availability,error,error,18018,"TObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidExecute(TMethod* method, TObjArray* params, int* error = 0); voidTObject::MakeZombie(). Data Members; public:. enum EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllShar",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:18888,Availability,error,error,18888," Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Lon",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:19157,Availability,error,error,19157,"sname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). T",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:19237,Availability,error,error,19237,"d EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TS",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:19915,Availability,error,error,19915,"r = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). Int_t SetClassSharedLibs(const char* cls, const char* libs). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). Int_t DeleteVariable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsEr",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:20601,Availability,error,error,20601,"iable(const char* name). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. cons",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:20697,Availability,error,error,20697,"istOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroNa",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:20789,Availability,error,error,20789,"o(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurit",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:20869,Availability,error,error,20869,"autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadT",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:341,Integrability,interface,interface,341,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long64_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFu",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:22346,Integrability,interface,interface,22346,"; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadText(const char* ) const; {;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void (*)() ) const; {;}. void SetAllocunlockfunc(void (*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {return 0;}. void CallFunc_Delete(void* ) const; G__CallFunc interface. {;}. void CallFunc_Exec(CallFunc_t* , void* ) const; {;}. Long_t CallFunc_ExecInt(CallFunc_t* , void* ) const; {return 0;}. Long64_t CallFunc_ExecInt64(CallFunc_t* , void* ) const; {return 0;}. Double_t CallFunc_ExecDouble(CallFunc_t* , void* ) const; {return 0;}. CallFunc_t * CallFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_Init(CallFunc_t* ) const; {;}. Bool_t CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. void CallFunc_ResetArg(CallFunc_t* ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Double_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long64_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , ULong64_t ) const; {;}. void CallFunc_SetArgArray(CallFunc_t* , Long_t* , Int_t ) const; {;}. void CallFunc_SetArgs(CallFunc_t* , const char* ) const; {;}",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:23666,Integrability,interface,interface,23666,"llFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_Init(CallFunc_t* ) const; {;}. Bool_t CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. void CallFunc_ResetArg(CallFunc_t* ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Double_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long64_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , ULong64_t ) const; {;}. void CallFunc_SetArgArray(CallFunc_t* , Long_t* , Int_t ) const; {;}. void CallFunc_SetArgs(CallFunc_t* , const char* ) const; {;}. void CallFunc_SetFunc(CallFunc_t* , ClassInfo_t* , const char* , const char* , Long_t* ) const; {;}. void CallFunc_SetFunc(CallFunc_t* , MethodInfo_t* ) const; {;}. void CallFunc_SetFuncProto(CallFunc_t* , ClassInfo_t* , const char* , const char* , Long_t* ) const; {;}. Long_t ClassInfo_ClassProperty(ClassInfo_t* ) const; G__ClassInfo interface. {return 0;}. void ClassInfo_Delete(ClassInfo_t* ) const; {;}. void ClassInfo_Delete(ClassInfo_t* , void* ) const; {;}. void ClassInfo_DeleteArray(ClassInfo_t* , void* , bool ) const; {;}. void ClassInfo_Destruct(ClassInfo_t* , void* ) const; {;}. ClassInfo_t * ClassInfo_Factory() const; {return 0;}. ClassInfo_t * ClassInfo_Factory(G__value* ) const; {return 0;}. ClassInfo_t * ClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. ClassInfo_t * ClassInfo_Factory(const char* ) const; {return 0;}. int ClassInfo_GetMethodNArg(ClassInfo_t* , const char* , const char* ) const; {return 0;}. Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t* ) const; {return 0;}. Bool_t ClassInfo_HasMethod(ClassInfo_t* , const char* ) const; {return 0;}. void ClassInfo_Init(ClassInfo_t* , const char* ) const; {;}. void ClassInfo_Init(ClassInfo_t* , int ) const; {;}. Bool_t ClassInfo_IsBase(ClassInfo_t* , const char* ) const; {return 0;}. Bool_t ClassInfo_IsEnum(const char*",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:25822,Integrability,interface,interface,25822,"ssInfo_IsValidMethod(ClassInfo_t* , const char* , const char* , Long_t* ) const; {return 0;}. int ClassInfo_Next(ClassInfo_t* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , int ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , int , void* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , void* ) const; {return 0;}. Long_t ClassInfo_Property(ClassInfo_t* ) const; {return 0;}. int ClassInfo_RootFlag(ClassInfo_t* ) const; {return 0;}. int ClassInfo_Size(ClassInfo_t* ) const; {return 0;}. Long_t ClassInfo_Tagnum(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_FileName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_FullName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Name(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Title(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_TmpltName(ClassInfo_t* ) const; {return 0;}. void BaseClassInfo_Delete(BaseClassInfo_t* ) const; G__BaseClassInfo interface. {;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* , int ) const; {return 0;}. Long_t BaseClassInfo_Offset(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Property(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_FullName(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_Name(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* ) const; {return 0;}. int DataMemberInfo_ArrayDim(DataMemberInfo_t* ) const; G__DataMemberInfo interface. {return 0;}. void DataMemberInfo_Delete(DataMemberInfo_t* ) const; {;}. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* = 0) const; {return 0;}. DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. Bo",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:26541,Integrability,interface,interface,26541,"Info_FullName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Name(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Title(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_TmpltName(ClassInfo_t* ) const; {return 0;}. void BaseClassInfo_Delete(BaseClassInfo_t* ) const; G__BaseClassInfo interface. {;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* , int ) const; {return 0;}. Long_t BaseClassInfo_Offset(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Property(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_FullName(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_Name(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* ) const; {return 0;}. int DataMemberInfo_ArrayDim(DataMemberInfo_t* ) const; G__DataMemberInfo interface. {return 0;}. void DataMemberInfo_Delete(DataMemberInfo_t* ) const; {;}. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* = 0) const; {return 0;}. DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. Bool_t DataMemberInfo_IsValid(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_MaxIndex(DataMemberInfo_t* , Int_t ) const; {return 0;}. int DataMemberInfo_Next(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Offset(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Property(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_TypeSize(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return ",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:27752,Integrability,interface,interface,27752,"fo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. Bool_t DataMemberInfo_IsValid(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_MaxIndex(DataMemberInfo_t* , Int_t ) const; {return 0;}. int DataMemberInfo_Next(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Offset(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Property(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_TypeSize(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Title(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* ) const; {return 0;}. void MethodInfo_CreateSignature(MethodInfo_t* , TString& ) const; G__MethodInfo interface. {;}. void MethodInfo_Delete(MethodInfo_t* ) const; {;}. MethodInfo_t * MethodInfo_Factory() const; {return 0;}. MethodInfo_t * MethodInfo_Factory(ClassInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. Bool_t MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const; {return 0;}. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetPrototype(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Name(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_TypeName(MethodInfo",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:28957,Integrability,interface,interface,28957,"st; {return 0;}. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. Bool_t MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const; {return 0;}. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetPrototype(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Name(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_TypeName(MethodInfo_t* ) const; {return 0;}. std::string MethodInfo_TypeNormalizedName(MethodInfo_t* ) const; {return """";}. const char * MethodInfo_Title(MethodInfo_t* ) const; {return 0;}. void MethodArgInfo_Delete(MethodArgInfo_t* ) const; G__MethodArgInfo interface. {;}. MethodArgInfo_t * MethodArgInfo_Factory() const; {return 0;}. MethodArgInfo_t * MethodArgInfo_Factory(MethodInfo_t* ) const; {return 0;}. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* ) const; {return 0;}. Bool_t MethodArgInfo_IsValid(MethodArgInfo_t* ) const; {return 0;}. int MethodArgInfo_Next(MethodArgInfo_t* ) const; {return 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* ) const; {return 0;}. void TypeInfo_Delete(TypeInfo_t* ) const; G__TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(G__value* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInf",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:29756,Integrability,interface,interface,29756,"turn 0;}. std::string MethodInfo_TypeNormalizedName(MethodInfo_t* ) const; {return """";}. const char * MethodInfo_Title(MethodInfo_t* ) const; {return 0;}. void MethodArgInfo_Delete(MethodArgInfo_t* ) const; G__MethodArgInfo interface. {;}. MethodArgInfo_t * MethodArgInfo_Factory() const; {return 0;}. MethodArgInfo_t * MethodArgInfo_Factory(MethodInfo_t* ) const; {return 0;}. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* ) const; {return 0;}. Bool_t MethodArgInfo_IsValid(MethodArgInfo_t* ) const; {return 0;}. int MethodArgInfo_Next(MethodArgInfo_t* ) const; {return 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* ) const; {return 0;}. void TypeInfo_Delete(TypeInfo_t* ) const; G__TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(G__value* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. Bool_t TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_Name(TypeInfo_t* ) const; {return 0;}. Long_t TypeInfo_Property(TypeInfo_t* ) const; {return 0;}. int TypeInfo_RefType(TypeInfo_t* ) const; {return 0;}. int TypeInfo_Size(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_TrueName(TypeInfo_t* ) const; {return 0;}. void TypedefInfo_Delete(TypedefInfo_t* ) const; G__TypedefInfo interface. {;}. TypedefInfo_t * TypedefInfo_Factory() const; {return 0;}. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* ) const; {return 0;}. void TypedefInfo_Init(TypedefInfo_t* , const char* ) const; {;}. Bool_t TypedefInfo_IsValid(TypedefInfo_t* ) const; {return 0;}. int TypedefInfo_Next(Typedef",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:30426,Integrability,interface,interface,30426,"char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* ) const; {return 0;}. void TypeInfo_Delete(TypeInfo_t* ) const; G__TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(G__value* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. Bool_t TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_Name(TypeInfo_t* ) const; {return 0;}. Long_t TypeInfo_Property(TypeInfo_t* ) const; {return 0;}. int TypeInfo_RefType(TypeInfo_t* ) const; {return 0;}. int TypeInfo_Size(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_TrueName(TypeInfo_t* ) const; {return 0;}. void TypedefInfo_Delete(TypedefInfo_t* ) const; G__TypedefInfo interface. {;}. TypedefInfo_t * TypedefInfo_Factory() const; {return 0;}. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* ) const; {return 0;}. void TypedefInfo_Init(TypedefInfo_t* , const char* ) const; {;}. Bool_t TypedefInfo_IsValid(TypedefInfo_t* ) const; {return 0;}. int TypedefInfo_Next(TypedefInfo_t* ) const; {return 0;}. Long_t TypedefInfo_Property(TypedefInfo_t* ) const; {return 0;}. int TypedefInfo_Size(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_TrueName(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_Name(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_Title(TypedefInfo_t* ) const; {return 0;}. » Author: Fons Rademakers 01/03/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to RO",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TInterpreter.html:21275,Safety,avoid,avoids,21275,"o). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadText(const char* ) const; {;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void (*)() ) const; {;}. void SetAllocunlockfunc(void (*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {retur",MatchSource.WIKI,root/html534/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TInterpreter.html
https://root.cern/root/html534/TIter.html:1120,Deployability,release,release,1120,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class and assign",MatchSource.WIKI,root/html534/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIter.html
https://root.cern/root/html534/TIter.html:323,Integrability,protocol,protocol,323,". TIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Fu",MatchSource.WIKI,root/html534/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIter.html
https://root.cern/root/html534/TIter.html:441,Modifiability,inherit,inherit,441,". TIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Fu",MatchSource.WIKI,root/html534/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIter.html
https://root.cern/root/html534/TIter.html:1025,Modifiability,inherit,inherits,1025,"rarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); Bool_toperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); Bool_toperator==(const TIter& aIter) const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIte",MatchSource.WIKI,root/html534/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIter.html
https://root.cern/root/html534/TIterator.html:513,Availability,avail,available,513,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); Bool_toperator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. Bool_t operator==(const TIterator& other) const; { return !(*this != other); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-20 17:44; This page has been a",MatchSource.WIKI,root/html534/TIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIterator.html
https://root.cern/root/html534/TIterator.html:342,Integrability,interface,interface,342,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); Bool_toperator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }. Bool_t operator==(const TIterator& other) const; { return !(*this != other); }. » Author: Fons Rademakers 13/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-20 17:44; This page has been a",MatchSource.WIKI,root/html534/TIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TIterator.html
https://root.cern/root/html534/TKDE.html:1443,Availability,error,error,1443,"ss TKDE: public TNamed. Function Members (Methods); public:. TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); virtual~TKDE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t data); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetAdaptiveWeights() const; TF1*GetApproximateBias(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Double_tGetBias(Double_t x) const; TF1*GetDrawnFunction(); TGraphErrors*GetDrawnGraph(); TF1*GetDrawnLowerFunction(); TF1*GetDrawnUpperFunction(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetE",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:1527,Availability,error,error,1527,"ss TKDE: public TNamed. Function Members (Methods); public:. TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); virtual~TKDE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t data); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetAdaptiveWeights() const; TF1*GetApproximateBias(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Double_tGetBias(Double_t x) const; TF1*GetDrawnFunction(); TGraphErrors*GetDrawnGraph(); TF1*GetDrawnLowerFunction(); TF1*GetDrawnUpperFunction(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetE",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:9688,Availability,error,errors,9688,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:10394,Availability,robust,robust,10394,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:15301,Availability,error,errors,15301,". void Fill(Double_t data); Fills data member with User input data event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Retur",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:15446,Availability,error,errors,15446,". void Fill(Double_t data); Fills data member with User input data event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Retur",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:15971,Availability,error,errors,15971,"rding to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:9314,Energy Efficiency,adapt,adaptive,9314,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:11991,Energy Efficiency,adapt,adaptive,11991,"_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); Class constructor. ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, Double_t xMin, Double_t xMax, Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitF",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:12488,Energy Efficiency,adapt,adaptive,12488,"tDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKernelS",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:16248,Energy Efficiency,adapt,adaptive,16248," option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:16338,Energy Efficiency,adapt,adaptive,16338,"s; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. Double_t ComputeMidspread(); Co",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:9314,Modifiability,adapt,adaptive,9314,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:11991,Modifiability,adapt,adaptive,11991,"_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); Class constructor. ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, Double_t xMin, Double_t xMax, Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitF",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:12488,Modifiability,adapt,adaptive,12488,"tDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKernelS",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:16248,Modifiability,adapt,adaptive,16248," option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:16338,Modifiability,adapt,adaptive,16338,"s; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. Double_t ComputeMidspread(); Co",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDE.html:12413,Performance,tune,tune,12413,"tion_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths",MatchSource.WIKI,root/html534/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDE.html
https://root.cern/root/html534/TKDTreeBinning.html:2393,Availability,error,error,2393,"t* data, UInt_t nBins = 100, bool adjustBinEdges = false); virtual~TKDTreeBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinData(ROOT::Fit::BinData& data) const; UInt_tFindBin(const Double_t* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetBinCenter(UInt_t bin) const; UInt_tGetBinContent(UInt_t bin) const; Double_tGetBinDensity(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinEdges(UInt_t bin) const; UInt_tGetBinMaxDensity() const; const Double_t*GetBinMaxEdges(UInt_t bin) const; UInt_tGetBinMinDensity() const; const Double_t*GetBinMinEdges(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinsEdges() const; const Double_t*GetBinsMaxEdges() const; const Double_t*GetBinsMinEdges() const; Double_tGetBinVolume(UInt_t bin) const; const Double",MatchSource.WIKI,root/html534/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTreeBinning.html
https://root.cern/root/html534/TKDTreeBinning.html:2477,Availability,error,error,2477," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinData(ROOT::Fit::BinData& data) const; UInt_tFindBin(const Double_t* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetBinCenter(UInt_t bin) const; UInt_tGetBinContent(UInt_t bin) const; Double_tGetBinDensity(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinEdges(UInt_t bin) const; UInt_tGetBinMaxDensity() const; const Double_t*GetBinMaxEdges(UInt_t bin) const; UInt_tGetBinMinDensity() const; const Double_t*GetBinMinEdges(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinsEdges() const; const Double_t*GetBinsMaxEdges() const; const Double_t*GetBinsMinEdges() const; Double_tGetBinVolume(UInt_t bin) const; const Double_t*GetBinWidth(UInt_t bin) const; Double_tGetDataMax(UInt_t dim) const; Double_tGetD",MatchSource.WIKI,root/html534/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTreeBinning.html
https://root.cern/root/html534/TKDTreeBinning.html:10259,Safety,avoid,avoid,10259,"ion. Thus data[] = x1,x2,x3,......xN, y1,y2,y3......yN, z1,z2,...........zN,.... Note that the passed dataSize is not the size of the array but is the number of points (N); The size of the array must be at least dataDim*dataSize. ~TKDTreeBinning(); Class's destructor. void SetNBins(UInt_t bins); Sets binning inner structure. void SortBinsByDensity(Bool_t sortAsc = kTRUE); Sorts bins by their density. void SetData(Double_t* data); Sets the data and finds minimum and maximum by dimensional coordinate. void SetTreeData(); Sets the data for constructing the kD-tree. void SetBinsContent(); Sets the bins' content. void SetBinsEdges(); Sets the bins' edges; Double_t* rawBinEdges = fDataBins->GetBoundaryExact(fDataBins->GetNNodes());. void SetBinMinMaxEdges(Double_t* binEdges); Sets the bins' minimum and maximum edges. void SetCommonBinEdges(Double_t* binEdges); Sets indexing on the bin edges which have common boundaries. void ReadjustMinBinEdges(Double_t* binEdges); Readjusts the bins' minimum edge by shifting it slightly lower; to avoid overlapping with the data. void ReadjustMaxBinEdges(Double_t* binEdges); Readjusts the bins' maximum edge; and shift it sligtly higher. const Double_t* GetBinsMinEdges() const; Returns the bins' minimum edges. const Double_t* GetBinsMaxEdges() const; Returns the bins' maximum edges. std::pair<const Double_t*, const Double_t*> GetBinsEdges() const; Returns the bins' edges. const Double_t* GetBinMinEdges(UInt_t bin) const; Returns the bin's minimum edges. 'bin' is between 0 and fNBins - 1. const Double_t* GetBinMaxEdges(UInt_t bin) const; Returns the bin's maximum edges. 'bin' is between 0 and fNBins - 1. std::pair<const Double_t*, const Double_t*> GetBinEdges(UInt_t bin) const; Returns the bin's edges. 'bin' is between 0 and fNBins - 1. UInt_t GetNBins() const; Returns the number of bins. UInt_t GetDim() const; Returns the number of dimensions. UInt_t GetBinContent(UInt_t bin) const; Returns the number of points in bin. 'bin' is between 0 a",MatchSource.WIKI,root/html534/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTreeBinning.html
https://root.cern/root/html534/TKDTree_int_double_.html:1960,Availability,down,down,1960,"ng a multidimensional search key (e.g. range searches and; nearest neighbour searches). kd-trees are a special case of BSP trees. A kd-tree uses only splitting planes that are perpendicular to one of the coordinate system axes.; This differs from BSP trees, in which arbitrary splitting planes can be used.; In addition, in the typical definition every node of a kd-tree, from the root to the leaves, stores a point.; This differs from BSP trees, in which leaves are typically the only nodes that contain points; (or other geometric primitives). As a consequence, each splitting plane must go through one of; the points in the kd-tree. kd-trees are a variant that store data only in leaf nodes. 2. Constructing a classical kd-tree ( Pseudo code). Since there are many possible ways to choose axis-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return n",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:11463,Availability,error,error,11463,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:11547,Availability,error,error,11547,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode) const; virtual const char*TObject::GetName() const; intGetNDim(); Int_",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:18321,Availability,failure,failure,18321,"tfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; double*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); double*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const double* point, Int_t kNN, int* ind, double* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const double* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const double* point) const; returns the in",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:19389,Availability,failure,failure,19389,"turns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const double* point, Int_t kNN, int* ind, double* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const double* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const double* point) const; returns the index of the terminal node to which point belongs; (index in the fAxis, fValue, etc arrays); returns -1 in case of failure. void TKDTree<Index, Value> FindPoint(double* point, int& index, Int_t& iter). find the index of point; works only if we keep fData pointers. void TKDTree<Index, Value> FindInRange(double* point, double range, vector<int>& res); Find all points in the sphere of a given radius ""range"" around the given point; 1st argument - the point; 2nd argument - radius of the shere; 3rd argument - a vector, in which the results will be returned. void TKDTree<Index, Value> UpdateRange(int inode, double* point, double range, vector<int>& res); Internal recursive function with the implementation of range searches. Index* TKDTree<Index, Value> GetPointsIndexes(Int_t node) const; return the indices of the points in that terminal node; for all the nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize. void TKDTree<Index, Value> GetNodePointsIndexes(Int_t node, Int_t& first1, ",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:6589,Energy Efficiency,consumption,consumption,6589," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:4038,Integrability,interface,interface,4038,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:4348,Modifiability,variab,variables,4348,"ave memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npoints; i++){; data0[i]=gRandom->Uniform(xmin, xmax);; data1[i]=gRandom->Uniform(xmin, xmax);; data2[i]=gRandom->Uniform(xmin, xmax);; }; TKDTreeID *kdtree = new TKDTreeID(npoints, ndim, bsize);; kdtree->SetData(0, data0);; kdtree->SetData(1, data1);; kdtree->SetData(2, data2);; kdtree->Build();; }. By default, the kd-tree doesn't own the data and doesn't delete it with itself. If you want the; data to ",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:24373,Modifiability,variab,variables,24373," node with just one point minimum and maximum for each; dimension are the same.; Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> FindBNodeA(double* point, double* delta, Int_t& inode). find the smallest node covering the full range - start. Value* TKDTree<Index, Value> GetBoundaries(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundariesExact(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundary(const Int_t node); Get a boundary. Value* TKDTree<Index, Value> GetBoundaryExact(const Int_t node); Get a boundary. Int_t GetLeft(Int_t inode) const; Get indexes of left and right daughter nodes. {return inode*2+1;}. Int_t GetRight(Int_t inode) const; {return (inode+1)*2;}. Int_t GetParent(Int_t inode) const. Other getters. {return (inode-1)/2;}. UChar_t GetNodeAxis(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fAxis[id];}. Value GetNodeValue(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fValue[id];}. Int_t GetNNodes() const; {return fNNodes;}. Int_t GetTotalNodes() const; {return fTotalNodes;}. Index GetNPoints(); { return fNPoints; }. Index GetNDim(); { return fNDim; }. Int_t GetRowT0(); Getters for internal variables. {return fRowT0;}. Int_t GetCrossNode(); {return fCrossNode;}. Int_t GetOffset(); {return fOffset;}. Index* GetIndPoints(); {return fIndPoints;}. Index GetBucketSize(); {return fBucketSize;}. Bool_t IsTerminal(int inode) const; {return (inode>=fNNodes);}. Int_t IsOwner(); { return fDataOwner; }. void SetOwner(Int_t owner); { fDataOwner = owner; }. TKDTree<Index, Value>& operator=(const TKDTree<int,double>& ). » Last changed: Sat Mar 14 16:42:48 2015 » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:3473,Performance,optimiz,optimized,3473,"is method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtre",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:6560,Performance,optimiz,optimized,6560," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:8725,Performance,perform,performed,8725,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:21865,Performance,perform,performed,21865," the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, double** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, double* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, double* a, int* index, double& min, double& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, double* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(double* range = 0x0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, ",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:7100,Security,access,access,7100,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:2864,Usability,simpl,simple,2864,"-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tre",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_double_.html:4118,Usability,simpl,simplify,4118,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html534/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_double_.html
https://root.cern/root/html534/TKDTree_int_float_.html:1957,Availability,down,down,1957,"ng a multidimensional search key (e.g. range searches and; nearest neighbour searches). kd-trees are a special case of BSP trees. A kd-tree uses only splitting planes that are perpendicular to one of the coordinate system axes.; This differs from BSP trees, in which arbitrary splitting planes can be used.; In addition, in the typical definition every node of a kd-tree, from the root to the leaves, stores a point.; This differs from BSP trees, in which leaves are typically the only nodes that contain points; (or other geometric primitives). As a consequence, each splitting plane must go through one of; the points in the kd-tree. kd-trees are a variant that store data only in leaf nodes. 2. Constructing a classical kd-tree ( Pseudo code). Since there are many possible ways to choose axis-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return n",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:11450,Availability,error,error,11450,"tion_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const float* point, int ind, Int_t type = 2) const; voidDistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(float* point, float* delta, Int_t& inode); voidFindInRange(float* point, float range, vector<int>& res); voidFindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); intFindNode(const float* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(float* point, int& index, Int_t& iter); float*GetBoundaries(); float*GetBoundariesExact(); float*GetBoundary(const Int_t node); float*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:11534,Availability,error,error,11534,"TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const float* point, int ind, Int_t type = 2) const; voidDistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(float* point, float* delta, Int_t& inode); voidFindInRange(float* point, float range, vector<int>& res); voidFindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); intFindNode(const float* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(float* point, int& index, Int_t& iter); float*GetBoundaries(); float*GetBoundariesExact(); float*GetBoundary(const Int_t node); float*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode) const; virtual const char*TObject::GetName() const; intGetNDim(); Int_tGetNNodes()",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:18273,Availability,failure,failure,18273," intfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; float*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); float*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of t",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:19334,Availability,failure,failure,19334,"nt; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of the terminal node to which point belongs; (index in the fAxis, fValue, etc arrays); returns -1 in case of failure. void TKDTree<Index, Value> FindPoint(float* point, int& index, Int_t& iter). find the index of point; works only if we keep fData pointers. void TKDTree<Index, Value> FindInRange(float* point, float range, vector<int>& res); Find all points in the sphere of a given radius ""range"" around the given point; 1st argument - the point; 2nd argument - radius of the shere; 3rd argument - a vector, in which the results will be returned. void TKDTree<Index, Value> UpdateRange(int inode, float* point, float range, vector<int>& res); Internal recursive function with the implementation of range searches. Index* TKDTree<Index, Value> GetPointsIndexes(Int_t node) const; return the indices of the points in that terminal node; for all the nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize. void TKDTree<Index, Value> GetNodePointsIndexes(Int_t node, Int_t& first1, Int_t",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:6586,Energy Efficiency,consumption,consumption,6586," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:4035,Integrability,interface,interface,4035,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:4345,Modifiability,variab,variables,4345,"ave memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npoints; i++){; data0[i]=gRandom->Uniform(xmin, xmax);; data1[i]=gRandom->Uniform(xmin, xmax);; data2[i]=gRandom->Uniform(xmin, xmax);; }; TKDTreeID *kdtree = new TKDTreeID(npoints, ndim, bsize);; kdtree->SetData(0, data0);; kdtree->SetData(1, data1);; kdtree->SetData(2, data2);; kdtree->Build();; }. By default, the kd-tree doesn't own the data and doesn't delete it with itself. If you want the; data to ",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:24304,Modifiability,variab,variables,24304,"nal node with just one point minimum and maximum for each; dimension are the same.; Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> FindBNodeA(float* point, float* delta, Int_t& inode). find the smallest node covering the full range - start. Value* TKDTree<Index, Value> GetBoundaries(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundariesExact(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundary(const Int_t node); Get a boundary. Value* TKDTree<Index, Value> GetBoundaryExact(const Int_t node); Get a boundary. Int_t GetLeft(Int_t inode) const; Get indexes of left and right daughter nodes. {return inode*2+1;}. Int_t GetRight(Int_t inode) const; {return (inode+1)*2;}. Int_t GetParent(Int_t inode) const. Other getters. {return (inode-1)/2;}. UChar_t GetNodeAxis(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fAxis[id];}. Value GetNodeValue(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fValue[id];}. Int_t GetNNodes() const; {return fNNodes;}. Int_t GetTotalNodes() const; {return fTotalNodes;}. Index GetNPoints(); { return fNPoints; }. Index GetNDim(); { return fNDim; }. Int_t GetRowT0(); Getters for internal variables. {return fRowT0;}. Int_t GetCrossNode(); {return fCrossNode;}. Int_t GetOffset(); {return fOffset;}. Index* GetIndPoints(); {return fIndPoints;}. Index GetBucketSize(); {return fBucketSize;}. Bool_t IsTerminal(int inode) const; {return (inode>=fNNodes);}. Int_t IsOwner(); { return fDataOwner; }. void SetOwner(Int_t owner); { fDataOwner = owner; }. TKDTree<Index, Value>& operator=(const TKDTree<int,float>& ). » Last changed: Sat Mar 14 16:42:48 2015 » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:3470,Performance,optimiz,optimized,3470,"is method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtre",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:6557,Performance,optimiz,optimized,6557," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:8722,Performance,perform,performed,8722,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:21803,Performance,perform,performed,21803,"of the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, float** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, float* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, float* a, int* index, float& min, float& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, float* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(float* range = 0x0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value>",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:7097,Security,access,access,7097,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:2861,Usability,simpl,simple,2861,"-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tre",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKDTree_int_float_.html:4115,Usability,simpl,simplify,4115,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html534/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKDTree_int_float_.html
https://root.cern/root/html534/TKey.html:897,Availability,redundant,redundant,897,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TStrin",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:3107,Availability,error,error,3107," const char* name, Int_t bufsize, TDirectory* motherDir = 0); virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*GetBufferRef() const; virtual const char*GetClassName() const; Short_tGetCycle() const; const TDatime&GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*GetIconName() const; Short_tGetKeep() const; Int_tGetKeylen() const; TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetObjlen() const; virtual Option_t*",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:3191,Availability,error,error,3191,"bject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*GetBufferRef() const; virtual const char*GetClassName() const; Short_tGetCycle() const; const TDatime&GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*GetIconName() const; Short_tGetKeep() const; Int_tGetKeylen() const; TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetObjlen() const; virtual Option_t*TObject::GetOption() const; virtual Long64_tGetSeekKey() const; virtual Long64_tGetS",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:17191,Availability,error,error,17191," The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& ); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fV",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:17407,Availability,error,error,17407,"ituation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& ); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fVersion;}. Long64_t GetSeekKey() const; {return fSeekKey;}. Long64_t GetSeekPdir() const; {return fSeekPdir;}. void SetBuffer(); { fBuffer = new char[fNbytes];}. void SetMotherDir(TDirectory* dir); { fMotherDir = dir;",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:11411,Energy Efficiency,allocate,allocated,11411,"ion parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You still have to call ""delete key"".; This is different from the behaviour of TObject::Delete()!. void DeleteBuffer(); Delete key buffer(s). Short_t GetCycle() const; Return cycle number associated to this key. TFile * GetFile() const; Returns file to which key belong. Short_t GetKeep() const; Returns the ""KEEP"" status. void FillBuffer(char*& buffer); Encode key header into output buffer. ULong_t Hash() const; This Hash function should redefine the default from TNamed. void IncrementPidOffset(UShort_t offset); Increment fPidOffset by 'offset'.; This offset is used when a key (or basket) is transfered from one file to; the other. In this case the TRef and TObject might have stored a pid; index (to retrieve TProcessIDs) which refered to their order on the; origin",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:13604,Modifiability,inherit,inheritance,13604,"o for new key/basket. Bool_t IsFolder() const; Check if object referenced by the key is a folder. void Keep(); Set the ""KEEP"" status.; When the KEEP flag is set to 1 the object cannot be purged. void ls(Option_t* option = """") const; List Key contents. void Print(Option_t* option = """") const; Print key contents. TObject * ReadObj(); To read a TObject* from the file. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass ",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:13981,Modifiability,inherit,inheritance,13981," The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. v",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:15411,Modifiability,inherit,inherits,15411,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:13863,Performance,perform,performance,13863," The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. v",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:897,Safety,redund,redundant,897,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TStrin",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:9744,Safety,avoid,avoid,9744," pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir,",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:10047,Safety,avoid,avoid,10047,"ncludes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); Copy a TKey from its original directory to the new 'motherDir'. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If obj",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:10315,Safety,avoid,avoid,10315,"(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, ",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:10617,Safety,avoid,avoid,10617,"irectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You s",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:15478,Safety,safe,safely,15478,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:954,Security,integrity,integrity,954,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(TDirectory* motherDir, const TKey& orig, UShort_t pidOffset); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TStrin",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKey.html:13667,Usability,simpl,simplified,13667," object cannot be purged. void ls(Option_t* option = """") const; List Key contents. void Print(Option_t* option = """") const; Print key contents. TObject * ReadObj(); To read a TObject* from the file. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Use TKey::ReadObjectAny to read any object non-derived from TObject. Note:; A C style cast can only be used in the case where the final class; of this object derives from TObject as a first inheritance, otherwise; one must use a dynamic_cast. Example1: simplified case:; class MyClass : public TObject, public AnotherClass; then on return, one get away with using:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like:; class MyClass : public AnotherClass, public TObject. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only i",MatchSource.WIKI,root/html534/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKey.html
https://root.cern/root/html534/TKeyMapFile.html:1695,Availability,error,error,1695,"MapFile(const char* name, const char* classname, TMapFile* mapfile); virtual~TKeyMapFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/TKeyMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyMapFile.html
https://root.cern/root/html534/TKeyMapFile.html:1779,Availability,error,error,1779,"File(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/TKeyMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyMapFile.html
https://root.cern/root/html534/TKeySQL.html:1777,Availability,error,error,1777,"r* keydatetime, Int_t cycle, const char* classname); virtual~TKeySQL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Long64_tGetDBDirId() const; Long64_tGetDBKeyId() const; Long64_tGetDBObjId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtua",MatchSource.WIKI,root/html534/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeySQL.html
https://root.cern/root/html534/TKeySQL.html:1861,Availability,error,error,1861,":AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Long64_tGetDBDirId() const; Long64_tGetDBKeyId() const; Long64_tGetDBObjId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetOb",MatchSource.WIKI,root/html534/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeySQL.html
https://root.cern/root/html534/TKeySQL.html:9928,Availability,error,error,9928,"st char* classname); Create TKeySQL object, which correponds to single entry in keys table. ~TKeySQL(); TKeySQL destructor. Bool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type from SQL database. void* ReadKeyObject(void* obj, const TClass* expectedClass); Read object, associated with key, from database. TKeySQL(const TKeySQL& ). TKeySQL& operator=(const TKeySQL& ). Int_t Read(const char* name); { return TKey::Read(name); }. Long64_t GetDBKeyId() const; { return fKeyId; }. Long64_t GetDBObjId() const; { return fObjId; }. void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return GetDBObjId() > 0 ? GetDBObjId() : 0; }. Long64_t GetSeekPdir() const; { return GetDBDirId() > 0 ? GetDBDirId() : 0; }. void Keep(); {}. void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t W",MatchSource.WIKI,root/html534/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeySQL.html
https://root.cern/root/html534/TKeySQL.html:10066,Availability,error,error,10066,"ool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type from SQL database. void* ReadKeyObject(void* obj, const TClass* expectedClass); Read object, associated with key, from database. TKeySQL(const TKeySQL& ). TKeySQL& operator=(const TKeySQL& ). Int_t Read(const char* name); { return TKey::Read(name); }. Long64_t GetDBKeyId() const; { return fKeyId; }. Long64_t GetDBObjId() const; { return fObjId; }. void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return GetDBObjId() > 0 ? GetDBObjId() : 0; }. Long64_t GetSeekPdir() const; { return GetDBDirId() > 0 ? GetDBDirId() : 0; }. void Keep(); {}. void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t WriteFile(Int_t = 1, TFile* = 0); { return 0; }. » Author: Sergey Linev 20/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fo",MatchSource.WIKI,root/html534/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeySQL.html
https://root.cern/root/html534/TKeySQL.html:9292,Deployability,update,updated,9292,"64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKeySQL(); default constructor. TKeySQL(TDirectory* mother, const TObject* obj, const char* name, const char* title = 0); Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. TKeySQL(TDirectory* mother, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. TKeySQL(TDirectory* mother, Long64_t keyid, Long64_t objid, const char* name, const char* title, const char* keydatetime, Int_t cycle, const char* classname); Create TKeySQL object, which correponds to single entry in keys table. ~TKeySQL(); TKeySQL destructor. Bool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type",MatchSource.WIKI,root/html534/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeySQL.html
https://root.cern/root/html534/TKeyXML.html:1707,Availability,error,error,1707,"Class* cl, const char* name, const char* title = 0); virtual~TKeyXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Long64_tGetKeyId() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; s",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKeyXML.html:1791,Availability,error,error,1791,":AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Long64_tGetKeyId() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKeyXML.html:9755,Availability,error,error,9755,"es TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return fKeyNode ? 1024 : 0;}. Long64_t GetSeekPdir() const; virtual ULong_t Hash() const { return 0; }. { return fKeyNode ? 1024 : 0;}. void Keep(); virtual void ls(Option_t* ="""") const;; virtual void Print(Option_t* ="""") const {}. {}. Int_t Read(TObject* tobj). void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. ",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKeyXML.html:9903,Availability,error,error,9903,"ML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return fKeyNode ? 1024 : 0;}. Long64_t GetSeekPdir() const; virtual ULong_t Hash() const { return 0; }. { return fKeyNode ? 1024 : 0;}. void Keep(); virtual void ls(Option_t* ="""") const;; virtual void Print(Option_t* ="""") const {}. {}. Int_t Read(TObject* tobj). void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t WriteFile(Int_t = 1, TFile* = 0); { return 0; }. XMLNodePointer_t KeyNode() const; TKeyXML sp",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKeyXML.html:9300,Deployability,update,update,9300,"rts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKeyXML.html:9368,Deployability,update,updates,9368," TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKeyXML.html:9429,Deployability,update,update,9429," TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return",MatchSource.WIKI,root/html534/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKeyXML.html
https://root.cern/root/html534/TKSocket.html:1467,Availability,error,error,1467,"tion = """"); Int_tBlockRead(char*& buf, TKSocket::EEncoding& type); Int_tBlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TKSocket*Connect(const char* server, Int_t port); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKSocket.html
https://root.cern/root/html534/TKSocket.html:1551,Availability,error,error,1551,"onst char* buf, Int_t len, TKSocket::EEncoding type); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TKSocket*Connect(const char* server, Int_t port); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKSocket.html
https://root.cern/root/html534/TKSocket.html:6008,Availability,error,error,6008,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKSocket.html
https://root.cern/root/html534/TKSocket.html:5490,Performance,cache,cache,5490,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKSocket.html
https://root.cern/root/html534/TKSocket.html:5357,Security,authenticat,authentication,5357,"or(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0). » Last changed: root/krb5auth:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TKSocket.html
https://root.cern/root/html534/TLatex.html:4177,Availability,down,downarrow,4177,"q"") ; Tl.DrawText(x2, y, ""#leq"");; y -= step ; Tl.DrawLatex(x1, y, ""#approx"") ; Tl.DrawText(x2, y, ""#approx"");; y -= step ; Tl.DrawLatex(x1, y, ""#in"") ; Tl.DrawText(x2, y, ""#in"");; y -= step ; Tl.DrawLatex(x1, y, ""#supset"") ; Tl.DrawText(x2, y, ""#supset"");; y -= step ; Tl.DrawLatex(x1, y, ""#cap"") ; Tl.DrawText(x2, y, ""#cap"");; y -= step ; Tl.DrawLatex(x1, y, ""#ocopyright"") ; Tl.DrawText(x2, y, ""#ocopyright"");; y -= step ; Tl.DrawLatex(x1, y, ""#trademark"") ; Tl.DrawText(x2, y, ""#trademark"");; y -= step ; Tl.DrawLatex(x1, y, ""#times"") ; Tl.DrawText(x2, y, ""#times"");; y -= step ; Tl.DrawLatex(x1, y, ""#bullet"") ; Tl.DrawText(x2, y, ""#bullet"");; y -= step ; Tl.DrawLatex(x1, y, ""#voidb"") ; Tl.DrawText(x2, y, ""#voidb"");; y -= step ; Tl.DrawLatex(x1, y, ""#doublequote"") ; Tl.DrawText(x2, y, ""#doublequote"");; y -= step ; Tl.DrawLatex(x1, y, ""#lbar"") ; Tl.DrawText(x2, y, ""#lbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbottom"") ; Tl.DrawText(x2, y, ""#arcbottom"");; y -= step ; Tl.DrawLatex(x1, y, ""#downarrow"") ; Tl.DrawText(x2, y, ""#downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#leftrightarrow"") ; Tl.DrawText(x2, y, ""#leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Downarrow"") ; Tl.DrawText(x2, y, ""#Downarrow"");. // Draw Second Column; y = 0.96; x1 = 0.22; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#Leftrightarrow"") ; Tl.DrawText(x2, y, ""#Leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#void8"") ; Tl.DrawText(x2, y, ""#void8"");; y -= step ; Tl.DrawLatex(x1, y, ""#hbar"") ; Tl.DrawText(x2, y, ""#hbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#diamond"") ; Tl.DrawText(x2, y, ""#diamond"");; y -= step ; Tl.DrawLatex(x1, y, ""#aleph"") ; Tl.DrawText(x2, y, ""#aleph"");; y -= step ; Tl.DrawLatex(x1, y, ""#geq"") ; Tl.DrawText(x2, y, ""#geq"");; y -= step ; Tl.DrawLatex(x1, y, ""#neq"") ; Tl.DrawText(x2, y, ""#neq"");; y -= step ; Tl.DrawLatex(x1, y, ""#notin"") ; Tl.DrawText(x2, y, ""#notin"");; y -= step ; Tl.DrawLatex(x1, y, ""#subseteq"") ; Tl.DrawText(x2, y, ""#subseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:4212,Availability,down,downarrow,4212,"tep ; Tl.DrawLatex(x1, y, ""#approx"") ; Tl.DrawText(x2, y, ""#approx"");; y -= step ; Tl.DrawLatex(x1, y, ""#in"") ; Tl.DrawText(x2, y, ""#in"");; y -= step ; Tl.DrawLatex(x1, y, ""#supset"") ; Tl.DrawText(x2, y, ""#supset"");; y -= step ; Tl.DrawLatex(x1, y, ""#cap"") ; Tl.DrawText(x2, y, ""#cap"");; y -= step ; Tl.DrawLatex(x1, y, ""#ocopyright"") ; Tl.DrawText(x2, y, ""#ocopyright"");; y -= step ; Tl.DrawLatex(x1, y, ""#trademark"") ; Tl.DrawText(x2, y, ""#trademark"");; y -= step ; Tl.DrawLatex(x1, y, ""#times"") ; Tl.DrawText(x2, y, ""#times"");; y -= step ; Tl.DrawLatex(x1, y, ""#bullet"") ; Tl.DrawText(x2, y, ""#bullet"");; y -= step ; Tl.DrawLatex(x1, y, ""#voidb"") ; Tl.DrawText(x2, y, ""#voidb"");; y -= step ; Tl.DrawLatex(x1, y, ""#doublequote"") ; Tl.DrawText(x2, y, ""#doublequote"");; y -= step ; Tl.DrawLatex(x1, y, ""#lbar"") ; Tl.DrawText(x2, y, ""#lbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbottom"") ; Tl.DrawText(x2, y, ""#arcbottom"");; y -= step ; Tl.DrawLatex(x1, y, ""#downarrow"") ; Tl.DrawText(x2, y, ""#downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#leftrightarrow"") ; Tl.DrawText(x2, y, ""#leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Downarrow"") ; Tl.DrawText(x2, y, ""#Downarrow"");. // Draw Second Column; y = 0.96; x1 = 0.22; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#Leftrightarrow"") ; Tl.DrawText(x2, y, ""#Leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#void8"") ; Tl.DrawText(x2, y, ""#void8"");; y -= step ; Tl.DrawLatex(x1, y, ""#hbar"") ; Tl.DrawText(x2, y, ""#hbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#diamond"") ; Tl.DrawText(x2, y, ""#diamond"");; y -= step ; Tl.DrawLatex(x1, y, ""#aleph"") ; Tl.DrawText(x2, y, ""#aleph"");; y -= step ; Tl.DrawLatex(x1, y, ""#geq"") ; Tl.DrawText(x2, y, ""#geq"");; y -= step ; Tl.DrawLatex(x1, y, ""#neq"") ; Tl.DrawText(x2, y, ""#neq"");; y -= step ; Tl.DrawLatex(x1, y, ""#notin"") ; Tl.DrawText(x2, y, ""#notin"");; y -= step ; Tl.DrawLatex(x1, y, ""#subseteq"") ; Tl.DrawText(x2, y, ""#subseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#cup"") ; Tl.DrawText(x2, y, ""#cup"");; y -= ",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:7381,Availability,down,downleftarrow,7381,"DrawText(x2, y, ""#heart"");; y -= step ; Tl.DrawLatex(x1, y, ""#Jgothic"") ; Tl.DrawText(x2, y, ""#Jgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#LT"") ; Tl.DrawText(x2, y, ""#LT"");; y -= step ; Tl.DrawLatex(x1, y, ""#equiv"") ; Tl.DrawText(x2, y, ""#equiv"");; y -= step ; Tl.DrawLatex(x1, y, ""#subset"") ; Tl.DrawText(x2, y, ""#subset"");; y -= step ; Tl.DrawLatex(x1, y, ""#supseteq"") ; Tl.DrawText(x2, y, ""#supseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#wedge"") ; Tl.DrawText(x2, y, ""#wedge"");; y -= step ; Tl.DrawLatex(x1, y, ""#oright"") ; Tl.DrawText(x2, y, ""#oright"");; y -= step ; Tl.DrawLatex(x1, y, ""#AA"") ; Tl.DrawText(x2, y, ""#AA"");; y -= step ; Tl.DrawLatex(x1, y, ""#pm"") ; Tl.DrawText(x2, y, ""#pm"");; y -= step ; Tl.DrawLatex(x1, y, ""#mp"") ; Tl.DrawText(x2, y, ""#mp"");; y -= step ; Tl.DrawLatex(x1, y, ""#3dots"") ; Tl.DrawText(x2, y, ""#3dots"");. // Draw Fourth Column; y = 0.96; x1 = 0.62; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#nabla"") ; Tl.DrawText(x2, y, ""#nabla"");; y -= step ; Tl.DrawLatex(x1, y, ""#downleftarrow"") ; Tl.DrawText(x2, y, ""#downleftarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#topbar"") ; Tl.DrawText(x2, y, ""#topbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbar"") ; Tl.DrawText(x2, y, ""#arcbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#uparrow"") ; Tl.DrawText(x2, y, ""#uparrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#oplus"") ; Tl.DrawText(x2, y, ""#oplus"");; y -= step ; Tl.DrawLatex(x1, y, ""#Uparrow"") ; Tl.DrawText(x2, y, ""#Uparrow"");; y -= step ; Tl.DrawLatex(x1, y-0.01, ""#sum"") ; Tl.DrawText(x2, y, ""#sum"");; y -= step ; Tl.DrawLatex(x1, y, ""#perp"") ; Tl.DrawText(x2, y, ""#perp"");; y -= step ; Tl.DrawLatex(x1, y, ""#forall"") ; Tl.DrawText(x2, y, ""#forall"");; y -= step ; Tl.DrawLatex(x1, y, ""#spade"") ; Tl.DrawText(x2, y, ""#spade"");; y -= step ; Tl.DrawLatex(x1, y, ""#Rgothic"") ; Tl.DrawText(x2, y, ""#Rgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#GT"") ; Tl.DrawText(x2, y, ""#GT"");; y -= step ; Tl.DrawLatex(x1, y, ""#propto"") ; Tl.DrawText(x2, y, ""#propto"");; y -= step ; Tl.DrawLatex(x1, y,",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:7420,Availability,down,downleftarrow,7420,"awLatex(x1, y, ""#Jgothic"") ; Tl.DrawText(x2, y, ""#Jgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#LT"") ; Tl.DrawText(x2, y, ""#LT"");; y -= step ; Tl.DrawLatex(x1, y, ""#equiv"") ; Tl.DrawText(x2, y, ""#equiv"");; y -= step ; Tl.DrawLatex(x1, y, ""#subset"") ; Tl.DrawText(x2, y, ""#subset"");; y -= step ; Tl.DrawLatex(x1, y, ""#supseteq"") ; Tl.DrawText(x2, y, ""#supseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#wedge"") ; Tl.DrawText(x2, y, ""#wedge"");; y -= step ; Tl.DrawLatex(x1, y, ""#oright"") ; Tl.DrawText(x2, y, ""#oright"");; y -= step ; Tl.DrawLatex(x1, y, ""#AA"") ; Tl.DrawText(x2, y, ""#AA"");; y -= step ; Tl.DrawLatex(x1, y, ""#pm"") ; Tl.DrawText(x2, y, ""#pm"");; y -= step ; Tl.DrawLatex(x1, y, ""#mp"") ; Tl.DrawText(x2, y, ""#mp"");; y -= step ; Tl.DrawLatex(x1, y, ""#3dots"") ; Tl.DrawText(x2, y, ""#3dots"");. // Draw Fourth Column; y = 0.96; x1 = 0.62; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#nabla"") ; Tl.DrawText(x2, y, ""#nabla"");; y -= step ; Tl.DrawLatex(x1, y, ""#downleftarrow"") ; Tl.DrawText(x2, y, ""#downleftarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#topbar"") ; Tl.DrawText(x2, y, ""#topbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbar"") ; Tl.DrawText(x2, y, ""#arcbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#uparrow"") ; Tl.DrawText(x2, y, ""#uparrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#oplus"") ; Tl.DrawText(x2, y, ""#oplus"");; y -= step ; Tl.DrawLatex(x1, y, ""#Uparrow"") ; Tl.DrawText(x2, y, ""#Uparrow"");; y -= step ; Tl.DrawLatex(x1, y-0.01, ""#sum"") ; Tl.DrawText(x2, y, ""#sum"");; y -= step ; Tl.DrawLatex(x1, y, ""#perp"") ; Tl.DrawText(x2, y, ""#perp"");; y -= step ; Tl.DrawLatex(x1, y, ""#forall"") ; Tl.DrawText(x2, y, ""#forall"");; y -= step ; Tl.DrawLatex(x1, y, ""#spade"") ; Tl.DrawText(x2, y, ""#spade"");; y -= step ; Tl.DrawLatex(x1, y, ""#Rgothic"") ; Tl.DrawText(x2, y, ""#Rgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#GT"") ; Tl.DrawText(x2, y, ""#GT"");; y -= step ; Tl.DrawLatex(x1, y, ""#propto"") ; Tl.DrawText(x2, y, ""#propto"");; y -= step ; Tl.DrawLatex(x1, y, ""#notsubset"") ; Tl.DrawText(x2, y, ""#notsubse",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:15404,Availability,avail,available,15404,"au"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Upsilon : "") ; Tl.DrawLatex(x2, y, ""#Upsilon"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Phi : "") ; Tl.DrawLatex(x2, y, ""#Phi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Chi : "") ; Tl.DrawLatex(x2, y, ""#Chi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Psi : "") ; Tl.DrawLatex(x2, y, ""#Psi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Omega : "") ; Tl.DrawLatex(x2, y, ""#Omega"");. // Draw the variations; x1 = 0.73; x2 = x1+0.2;; y = 0.7500 ; Tl.DrawLatex(x1, y, ""varepsilon : "") ; Tl.DrawLatex(x2, y, ""#varepsilon"");; y = 0.6375 ; Tl.DrawLatex(x1, y, ""vartheta : "") ; Tl.DrawLatex(x2, y, ""#vartheta"");; y = 0.2625 ; Tl.DrawLatex(x1, y, ""varsigma : "") ; Tl.DrawLatex(x2, y, ""#varsigma"");; y = 0.1875 ; Tl.DrawLatex(x1, y, ""varUpsilon : "") ; Tl.DrawLatex(x2, y, ""#varUpsilon"");; y = 0.1500 ; Tl.DrawLatex(x1, y, ""varphi : "") ; Tl.DrawLatex(x2, y, ""#varphi"");; y = 0.0375 ; Tl.DrawLatex(x1, y, ""varomega : "") ; Tl.DrawLatex(x2, y, ""#varomega"");. return Gl;; }. Accents; Several kind of accents are available:. #hat = ; #check = ; #acute = ; #grave = ; #dot = ; #ddot = ; #tilde = . The special sign: #slash draws a slash on top of the text between brackets:. #slash{E}_{T} : . Bar and vectors sign are done the following way:. #bar{a}: ; #vec{a}: . Changing Style; One can change the font, the text color, or the text size at any time using :; #font[font-number]{...}, #color[color-number]{...}; and #scale[scale-factor]{...}; Examples:. #font[12]{Times Italic} and #font[22]{Times bold} : ; #color[2]{Red} and #color[4]{Blue} : ; #scale[1.2]{Bigger} and #scale[0.8]{Smaller} : . Alignment Rules; The TText alignment rules apply to the TLatex objects with one exception; concerning the vertical alignment:. if the vertical alignment = 1 , subscripts are not taken into account ; if the vertical alignment = 0 , the text is aligned to the box surrounding; the full text with sub and superscripts. This is illustrated by the following example:. Picture; Source. {; TCanvas Tlva(""Tlva"",""T",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:17752,Availability,down,down,17752,"awLatex(.2,.9,""K_{S}"");; latex.DrawLatex(.3,.9,""K^{*0}"");; latex.DrawLatex(.2,.8,longstring);. latex.SetTextAlign(12); //centered; latex.DrawLatex(.2,.6,""K_{S}"");; latex.DrawLatex(.3,.6,""K^{*0}"");; latex.DrawLatex(.2,.5,longstring);. latex.SetTextAlign(11); //default bottom alignment; latex.DrawLatex(.2,.4,""K_{S}"");; latex.DrawLatex(.3,.4,""K^{*0}"");; latex.DrawLatex(.2,.3,longstring);. latex.SetTextAlign(10); //special bottom alignment; latex.DrawLatex(.2,.2,""K_{S}"");; latex.DrawLatex(.3,.2,""K^{*0}"");; latex.DrawLatex(.2,.1,longstring);. latex.SetTextAlign(12);; latex.SetTextFont(72);; latex.DrawLatex(.1,.80,""13"");; latex.DrawLatex(.1,.55,""12"");; latex.DrawLatex(.1,.35,""11"");; latex.DrawLatex(.1,.18,""10"");; return Tlva;; }. Character Adjustement; The two commands #kern and #lower enable a better control; over character placement. The command #kern[(Float_t)dx]{text} moves; the output string horizontally by the fraction dx of its length.; Similarly, #lower[(Float_t)dy]{text} shifts the text up or down by; the fraction dy of its height.; Examples:. Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g}:. Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g}:. Vertical a#lower[0.2]{d}#lower[0.4]{j}#lower[0.1]{u}#lower[-0.1]{s}#lower[-0.3]{t}#lower[-0.4]{m}#lower[-0.2]{e}#lower[0.1]{n}t:. Italic and Boldface; Text can be turned italic or boldface using the commands; #it and #bf.; Examples:. #bf{bold}, #it{italic}, #bf{#it{bold italic}}, #bf{#bf{unbold}}}:. abc#alpha#beta#gamma, #it{abc#alpha#beta#gamma}:. Examples. Picture; Source. {; TCanvas ex1(""ex1"",""Latex"",500,600);; TLatex Tl;; Tl.SetTextAlign(12);; Tl.SetTextSize(0.04);; Tl.DrawLatex(0.1,0.8,""1) C(x) = d #sqrt{#frac{2}{#lambdaD}} #int^{x}_{0}cos(#frac{#pi}{2}t^{2})dt"");; Tl.DrawLatex(0.1,0.6,""2) C(x) = d #sqrt{#frac{2}{#lambdaD}} #int^{x}cos(#frac{#pi}{2}t^{2})dt"");; Tl.DrawLatex(0.1,0.4,""3) R = |A|^{2} = #frac{1}{2}(#[]{#frac{1}{2}+C(V)}^{",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:21885,Availability,error,error,21885,"idTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TLatex*DrawLatex(Double_t x, Double_t y, const char* text); TLatex*DrawLatexNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetHeight() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtu",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:21969,Availability,error,error,21969,"x, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TLatex*DrawLatex(Double_t x, Double_t y, const char* text); TLatex*DrawLatexNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetHeight() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetO",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:30323,Availability,error,error,30323,"tex1(Double_t x, Double_t y, Double_t angle, Double_t size, const char* text); TLatexFormSizeReadfs(); voidSavefs(TLatexFormSize* fs). Data Members; public:. enum { kTextNDC; };; enum TText::[unnamed] { kTextNDC; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const Char_t*fError!error code; Double_tfFactorPos!Relative position of subscripts and superscripts; Double_tfFactorSize!Relative size of subscripts and superscripts; Bool_tfItalic!Currently inside #it operator; Int_tfLimitFactorSizelower bound for subscripts/superscripts size; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Double_tfOriginSizeFont size of the starting font; Int_tfPos!Current position in array fTabSize;; Bool_tfShow!is true during the second pass (Painting); Int_tfTabMax!Maximum allocation for array fTabSize;; FormSize_t*fTabSize!array of values for the different zones; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; void*TText::fWcsTitle!Used by TMathText; Double_tTText::fXX position of text (left,center,etc..); Double_tTText::fYY position of text (left,center,etc..). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLatex(); Default constructor. TLatex(Double_t x, Double_t y, const char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpe",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:32460,Availability,down,down,32460,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. TLatex * DrawLatexNDC(Double_t x, Double_t y, const char* text); Draw this TLatex with new coordinates in NDC. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (rig",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:32615,Availability,down,down,32615,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. TLatex * DrawLatexNDC(Double_t x, Double_t y, const char* text); Draw this TLatex with new coordinates in NDC. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (rig",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLatex.html:32760,Availability,down,down,32760,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. TLatex * DrawLatexNDC(Double_t x, Double_t y, const char* text); Draw this TLatex with new coordinates in NDC. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (rig",MatchSource.WIKI,root/html534/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLatex.html
https://root.cern/root/html534/TLeaf.html:1387,Availability,error,error,1387," TLeaf(); TLeaf(TBranch* parent, const char* name, const char* type); virtual~TLeaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const ",MatchSource.WIKI,root/html534/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeaf.html
https://root.cern/root/html534/TLeaf.html:1471,Availability,error,error,1471,"Leaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeafCount() const; virtual TLeaf*GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tGetLenStatic() const; virtual Int_tGetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual I",MatchSource.WIKI,root/html534/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeaf.html
https://root.cern/root/html534/TLeaf.html:8763,Integrability,rout,routine,8763,"ent of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the pointer to; the leaf named nelem, otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; return countval = nelem and a null pointer.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]; where nelem and nelem2 are non-negative integers) then; return countval = product of all dimension sizes and a null pointer.; If leaf name has the form var[... (and does not match the previous 2; cases) return countval = -1 and null pointer;; Otherwise return countval = 1 and a null pointer. Int_t GetLen() const; -- Return the number of effective elements of this leaf. Int_t ResetAddress(void* add, Bool_t destructor = kFALSE); -- Helper routine for TLeafX::SetAddress. The return value is non-zero if we owned the old; value buffer and must delete it now. The size; of the value buffer is recalculated and stored,; and a decision is made whether or not we own the; new value buffer. void SetLeafCount(TLeaf* leaf); -- Set the leaf count of this leaf. void Streamer(TBuffer& ); -- Stream a class object. Double_t GetValue(Int_t i = 0) const; { return 0.0; }. void PrintValue(Int_t i = 0) const; {}. void SetAddress(void* add = 0); {}. void Export(TClonesArray* , Int_t ); {}. TBranch * GetBranch() const; { return fBranch; }. TLeaf * GetLeafCount() const; { return fLeafCount; }. Int_t GetLenStatic() const; { return fLen; }. Int_t GetLenType() const; { return fLenType; }. Int_t GetMaximum() const; { return 0; }. Int_t GetMinimum() const; { return 0; }. Int_t GetNdata() const; { return fNdata; }. Int_t GetOffset() const; { return fOffset; }. void * GetValuePointer() const; { return 0; }. const char * GetTypeName()",MatchSource.WIKI,root/html534/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeaf.html
https://root.cern/root/html534/TLeaf.html:7020,Modifiability,variab,variable,7020,"onst char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TLeaf(const TLeaf&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&operator=(const TLeaf&). Data Members; public:. enum { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*fBranch! Pointer to supporting branch (we do not own the branch); Bool_tfIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tfIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tfLenNumber of fixed length elements; Int_tfLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tfNdata! Number of elements in fAddress data buffer; Int_tfOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeaf(). TLeaf(TBranch* parent, const char* name, const char* type); Create a Leaf. See the TTree and TBranch constructors for explanation of parameters. TLeaf(const TLeaf& ); copy constructor. TLeaf& operator=(const TLeaf& ); assignment operator. ~TLeaf(); -- Destructor. void Browse(TBrowser* b); Browse the content of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the poi",MatchSource.WIKI,root/html534/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeaf.html
https://root.cern/root/html534/TLeafB.html:1378,Availability,error,error,1378,"fB&); TLeafB(TBranch* parent, const char* name, const char* type); virtual~TLeafB(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafB.html
https://root.cern/root/html534/TLeafB.html:1462,Availability,error,error,1462," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html534/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafB.html
https://root.cern/root/html534/TLeafB.html:7284,Modifiability,variab,variable,7284,"t::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Char_tfMaximumMaximum value if leaf range is specified; Char_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Char_t**fPointer!Address of a pointer to data buffer!; TStringTNamed::fTitleobject title; Char_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafB(); -- Default constructor. TLeafB(TBranch* parent, const char* name, const char* type); -- Create a LeafB. ~TLeafB(); -- Destructor. void Export(TClonesArray* list, Int_t n); -- Export element from local leaf buffer to a ClonesArray. void FillBasket(TBuffer& b); -- Pack leaf elements into Basket output buffer. const char * GetTypeName() const; -- Returns name of leaf type. void Import(TClonesArray* list, Int_t n); -- Import element from ClonesArray into local leaf buffer. void PrintValue(In",MatchSource.WIKI,root/html534/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafB.html
https://root.cern/root/html534/TLeafC.html:1376,Availability,error,error,1376,"fC&); TLeafC(TBranch* parent, const char* name, const char* type); virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafC.html
https://root.cern/root/html534/TLeafC.html:1460,Availability,error,error,1460," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html534/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafC.html
https://root.cern/root/html534/TLeafC.html:291,Modifiability,variab,variable,291,". TLeafC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TLeafC. class TLeafC: public TLeaf. A TLeaf for a variable length string. Function Members (Methods); public:. TLeafC(); TLeafC(const TLeafC&); TLeafC(TBranch* parent, const char* name, const char* type); virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual con",MatchSource.WIKI,root/html534/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafC.html
https://root.cern/root/html534/TLeafC.html:7312,Modifiability,variab,variable,7312,"ect::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Int_tfMaximumMaximum value if leaf range is specified; Int_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Char_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Char_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafC(); Default constructor for LeafC*-*-*-*-*-*-*-*-; *-* ============================. TLeafC(TBranch* parent, const char* name, const char* type); Create a LeafC*-*-; *-* ==============; -. ~TLeafC(); Default destructor for a LeafC*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Ba",MatchSource.WIKI,root/html534/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafC.html
https://root.cern/root/html534/TLeafD.html:1385,Availability,error,error,1385,"fD&); TLeafD(TBranch* parent, const char* name, const char* type); virtual~TLeafD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html534/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafD.html
https://root.cern/root/html534/TLeafD.html:1469,Availability,error,error,1469," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html534/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafD.html
https://root.cern/root/html534/TLeafD.html:7236,Modifiability,variab,variable,7236,"Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Double_tfMaximumMaximum value if leaf range is specified; Double_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Double_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Double_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements ",MatchSource.WIKI,root/html534/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafD.html
https://root.cern/root/html534/TLeafD.html:9236,Usability,simpl,simple,9236,"fer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafD.html
https://root.cern/root/html534/TLeafElement.html:1501,Availability,error,error,1501,"nt(TBranch* parent, const char* name, Int_t id, Int_t type); virtual~TLeafElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; v",MatchSource.WIKI,root/html534/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafElement.html
https://root.cern/root/html534/TLeafElement.html:1585,Availability,error,error,1585," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdata() const; virtual ch",MatchSource.WIKI,root/html534/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafElement.html
https://root.cern/root/html534/TLeafElement.html:7445,Modifiability,variab,variable,7445,"option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fAbsAddress! Absolute leaf Address; TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Int_tfIDelement serial number in fInfo; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Int_tfTypeleaf type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafElement(); Default constructor for LeafObject. TLeafElement(TBranch* parent, const char* name, Int_t id, Int_t type); Create a LeafObject. ~TLeafElement(); Default destructor for a LeafObject. TMethodCall * GetMethodCall(const char* name); Returns pointer to method corresponding to name name is a string; with the general form ""method(list of params)"" If list of params is; omitted, () is assumed;. Bool_t IsOnTerminalBranch() const; Return true if this leaf is does not have any sub-branch/leaf. TLeafElement(). Int_t GetLen() const; {return ((TB",MatchSource.WIKI,root/html534/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafElement.html
https://root.cern/root/html534/TLeafF.html:1385,Availability,error,error,1385,"fF&); TLeafF(TBranch* parent, const char* name, const char* type); virtual~TLeafF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html534/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafF.html
https://root.cern/root/html534/TLeafF.html:1469,Availability,error,error,1469," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html534/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafF.html
https://root.cern/root/html534/TLeafF.html:7236,Modifiability,variab,variable,7236,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Float_tfMaximumMaximum value if leaf range is specified; Float_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Float_t**fPointer!Addresss of pointer to data buffer!; TStringTNamed::fTitleobject title; Float_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements i",MatchSource.WIKI,root/html534/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafF.html
https://root.cern/root/html534/TLeafF.html:9233,Usability,simpl,simple,9233,"uffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a float from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafF(). const char * GetTypeName() const; {return ""Float_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafF.html
https://root.cern/root/html534/TLeafI.html:1372,Availability,error,error,1372,"fI&); TLeafI(TBranch* parent, const char* name, const char* type); virtual~TLeafI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafI.html
https://root.cern/root/html534/TLeafI.html:1456,Availability,error,error,1456," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html534/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafI.html
https://root.cern/root/html534/TLeafI.html:7279,Modifiability,variab,variable,7279,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Int_tfMaximumMaximum value if leaf range is specified; Int_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in B",MatchSource.WIKI,root/html534/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafI.html
https://root.cern/root/html534/TLeafI.html:8669,Usability,simpl,simple,8669,"Array object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read an integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafI(). Int_t GetMaximum() const; {return fMaximum;}. Int_t GetMinimum() const; {return fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Int_t ma",MatchSource.WIKI,root/html534/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafI.html
https://root.cern/root/html534/TLeafL.html:1378,Availability,error,error,1378,"fL&); TLeafL(TBranch* parent, const char* name, const char* type); virtual~TLeafL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafL.html
https://root.cern/root/html534/TLeafL.html:1462,Availability,error,error,1462," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html534/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafL.html
https://root.cern/root/html534/TLeafL.html:7277,Modifiability,variab,variable,7277,"Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Long64_tfMaximumMaximum value if leaf range is specified; Long64_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf element",MatchSource.WIKI,root/html534/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafL.html
https://root.cern/root/html534/TLeafL.html:8679,Usability,simpl,simple,8679,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ======",MatchSource.WIKI,root/html534/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafL.html
https://root.cern/root/html534/TLeafL.html:8875,Usability,simpl,simple,8875,"s; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return",MatchSource.WIKI,root/html534/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafL.html
https://root.cern/root/html534/TLeafL.html:9768,Usability,simpl,simple,9768,"========================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. LongDouble_t GetValueLongDouble(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Long64_t GetValueLong64(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t max); {fMaximum = max;}. void SetMinimum(Long64_t min); {fMinimum = min;}. » Author: Rene Brun 19/12/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafL.html
https://root.cern/root/html534/TLeafO.html:1368,Availability,error,error,1368,"fO&); TLeafO(TBranch* parent, const char* name, const char* type); virtual~TLeafO(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafO.html
https://root.cern/root/html534/TLeafO.html:1452,Availability,error,error,1452," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html534/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafO.html
https://root.cern/root/html534/TLeafO.html:7277,Modifiability,variab,variable,7277,"t::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Bool_tfMaximumMaximum value if leaf range is specified; Bool_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Bool_t**fPointer!Address of a pointer to data buffer!; TStringTNamed::fTitleobject title; Bool_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafO(); Default constructor for LeafB*-*-*-*-*-*-*-*-; *-* ============================. TLeafO(TBranch* parent, const char* name, const char* type); Create a LeafB*-*-; *-* ==============; -. ~TLeafO(); Default destructor for a LeafB*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in ",MatchSource.WIKI,root/html534/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafO.html
https://root.cern/root/html534/TLeafObject.html:1429,Availability,error,error,1429,"fObject(TBranch* parent, const char* name, const char* type); virtual~TLeafObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual I",MatchSource.WIKI,root/html534/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafObject.html
https://root.cern/root/html534/TLeafObject.html:1513,Availability,error,error,1513," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafObject.html
https://root.cern/root/html534/TLeafObject.html:7488,Modifiability,variab,variable,7488,"ct::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum { kWarn; };; enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); TClassReffClass! pointer to class; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; void**fObjAddress! Address of Pointer to object; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Bool_tfVirtualSupport for polymorphism, when set classname is written with object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafObject(); Default constructor for LeafObject*-*-*-*-*-*-*-*-; *-* =================================. TLeafObject(TBranch* parent, const char* name, const char* type); Create a LeafObject*-*-; *-* ==================; -. ~TLeafObject(); Default destructor for a LeafObject*-*-*-*-*-*-; *-* ==================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. TMethodCall * GetMethodCall(const char* name); -*Returns pointer",MatchSource.WIKI,root/html534/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafObject.html
https://root.cern/root/html534/TLeafObject.html:7909,Modifiability,polymorphi,polymorphism,7909,"ct::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum { kWarn; };; enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); TClassReffClass! pointer to class; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; void**fObjAddress! Address of Pointer to object; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Bool_tfVirtualSupport for polymorphism, when set classname is written with object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafObject(); Default constructor for LeafObject*-*-*-*-*-*-*-*-; *-* =================================. TLeafObject(TBranch* parent, const char* name, const char* type); Create a LeafObject*-*-; *-* ==================; -. ~TLeafObject(); Default destructor for a LeafObject*-*-*-*-*-*-; *-* ==================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. TMethodCall * GetMethodCall(const char* name); -*Returns pointer",MatchSource.WIKI,root/html534/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafObject.html
https://root.cern/root/html534/TLeafS.html:1378,Availability,error,error,1378,"fS&); TLeafS(TBranch* parent, const char* name, const char* type); virtual~TLeafS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html534/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafS.html
https://root.cern/root/html534/TLeafS.html:1462,Availability,error,error,1462," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html534/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafS.html
https://root.cern/root/html534/TLeafS.html:7289,Modifiability,variab,variable,7289,"::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Short_tfMaximumMaximum value if leaf range is specified; Short_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Short_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Short_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafS(); Default constructor for LeafS*-*-*-*-*-*-*-*-; *-* ============================. TLeafS(TBranch* parent, const char* name, const char* type); Create a LeafS*-*-; *-* ==============; -. ~TLeafS(); Default destructor for a LeafS*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in",MatchSource.WIKI,root/html534/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafS.html
https://root.cern/root/html534/TLeafS.html:8686,Usability,simpl,simple,8686,"ay object (if one); Short_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Short_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafS(); Default constructor for LeafS*-*-*-*-*-*-*-*-; *-* ============================. TLeafS(TBranch* parent, const char* name, const char* type); Create a LeafS*-*-; *-* ==============; -. ~TLeafS(); Default destructor for a LeafS*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a integer integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafS(). Int_t GetMaximum() const; { return fMaximum; }. Int_t GetMinimum() const; { return fMinimum; }. void * GetValuePointer() const; {return fValue;}. void SetMaxim",MatchSource.WIKI,root/html534/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLeafS.html
https://root.cern/root/html534/TLegend.html:2226,Availability,error,error,2226," matching; name is found, the coresponding object is added in the legend using its pointer. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inh",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:3337,Availability,error,error,3337,"ith error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:6203,Availability,error,error,6203,"onvertNDCtoPad(); virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteEntry()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditEntryAttFill(); virtual voidEditEntryAttLine(); virtual voidEditEntryAttMarker(); virtual voidEditEntryAttText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Float_tGetColumnSeparation() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TLegendEntry*GetEntry() const; Float_tGetEntrySeparation() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetHeader() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLine",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:6287,Availability,error,error,6287,"Option_t* option = """")MENU ; virtual voidDeleteEntry()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditEntryAttFill(); virtual voidEditEntryAttLine(); virtual voidEditEntryAttMarker(); virtual voidEditEntryAttText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Float_tGetColumnSeparation() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TLegendEntry*GetEntry() const; Float_tGetEntrySeparation() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetHeader() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfPrimitives() const; Float_tGetMargin() const; virtual ",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:17533,Availability,error,error,17533,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:18154,Availability,error,error,18154,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:2284,Modifiability,inherit,inherits,2284,";. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: dra",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:3143,Modifiability,inherit,inherits,3143,"ith error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:3220,Modifiability,inherit,inherits,3220,"ith error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:3301,Modifiability,inherit,inherits,3301,"ith error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l"");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """");; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. It is possible to draw the legend entries over several columns using; the method SetNColumns() like in the following example. Picture; Source. {; TCanvas *c3 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg-> SetNColumns(2);. leg->AddEntry(h, ""Column",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:17339,Modifiability,inherit,inherits,17339,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:17416,Modifiability,inherit,inherits,17416,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:17497,Modifiability,inherit,inherits,17497,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:17960,Modifiability,inherit,inherits,17960,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:18037,Modifiability,inherit,inherits,18037,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:18118,Modifiability,inherit,inherits,18118,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:1001,Performance,perform,performed,1001,"dex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TLegend. class TLegend: public TPave, public TAttText. Legend class; This class displays a legend box (TPaveText) containing several legend entries.; Each legend entry is made of a reference to a ROOT object, a text label and an; option specifying which graphical attributes (marker/line/fill) should be; displayed. The following example shows how to create a legend. In this example the legend; contains a histogram, a function and a graph. The histogram is put in the legend; using its reference pointer whereas the graph and the function are added; using their names. Note that, because TGraph contructors do not have the; TGraph name as parameter, the graph name should be specified using the; SetName method. When an object is added by name, a scan is performed on the list of objects; contained in the current pad (gPad) and also in the possible; TMultiGraph and THStack present in the pad. If a matching; name is found, the coresponding object is added in the legend using its pointer. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeade",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegend.html:2592,Usability,simpl,simply,2592,"lue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }. TLegend inherits from TAttText therefore changing any; text attributes (text alignmemt, font, color...) on a legend will changed the; text attributes on each line. In particular it can be interessting to change the text alignement that way. In; order to have a base-line vertical alignment instead of a centered one simply do:. leg->SetTextAlign(13);. leg->SetTextAlign(11);. TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; le->SetTextColor(kBlue);;. Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2",MatchSource.WIKI,root/html534/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegend.html
https://root.cern/root/html534/TLegendEntry.html:1676,Availability,error,error,1676,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual TObject*GetObject() const; vir",MatchSource.WIKI,root/html534/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegendEntry.html
https://root.cern/root/html534/TLegendEntry.html:1760,Availability,error,error,1760,"* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html534/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegendEntry.html
https://root.cern/root/html534/TLegendEntry.html:9860,Modifiability,inherit,inherits,9860,"rker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TObject*fObjectpointer to object being represented by this entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void Se",MatchSource.WIKI,root/html534/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegendEntry.html
https://root.cern/root/html534/TLegendEntry.html:9930,Modifiability,inherit,inherits,9930,"is entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void SetOption(Option_t* option = ""lpf""); { fOption = option; }. TLegendEntry& operator=(const TLegendEntry& ). » Author: Matthew.Adam.Dob",MatchSource.WIKI,root/html534/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegendEntry.html
https://root.cern/root/html534/TLegendEntry.html:10009,Modifiability,inherit,inherits,10009,"is entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void SetOption(Option_t* option = ""lpf""); { fOption = option; }. TLegendEntry& operator=(const TLegendEntry& ). » Author: Matthew.Adam.Dob",MatchSource.WIKI,root/html534/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLegendEntry.html
https://root.cern/root/html534/TLibraryDocInfo.html:1451,Availability,error,error,1451,"Info(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; set<std::string>&GetModules(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Inf",MatchSource.WIKI,root/html534/TLibraryDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLibraryDocInfo.html
https://root.cern/root/html534/TLibraryDocInfo.html:1535,Availability,error,error,1535,"st string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; set<std::string>&GetModules(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom",MatchSource.WIKI,root/html534/TLibraryDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLibraryDocInfo.html
https://root.cern/root/html534/TLimit.html:748,Availability,avail,available,748,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector&); virtu",MatchSource.WIKI,root/html534/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimit.html
https://root.cern/root/html534/TLimit.html:303,Energy Efficiency,adapt,adapted,303,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector&); virtu",MatchSource.WIKI,root/html534/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimit.html
https://root.cern/root/html534/TLimit.html:2809,Integrability,wrap,wrapped,2809,"0000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. static boolFluctuate(TLimitDataSource* input, TLimitDataSource* output, bool init, TRandom*, bool stat = false); static Double_tLogLikelihood(Double_t s, Double_t b, Double_t b2, Double_t d). Data Members; private:. static TOrdCollection*fgSystNamesCollection of systematics names; static TArrayD*fgTablea log table... just to speed up calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");;",MatchSource.WIKI,root/html534/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimit.html
https://root.cern/root/html534/TLimit.html:303,Modifiability,adapt,adapted,303,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector&); virtu",MatchSource.WIKI,root/html534/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimit.html
https://root.cern/root/html534/TLimit.html:3546,Performance,perform,performed,3546,"mentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; cout << "" CLs : "" << myconfidence->CLs() << endl;; cout << "" CLsb : "" << myconfidence->CLsb() << endl;; cout << "" CLb : "" << myconfidence->CLb() << endl;; cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << endl;; cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << endl;; cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << endl;; delete myconfidence;; delete mydatasource;; infile->Clos",MatchSource.WIKI,root/html534/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimit.html
https://root.cern/root/html534/TLimit.html:2406,Testability,log,log,2406,", Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. static boolFluctuate(TLimitDataSource* input, TLimitDataSource* output, bool init, TRandom*, bool stat = false); static Double_tLogLikelihood(Double_t s, Double_t b, Double_t b2, Double_t d). Data Members; private:. static TOrdCollection*fgSystNamesCollection of systematics names; static TArrayD*fgTablea log table... just to speed up calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, ",MatchSource.WIKI,root/html534/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimit.html
https://root.cern/root/html534/TLimitDataSource.html:1642,Availability,error,error,1642," char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual ",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:1726,Availability,error,error,1726,"el(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:5938,Availability,error,error,5938,"tBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:5998,Availability,error,error,5998,"tBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:6066,Availability,error,error,6066,"tBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:6829,Availability,error,error,6829," (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bin has to be seen as; an error source (relative).; names is an array of strings containing the names of the sources.; Sources with the same name are correlated. void SetOwner(bool swtch = kTRUE); Gives to the TLimitDataSource the ownership of the various objects; given as input.; Objects are then deleted by the TLimitDataSource destructor. virtual ~TLimitDataSource(); {}. TObjArray* GetSignal(); { return &fSignal;}. TObjArray* GetBackground(); { return &fBackground;}. TObjArray* GetCandidates(); { return &fCandidates;}. TObjArray* GetErrorOnSignal(); { return &fErrorOnSignal;}. TObjArray* GetErrorOnBackground(); { return &fErrorOnBackground;}. TObjArray* GetErrorNames(); { return &fIds;}. » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:6923,Availability,error,error,6923," (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bin has to be seen as; an error source (relative).; names is an array of strings containing the names of the sources.; Sources with the same name are correlated. void SetOwner(bool swtch = kTRUE); Gives to the TLimitDataSource the ownership of the various objects; given as input.; Objects are then deleted by the TLimitDataSource destructor. virtual ~TLimitDataSource(); {}. TObjArray* GetSignal(); { return &fSignal;}. TObjArray* GetBackground(); { return &fBackground;}. TObjArray* GetCandidates(); { return &fCandidates;}. TObjArray* GetErrorOnSignal(); { return &fErrorOnSignal;}. TObjArray* GetErrorOnBackground(); { return &fErrorOnBackground;}. TObjArray* GetErrorNames(); { return &fIds;}. » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:348,Integrability,interface,interface,348,". TLimitDataSource. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimitDataSource. class TLimitDataSource: public TObject. TLimitDataSource. This class serves as interface to feed data into the TLimit routines. Function Members (Methods); public:. TLimitDataSource(); TLimitDataSource(TH1* s, TH1* b, TH1* d); TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); virtual~TLimitDataSource(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) cons",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLimitDataSource.html:387,Integrability,rout,routines,387,". TLimitDataSource. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TLimitDataSource. class TLimitDataSource: public TObject. TLimitDataSource. This class serves as interface to feed data into the TLimit routines. Function Members (Methods); public:. TLimitDataSource(); TLimitDataSource(TH1* s, TH1* b, TH1* d); TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); virtual~TLimitDataSource(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) cons",MatchSource.WIKI,root/html534/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLimitDataSource.html
https://root.cern/root/html534/TLine.html:1634,Availability,error,error,1634,"c TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_t",MatchSource.WIKI,root/html534/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLine.html
https://root.cern/root/html534/TLine.html:1718,Availability,error,error,1718,"::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; virtual Bool_tTObject::",MatchSource.WIKI,root/html534/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLine.html
https://root.cern/root/html534/TLine.html:8102,Deployability,release,released,8102,"th; Double_tfX1X of 1st point; Double_tfX2X of 2nd point; Double_tfY1Y of 1st point; Double_tfY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLine(); Line default constructor. TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Line normal constructor. ~TLine(); Line default destructor. TLine(const TLine& line); Line copy constructor. void Copy(TObject& line) const; Copy this line to line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. TLine * DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates in NDC. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event.; This member function is called when a line is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the l",MatchSource.WIKI,root/html534/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLine.html
https://root.cern/root/html534/TLine.html:8196,Deployability,release,released,8196,"d point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLine(); Line default constructor. TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Line normal constructor. ~TLine(); Line default destructor. TLine(const TLine& line); Line copy constructor. void Copy(TObject& line) const; Copy this line to line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. TLine * DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates in NDC. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event.; This member function is called when a line is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis als",MatchSource.WIKI,root/html534/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLine.html
https://root.cern/root/html534/TLine.html:9181,Modifiability,inherit,inheritance,9181," to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the line to be drawn vertically.; Makes fX2 equal to fX1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void Streamer(TBuffer& ); Stream an object of class TLine. Rectangle_t GetBBox(); Return the bounding Box of the Line. TPoint GetBBoxCenter(); Return the center of the BoundingBox as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the BoundingBox. void SetBBoxCenterX(const Int_t x); Set X coordinate of the center of the BoundingBox. void SetBBoxCenterY(const Int_t y); Set Y coordinate of the center of the BoundingBox. void SetBBoxX1(const Int_t x); Set lefthandside of BoundingBox to a value; (resize in x direction on left). void SetBBoxX2(const Int_t x); Set righthandside of BoundingBox to a value; (resize in x direction on right). void SetBBoxY1(const Int_t y); Set top of BoundingBox to a value (resize in y direction on top). void SetBBoxY2(const Int_t ",MatchSource.WIKI,root/html534/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLine.html
https://root.cern/root/html534/TLine.html:9366,Modifiability,inherit,inheritance,9366,"ttributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the line to be drawn vertically.; Makes fX2 equal to fX1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void Streamer(TBuffer& ); Stream an object of class TLine. Rectangle_t GetBBox(); Return the bounding Box of the Line. TPoint GetBBoxCenter(); Return the center of the BoundingBox as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the BoundingBox. void SetBBoxCenterX(const Int_t x); Set X coordinate of the center of the BoundingBox. void SetBBoxCenterY(const Int_t y); Set Y coordinate of the center of the BoundingBox. void SetBBoxX1(const Int_t x); Set lefthandside of BoundingBox to a value; (resize in x direction on left). void SetBBoxX2(const Int_t x); Set righthandside of BoundingBox to a value; (resize in x direction on right). void SetBBoxY1(const Int_t y); Set top of BoundingBox to a value (resize in y direction on top). void SetBBoxY2(const Int_t y); Set bottom of BoundingBox to a value; (resize in y direction on bottom). Double_t GetX1() const; {return fX1;}. Double_t GetX2() const; {return fX2;}. Double_t GetY1() const; {retur",MatchSource.WIKI,root/html534/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLine.html
https://root.cern/root/html534/TLinearFitter.html:5792,Availability,error,errors,5792,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:5998,Availability,robust,robust,5998,"();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(con",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:6682,Availability,robust,robust,6682," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual ",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:6819,Availability,error,errors,6819,"t be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObje",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:8430,Availability,error,error,8430,"ual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(); virtual Int_tEvalRobust(Double_t h = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidFixParameter(Int_t ipar, Double_t parvalue); virtual voidGetAtbVector(TVectorD& v); virtual Double_tGetChisquare(); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:8514,Availability,error,error,8514,"ual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(); virtual Int_tEvalRobust(Double_t h = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidFixParameter(Int_t ipar, Double_t parvalue); virtual voidGetAtbVector(TVectorD& v); virtual Double_tGetChisquare(); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:18654,Availability,error,errors,18654,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:18726,Availability,robust,robust,18726,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:18942,Availability,robust,robust,18942,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:19380,Availability,robust,robust,19380,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:21807,Availability,error,error,21807," of the following kind:; TFormula(""f"", ""x++y++z++x*x"") or; TFormula(""f"", ""x[0]++x[1]++x[2]*x[2]"");; Other than the look, it's in no; way different from the regular formula, it can be evaluated,; drawn, etc.; The option is to store or not to store the data; If you don't want to store the data, choose """" for the option, or run; StoreData(kFalse) member function after the constructor. TLinearFitter(const TLinearFitter& tlf); Copy ctor. ~TLinearFitter(); Linear fitter cleanup. TLinearFitter& operator=(const TLinearFitter& tlf); Assignment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates t",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:22927,Availability,error,errors,22927,"_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set ",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:24273,Availability,error,errors,24273,"t_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argum",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:24286,Availability,error,errors,24286,"t_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argum",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:24523,Availability,error,error,24523,"t_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argum",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:25076,Availability,error,errors,25076,"eter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. ",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:25427,Availability,error,error,25427,"ach bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:25727,Availability,robust,robust,25727,"2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level,",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:26846,Availability,error,errors,26846,"t fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level, Double_t amin = 0) const; Level = 3 (to be consistent with minuit) prints parameters and parameter; errors. Int_t GraphLinearFitter(Double_t h); Used in TGraph::Fit(). Int_t Graph2DLinearFitter(Double_t h); Minimisation function for a TGraph2D. Int_t MultiGraphLinearFitter(Double_t h); Minimisation function for a TMultiGraph. Int_t HistLinearFitter(); Minimization function for H1s using a Chisquare method. void Streamer(TBuffer& ). Int_t EvalRobust(Double_t h = -1); Finds the parameters of the fitted function in case data contains; outliers.; Parameter h stands for the minimal fraction of good points in the; dataset (h < 1, i.e. for 70% of good points take h=0.7).; The default value of h*Npoints is (Npoints + Nparameters+1)/2; If the user provides a value of h smaller than above, default is taken; See class description for the algorithm details. void CreateSubset(Int_t ntotal, Int_t h, Int_t* index); Creates a p-subset to start; ntotal - total number of points from which the subset is chosen. Double_t CStep(Int_t step, Int",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:18782,Deployability,release,released,18782,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:538,Integrability,depend,dependency,538,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:2607,Modifiability,variab,variables,2607,"ion by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional formula, one can create a; TF123 based on a linear expression and pass this function; to the fitter:; --Example:; TLinearFitter *lf = new TLinearFitter();; TF2 *f2 = new TF2(""f2"", ""x ++ y ++ x*x*y*y"", -2, 2, -2, 2);; lf->SetFormula(f2);; --The results of the fit are then stored in the function,; just like when the TH1::Fit or TGraph::Fit is used; --A linear function of this kind is by no means different; from any other function, it can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:4285,Modifiability,variab,variables,4285,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:5756,Modifiability,variab,variable,5756,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:19687,Modifiability,variab,variable,19687,".stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands for number of dimensions in the fitting formula; The input data is stored. If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); First parameter stands for number of dimensions in the fitting formula; Second parameter is the fitting formula: see class description for formula syntax; Options:; The option is to store or not to store the data; If you don't want to store the data, choose """" for the option, or run; StoreData(kFalse) member function afte",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:22233,Modifiability,variab,variables,22233,"gnment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisqua",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:22279,Modifiability,variab,variables,22279,"gnment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisqua",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:23802,Modifiability,inherit,inherits,23802," Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:837,Performance,perform,performed,837,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:4189,Performance,perform,performance,4189,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:6672,Performance,perform,perform,6672," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual ",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:17449,Performance,cache,cache,17449,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSym",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:19367,Performance,perform,performing,19367,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:5174,Security,access,access,5174,"d give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficie",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:1669,Usability,simpl,simply,1669,"is sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearFitter.html:5028,Usability,clear,cleared,5028," ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recomme",MatchSource.WIKI,root/html534/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearFitter.html
https://root.cern/root/html534/TLinearGradient.html:2596,Availability,error,error,2596,,MatchSource.WIKI,root/html534/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearGradient.html
https://root.cern/root/html534/TLinearGradient.html:2680,Availability,error,error,2680,,MatchSource.WIKI,root/html534/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearGradient.html
https://root.cern/root/html534/TLinearGradient.html:344,Modifiability,extend,extends,344,". TLinearGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLinearGradient. class TLinearGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. TLinearGradient(); TLinearGradient(const TLinearGradient&); TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); ~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTab",MatchSource.WIKI,root/html534/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearGradient.html
https://root.cern/root/html534/TLinearGradient.html:455,Modifiability,inherit,inheriting,455,". TLinearGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLinearGradient. class TLinearGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. TLinearGradient(); TLinearGradient(const TLinearGradient&); TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); ~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTab",MatchSource.WIKI,root/html534/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearGradient.html
https://root.cern/root/html534/TLinearGradient.html:10708,Modifiability,inherit,inherited,10708,"r* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TColorGradient::ECoordinateMode { kPadMode; kObjectBoundingMode; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. TColorGradient::PointfEnd; TColorGradient::PointfStart. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearGradient(). TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). void SetStartEnd(const TColorGradient::Point& p1, const TColorGradient::Point& p2). const TColorGradient::Point & GetStart() const. const TColorGradient::Point & GetEnd() const. TLinearGradient(); With C++11 we'll use inherited constructors!!!. » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearGradient.html
https://root.cern/root/html534/TLinearGradient.html:391,Usability,simpl,simple,391,". TLinearGradient. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLinearGradient. class TLinearGradient: public TColorGradient. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. TLinearGradient(); TLinearGradient(const TLinearGradient&); TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); TLinearGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); ~TLinearGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTab",MatchSource.WIKI,root/html534/TLinearGradient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearGradient.html
https://root.cern/root/html534/TLinearMinimizer.html:5652,Availability,error,errors,5652,"e(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(c",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:6265,Availability,robust,robust,6265,"ROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum fu",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:6517,Availability,error,error,6517," intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:7986,Availability,error,error,7986,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:7996,Availability,error,error,7996,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:8066,Availability,error,errors,8066,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:8329,Availability,error,errors,8329,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:395,Integrability,interface,interface,395,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtu",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:577,Integrability,depend,dependence,577,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtu",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:742,Modifiability,plug-in,plug-in,742,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtu",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:759,Modifiability,plug-in,plug-in,759,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtu",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:6163,Modifiability,plug-in,plug-ins,6163," const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double )",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:6940,Modifiability,variab,variable,6940,"ctor<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:7146,Modifiability,variab,variable,7146," needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:7730,Modifiability,variab,variables,7730,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:7827,Modifiability,variab,variables,7827,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:8243,Modifiability,variab,variable,8243,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:8301,Modifiability,variab,variables,8301,"performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:6724,Performance,perform,performing,6724,"; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { ",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:5669,Security,validat,validated,5669,"e(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(c",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLinearMinimizer.html:343,Usability,simpl,simple,343,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtu",MatchSource.WIKI,root/html534/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html
https://root.cern/root/html534/TLineEditor.html:4620,Availability,error,error,4620,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLineEditor.html
https://root.cern/root/html534/TLineEditor.html:4704,Availability,error,error,4704,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLineEditor.html
https://root.cern/root/html534/TLineEditor.html:17600,Availability,mask,mask,17600,,MatchSource.WIKI,root/html534/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLineEditor.html
https://root.cern/root/html534/TLink.html:1834,Availability,error,error,1834,"nst; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTText::Copy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidTText::GetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText::GetText",MatchSource.WIKI,root/html534/TLink.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLink.html
https://root.cern/root/html534/TLink.html:1918,Availability,error,error,1918,"(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTText::Copy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidTText::GetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText::GetTextAdvance(UInt_t& a, const char* text, const Bool_t kern = kTRUE) const; virtual Short",MatchSource.WIKI,root/html534/TLink.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLink.html
https://root.cern/root/html534/TList.html:3894,Availability,error,error,3894,"se(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vi",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:3978,Availability,error,error,3978,"const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() cons",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:436,Integrability,wrap,wrapped,436,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:801,Integrability,wrap,wrapper,801,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:1268,Integrability,wrap,wrap,1268,"inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); ",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:324,Modifiability,inherit,inheriting,324,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:10827,Performance,cache,cache,10827,"; voidTObject::MakeZombie(); virtual TObjLink*NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. TList(const TList&); TList&operator=(const TList&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*fFirst! pointer to first entry in linked list; TObjLink*fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TList(); Delete the list. Objects are not deleted unless the TList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TList.html:14096,Security,access,access,14096,"nd using the; object's IsEqual() method. Returns 0 if obj is last in list. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Obj is found using the; object's IsEqual() method. Returns 0 if obj is first in list. void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects; unless the TList is the owner (set via SetOwner()) and option; ""nodelete"" is not set.; If option=""nodelete"" then don't delete any heap objects that were; marked with the kCanDelete bit, otherwise these objects will be; deleted (this option is used by THashTable::Clear()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). void DeleteLink(TObjLink* lnk); Delete a TObjLink object. TObject * FindObject(const char* name) const; Find an object in this list using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. This method overrides the generic FindObject(); of TCollection for efficiency reasons. TObject * FindObject(const TObject* obj) const; Find an object in this list using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; This method overrides the generic FindObject() of TCollection for; efficiency reasons. TObjLink * FindLink(const TObject* obj, Int_t& idx) const; Returns the TObjLink object that contains object obj. In idx it returns; the position of the object in the list. TObject * First() const; Return the first object in the list. Returns 0 when list is empty. TObject ** GetObject",MatchSource.WIKI,root/html534/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TList.html
https://root.cern/root/html534/TLockFile.html:1569,Availability,error,error,1569," TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root/html534/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockFile.html
https://root.cern/root/html534/TLockFile.html:1653,Availability,error,error,1653," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockFile.html
https://root.cern/root/html534/TLockFile.html:376,Deployability,release,released,376,". TLockFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TLockFile. class TLockFile: public TObject. TLockFile. Lock an object using a file.; Constructor blocks until lock is obtained. Lock is released in the; destructor. Use it in scope-blocks like:; {; TLockFile lock(""path.to.lock.file"");; do something you need the lock for; } // lock is automatically released. Function Members (Methods); public:. TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root/html534/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockFile.html
https://root.cern/root/html534/TLockFile.html:539,Deployability,release,released,539,". TLockFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TLockFile. class TLockFile: public TObject. TLockFile. Lock an object using a file.; Constructor blocks until lock is obtained. Lock is released in the; destructor. Use it in scope-blocks like:; {; TLockFile lock(""path.to.lock.file"");; do something you need the lock for; } // lock is automatically released. Function Members (Methods); public:. TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root/html534/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockFile.html
https://root.cern/root/html534/TLockGuard.html:376,Availability,avail,available,376,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockGuard.html
https://root.cern/root/html534/TLockGuard.html:320,Integrability,interface,interface,320,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockGuard.html
https://root.cern/root/html534/TLockGuard.html:419,Performance,load,loaded,419,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockGuard.html
https://root.cern/root/html534/TLockGuard.html:521,Safety,safe,safe,521,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockGuard.html
https://root.cern/root/html534/TLockGuard.html:775,Safety,safe,safe,775,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLockGuard.html
https://root.cern/root/html534/TLorentzRotation.html:5247,Availability,error,error,5247,"Method(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TLorentzRotation&Boost(const TVector3& b); TLorentzRotation&Boost(Double_t bx, Double_t by, Double_t bz); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzRotation.html
https://root.cern/root/html534/TLorentzRotation.html:5331,Availability,error,error,5331,"""""); TLorentzRotation&Boost(const TVector3& b); TLorentzRotation&Boost(Double_t bx, Double_t by, Double_t bz); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzRotation.html
https://root.cern/root/html534/TLorentzRotation.html:2216,Testability,test,test,2216," an other TLorentzRotation,; by a pure TRotation or by a boost:;   TLorentzRotation l;      // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |    ",MatchSource.WIKI,root/html534/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzRotation.html
https://root.cern/root/html534/TLorentzRotation.html:2257,Testability,test,test,2257,"TRotation or by a boost:;   TLorentzRotation l;      // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |               ; |;            ; | xz  yz  ",MatchSource.WIKI,root/html534/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzRotation.html
https://root.cern/root/html534/TLorentzRotation.html:2309,Testability,test,test,2309,"     // l is; initialized as identity;   TLorentzRotation m(l);   // m = l;   TRotation r;;   TLorentzRotation lr(r);;   TLorentzRotation lb1(bx,by,bz);;   TVector3 b;;   TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:;  | 1+gamma'*bx*bx  gamma'*bx*by   gamma'*bx*bz ; gamma*bx |;  |  gamma'*by*bx  1+gamma'*by*by  gamma'*by*bz ; gamma*by |;  |  gamma'*bz*bx   gamma'*bz*by  1+gamma'*bz*bz; gamma*bz |;  |    gamma*bx      ; gamma*by       gamma*bz    ; gamma   |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;   Double_t xx;;   TLorentzRotation l;;   xx = l.XX();    // gets the xx component;   xx = l(0,0);    // gets the xx component;   if (l==m) {...}  // test for equality;   if (l !=m) {...} // test for inequality;   if (l.IsIdentity()) {...} // test for identity;  . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;   TLorentzRotation a,b,c;;   c = b*a;                       // product;   c = a.MatrixMultiplication(b);  // a is unchanged;   a *= b;                        // Attention: a=a*b;   c = a.Transform(b)             // a=b*a then c=a;  . Lorentz boosts;   Double_t bx, by, bz;;   TVector3 v(bx,by,bz);;   TLorentzRotation l;;   l.Boost(v);;   l.Boost(bx,by,bz);;  . Rotations;   TVector3 axis;;   l.RotateX(TMath::Pi());   //  rotation around; x-axis;   l.Rotate(.5,axis);               //  rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:;            ; | xx  yx  zx -tx |;            ; |               ; |;            ; | xy  yy  zy -ty |;            ; |               ; |;            ; | xz  yz  zz -tz |;            ; |               ; |;     ",MatchSource.WIKI,root/html534/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzRotation.html
https://root.cern/root/html534/TLorentzVector.html:8523,Availability,error,error,8523,"ual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector& v) const; Double_tDeltaR(const TLorentzVector& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector& q) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector& v) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3& v) const; Double_tEt2() const; Double_tEt2(const TVector3& v) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:8607,Availability,error,error,8607,"ct& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector& v) const; Double_tDeltaR(const TLorentzVector& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector& q) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector& v) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3& v) const; Double_tEt2() const; Double_tEt2(const TVector3& v) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:951,Energy Efficiency,energy,energy,951,". TLorentzVector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TLorentzVector. class TLorentzVector: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = ",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:1774,Energy Efficiency,energy,energy,1774,"asha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;   v.SetVect(TVector3(1,2,3));;   v.SetXYZT(x,y,z,t);;",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:4427,Energy Efficiency,energy,energy,4427,"r convenience there are two more set functions SetPtEtaPhiE(pt,eta,phi,e);; and SetPtEtaPhiM(pt,eta,phi,m);. Arithmetic and comparison operators; The TLorentzVector class provides operators to add, subtract or; compare four-vectors:;   v3 = -v1;;   v1 = v2+v3;;   v1+= v3;;   v1 = v2 + v3;;   v1-= v3;;   if (v1 == v2) {...};   if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;    i.e.   s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;           mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation aro",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:6372,Energy Efficiency,adapt,adapt,6372,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly.; . Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. TLorentzVector(); TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3& b); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); static",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:14839,Energy Efficiency,energy,energy,14839,"() const; TLorentzVector&Transform(const TRotation& m); TLorentzVector&Transform(const TLorentzRotation&); virtual voidTObject::UseCurrentStyle(); TVector3Vect() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const; Double_tZ() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum { kX; kY; kZ; kT; kNUM_COORDINATES; kSIZE; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfEtime or energy of (x,y,z,t) or (px,py,pz,e); TVector3fP3 vector component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLorentzVector(); {}. TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); {}. TLorentzVector(const Double_t* carray); {}. TLorentzVector(const Float_t* carray); {}. TLorentzVector(const TVector3& vector3, Double_t t); {}. TLorentzVector(const TLorentzVector& lorentzvector); {}. ~TLorentzVector(); {}. void Boost(Double_t , Double_t , Double_t ); Boost this Lorentz vector. Double_t Rapidity() const; return rapidity. TLorentzVector & Transform(const TLorentzRotation& ); Transform this Lorentzvector. void Streamer(TBuffer& ); Stream an object of class TLorentzVector. void Print(Option_t* option = """") const; Print the TLorentz vector components as (x,y,z,t) and (P,eta,phi,E) representations. Double_t X() const; { return fP.X(); }. Double_t Y() const; { return fP.Y(); }. Double_t Z() const; { return fP.Z(); }. Double_t T() const; { return fE; }. vo",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:1060,Modifiability,variab,variable,1060,"k Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TLorentzVector. class TLorentzVector: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; y",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:4691,Modifiability,parameteriz,parameterized,4691,"act or; compare four-vectors:;   v3 = -v1;;   v1 = v2+v3;;   v1+= v3;;   v1 = v2 + v3;;   v1-= v3;;   if (v1 == v2) {...};   if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;    i.e.   s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;           mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:6372,Modifiability,adapt,adapt,6372,"st(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly.; . Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;   TLorentzRotation l;;   v.Transform(l);;   v = l*v;     or    ; v *= l;  // Attention v = l*v. Function Members (Methods); public:. TLorentzVector(); TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x, Double_t y, Double_t z, Double_t t); virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3& b); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); static",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:5138,Performance,perform,performs,5138,"tive mag = -Sqrt(-mag*mag). The member; functions are:;   Double_t s, s2;;   s  = v1.Dot(v2);     // scalar; product;   s  = v1*v2;         // scalar product;   s2 = v.Mag2();   or    s2 = v.M2();;   s  = v.Mag();         ; s  = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;   x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;           x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;           t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;   TVector3 b;;   v.Boost(bx,by,bz);;   v.Boost(b);;   b = v.BoostVector();   // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;   v.RotateX(TMath::Pi()/2.);;   v.RotateY(.5);;   v.RotateZ(.99);. rotation around an arbitary axis;   v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;   v.RotateUz(direction); //  direction must be a unit TVector3. by TRotation (see TRotation);   TRotation r;;   v.Transform(r);    or    ; v *= r; // Attention v=M*v. Misc. Angle between two vectors;   Double_t a = v1.Angle(v2.Vect());  // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;   Double_t pcone = v.Plus();;   Double_t mcone = v.Minus()",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:1443,Security,access,access,1443," ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).;  . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one com",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TLorentzVector.html:1935,Security,access,accessed,1935,"Double_t variable.; By default all components are initialized by zero.;   TLorentzVector v1;      // initialized; by (0., 0., 0., 0.);   TLorentzVector v2(1., 1., 1., 1.);;   TLorentzVector v3(v1);;   TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t  C array.;  . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;   Double_t xx =v.X();;   ...;   Double_t tt = v.T();;   Double_t px = v.Px();;   ...;   Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;   xx = v(0);       or    ; xx = v[0];;   yy = v(1);             ; yy = v[1];;   zz = v(2);             ; zz = v[2];;   tt = v(3);             ; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;   TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:;  ;   v.SetX(1.);        or   ; v.SetPx(1.);;   ...                              ; ...;   v.SetT(1.);             ; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;   v.SetVect(TVector3(1,2,3));;   v.SetXYZT(x,y,z,t);;   v.SetPxPyPzE(px,py,pz,e);;   v.SetXYZM(x,y,z,m);   //   -> ; v=(x,y,z,e=Sqrt(x*x+y*y+z*z+m*m)). Vector components in noncartesian coordinate systems; There are a couple of memberfunctions to get and set the TVector3; part of the parameters in; spherical coordinate systems:;   Double_t m, theta, cost, phi, pp, pp2, ppv2, pp2v2;;   m = v.Rho();;   t = v.Theta();;   cost = v.",MatchSource.WIKI,root/html534/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TLorentzVector.html
https://root.cern/root/html534/TMacro.html:2418,Availability,error,error,2418,"me, const char* title = """"); virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; ",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:2511,Availability,error,error,2511,") const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtu",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:2595,Availability,error,error,2595,"d(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTO",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:7716,Availability,error,error,7716,"; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macr",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:8645,Availability,error,error,8645,"; Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() cons",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:8695,Availability,error,error,8695,"rwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}. » Author: Rene Brun 16/08/2005 » Copyright (C) 1995-2005, Rene Brun an",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:8806,Availability,error,error,8806,"ed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}. » Author: Rene Brun 16/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:44; This page has been automat",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:722,Deployability,update,updated,722,". TMacro. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMacro. class TMacro: public TNamed. TMacro. Class supporting a collection of lines with C++ code.; A TMacro can be executed, saved to a ROOT file, edited, etc. A macro can be built line by line by calling the AddLine function.; or it can be created directly from a file via the special constructor; when the first argument is a file name. A macro can be executed via the Exec function.; Arguments can be specified when calling Exec. A macro can be drawn in a pad. When the pad is updated, the macro is; automatically executed. The code in the macro can be saved via the SaveSource function.; If the macro is in the list of primitives of a pad/canvas, the macro; will be saved in the script generated by TCanvas::SaveSource. A macro can be written to a ROOT file via TObject::Write. Examples:; TMacro m(""Peaks.C""); //macro m with name ""Peaks"" is created; from file Peaks.C; m.Exec(); //macro executed with default arguments; m.Exec(""4""); //macro executed with argument; m.SaveSource(""newPeaks.C"");; TFile f(""mymacros.root"",""recreate"");; m.Write(); //macro saved to file with name ""Peaks"". Function Members (Methods); public:. TMacro(); TMacro(const TMacro&); TMacro(const char* name, const char* title = """"); virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:7861,Integrability,depend,depending,7861,"meobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:7890,Modifiability,variab,variable,7890,"meobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:7835,Performance,perform,performed,7835,"meobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:8536,Security,checksum,checksum,8536," macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(c",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:8465,Testability,log,log,8465,"const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMacro.html:8497,Testability,log,log,8497," constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. Returns 0 in; case of error, otherwise the added TObjString. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro sou",MatchSource.WIKI,root/html534/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMacro.html
https://root.cern/root/html534/TMap.html:2291,Availability,error,error,2291,"ar(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTit",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:2375,Availability,error,error,2375,""""") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TObject*GetValue(const char*",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:10526,Availability,down,downcast,10526,"ts in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; Returns a pointer to the value associated with key. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key f",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:10781,Availability,down,downcast,10781,"ption = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; Returns a pointer to the value associated with key. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key from the map. Returns the; key object or 0 in case key was not found. If map is the owner; of values, the value is deleted. TPair * RemoveEntry(TObject* key); Remove (key,value) pair with key from the map. Returns the; pair object or 0 in case the key was ",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:365,Energy Efficiency,efficient,efficient,365,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TOb",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:9868,Energy Efficiency,allocate,allocated,9868,"s() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Va",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:9991,Energy Efficiency,allocate,allocated,9991,"tSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) con",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:10120,Energy Efficiency,allocate,allocated,10120," the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; R",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:9116,Integrability,depend,depending,9116,"number of elements in collection. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:12175,Integrability,depend,depending,12175,"(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key from the map. Returns the; key object or 0 in case key was not found. If map is the owner; of values, the value is deleted. TPair * RemoveEntry(TObject* key); Remove (key,value) pair with key from the map. Returns the; pair object or 0 in case the key was not found.; It is caller's responsibility to delete the pair and, eventually,; the key and value objects. void SetOwnerValue(Bool_t enable = kTRUE); Set whether this map is the owner (enable==true); of its values. If it is the owner of its contents,; these objects will be deleted whenever the collection itself; is deleted. The objects might also be deleted or destructed when Clear; is called (depending on the collection). void SetOwnerKeyValue(Bool_t ownkeys = kTRUE, Bool_t ownvals = kTRUE); Set ownership for keys and values. void Streamer(TBuffer& ); Stream all key/value pairs in the map to or from the I/O buffer. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write all objects in this map. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a single key specify a name and set option to; TObject::kSingleKey (i.e. 1). Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write all objects in this map. By default all objects in; the collection are written individually (each object gets its; own key). Note, this is recursive, i.e. objects in collections; in the collection are also written individually. To write all; objects using a",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:615,Modifiability,inherit,inherit,615,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TOb",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:451,Security,hash,hash,451,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TOb",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:8934,Security,hash,hashtable,8934,"ick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); ",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:9546,Security,hash,hash,9546,"is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMap.html:9714,Security,hash,hash,9714,"d(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const;",MatchSource.WIKI,root/html534/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMap.html
https://root.cern/root/html534/TMapFile.html:2414,Availability,robust,robust,2414,"directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dr",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:3657,Availability,error,error,3657," option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObject*Get(const char* name, TObject* retObj = 0); void*GetBaseAddr() const; void*GetBreakval() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFd() const; TMapRec*GetFirst() const; virtual const char*TObject::GetIconName() const; TMapRec*GetLast() const; void*GetMmallocDesc() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; Int_tGetSize() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:3741,Availability,error,error,3741,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObject*Get(const char* name, TObject* retObj = 0); void*GetBaseAddr() const; void*GetBreakval() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFd() const; TMapRec*GetFirst() const; virtual const char*TObject::GetIconName() const; TMapRec*GetLast() const; void*GetMmallocDesc() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; Int_tGetSize() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject:",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:11912,Availability,error,error,11912,"ce the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t GetBestBuffer(); Return the best buffer size for objects in this fil",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:11987,Availability,error,error,11987,"t* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. Int_t GetBestBuffer(); Return the best buffer size for objects in this file. The best buffer size is estimated based on the current mean value; and s",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:8632,Deployability,update,update,8632,"t*Remove(const char* name, Bool_t lock); voidSumBuffer(Int_t bufsize). Data Members; public:. enum { kDefaultMapSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. ULong_tfBaseAddrBase address of mapped memory region; TList*fBrowseListList of KeyMapFile objects; TDirectory*fDirectoryPointer to directory associated to this mapfile; Int_tfFdDescriptor of mapped file; TMapRec*fFirstList of streamed objects is shared memory; TObject*fGettingDon't deadlock in update mode, when from Get() Add() is called; TMapRec*fLastLast object in list of shared objects; void*fMmallocDescPointer to mmalloc descriptor; char*fNameName of mapped file; Long_tfOffsetOffset in bytes for region mapped by reader; char*fOptionDirectory creation options; Int_tfSemaphoreModification semaphore (or getpid() for WIN32); Int_tfSizeOriginal start size of memory mapped region; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written sofar; char*fTitleTitle of mapped file; Int_tfVersionROOT version (or -1 for shadow map file); Bool_tfWritableTRUE if mapped file opened in RDWR mode; Int_tfWrittenNumber of objects written sofar; static Long_tfgMapAddressMap to this address, set address via SetMapAddress(); static void*fgMmallocDescUsed in Close() and operator delete(); ULong_tfhSemaphoreHANDLE of WIN32 Mutex object to implement semaphore. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMapFile(); Default ctor. Does not much except setting some basic values. TMapFile(const char* name, const char* title, Option_t* option, Int_t size, TMapFile*& newMapFile); Create a memory mapped file. This opens a file (to which the; memory will be mapped) and attaches a memory region to i",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:1405,Energy Efficiency,allocate,allocate,1405,") also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:11596,Energy Efficiency,allocate,allocated,11596,"operator has been made private. Use Close() to properly; terminate a TMapFile (also done via the TROOT dtor). void InitDirectory(); Create the directory associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents ",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:11759,Integrability,synchroniz,synchronizing,11759," associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuf",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:2148,Modifiability,inherit,inheritance,2148,"w the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size =",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:904,Security,access,access,904,". TMapFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TMapFile. class TMapFile: public TObject. TMapFile. This class implements a shared memory region mapped to a file.; Objects can be placed into this shared memory area using the Add(); member function. To actually place a copy of the object is shared; memory call Update() also whenever the mapped object(s) change(s); call Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is d",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:11773,Security,access,access,11773," associated to this mapfile. void Add(const TObject* obj, const char* name = """"); Add an object to the list of objects to be stored in shared memory.; To place the object actually into shared memory call Update(). void Update(TObject* obj = 0); Update an object (or all objects, if obj == 0) in shared memory. TObject * Remove(TObject* obj, Bool_t lock); Remove object from shared memory. Returns pointer to removed; object if successful, 0 otherwise. TObject * Remove(const char* name, Bool_t lock); Remove object by name from shared memory. Returns pointer to removed; object if successful, 0 otherwise. void RemoveAll(); Remove all objects from shared memory. TObject * Get(const char* name, TObject* retObj = 0); Return pointer to object retrieved from shared memory. The object must; be deleted after use. If delObj is a pointer to a previously allocated; object it will be deleted. Returns 0 in case object with the given; name does not exist. void CreateSemaphore(Int_t pid = 0); Create semaphore used for synchronizing access to shared memory. void DeleteSemaphore(); Delete the semaphore. Int_t AcquireSemaphore(); Acquire semaphore. Returns 0 if OK, -1 on error. Int_t ReleaseSemaphore(); Release semaphore. Returns 0 if OK, -1 on error. void Close(Option_t* option = """"); Close a mapped file. First detach mapped memory then close file.; No member functions of a TMapFile that was opened in write mode; may be called after Close() (this includes, of course, ""delete"" which; would call the dtors). The option=""dtor"" is only used when called; via the ~TMapFile. TMapFile * FindShadowMapFile(); Returns shadow map file. void Print(Option_t* option = """") const; Print some info about the mapped file. Bool_t IsFolder() const; Returns kTRUE in case object is a folder (i.e. contains browsable lists). void Browse(TBrowser* b); Browse contents of TMapFile. Bool_t cd(const char* path = 0); Cd to associated directory,. void ls(Option_t* option = """") const; List contents of TMapFile. void SumBuf",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapFile.html:1762,Usability,simpl,simple,1762,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual co",MatchSource.WIKI,root/html534/TMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapFile.html
https://root.cern/root/html534/TMapRec.html:785,Security,access,access,785,". TMapRec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TMapRec. class TMapRec. TMapFile. This class implements a shared memory region mapped to a file.; Objects can be placed into this shared memory area using the Add(); member function. Whenever the mapped object(s) change(s) call; Update() to put a fresh copy in the shared memory. This extra; step is necessary since it is not possible to share objects with; virtual pointers between processes (the vtbl ptr points to the; originators unique address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. Function Members (Methods); public:. TMapRec(const char* name, const TObject* obj, Int_t size, void* buf); ~TMapRec(); void*GetBuffer(Long_t offset = 0) const; Int_tGetBufSize() const; const char*GetClassName(Long_t offset = 0) const; const char*GetName(Long_t offset = 0) const; TMapRec*GetNext(Long_t offset = 0) const; TObject*GetObject() const. private:. TMapRec(const TMapRec&); TMapRec&operator=(const TMapRec&). Data Members; private:. Int_tfBufSizebuffer size; void*fBufferbuffer containing object of class name; char*fClassNameclass name; char*fNameobject name; TMapRec*fNextnext MapRec in list; TObject*fObjectpointer to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void operator=(const TMapRec& ). const char * GetName(); { return fName; }. TMapRec(const TMapRec& ). TMapRec(const char* name, const TObject* obj, Int_t size, void* buf). ~TMapRec(). const char * GetClassName(Long_t offset = 0) const; { return (ch",MatchSource.WIKI,root/html534/TMapRec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMapRec.html
https://root.cern/root/html534/TMarker.html:1565,Availability,error,error,1565,"_t marker); virtual~TMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX() const;",MatchSource.WIKI,root/html534/TMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMarker.html
https://root.cern/root/html534/TMarker.html:1649,Availability,error,error,1649,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX() const; Double_tGetY() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual UL",MatchSource.WIKI,root/html534/TMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMarker.html
https://root.cern/root/html534/TMarker.html:7924,Deployability,release,released,7924,"ted Members; Includes; Libraries. Function documentation; TMarker(); Marker default constructor. TMarker(Double_t x, Double_t y, Int_t marker); Marker normal constructor. ~TMarker(); Marker default destructor. TMarker(const TMarker& marker); Marker copy constructor. void Copy(TObject& marker) const; Copy this marker to marker. void DisplayMarkerTypes(); Display the table of markers with their numbers. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a marker. Compute the closest distance of approach from point px,py to this marker.; The distance is computed in pixels units. void Draw(Option_t* option = """"); Draw this marker with its current attributes. void DrawMarker(Double_t x, Double_t y); Draw this marker with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a marker is clicked with the locator. If Left button is clicked on a marker, the marker is moved to; a new position when the mouse button is released. void ls(Option_t* option = """") const; List this marker with its attributes. void Paint(Option_t* option = """"); Paint this marker with its current attributes. void PaintMarker(Double_t x, Double_t y); Draw this marker with new coordinates. void PaintMarkerNDC(Double_t u, Double_t v); Draw this marker with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this marker with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. void Streamer(TBuffer& ); Stream an object of class TMarker. Rectangle_t GetBBox(); Return the bounding Box of the Line. TPoint GetBBoxCenter(); Return the center of the BoundingBox as TPoint in pixels. void SetBBoxCenter(const TPoint& p); Set center of the BoundingBox. void SetBBoxCenterX(const Int_t x); Set X coordinate of the cen",MatchSource.WIKI,root/html534/TMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMarker.html
https://root.cern/root/html534/TMarker3DBox.html:1993,Availability,error,error,1993,"AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGetDirection(Float_t& theta, Float_t& phi) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPosition(Fl",MatchSource.WIKI,root/html534/TMarker3DBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMarker3DBox.html
https://root.cern/root/html534/TMarker3DBox.html:2077,Availability,error,error,2077,"ption = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGetDirection(Float_t& theta, Float_t& phi) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPosition(Float_t& x, Float_t& y, Float_t& z) const; TObject*GetRefObject() const; virtual voidG",MatchSource.WIKI,root/html534/TMarker3DBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMarker3DBox.html
https://root.cern/root/html534/TMaterial.html:1572,Availability,error,error,1572," a, Float_t z, Float_t density, Float_t radl, Float_t inter); virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tGetInterLength() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRadLength() const; vi",MatchSource.WIKI,root/html534/TMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMaterial.html
https://root.cern/root/html534/TMaterial.html:1656,Availability,error,error,1656,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA() const; virtual Float_tGetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tGetInterLength() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRadLength() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() cons",MatchSource.WIKI,root/html534/TMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMaterial.html
https://root.cern/root/html534/TMaterial.html:315,Safety,detect,detector,315,". TMaterial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMaterial. class TMaterial: public TNamed, public TAttFill. Manages a detector material. See class TGeometry. Function Members (Methods); public:. TMaterial(); TMaterial(const TMaterial&); TMaterial(const char* name, const char* title, Float_t a, Float_t z, Float_t density); TMaterial(const char* name, const char* title, Float_t a, Float_t z, Float_t density, Float_t radl, Float_t inter); virtual~TMaterial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetA(",MatchSource.WIKI,root/html534/TMaterial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMaterial.html
https://root.cern/root/html534/TMath.html:10770,Availability,down,down,10770,"ULong_tRange(ULong_t lb, ULong_t ub, ULong_t x); Double_tRange(Double_t lb, Double_t ub, Double_t x); Double_tRgair(); Double_tRMS(Long64_t n, const short* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const int* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const float* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const double* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:10846,Availability,down,down,10846,"Double_t ub, Double_t x); Double_tRgair(); Double_tRMS(Long64_t n, const short* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const int* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const float* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const double* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:10924,Availability,down,down,10924,"* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const int* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const float* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const double* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x);",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11003,Availability,down,down,11003,"_t* w = 0); Double_tRMS(Long64_t n, const float* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const double* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11080,Availability,down,down,11080,"ouble_tRMS(Long64_t n, const double* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11162,Availability,down,down,11162,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11228,Availability,down,down,11228,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11292,Availability,down,down,11292,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11358,Availability,down,down,11358,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11425,Availability,down,down,11425,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11490,Availability,down,down,11490,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:11560,Availability,down,down,11560,"g64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4).",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:12542,Availability,error,error,12542,"g long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the norma",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:12680,Availability,error,error,12680,"(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:12827,Availability,error,error,12827,"t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, D",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:12937,Availability,error,error,12937,"e_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the normalized lower incomplete gamma function P(a,x) as defined in the; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, B",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18455,Availability,error,error,18455,"nst Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:21140,Availability,error,error,21140,"convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roo",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:21362,Availability,error,error,21362,"just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:43073,Availability,down,down,43073,"lement value); Binary search in an array defined by its iterators. The values in the iterators range are supposed to be sorted; prior to this call. If match is found, function returns; position of element. If no match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> T * Cross(const T v1[3],const T v2[3], T out[3]); Calculate the Cross Product of two vectors:; out = [v1 x v2]. template <typename T> T * Normal2Plane(const T p1[3],const T p2[3],const T p3[3], T normal[3]); Calculate a normal vector of a plane. Input:; Float_t *p1,*p2,*p3 - 3 3D points belonged the plane to define it. Return:; Pointer to 3D normal vector (normalized). template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y); Function which returns kTRUE if point xp,yp lies inside the; polygon defined by the np points in arrays x and y, kFALSE otherwise.; Note that the polygon may be open or closed. template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:43237,Availability,down,down,43237,"o match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> T * Cross(const T v1[3],const T v2[3], T out[3]); Calculate the Cross Product of two vectors:; out = [v1 x v2]. template <typename T> T * Normal2Plane(const T p1[3],const T p2[3],const T p3[3], T normal[3]); Calculate a normal vector of a plane. Input:; Float_t *p1,*p2,*p3 - 3 3D points belonged the plane to define it. Return:; Pointer to 3D normal vector (normalized). template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y); Function which returns kTRUE if point xp,yp lies inside the; polygon defined by the np points in arrays x and y, kFALSE otherwise.; Note that the polygon may be open or closed. template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the median of the array a where each entry i has weight w[i] .; Both arrays have a length of at least n . The median is a number obtained; from the sorted array a through. median = (a[jl]+a[jh])/2. where (using al",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:49846,Availability,down,down,49846,"is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value). template <typename Iterator, typename Element> Iterator BinarySearch(Iterator first, Iterator last, Element value). void Sort(Index n, const Element* a, Index* index, Bool_t down=kTRUE); Sorting. template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y); IsInside. template <typename T> T * Cross(const T v1[3],const T v2[3], T out[3]); Calculate the Cross Product of two vectors. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. template <typename T> T * Normal2Plane(const T v1[3],const T v2[3],const T v3[3], T normal[3]); Calculate a normal vector of a plane. template <typename T> Double_t Mean(Long64_t n, const T *a, const Double_t *w=0). Statistics over arrays. Mean, Geometric Mean, Median, RMS(sigma). template <typename Iterator> Double_t Mean(Iterator first, Iterator last). template <typename Iterator, typename WeightIterator> Double_t Mean(Iterator first, Iterator last, WeightIterator wfirst). template <typename T> Double_t GeomMean(Long64_t n, const T *a). template <typename Iterator> Double_t GeomMean(Iterator first, Iterator last). t",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:53591,Availability,down,down,53591,"lement value); Binary search in an array defined by its iterators. The values in the iterators range are supposed to be sorted; prior to this call. If match is found, function returns; position of element. If no match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the median of the array a where each entry i has weight w[i] .; Both arrays have a length of at least n . The median is a number obtained; from the sorted array a through. median = (a[jl]+a[jh])/2. where (using also the sorted index on the array w). sum_i=0,jl w[i] <= sumTot/2; sum_i=0,jh w[i] >= sumTot/2; sumTot = sum_i=0,n w[i]. If w=0, the algorithm defaults to the median definition where it is; a number that divides the sorted sequence into 2 halves.; When n is odd or n > 1000, the median is kth element k = (n + 1) / 2.; when n is even and n < 1000the median is a mean of the elements k = n/2 and k = n/2 + 1. If the weights are supplied ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:53755,Availability,down,down,53755,"o match found, function gives nearest; element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value); Binary search in an array of n values to locate value. Array is supposed to be sorted prior to this call.; If match is found, function returns position of element.; If no match found, function gives nearest element smaller than value. template <typename Element, typename Index> void Sort(Index n, const Element* a, Index* index, Bool_t down); Sort the n elements of the array a of generic templated type Element.; In output the array index of type Index contains the indices of the sorted array.; If down is false sort in increasing order (default is decreasing order). template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work); Return the median of the array a where each entry i has weight w[i] .; Both arrays have a length of at least n . The median is a number obtained; from the sorted array a through. median = (a[jl]+a[jh])/2. where (using also the sorted index on the array w). sum_i=0,jl w[i] <= sumTot/2; sum_i=0,jh w[i] >= sumTot/2; sumTot = sum_i=0,n w[i]. If w=0, the algorithm defaults to the median definition where it is; a number that divides the sorted sequence into 2 halves.; When n is odd or n > 1000, the median is kth element k = (n + 1) / 2.; when n is even and n < 1000the median is a mean of the elements k = n/2 and k = n/2 + 1. If the weights are supplied (w not 0) all weights must be >= 0. If work is supplied, it is used to store the sorting index and assumed to be; >= n . If work=0, local storage is used, either on the stack if n < kWorkMax; or on the heap fo",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18671,Deployability,integrat,integrated,18671,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:23072,Deployability,continuous,continuous,23072,"urned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array'",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:29385,Deployability,continuous,continuous,29385,"atural lower and upper limits. Double_t BetaIncomplete(Double_t x, Double_t a, Double_t b); Calculates the incomplete Beta-function. Double_t Binomial(Int_t n, Int_t k); Calculate the binomial coefficient n over k. Double_t BinomialI(Double_t p, Int_t n, Int_t k); Suppose an event occurs with probability _p_ per trial; Then the probability P of its occuring _k_ or more times; in _n_ trials is termed a cumulative binomial probability; the formula is P = sum_from_j=k_to_n(TMath::Binomial(n, j)*; *TMath::Power(p, j)*TMath::Power(1-p, n-j); For _n_ larger than 12 BetaIncomplete is a much better way; to evaluate the sum than would be the straightforward sum calculation; for _n_ smaller than 12 either method is acceptable; (""Numerical Recipes""); --implementation by Anna Kreshuk. Double_t CauchyDist(Double_t x, Double_t t = 0, Double_t s = 1); Computes the density of Cauchy distribution at point x; by default, standard Cauchy distribution is used (t=0, s=1); t is the location parameter; s is the scale parameter; The Cauchy distribution, also called Lorentzian distribution,; is a continuous distribution describing resonance behavior; The mean and standard deviation of the Cauchy distribution are undefined.; The practical meaning of this is that collecting 1,000 data points gives; no more accurate an estimate of the mean and standard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:14583,Energy Efficiency,adapt,adapted,14583,"he; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mu is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; (most proble value) is at x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for any x integer argument it is correct.; BUT for non-integer x values, it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:16681,Energy Efficiency,power,powerful,16681,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18777,Energy Efficiency,adapt,adapted,18777,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:21289,Energy Efficiency,adapt,adapted,21289," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:22674,Energy Efficiency,allocate,allocated,22674,"ubject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:22765,Energy Efficiency,allocate,allocated,22765,"ble_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; type=8 - resulting sample quantiles are approximately median unbiased; regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; type=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and F",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:33886,Energy Efficiency,adapt,adapted,33886,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:48536,Energy Efficiency,charge,charge,48536," 1.0e7 * K(); }. Double_t KUncertainty(); { return 0.0000024e-23; }. Double_t Sigma(); Stefan-Boltzmann constant. { return 5.6704e-8; }. Double_t SigmaUncertainty(); { return 0.000040e-8; }. Double_t Na(); Avogadro constant (Avogadro's Number). { return 6.02214199e+23; }. Double_t NaUncertainty(); { return 0.00000047e+23; }. Double_t R(); universal gas constant (Na * K); http://scienceworld.wolfram.com/physics/UniversalGasConstant.html. { return K() * Na(); }. Double_t RUncertainty(); { return R()*((KUncertainty()/K()) + (NaUncertainty()/Na())); }. Double_t MWair(); Molecular weight of dry air; 1976 US Standard Atmosphere,; also see http://atmos.nmsu.edu/jsdap/encyclopediawork.html. { return 28.9644; }. Double_t Rgair(); Dry Air Gas Constant (R / MWair); http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm. { return (1000.0 * R()) / MWair(); }. Double_t EulerGamma(); Euler-Mascheroni Constant. { return 0.577215664901532860606512090082402431042; }. Double_t Qe(); Elementary charge. { return 1.602176462e-19; }. Double_t QeUncertainty(); { return 0.000000063e-19; }. Int_t Nint(T x). T Min(). T Max(). Bool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Comparing floating points. return Abs(af-bf); return kTRUE if absolute difference between af and bf is less than epsilon. Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec); return kTRUE if relative difference between af and bf is less than relPrec. return Abs(af-bf). template <typename T> T MinElement(Long64_t n, const T *a). Array Algorithms. Min, Max of an array. template <typename T> T MaxElement(Long64_t n, const T *a). template <typename T> Long64_t LocMin(Long64_t n, const T *a); Locate Min, Max element number in an array. template <typename Iterator> Iterator LocMin(Iterator first, Iterator last). template <typename T> Long64_t LocMax(Long64_t n, const T *a). template <typename Iterator> Iterator LocMax(Iterator first, Iterator last). template <typename T> Long64_t Bin",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:296,Integrability,rout,routines,296,". TMath. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TMath. namespace TMath. TMath. Encapsulate math routines. Function Members (Methods); public:. Short_tAbs(Short_t d); Int_tAbs(Int_t d); Long_tAbs(Long_t d); Long64_tAbs(Long64_t d); Float_tAbs(Float_t d); Double_tAbs(Double_t d); LongDouble_tAbs(LongDouble_t d); Double_tACos(Double_t x); Double_tACosH(Double_t); Bool_tAreEqualAbs(Double_t af, Double_t bf, Double_t epsilon); Bool_tAreEqualRel(Double_t af, Double_t bf, Double_t relPrec); Double_tASin(Double_t x); Double_tASinH(Double_t); Double_tATan(Double_t x); Double_tATan2(Double_t y, Double_t x); Double_tATanH(Double_t); Double_tBesselI(Int_t n, Double_t x); Double_tBesselI0(Double_t x); Double_tBesselI1(Double_t x); Double_tBesselJ0(Double_t x); Double_tBesselJ1(Double_t x); Double_tBesselK(Int_t n, Double_t x); Double_tBesselK0(Double_t x); Double_tBesselK1(Double_t x); Double_tBesselY0(Double_t x); Double_tBesselY1(Double_t x); Double_tBeta(Double_t p, Double_t q); Double_tBetaCf(Double_t x, Double_t a, Double_t b); Double_tBetaDist(Double_t x, Double_t p, Double_t q); Double_tBetaDistI(Double_t x, Double_t p, Double_t q); Double_tBetaIncomplete(Double_t x, Double_t a, Double_t b); Long64_tBinarySearch(Long64_t n, const short* array, short value); Long64_tBinarySearch(Long64_t n, const short** array, short value); Long64_tBinarySearch(Long64_t n, const int* array, int value); Long64_tBinarySearch(Long64_t n, const int** array, int value); Long64_tBinarySearch(Long64_t n, const float* array, float value); Long64_tBinarySearch(Long64_t n, const float** array, float value); Long64_tBinarySearch(Long64_t n, const double* array, double value); Long64_tBinarySearch(Long64_t n, const double** array, double value); Long64_tBinarySearch(Long64_t n, const long* array, long val",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:14608,Integrability,rout,routine,14608,"he; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mu is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; (most proble value) is at x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for any x integer argument it is correct.; BUT for non-integer x values, it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18671,Integrability,integrat,integrated,18671,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18811,Integrability,rout,routine,18811,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:33907,Integrability,rout,routine,33907,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:39526,Integrability,wrap,wrapper,39526,"e_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Int_t Nint(T x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. LongDouble_t Power(LongDouble_t x, LongDouble_t y); { return std::pow(x,y); }. LongDouble_t Power(LongDouble_t x, Long64_t y); { return std::pow(x,(LongDouble_t)y); }. LongDouble_t Power(Long64_t x, Long64_t y); { return std::pow(x,y); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with the maximum element.; If more than one element is maximum returns first found. Iterator LocMax(Iterator first, Iterator last); Return index of array with the maximum element.; If more than one element is maximum re",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:14583,Modifiability,adapt,adapted,14583,"he; Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 .; Its normalization is such that TMath::Gamma(a,+infinity) = 1 . --- Nve 14-nov-1998 UU-SAP Utrecht. Double_t BreitWigner(Double_t x, Double_t mean = 0, Double_t gamma = 1); Calculate a Breit Wigner function with mean and gamma. Double_t Gaus(Double_t x, Double_t mean = 0, Double_t sigma = 1, Bool_t norm = kFALSE); Calculate a gaussian function with mean and sigma.; If norm=kTRUE (default is kFALSE) the result is divided; by sqrt(2*Pi)*sigma. Double_t Landau(Double_t x, Double_t mpv = 0, Double_t sigma = 1, Bool_t norm = kFALSE); The LANDAU function.; mu is a location parameter and correspond approximatly to the most probable value; and sigma is a scale parameter (not the sigma of the full distribution which is not defined); Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; (most proble value) is at x = -0.22278; This function has been adapted from the CERNLIB routine G110 denlan.; If norm=kTRUE (default is kFALSE) the result is divided by sigma. Double_t LnGamma(Double_t z); Computation of ln[gamma(z)] for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. The accuracy of the result is better than 2e-10. --- Nve 14-nov-1998 UU-SAP Utrecht. Float_t Normalize(Float_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector. Double_t Normalize(Double_t v[3]); Normalize a vector v in place.; Returns the norm of the original vector.; This implementation (thanks Kevin Lynch <krlynch@bu.edu>) is protected; against possible overflows. Double_t Poisson(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); The Poisson PDF is implemented by means of Euler's Gamma-function; (for the factorial), so for any x integer argument it is correct.; BUT for non-integer x values, it IS NOT equal to the Poisson distribution.; see TMath::PoissonI to get a non-smooth function.; Note ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18777,Modifiability,adapt,adapted,18777,":; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is in",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:21289,Modifiability,adapt,adapted,21289," would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:30640,Modifiability,variab,variable,30640,"andard deviation than; does a single point.; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() impl",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:33886,Modifiability,adapt,adapted,33886,"meter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then th",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:34275,Modifiability,variab,variable,34275,"e shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distrib",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:34835,Modifiability,variab,variable,34835,"f; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Computes quantiles of the Student's t-distribution; 1st argument is the probability, at which the quantile is computed; 2nd argument - the number of degrees of freedom of the; Student distribution; When the 3rd argument lower_tail i",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:20406,Performance,perform,perform,20406,"a++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:24566,Security,hash,hash,24566,"pe=9 - resulting sample quantiles are approximately unbiased, when; the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);. default type = 7. References:; 1) Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:24757,Security,hash,hash,24757," Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; American Statistician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-S",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:24788,Security,hash,hash,24788,"istician, 50, 361-365; 2) R Project documentation for the function quantile of package {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:24858,Security,hash,hash,24858,"ackage {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; A",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:16593,Testability,test,test,16593,"e values of par, it is better to call; TMath::Gaus(x,par,sqrt(par),kTRUE). /*. */. Double_t PoissonI(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:16691,Testability,test,test,16691,"I(Double_t x, Double_t par); compute the Poisson distribution function for (x,par); This is a non-smooth function.; This function is equivalent to ROOT::Math::poisson_pdf. /*. */. Double_t Prob(Double_t chi2, Int_t ndf); Computation of the probability for a certain Chi-squared (chi2); and number of degrees of freedom (ndf). Calculations are based on the incomplete gamma function P(a,x),; where a=ndf/2 and x=chi2/2. P(a,x) represents the probability that the observed Chi-squared; for a correct model should be less than the value chi2. The returned probability corresponds to 1-P(a,x),; which denotes the probability that an observed Chi-squared exceeds; the value chi2 by chance, even for a correct model. --- NvE 14-nov-1998 UU-SAP Utrecht. Double_t KolmogorovProb(Double_t z); Calculates the Kolmogorov distribution function,. /*; ; */. which gives the probability that Kolmogorov's test statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:17583,Testability,test,test,17583,"est statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:17715,Testability,test,test,17715,"est statistic will exceed; the value z assuming the null hypothesis. This gives a very powerful; test for comparing two one-dimensional distributions.; see, for example, Eadie et al, ""statistocal Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; z = dn*sqrt(n), and; dn is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; n events. NOTE: To compare two experimental distributions with m and n events,; use z = sqrt(m*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18172,Testability,test,test,18172,"*n/(m+n))*dn. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than 10^-15 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1. This function was translated by Rene Brun from PROBKL in CERNLIB. Double_t KolmogorovTest(Int_t na, const Double_t* a, Int_t nb, const Double_t* b, Option_t* option); Statistical test whether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two so",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18596,Testability,test,test,18596,"ether two one-dimensional sets of points are compatible; with coming from the same parent distribution, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (i",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:18614,Testability,test,test,18614,"on, using the Kolmogorov test.; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively.; The elements of a and b must be given in ascending order.; option is a character string to specify options; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a; statistical test for compatibility of a and b.; Values of prob close to zero are taken as indicating a small probability; of compatibility. For two point sets drawn randomly from the same parent; distribution, the value of prob should be uniformly distributed between; zero and one.; in case of error the function return -1; If the 2 sets have a different number of points, the minimum of; the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation; between the two integrated distribution functions, multiplied by the; normalizing factor (rdmax*sqrt(na*nb/(na+nb)). Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; Statistical Methods in Experimental Physics, (North-Holland,; Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov). The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; over the two sorted arrays a and b representing empirical distribution; functions. The for-loop handles 3 cases: when the next points to be; evaluated satisfy a>b, a<b, or a=b:. for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {; rdiff += sb - sa;; ia++;; ib++;; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; }. For the last case,",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:20692,Testability,test,test,20692,"ase, a=b, the algorithm advances each array by one index in an; attempt to move through the equality. However, this is incorrect when one or; the other of a or b (or both) have a repeated value, call it x. For the KS; statistic to be computed properly, rdiff needs to be calculated after all of; the a and b at x have been tallied (this is due to the definition of the; empirical distribution function; another way to convince yourself that the; old CERNLIB method is wrong is that it implies that the function defined as the; difference between a and b is multi-valued at x -- besides being ugly, this; would invalidate Kolmogorov's theorem). The solution is to just add while-loops into the equality-case handling to; perform the tally:. } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4); Computation of Voigt function (normalised).; Voigt is a convolution of; gauss(xx) = 1/(sqrt(2*pi)*sigma) * exp(xx*xx/(2*sigma*sigma); and; lorentz(xx) = (1/pi) * (lg/2) / (xx*xx + lg*lg/4); functions. The Voigt function is known to be the real part of Faddeeva function also; called complex error function [2]. The algoritm was developed by J. Humlicek [1].; This code is based on fortran code presented by R. J. Wells [2].; Translated and adapted by Miha D. Puc. To calculate the Faddeeva function with relative error less than 10^(-r).; r can be set by the the user subject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubi",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:24951,Testability,test,tested,24951,"t to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Dou",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:30789,Testability,test,testing,30789,"/section3/eda3663.htm; Implementation by Anna Kreshuk.; Example:; TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; fc->SetParameters(0, 1);; fc->Draw();. Double_t ChisquareQuantile(Double_t p, Double_t ndf); Evaluate the quantiles of the chi-squared probability distribution function.; Algorithm AS 91 Appl. Statist. (1975) Vol.24, P.35; implemented by Anna Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Doub",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:31218,Testability,test,test,31218,"na Kreshuk.; Incorporates the suggested changes in AS R85 (vol.40(1), pp.233-5, 1991); Parameters:; p - the probability value, at which the quantile is computed; ndf - number of degrees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now impleme",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:31289,Testability,test,test,31289,"grees of freedom. Double_t FDist(Double_t F, Double_t N, Double_t M); Computes the density function of F-distribution; (probability function, integral of density, is computed in FDistI). Parameters N and M stand for degrees of freedom of chi-squares; mentioned above parameter F is the actual variable x of the; density function p(x) and the point at which the density function; is calculated. About F distribution:; F-distribution arises in testing whether two random samples; have the same variance. It is the ratio of two chi-square; distributions, with N and M degrees of freedom respectively,; where each chi-square is first divided by it's number of degrees; of freedom.; Implementation by Anna Kreshuk. Double_t FDistI(Double_t F, Double_t N, Double_t M); Calculates the cumulative distribution function of F-distribution,; this function occurs in the statistical test of whether two observed; samples have the same variance. For this test a certain statistic F,; the ratio of observed dispersion of the first sample to that of the; second sample, is calculated. N and M stand for numbers of degrees; of freedom in the samples 1-FDistI() is the significance level at; which the hypothesis ""1 has smaller variance than 2"" can be rejected.; A small numerical value of 1 - FDistI() implies a very significant; rejection, in turn implying high confidence in the hypothesis; ""1 has variance greater than 2"".; Implementation by Anna Kreshuk. Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu = 0, Double_t beta = 1); Computes the density function of Gamma distribution at point x.; gamma - shape parameter; mu - location parameter; beta - scale parameter. The definition can be found in ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda366b.htm; use now implementation in ROOT::Math::gamma_pdf. /*; ; */. Double_t LaplaceDist(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the probability density function of Laplace distributi",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:33227,Testability,log,lognormal,33227,"lace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LaplaceDistI(Double_t x, Double_t alpha = 0, Double_t beta = 1); Computes the distribution function of Laplace distribution; at point x, with location parameter alpha and shape parameter beta.; By default, alpha=0, beta=1; This distribution is known under different names, most common is; double exponential distribution, but it also appears as; the two-tailed exponential or the bilateral exponential distribution. Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta = 0, Double_t m = 1); Computes the density of LogNormal distribution at point x.; Variable X has lognormal distribution if Y=Ln(X) has normal distribution; sigma is the shape parameter; theta is the location parameter; m is the scale parameter; The formula was taken from ""Engineering Statistics Handbook"" on site; http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; Implementation using ROOT::Math::lognormal_pdf. /*; ; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at wh",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:34507,Testability,test,tests,34507,"; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Dou",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:34548,Testability,test,tests,34548,"; */. Double_t NormQuantile(Double_t p); Computes quantiles for standard normal distribution N(0, 1); at probability p; ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484. Bool_t Permute(Int_t n, Int_t* a); Simple recursive algorithm to find the permutations of; n natural numbers, not necessarily all distinct; adapted from CERNLIB routine PERMU.; The input array has to be initialised with a non descending; sequence. The method returns kFALSE when; all combinations are exhausted. Double_t Student(Double_t T, Double_t ndf); Computes density function for Student's t- distribution; (the probability function (integral of density) is computed in StudentI). First parameter stands for x - the actual variable of the; density function p(x) and the point at which the density is calculated.; Second parameter stands for number of degrees of freedom. About Student distribution:; Student's t-distribution is used for many significance tests, for example,; for the Student's t-tests for the statistical significance of difference; between two sample means and for confidence intervals for the difference; between two population means. Example: suppose we have a random sample of size n drawn from normal; distribution with mean Mu and st.deviation Sigma. Then the variable. t = (sample_mean - Mu)/(sample_deviation / sqrt(n)). has Student's t-distribution with n-1 degrees of freedom. NOTE that this function's second argument is number of degrees of freedom,; not the sample size. As the number of degrees of freedom grows, t-distribution approaches; Normal(0,1) distribution.; Implementation by Anna Kreshuk. Double_t StudentI(Double_t T, Double_t ndf); Calculates the cumulative distribution function of Student's; t-distribution second parameter stands for number of degrees of freedom,; not for the number of samples; if x has Student's t-distribution, the function returns the probability of; x being less than T.; Implementation by Anna Kreshuk. Double_t StudentQuantile(Double_t p, Dou",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:39323,Testability,log,log,39323,"return tanh(x); }. Double_t ASin(Double_t x). Double_t ACos(Double_t x). Double_t ATan(Double_t x); { return atan(x); }. Double_t ATan2(Double_t y, Double_t x). Double_t Sqrt(Double_t x); { return sqrt(x); }. Double_t Ceil(Double_t x); { return ceil(x); }. Int_t CeilNint(Double_t x); { return TMath::Nint(ceil(x)); }. Double_t Floor(Double_t x); { return floor(x); }. Int_t FloorNint(Double_t x); { return TMath::Nint(floor(x)); }. Int_t Nint(T x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t Exp(Double_t x); { return exp(x); }. Double_t Ldexp(Double_t x, Int_t exp); { return ldexp(x, exp); }. LongDouble_t Power(LongDouble_t x, LongDouble_t y); { return std::pow(x,y); }. LongDouble_t Power(LongDouble_t x, Long64_t y); { return std::pow(x,(LongDouble_t)y); }. LongDouble_t Power(Long64_t x, Long64_t y); { return std::pow(x,y); }. Double_t Power(Double_t x, Double_t y); { return pow(x, y); }. Double_t Power(Double_t x, Int_t y). Double_t Log(Double_t x); { return log(x); }. Double_t Log10(Double_t x); { return log10(x); }. Int_t Finite(Double_t x); { return isfinite(x); }. Int_t IsNaN(Double_t x); from math.h. { return ::isnan(x); }. Double_t QuietNaN(); --------wrapper to numeric_limits. Double_t SignalingNaN(). Double_t Infinity(); returns an infinity as defined by the IEEE standard. template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]); Calculate the Normalized Cross Product of two vectors. T MinElement(Long64_t n, const T *a); Return minimum of array a of length n. T MaxElement(Long64_t n, const T *a); Return maximum of array a of length n. Long64_t LocMin(Long64_t n, const T *a); Return index of array with the minimum element.; If more than one element is minimum returns first found. Iterator LocMin(Iterator first, Iterator last); Return index of array with the minimum element.; If more than one element is minimum returns first found. Long64_t LocMax(Long64_t n, const T *a); Return index of array with ",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:46263,Testability,log,log,46263,"sorting index and; assumed to be >= n. If work=0, local storage is used, either on; the stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbar",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:46330,Testability,log,log,46330,"he stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:46352,Testability,log,log,46352,"he stack if n < kWorkMax or on the heap for n >= kWorkMax.; Note that the work index array will not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:46425,Testability,log,log,46425," not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-34; }. Double_t HC(); hc (h * c). { return H() * C(); }. Double_t HCcgs(); { return Hcgs() * C",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMath.html:46452,Testability,log,log,46452," not contain the sorted indices but; all indeces of the smaller element in arbitrary order in work[0,...,k-1] and; all indeces of the larger element in arbitrary order in work[k+1,..,n-1]; work[k] will contain instead the index of the returned element. Taken from ""Numerical Recipes in C++"" without the index array; implemented by Anna Khreshuk. See also the declarations at the top of this file. Double_t Pi(). Fundamental constants. { return 3.14159265358979323846; }. Double_t TwoPi(); { return 2.0 * Pi(); }. Double_t PiOver2(); { return Pi() / 2.0; }. Double_t PiOver4(); { return Pi() / 4.0; }. Double_t InvPi(); { return 1.0 / Pi(); }. Double_t RadToDeg(); { return 180.0 / Pi(); }. Double_t DegToRad(); { return Pi() / 180.0; }. Double_t Sqrt2(); { return 1.4142135623730950488016887242097; }. Double_t E(); e (base of natural log). { return 2.71828182845904523536; }. Double_t Ln10(); natural log of 10 (to convert log to ln). { return 2.30258509299404568402; }. Double_t LogE(); base-10 log of e (to convert ln to log). { return 0.43429448190325182765; }. Double_t C(); velocity of light. { return 2.99792458e8; }. Double_t Ccgs(); { return 100.0 * C(); }. Double_t CUncertainty(); { return 0.0; }. Double_t G(); gravitational constant. { return 6.673e-11; }. Double_t Gcgs(); { return G() / 1000.0; }. Double_t GUncertainty(); { return 0.010e-11; }. Double_t GhbarC(); G over h-bar C. { return 6.707e-39; }. Double_t GhbarCUncertainty(); { return 0.010e-39; }. Double_t Gn(); standard acceleration of gravity. { return 9.80665; }. Double_t GnUncertainty(); { return 0.0; }. Double_t H(); Planck's constant. { return 6.62606876e-34; }. Double_t Hcgs(); { return 1.0e7 * H(); }. Double_t HUncertainty(); { return 0.00000052e-34; }. Double_t Hbar(); h-bar (h over 2 pi). { return 1.054571596e-34; }. Double_t Hbarcgs(); { return 1.0e7 * Hbar(); }. Double_t HbarUncertainty(); { return 0.000000082e-34; }. Double_t HC(); hc (h * c). { return H() * C(); }. Double_t HCcgs(); { return Hcgs() * C",MatchSource.WIKI,root/html534/TMath.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMath.html
https://root.cern/root/html534/TMathText.html:2347,Availability,avail,available,2347,"left( \\prod_f {d^3p_f\\over (2\\pi)^3} {1\\over 2E_f} \\right) \\left| \\mathscr{M} \\left(m_A - \\left\\{p_f\\right\\} \\right) \\right|^2 (2\\pi)^4 \\delta^{(4)} \\left(p_A - \\sum p_f \\right)"");; l.DrawMathText(0.50, 0.425, ""4\\mathrm{Re}\\left\\{{2\\over 1-\\Delta\\alpha} \\chi(s) \\left[ \\^{g}_\\nu^e \\^{g}_\\nu^f (1 + \\cos^2\\theta) + \\^{g}_a^e \\^{g}_a^f \\cos\\theta \\right] \\right\\}"");; l.DrawMathText(0.50, 0.330, ""p(n) = {1\\over\\pi\\sqrt{2}} \\sum_{k = 1}^\\infty \\sqrt{k} A_k(n) {d\\over dn} {\\sinh \\left\\{ {\\pi\\over k} \\sqrt{2\\over 3} \\sqrt{n - {1\\over 24}} \\right\\} \\over \\sqrt{n - {1\\over 24}}}"");; l.DrawMathText(0.13, 0.150, ""{(\\ell+1)C_{\\ell}^{TE} \\over 2\\pi}"");; l.DrawMathText(0.27, 0.110, ""\\mathbb{N} \\subset \\mathbb{R}"");; l.DrawMathText(0.63, 0.100, ""\\hbox{RHIC スピン物理 Нью-Йорк}"");. c1->Print(""c1.gif"");; c1->Print(""c1.jpg"");; c1->Print(""c1.png"");; c1->Print(""c1.ps"");; c1->Print(""c1.eps"");; ; return c1;; }. The list of all available symbols is given in the following example:. Picture; Source. // This macro draw all possible symbols provided by TMathtext; //Author: Olivier Couet. {; TCanvas *c1 = new TCanvas(""mathtext"",""TMathText symbol"",1200,1400);. TMathText l;; l.SetTextSize(0.013);; l.SetTextFont(132);; ; // Draw 1st Column; l.SetTextAlign(12);; float y, step, x1, x2;; y = 0.99; step = 0.0126; x1 = 0.01; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\\""""); l.DrawText(x2, y, ""\\\"""");; y -= step ; l.DrawMathText(x1, y, ""\\'""); l.DrawText(x2, y, ""\\'"");; y -= step ; l.DrawMathText(x1, y, ""\\.""); l.DrawText(x2, y, ""\\."");; y -= step ; l.DrawMathText(x1, y, ""\\=""); l.DrawText(x2, y, ""\\="");; y -= step ; l.DrawMathText(x1, y, ""\\Box""); l.DrawText(x2, y, ""\\Box"");; y -= step ; l.DrawMathText(x1, y, ""\\Bumpeq""); l.DrawText(x2, y, ""\\Bumpeq"");; y -= step ; l.DrawMathText(x1, y, ""\\Cap""); l.DrawText(x2, y, ""\\Cap"");; y -= step ; l.DrawMathText(x1, y, ""\\Cup""); l.DrawText(x2, y, ""\\Cup"");; y -= step ; l.DrawMathText(x1, y, ""\\Delta""); l",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:14823,Availability,down,downarrow,14823,"diamond""); l.DrawText(x2, y, ""\\diamond"");; y -= step ; l.DrawMathText(x1, y, ""\\diamondsuit""); l.DrawText(x2, y, ""\\diamondsuit"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:14857,Availability,down,downarrow,14857,"; y -= step ; l.DrawMathText(x1, y, ""\\diamondsuit""); l.DrawText(x2, y, ""\\diamondsuit"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\e",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:14908,Availability,down,downdownarrows,14908,"dsuit""); l.DrawText(x2, y, ""\\diamondsuit"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y ",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:14947,Availability,down,downdownarrows,14947,"-= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.D",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15003,Availability,down,downdownharpoons,15003,"DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMat",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15044,Availability,down,downdownharpoons,15044,"athText(x1, y, ""\\digamma""); l.DrawText(x2, y, ""\\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, """,MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15102,Availability,down,downharpoonleft,15102,"\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15142,Availability,down,downharpoonleft,15142,"\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantl",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15199,Availability,down,downharpoonright,15199," l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equi",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15240,Availability,down,downharpoonright,15240,"ext(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15298,Availability,down,downuparrows,15298,"rawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y,",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15335,Availability,down,downuparrows,15335,"y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, ""\\eta"");; y -= step ; l.DrawMathText(x1, y,",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15389,Availability,down,downupharpoons,15389," y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, ""\\eta"");; y -= step ; l.DrawMathText(x1, y, ""\\eth""); l.DrawText(x2, y, ""\\eth"");; y -= st",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:15428,Availability,down,downupharpoons,15428,""");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantless"");; y -= step ; l.DrawMathText(x1, y, ""\\equiv""); l.DrawText(x2, y, ""\\equiv"");; y -= step ; l.DrawMathText(x1, y, ""\\eta""); l.DrawText(x2, y, ""\\eta"");; y -= step ; l.DrawMathText(x1, y, ""\\eth""); l.DrawText(x2, y, ""\\eth"");; y -= step ; l.DrawMathText(x1, y, ""\\exists""); l.DrawT",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:54289,Availability,error,error,54289,"ual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTOb",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:54373,Availability,error,error,54373,"are(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTTex",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:52217,Testability,log,log,52217,", ""\\csc"");; y -= step ; l.DrawMathText(x1, y, ""\\deg""); l.DrawText(x2, y, ""\\deg"");; y -= step ; l.DrawMathText(x1, y, ""\\det""); l.DrawText(x2, y, ""\\det"");; y -= step ; l.DrawMathText(x1, y, ""\\dim""); l.DrawText(x2, y, ""\\dim"");; y -= step ; l.DrawMathText(x1, y, ""\\exp""); l.DrawText(x2, y, ""\\exp"");; y -= step ; l.DrawMathText(x1, y, ""\\gcd""); l.DrawText(x2, y, ""\\gcd"");; y -= step ; l.DrawMathText(x1, y, ""\\hom""); l.DrawText(x2, y, ""\\hom"");; y -= step ; l.DrawMathText(x1, y, ""\\inf""); l.DrawText(x2, y, ""\\inf"");; y -= step ; l.DrawMathText(x1, y, ""\\ker""); l.DrawText(x2, y, ""\\ker"");; y -= step ; l.DrawMathText(x1, y, ""\\lg""); l.DrawText(x2, y, ""\\lg"");; y -= step ; l.DrawMathText(x1, y, ""\\lim""); l.DrawText(x2, y, ""\\lim"");; y -= step ; l.DrawMathText(x1, y, ""\\liminf""); l.DrawText(x2, y, ""\\liminf"");; y -= step ; l.DrawMathText(x1, y, ""\\limsup""); l.DrawText(x2, y, ""\\limsup"");; y -= step ; l.DrawMathText(x1, y, ""\\ln""); l.DrawText(x2, y, ""\\ln"");; y -= step ; l.DrawMathText(x1, y, ""\\log""); l.DrawText(x2, y, ""\\log"");; y -= step ; l.DrawMathText(x1, y, ""\\max""); l.DrawText(x2, y, ""\\max"");; y -= step ; l.DrawMathText(x1, y, ""\\min""); l.DrawText(x2, y, ""\\min"");; y -= step ; l.DrawMathText(x1, y, ""\\sec""); l.DrawText(x2, y, ""\\sec"");; y -= step ; l.DrawMathText(x1, y, ""\\sin""); l.DrawText(x2, y, ""\\sin"");; y -= step ; l.DrawMathText(x1, y, ""\\sinh""); l.DrawText(x2, y, ""\\sinh"");; y -= step ; l.DrawMathText(x1, y, ""\\sup""); l.DrawText(x2, y, ""\\sup"");; y -= step ; l.DrawMathText(x1, y, ""\\tan""); l.DrawText(x2, y, ""\\tan"");; y -= step ; l.DrawMathText(x1, y, ""\\tanh""); l.DrawText(x2, y, ""\\tanh"");; ; return c1;; }. Function Members (Methods); public:. TMathText(); TMathText(const TMathText& text); TMathText(Double_t x, Double_t y, const char* text); virtual~TMathText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMathText.html:52245,Testability,log,log,52245,"ext(x1, y, ""\\deg""); l.DrawText(x2, y, ""\\deg"");; y -= step ; l.DrawMathText(x1, y, ""\\det""); l.DrawText(x2, y, ""\\det"");; y -= step ; l.DrawMathText(x1, y, ""\\dim""); l.DrawText(x2, y, ""\\dim"");; y -= step ; l.DrawMathText(x1, y, ""\\exp""); l.DrawText(x2, y, ""\\exp"");; y -= step ; l.DrawMathText(x1, y, ""\\gcd""); l.DrawText(x2, y, ""\\gcd"");; y -= step ; l.DrawMathText(x1, y, ""\\hom""); l.DrawText(x2, y, ""\\hom"");; y -= step ; l.DrawMathText(x1, y, ""\\inf""); l.DrawText(x2, y, ""\\inf"");; y -= step ; l.DrawMathText(x1, y, ""\\ker""); l.DrawText(x2, y, ""\\ker"");; y -= step ; l.DrawMathText(x1, y, ""\\lg""); l.DrawText(x2, y, ""\\lg"");; y -= step ; l.DrawMathText(x1, y, ""\\lim""); l.DrawText(x2, y, ""\\lim"");; y -= step ; l.DrawMathText(x1, y, ""\\liminf""); l.DrawText(x2, y, ""\\liminf"");; y -= step ; l.DrawMathText(x1, y, ""\\limsup""); l.DrawText(x2, y, ""\\limsup"");; y -= step ; l.DrawMathText(x1, y, ""\\ln""); l.DrawText(x2, y, ""\\ln"");; y -= step ; l.DrawMathText(x1, y, ""\\log""); l.DrawText(x2, y, ""\\log"");; y -= step ; l.DrawMathText(x1, y, ""\\max""); l.DrawText(x2, y, ""\\max"");; y -= step ; l.DrawMathText(x1, y, ""\\min""); l.DrawText(x2, y, ""\\min"");; y -= step ; l.DrawMathText(x1, y, ""\\sec""); l.DrawText(x2, y, ""\\sec"");; y -= step ; l.DrawMathText(x1, y, ""\\sin""); l.DrawText(x2, y, ""\\sin"");; y -= step ; l.DrawMathText(x1, y, ""\\sinh""); l.DrawText(x2, y, ""\\sinh"");; y -= step ; l.DrawMathText(x1, y, ""\\sup""); l.DrawText(x2, y, ""\\sup"");; y -= step ; l.DrawMathText(x1, y, ""\\tan""); l.DrawText(x2, y, ""\\tan"");; y -= step ; l.DrawMathText(x1, y, ""\\tanh""); l.DrawText(x2, y, ""\\tanh"");; ; return c1;; }. Function Members (Methods); public:. TMathText(); TMathText(const TMathText& text); TMathText(Double_t x, Double_t y, const char* text); virtual~TMathText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual v",MatchSource.WIKI,root/html534/TMathText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMathText.html
https://root.cern/root/html534/TMatrixTBase_double_.html:822,Availability,avail,available,822,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3983,Availability,down,down,3983,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:7544,Availability,avail,available,7544,"Function(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixDBase, TMatrixTBase<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual vo",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:8862,Availability,error,error,8862,"(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:8946,Availability,error,error,8946,"; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2031,Deployability,integrat,integrated,2031,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2545,Deployability,install,installation,2545,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2583,Deployability,install,installation,2583,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:1988,Energy Efficiency,efficient,efficient,1988,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2454,Energy Efficiency,adapt,adapted,2454,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3259,Energy Efficiency,adapt,adapted,3259,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3315,Energy Efficiency,efficient,efficiently,3315,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:4342,Energy Efficiency,efficient,efficient,4342,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2031,Integrability,integrat,integrated,2031,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3101,Integrability,rout,routines,3101,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3298,Integrability,rout,routines,3298,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2454,Modifiability,adapt,adapted,2454,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3259,Modifiability,adapt,adapted,3259,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:3955,Performance,optimiz,optimized,3955,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:851,Safety,avoid,avoiding,851,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:2133,Testability,test,test,2133," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:4688,Testability,test,test,4688,"; from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; st",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:6650,Testability,test,test,6650,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixDBase, TMatrixTBase<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs()",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:6277,Usability,simpl,simple,6277,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_double_.html:6950,Usability,simpl,simple,6950,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixDBase, TMatrixTBase<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActio",MatchSource.WIKI,root/html534/TMatrixTBase_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_double_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:819,Availability,avail,available,819,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3980,Availability,down,down,3980,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:7540,Availability,avail,available,7540,"yFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixFBase, TMatrixTBase<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObje",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:8850,Availability,error,error,8850,"ply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:8934,Availability,error,error,8934,"b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatE2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tGetNcols() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*T",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2028,Deployability,integrat,integrated,2028,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2542,Deployability,install,installation,2542,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2580,Deployability,install,installation,2580,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:1985,Energy Efficiency,efficient,efficient,1985,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2451,Energy Efficiency,adapt,adapted,2451,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3256,Energy Efficiency,adapt,adapted,3256,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3312,Energy Efficiency,efficient,efficiently,3312,"; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices,",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:4339,Energy Efficiency,efficient,efficient,4339,"or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2028,Integrability,integrat,integrated,2028,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3098,Integrability,rout,routines,3098,"age examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) ca",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3295,Integrability,rout,routines,3295,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2451,Modifiability,adapt,adapted,2451,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3256,Modifiability,adapt,adapted,3256,"bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:3952,Performance,optimiz,optimized,3952,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:848,Safety,avoid,avoiding,848,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:2130,Testability,test,test,2130," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:4685,Testability,test,test,4685,"; from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *= haar_t;; VerifyMatrixIdentity(unit,hth);; VerifyMatrixIdentity(unit,hht);; VerifyMatrixIdentity(unit,hht1);. 4. Accessing row/col/diagonal of a matrix without much fuss; (and without moving a lot of stuff around):. TMatrixD m(n,n); TVectorD v(n); TMatrixDDiag(m) += 4;; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; st",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:6647,Testability,test,test,6647,"xD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixFBase, TMatrixTBase<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); v",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:6274,Usability,simpl,simple,6274,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTBase_float_.html:6947,Usability,simpl,simple,6947,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixFBase, TMatrixTBase<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<flo",MatchSource.WIKI,root/html534/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTBase_float_.html
https://root.cern/root/html534/TMatrixTCramerInv.html:402,Energy Efficiency,adapt,adapted,402,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html534/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTCramerInv.html
https://root.cern/root/html534/TMatrixTCramerInv.html:367,Integrability,rout,routines,367,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html534/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTCramerInv.html
https://root.cern/root/html534/TMatrixTCramerInv.html:415,Integrability,rout,routines,415,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html534/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTCramerInv.html
https://root.cern/root/html534/TMatrixTCramerInv.html:402,Modifiability,adapt,adapted,402,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html534/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTCramerInv.html
https://root.cern/root/html534/TMatrixTLazy_double_.html:663,Availability,avail,available,663,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Double_t>, TMatrixDLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html534/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_double_.html
https://root.cern/root/html534/TMatrixTLazy_double_.html:1641,Availability,error,error,1641," virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html534/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_double_.html
https://root.cern/root/html534/TMatrixTLazy_double_.html:1725,Availability,error,error,1725," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html534/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_double_.html
https://root.cern/root/html534/TMatrixTLazy_float_.html:659,Availability,avail,available,659,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFLazy, TMatrixTLazy<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html534/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_float_.html
https://root.cern/root/html534/TMatrixTLazy_float_.html:1636,Availability,error,error,1636," virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html534/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_float_.html
https://root.cern/root/html534/TMatrixTLazy_float_.html:1720,Availability,error,error,1720," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html534/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_float_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:5249,Availability,error,error,5249," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:5333,Availability,error,error,5333,"oidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTMatrixTBase<double>::GetNrows() const; virtual char*",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:17957,Energy Efficiency,allocate,allocated,17957,"lon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:18183,Energy Efficiency,allocate,allocated,18183,"_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:18409,Energy Efficiency,allocate,allocated,18409,"). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:18633,Energy Efficiency,allocate,allocated,18633,"nt_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy m",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:18851,Energy Efficiency,allocate,allocated,18851,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:19079,Energy Efficiency,allocate,allocated,19079,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:19301,Energy Efficiency,allocate,allocated,19301,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source t",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:19523,Energy Efficiency,allocate,allocated,19523,"lement> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b;",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:20567,Energy Efficiency,allocate,allocated,20567,"ubtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:20808,Energy Efficiency,allocate,allocated,20808,"Nelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:2198,Integrability,rout,routine,2198,"+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixTSparse<Double_t>, TMatrixDSparse. Function Members (Methods); public:. TMatrixTSparse<double>(); TMatrixTSparse<double>(const TMatrixTSparse<double>& another); TMatrixTSparse<double>(const TMatrixT<double>& another); TMatrixTSparse<double>(Int_t nrows, Int_t ncols); TMatrixTSparse<double>(TMatrixTSparse<double>::EMatrixCreatorsOp1 op, const TMatrixTSparse<double>& prototype); TM",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:22021,Integrability,depend,depends,22021,"zeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<double>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:2320,Modifiability,flexible,flexible,2320,"e matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixTSparse<Double_t>, TMatrixDSparse. Function Members (Methods); public:. TMatrixTSparse<double>(); TMatrixTSparse<double>(const TMatrixTSparse<double>& another); TMatrixTSparse<double>(const TMatrixT<double>& another); TMatrixTSparse<double>(Int_t nrows, Int_t ncols); TMatrixTSparse<double>(TMatrixTSparse<double>::EMatrixCreatorsOp1 op, const TMatrixTSparse<double>& prototype); TMatrixTSparse<double>(const TMatrixTSparse<double>& a, TMatrixTSparse<double>::EMatrixCreatorsOp2 op, const TMatrixTSparse<double>& b); TMatrixTSparse<double>(const TMatrixTSparse<double>& a, TMatrixTSparse<double>::EMatrixCreatorsOp2 op, const TMatrixT<do",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:1566,Performance,perform,performance,1566,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is sm",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_double_.html:840,Security,access,access,840,". TMatrixTSparse<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSparse<double>. class TMatrixTSparse<double>: public TMatrixTBase<double>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); wher",MatchSource.WIKI,root/html534/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_double_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:5205,Availability,error,error,5205,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNo",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:5289,Availability,error,error,5289,"tual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNoElements() const; Int_tTMatrixTBase<float>::GetNrows() const; virtual char*TObject::",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:17740,Energy Efficiency,allocate,allocated,17740,"silon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:17966,Energy Efficiency,allocate,allocated,17966,"nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatri",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:18192,Energy Efficiency,allocate,allocated,18192,"at). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<E",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:18416,Energy Efficiency,allocate,allocated,18416,"Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy ma",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:18634,Energy Efficiency,allocate,allocated,18634,"Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/co",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:18862,Energy Efficiency,allocate,allocated,18862,"t_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(I",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:19084,Energy Efficiency,allocate,allocated,19084,"b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to s",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:19306,Energy Efficiency,allocate,allocated,19306,"lement> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:20347,Energy Efficiency,allocate,allocated,20347,"x subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:20588,Energy Efficiency,allocate,allocated,20588," fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros,",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:2194,Integrability,rout,routine,2194,"+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixFSparse, TMatrixTSparse<Float_t>. Function Members (Methods); public:. TMatrixTSparse<float>(); TMatrixTSparse<float>(const TMatrixTSparse<float>& another); TMatrixTSparse<float>(const TMatrixT<float>& another); TMatrixTSparse<float>(Int_t nrows, Int_t ncols); TMatrixTSparse<float>(TMatrixTSparse<float>::EMatrixCreatorsOp1 op, const TMatrixTSparse<float>& prototype); TMatrixTSpar",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:21799,Integrability,depend,depends,21799,"onzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<float>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The n",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:2316,Modifiability,flexible,flexible,2316,"e matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixFSparse, TMatrixTSparse<Float_t>. Function Members (Methods); public:. TMatrixTSparse<float>(); TMatrixTSparse<float>(const TMatrixTSparse<float>& another); TMatrixTSparse<float>(const TMatrixT<float>& another); TMatrixTSparse<float>(Int_t nrows, Int_t ncols); TMatrixTSparse<float>(TMatrixTSparse<float>::EMatrixCreatorsOp1 op, const TMatrixTSparse<float>& prototype); TMatrixTSparse<float>(const TMatrixTSparse<float>& a, TMatrixTSparse<float>::EMatrixCreatorsOp2 op, const TMatrixTSparse<float>& b); TMatrixTSparse<float>(const TMatrixTSparse<float>& a, TMatrixTSparse<float>::EMatrixCreatorsOp2 op, const TMatrixT<float>& b); TMatrix",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:1562,Performance,perform,performance,1562,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted. Be aware that the input data array will be modified; inside the routine for doing the necessary sorting of indices !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is sm",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSparse_float_.html:836,Security,access,access,836,". TMatrixTSparse<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSparse<float>. class TMatrixTSparse<float>: public TMatrixTBase<float>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it",MatchSource.WIKI,root/html534/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSparse_float_.html
https://root.cern/root/html534/TMatrixTSymCramerInv.html:414,Energy Efficiency,adapt,adapted,414,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html534/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymCramerInv.html
https://root.cern/root/html534/TMatrixTSymCramerInv.html:379,Integrability,rout,routines,379,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html534/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymCramerInv.html
https://root.cern/root/html534/TMatrixTSymCramerInv.html:427,Integrability,rout,routines,427,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html534/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymCramerInv.html
https://root.cern/root/html534/TMatrixTSymCramerInv.html:414,Modifiability,adapt,adapted,414,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html534/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymCramerInv.html
https://root.cern/root/html534/TMatrixTSymLazy_double_.html:678,Availability,avail,available,678,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixDSymLazy, TMatrixTSymLazy<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html534/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_double_.html
https://root.cern/root/html534/TMatrixTSymLazy_double_.html:1659,Availability,error,error,1659," virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html534/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_double_.html
https://root.cern/root/html534/TMatrixTSymLazy_double_.html:1743,Availability,error,error,1743," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html534/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_double_.html
https://root.cern/root/html534/TMatrixTSymLazy_float_.html:674,Availability,avail,available,674,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Float_t>, TMatrixFSymLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html534/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_float_.html
https://root.cern/root/html534/TMatrixTSymLazy_float_.html:1654,Availability,error,error,1654," virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html534/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_float_.html
https://root.cern/root/html534/TMatrixTSymLazy_float_.html:1738,Availability,error,error,1738," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRowLwb() const; Int_tGetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html534/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_float_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:2905,Availability,error,error,2905,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:2989,Availability,error,error,2989,"Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double>::GetNoElements() const; Int_tTM",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:492,Deployability,update,updated,492,". TMatrixTSym<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSym<double>. class TMatrixTSym<double>: public TMatrixTBase<double>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . This class is also known as (typedefs to this class)TMatrixTSym<Double_t>, TMatrixDSym. Function Members (Methods); public:. TMatrixTSym<double>(); TMatrixTSym<double>(Int_t nrows); TMatrixTSym<double>(const TMatrixTSym<double>& another); TMatrixTSym<double>(const TMatrixTSymLazy<double>& lazy_constructor); TMatrixTSym<double>(Int_t row_lwb, Int_t row_upb); TMatrixTSym<double>(TMatrixTSym<double>::EMatrixCreatorsOp1 op, const TMatrixTSym<double>& prototype); TMatrixTSym<double>(TMatrixTSym<double>::EMatrixCreatorsOp1 op, const TMatrixT<double>& prototype); TMatrixTSym<double>(Int_t nrows, const double* data, Option_t* option = """"); TMatrixTSym<double>(const TMatrixTSym<double>& a, TMatrixTSym<double>::EMatrixCreatorsOp2 op, const TMatrixTSym<double>& b); TMatrixTSym<double>(Int_t row_lwb, Int_t row_upb, const double* data, Option_t* option = """"); virtual~TMatrixTSym<double>(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(con",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:18161,Energy Efficiency,efficient,efficient,18161," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:18501,Energy Efficiency,efficient,efficient,18501,"<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:18893,Energy Efficiency,efficient,efficient,18893,"= 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:15162,Integrability,depend,depends,15162,"ound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starti",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:15593,Integrability,depend,depends,15593," Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const double* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set siz",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:18225,Integrability,rout,routine,18225," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:18565,Integrability,rout,routine,18565,"<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Ele",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:18957,Integrability,rout,routine,18957,"= 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_double_.html:17491,Security,access,access,17491,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficien",MatchSource.WIKI,root/html534/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_double_.html
https://root.cern/root/html534/TMatrixTSym_float_.html:2921,Availability,error,error,2921,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html534/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TMatrixTSym_float_.html
