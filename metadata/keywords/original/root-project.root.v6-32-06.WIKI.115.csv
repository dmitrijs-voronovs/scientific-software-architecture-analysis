id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TError_8h.html:2553,Usability,simpl,simple,2553," The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMs",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/tessellatedNav_8C.html:4072,Performance,perform,perform,4072," the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetTimeInt_t GetTime() constReturn time in form of 123623 (i.e. 12:36:23)Definition TDatime.cxx:259; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoTessellated::ImportFromObjFormatstatic TGeoTessellated * ImportFromObjFormat(const char *objfile, bool check=false, bool verbose=false)Reader from .obj format.Definition TGeoTessellated.cxx:579; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetLineWidthvoid SetLineWidth(Width_t lwidth) overrideSet the line width.Definition TGeoVolume.cxx:2185; TGeoVolume::Raytracevoid Raytrace(Bool_t flag=kTRUE)Draw this volume with current settings and perform raytracing in the pad.Definition TGeoVolume.cxx:1427; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, con",MatchSource.WIKI,doc/master/tessellatedNav_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tessellatedNav_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:257,Availability,error,errors,257,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:56434,Availability,error,error,56434,"2f"", h1->GetMean(), h1->GetRMS()), ""l"");; l3->Draw();; ; c1->cd(4);; hChisquared->Draw(""HIST"");; }; ; int main() {; TestBinomial();; }; BinData.h; HFitInterface.h; IntegratorOptions.h; mainint main()Definition Prototype.cxx:12; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TBinomialEfficiencyFitter.h; TCanvas.h; TF1.h; TFitResult.h; plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; TGraphErrors.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TLegend.h; TObjArray.h; TPaveStats.h; TRandom3.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualFitter.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResult::GetConfidenceIntervalsvoid GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) constget confidence intervals for an array of n points x.Definition FitResult.cxx:506; ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegratorstatic void SetDefaultIntegrator(const char *name)Definition IntegratorOptions.cxx:222; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMa",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:57847,Availability,error,error,57847,"Integrator(const char *name)Definition IntegratorOptions.cxx:222; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TBinomialEfficiencyFitterBinomial fitter for the division of two histograms.Definition TBinomialEfficiencyFitter.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TF11-Dim function classDefinition TF1.h:233; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetParErrorvirtual Double_t GetParError(Int_t ipar) constReturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::GetProbvirtual Double_t GetProb() constReturn the fit probability.Definition TF1.cxx:1955; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t va",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:57857,Availability,error,error,57857,"Integrator(const char *name)Definition IntegratorOptions.cxx:222; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TBinomialEfficiencyFitterBinomial fitter for the division of two histograms.Definition TBinomialEfficiencyFitter.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TF11-Dim function classDefinition TF1.h:233; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetParErrorvirtual Double_t GetParError(Int_t ipar) constReturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::GetProbvirtual Double_t GetProb() constReturn the fit probability.Definition TF1.cxx:1955; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t va",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:59220,Availability,error,errors,59220,"eturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::GetProbvirtual Double_t GetProb() constReturn the fit probability.Definition TF1.cxx:1955; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:10491; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogra",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:59301,Availability,error,error,59301,"obability.Definition TF1.cxx:1955; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:10491; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Perfo",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:60323,Availability,error,errors,60323,"Errors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1D::Resetvoid Reset(Option_t *option="""") overrideReset.Definition TH1.cxx:10491; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetRMSDouble_t GetRMS(Int_t axis=1) constThis function returns the Standard Deviation (Sigma) of the distribution not the Root Mean Square (RM...Definition TH1.h:319; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TLegendThis class displays a legend box (TPaveText) con",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:61035,Availability,error,errors,61035,"ion TH1.cxx:3519; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetRMSDouble_t GetRMS(Int_t axis=1) constThis function returns the Standard Deviation (Sigma) of the distribution not the Root Mean Square (RM...Definition TH1.h:319; TH1::DrawCopyvirtual TH1 * DrawCopy(Option_t *option="""", const char *name_postfix=""_copy"") constCopy this histogram and Draw in the current pad.Definition TH1.cxx:3113; TH1::Dividevirtual Bool_t Divide(TF1 *f1, Double_t c1=1)Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:2840; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetS",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:63089,Energy Efficiency,schedul,scheduler,63089,"ition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; c1return c1Definition legend1.C:41; grTGraphErrors * grDefinition legend1.C:25; h1TH1F * h1Definition legend1.C:5; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; AuthorRene Brun ; Definition in file TestBinomial.C. tutorialsfitTestBinomial.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:347,Performance,perform,performed,347,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:565,Performance,perform,performed,565,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:812,Performance,perform,performed,812,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:889,Performance,perform,performing,889,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:989,Performance,perform,performing,989,": tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ; ****",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:52501,Performance,perform,performing,52501,"RN"";; if (debug) optFit += TString(""SV"");; TFitResultPtr res = hM2E->Fit(fM2Fit, optFit);; if (plot) {; hM2E->DrawCopy(""E"");; fM2Fit->SetLineColor(kBlue);; fM2Fit->DrawCopy(""SAME"");; }; if (debug) res->Print();; status = res;; break;; }; case 1:; {; // if (fM2Fit2) delete fM2Fit2;; // fM2Fit2 = dynamic_cast<TF1*>(fM2Fit->Clone(""fM2Fit2""));; fM2Fit2 = fM2Fit; // do not clone/copy the function; if (fM2Fit2->GetParameter(0) >= 1.0); fM2Fit2->SetParameter(0, 0.95);; fM2Fit2->SetParLimits(0, 0.0, 1.0);; ; // TVirtualPad * pad = gPad;; // new TCanvas();; // fM2Fit2->Draw();; // gPad = pad;; ; TBinomialEfficiencyFitter bef(hM2N, hM2D);; TString optFit = ""RI S"";; if (debug) optFit += TString(""V"");; TFitResultPtr res = bef.Fit(fM2Fit2,optFit);; status = res;; if (status !=0) {; std::cerr << ""Error performing binomial efficiency fit, result = ""; << status << std::endl;; res->Print();; continue;; }; if (plot) {; fM2Fit2->SetLineColor(kRed);; fM2Fit2->DrawCopy(""SAME"");; ; bool confint = (status == 0);; if (confint) {; // compute confidence interval on fitted function; auto htemp = fM2Fit2->GetHistogram();; ROOT::Fit::BinData xdata;; ROOT::Fit::FillData(xdata, fM2Fit2->GetHistogram() );; TGraphErrors gr(fM2Fit2->GetHistogram() );; res->GetConfidenceIntervals(xdata, gr.GetEY(), 0.68, false);; gr.SetFillColor(6);; gr.SetFillStyle(3005);; gr.DrawClone(""4 same"");; }; }; if (debug) {; res->Print();; }; }; }; ; if (status != 0) break;; ; double fnorm = fM2Fit->GetParameter(0);; double enorm = fM2Fit->GetParError(0);; double fthreshold = fM2Fit->GetParameter(1);; double ethreshold = fM2Fit->GetParError(1);; double fwidth = fM2Fit->GetParameter(2);; double ewidth = fM2Fit->GetParError(2);; if (fit == 1) {; fnorm = fM2Fit2->GetParameter(0);; enorm = fM2Fit2->GetParError(0);; fthreshold = fM2Fit2->GetParameter(1);; ethreshold = fM2Fit2->GetParError(1);; fwidth = fM2Fit2->GetParameter(2);; ewidth = fM2Fit2->GetParError(2);; hChisquared->Fill(fM2Fit2->GetProb());; }; ; TH1D* h = dynamic_cas",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:63056,Performance,optimiz,optimizer,63056,"ition TLegend.cxx:320; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TPad::Dividevoid Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0) overrideAutomatic pad generation by division.Definition TPad.cxx:1249; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; c1return c1Definition legend1.C:41; grTGraphErrors * grDefinition legend1.C:25; h1TH1F * h1Definition legend1.C:5; PyTorch_Generate_CNN_Model.fitfit(model, train_loader, val_loader, num_epochs, batch_size, optimizer, criterion, save_best, scheduler)Definition PyTorch_Generate_CNN_Model.py:34; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; AuthorRene Brun ; Definition in file TestBinomial.C. tutorialsfitTestBinomial.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:48716,Safety,safe,safely,48716,"; gStyle->SetLineWidth(2.0);; gStyle->SetOptStat(11);; ; TObjArray hbiasNorm;; hbiasNorm.Add(new TH1D(""h0Norm"", ""Bias Histogram fit"",100,-5,5));; hbiasNorm.Add(new TH1D(""h1Norm"",""Bias Binomial fit"",100,-5,5));; TObjArray hbiasThreshold;; hbiasThreshold.Add(new TH1D(""h0Threshold"", ""Bias Histogram fit"",100,-5,5));; hbiasThreshold.Add(new TH1D(""h1Threshold"",""Bias Binomial fit"",100,-5,5));; TObjArray hbiasWidth;; hbiasWidth.Add(new TH1D(""h0Width"", ""Bias Histogram fit"",100,-5,5));; hbiasWidth.Add(new TH1D(""h1Width"",""Bias Binomial fit"",100,-5,5));; TH1D* hChisquared = new TH1D(""hChisquared"",; ""#chi^{2} probability (Baker-Cousins)"", 200, 0.0, 1.0);; ; TVirtualFitter::SetDefaultFitter(""Minuit2"");; ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(""Gauss"");; ; // Note: in order to be able to use TH1::FillRandom() to generate; // pseudo-experiments, we use a trick: generate ""selected""; // and ""non-selected"" samples independently. These are; // statistically independent and therefore can be safely; // added to yield the ""before selection"" sample.; ; ; // Define (arbitrarily?) a distribution of input events.; // Here: assume a x^(-2) distribution. Boundaries: [10, 100].; ; double xmin =10, xmax = 100;; TH1D* hM2D = new TH1D(""hM2D"", ""x^(-2) denominator distribution"",; 45, xmin, xmax);; TH1D* hM2N = new TH1D(""hM2N"", ""x^(-2) numerator distribution"",; 45, xmin, xmax);; TH1D* hM2E = new TH1D(""hM2E"", ""x^(-2) efficiency"",; 45, xmin, xmax);; ; TF1* fM2D = new TF1(""fM2D"", ""(1-[0]/(1+exp(([1]-x)/[2])))/(x*x)"",; xmin, xmax);; TF1* fM2N = new TF1(""fM2N"", ""[0]/(1+exp(([1]-x)/[2]))/(x*x)"",; xmin, xmax);; TF1* fM2Fit = new TF1(""fM2Fit"", ""[0]/(1+exp(([1]-x)/[2]))"",; xmin, xmax);; TF1* fM2Fit2 = nullptr;; ; TRandom3 rb(seed);; ; // First try: use a single set of parameters.; // For each try, we need to find the overall normalization; ; double normalization = 0.80;; double threshold = 25.0;; double width = 5.0;; ; fM2D->SetParameter(0, normalization);; fM2D->SetParameter(1, threshold);; ",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/TestBinomial_8C.html:372,Usability,simpl,simple,372,". ROOT: tutorials/fit/TestBinomial.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TestBinomial.C File ReferenceTutorials » Fit Tutorials. Detailed Description; Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; Three different fits are performed and compared:. simple least square fit to the divided histogram obtained from TH1::Divide with option b; least square fit to the TGraphAsymmErrors obtained from TGraphAsymmErrors::BayesDivide; likelihood fit performed on the dividing histograms using binomial statistics with the TBinomialEfficiency class. The first two methods are biased while the last one is statistical correct. Running the script passing an integer value n larger than 1, n fits are performed and the bias are also shown. To run the script :; to show the bias performing 100 fits for 1000 events per ""experiment""; root[0]: .x TestBinomial.C+; to show the bias performing 100 fits for 1000 events per ""experiment""; .x TestBinomial.C+(100, 1000). ; 32 68; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 0.350714; NDf = 3; Edm = 1.27001e-06; NCalls = 81; p0 = 0.694132 +/- 0.210029 ; p1 = 19.3471 +/- 5.85483 ; p2 = 5.2245 +/- 5.11013 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 14.3081; Chi2 = 28.6162; NDf = 21; Edm = 4.11934e-08; NCalls = 91; p0 = 0.822966 +/- 0.0807557 (limited); p1 = 21.9819 +/- 2.14579 ; p2 = 3.36105 +/- 1.05866 ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 1.64738; NDf = 5; Edm = 1.01171e-06; NCalls = 137; p0 = 0.677329 +/- 0.135567 (limited); p1 = 15.5028 +/- 4.11118 ; p2 = 4.10441 +/- 2.77044 ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 19.363; Chi2 = 38.7261; NDf = 25; Edm = 9.40378e-08; NCalls = 80; p0 = 0.778188 +/- 0.0815568 (limited); p1 = 23.7948 +/- 2.21356 ; p2 = 4.58769 +/- 1.24153 ;",MatchSource.WIKI,doc/master/TestBinomial_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html
https://root.cern/doc/master/testoptical_8C.html:924,Security,access,accessors,924,". ROOT: tutorials/geom/gdml/testoptical.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testoptical.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Tests importing/exporting optical surfaces from GDML. ; Optical surfaces, skin surfaces and border surfaces are imported in object arrays stored by TGeoManager class. Optical surfaces do not store property arrays but point to GDML matrices describing such properties. One can get the data for such property like: TGeoOpticalSurface *surf = geom->GetOpticalSurface(""surf1""); const char *property = surf=>GetPropertyRef(""REFLECTIVITY""); TGeoGDMLMatrix *m = geom->GetGDMLMatrix(property); Skin surfaces and border surfaces can be retrieved from the TGeoManager object by using: TObjArray *skin_array = geom->GetListOfSkinSurfaces(); TObjArra8 *border_array = geom->GetListOfBorderSurfaces(); Alternatively accessors by name can also be used: GetSkinSurface(name)/GetBorderSurface(name); AuthorAndrei Gheata ; Definition in file testoptical.C. tutorialsgeomgdmltestoptical.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testoptical_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testoptical_8C.html
https://root.cern/doc/master/testoptical_8C.html:28,Testability,test,testoptical,28,". ROOT: tutorials/geom/gdml/testoptical.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testoptical.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Tests importing/exporting optical surfaces from GDML. ; Optical surfaces, skin surfaces and border surfaces are imported in object arrays stored by TGeoManager class. Optical surfaces do not store property arrays but point to GDML matrices describing such properties. One can get the data for such property like: TGeoOpticalSurface *surf = geom->GetOpticalSurface(""surf1""); const char *property = surf=>GetPropertyRef(""REFLECTIVITY""); TGeoGDMLMatrix *m = geom->GetGDMLMatrix(property); Skin surfaces and border surfaces can be retrieved from the TGeoManager object by using: TObjArray *skin_array = geom->GetListOfSkinSurfaces(); TObjArra8 *border_array = geom->GetListOfBorderSurfaces(); Alternatively accessors by name can also be used: GetSkinSurface(name)/GetBorderSurface(name); AuthorAndrei Gheata ; Definition in file testoptical.C. tutorialsgeomgdmltestoptical.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testoptical_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testoptical_8C.html
https://root.cern/doc/master/testoptical_8C.html:139,Testability,test,testoptical,139,". ROOT: tutorials/geom/gdml/testoptical.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testoptical.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Tests importing/exporting optical surfaces from GDML. ; Optical surfaces, skin surfaces and border surfaces are imported in object arrays stored by TGeoManager class. Optical surfaces do not store property arrays but point to GDML matrices describing such properties. One can get the data for such property like: TGeoOpticalSurface *surf = geom->GetOpticalSurface(""surf1""); const char *property = surf=>GetPropertyRef(""REFLECTIVITY""); TGeoGDMLMatrix *m = geom->GetGDMLMatrix(property); Skin surfaces and border surfaces can be retrieved from the TGeoManager object by using: TObjArray *skin_array = geom->GetListOfSkinSurfaces(); TObjArra8 *border_array = geom->GetListOfBorderSurfaces(); Alternatively accessors by name can also be used: GetSkinSurface(name)/GetBorderSurface(name); AuthorAndrei Gheata ; Definition in file testoptical.C. tutorialsgeomgdmltestoptical.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testoptical_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testoptical_8C.html
https://root.cern/doc/master/testoptical_8C.html:1046,Testability,test,testoptical,1046,". ROOT: tutorials/geom/gdml/testoptical.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testoptical.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Tests importing/exporting optical surfaces from GDML. ; Optical surfaces, skin surfaces and border surfaces are imported in object arrays stored by TGeoManager class. Optical surfaces do not store property arrays but point to GDML matrices describing such properties. One can get the data for such property like: TGeoOpticalSurface *surf = geom->GetOpticalSurface(""surf1""); const char *property = surf=>GetPropertyRef(""REFLECTIVITY""); TGeoGDMLMatrix *m = geom->GetGDMLMatrix(property); Skin surfaces and border surfaces can be retrieved from the TGeoManager object by using: TObjArray *skin_array = geom->GetListOfSkinSurfaces(); TObjArra8 *border_array = geom->GetListOfBorderSurfaces(); Alternatively accessors by name can also be used: GetSkinSurface(name)/GetBorderSurface(name); AuthorAndrei Gheata ; Definition in file testoptical.C. tutorialsgeomgdmltestoptical.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testoptical_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testoptical_8C.html
https://root.cern/doc/master/testrandom_8C.html:12800,Deployability,continuous,continuous,12800," %8.3f"",sw.CpuTime()*cpn);; gRandom = r1;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r2;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r3;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; TF1 *f2 = new TF1(""f2"",""landau"",-5,15);; f2->SetParameters(1,0,1);; ; gRandom = r0;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf(""LandauTF1......... %8.3f"",sw.CpuTime()*cpn);; gRandom = r1;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r2;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r3;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; // test using Unuran; #if __has_include(""TUnuran.h""); TUnuran unr0(r0);; TUnuran unr1(r1);; TUnuran unr2(r2);; TUnuran unr3(r3);; ; // continuous distribution (ex. Gaus); TUnuranContDist dist(f1);; // use arou method (is probably the fastest); unr0.Init(dist,""arou"");; unr1.Init(dist,""arou"");; unr2.Init(dist,""arou"");; unr3.Init(dist,""arou"");; ; sw.Start();; for (i=0;i<N;i++) {; x = unr0.Sample();; }; printf(""GausUNURAN........ %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr1.Sample();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr2.Sample();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr3.Sample();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; // Poisson (need to initialize before with Poisson mu value); ; unr0.InitPoisson(10);; unr1.InitPoisson(10);; unr2.InitPoisson(10);; unr3.InitPoisson(10);; ; sw.Start();; for (i=0;i<N;i++) {; x = unr0.SampleDiscr();; }; printf(""PoissonUNURAN(10). %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr1.SampleDiscr();; }; printf("" %8.3f"",sw.CpuTime()*c",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:32578,Deployability,continuous,continuous,32578,"igma=1.Definition TRandom.cxx:507; TRandom::Poissonvirtual ULong64_t Poisson(Double_t mean)Generates a random integer N according to a Poisson law.Definition TRandom.cxx:404; TRandom::Expvirtual Double_t Exp(Double_t tau)Returns an exponential deviate.Definition TRandom.cxx:252; TRandom::Landauvirtual Double_t Landau(Double_t mean=0, Double_t sigma=1)Generate a random number following a Landau distribution with location parameter mu and scale paramet...Definition TRandom.cxx:381; TRandom::Binomialvirtual Int_t Binomial(Int_t ntot, Double_t prob)Generates a random integer N according to the binomial law.Definition TRandom.cxx:212; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::CpuTimeDouble_t CpuTime()Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the start an...Definition TStopwatch.cxx:125; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranTUnuran class.Definition TUnuran.h:79; TRandomMixMaxTRandomGen< ROOT::Math::MixMaxEngine< 240, 0 > > TRandomMixMaxMIXMAX generator based on a state of N=240.Definition TRandomGen.h:105; TRandomMT64TRandomGen< ROOT::Math::StdEngine< std::mt19937_64 > > TRandomMT64Generator based on a the Mersenne-Twister generator with 64 bits, using the implementation provided b...Definition TRandomGen.h:141; TRandomMixMax256TRandomGen< ROOT::Math::MixMaxEngine< 256, 2 > > TRandomMixMax256MIXMAX generator based on a state of N=256, based on the generator described in this paper:Definition TRandomGen.h:130; TRandomMixMax17TRandomGen< ROOT::Math::MixMaxEngine< 17, 0 > > TRandomMixMax17MIXMAX generator based on a state of N=17.Definition TRandomGen.h:116; TRandomRanlux48TRandomGen< ROOT::Math::StdEngine< std::ranlux48 > > TRandomRanlux48Generator based on a the RanLux generator with 48 bits, using the implementation pr",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:23,Testability,test,testrandom,23,". ROOT: tutorials/math/testrandom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testrandom.C File ReferenceTutorials » Math tutorials. Detailed Description; Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2. ; E.g. on an an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRando",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:133,Testability,test,testrandom,133,". ROOT: tutorials/math/testrandom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testrandom.C File ReferenceTutorials » Math tutorials. Detailed Description; Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2. ; E.g. on an an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRando",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:222,Testability,test,test,222,". ROOT: tutorials/math/testrandom.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testrandom.C File ReferenceTutorials » Math tutorials. Detailed Description; Performance test of all the ROOT random generator (TRandom, TRandom1, TRandom2 and TRandom3) Tests the generator TRandom3 against some ref values and creates a timing table against TRandom, TRandom1 and TRandom2. ; E.g. on an an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRando",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:1922,Testability,test,testrandom,1922," 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3 MixMax240 MixMax17 Mixmax256_0 MixMax256_2 MixMax256_4 MT_64 Ranlux48; Rndm.............. 5.000 100.000 5.000 10.000 10.000 10.000 10.000 25.000 35.000 20.000 200.000; ; RndmArray......... 5.000 50.000 5.000 5.000 10.000 5.000 10.000 20.000 30.000 20.000 200.000; Gaus.............. 25.000 150.000 30.000 30.000 40.000 40.000 35.000 60.000 70.000 45.000; Rannor............ 25.000 100.000 30.000 30.000 35.000 35.000 35.000 45.000 55.000 45.000; Landau............ 15.000 100.000 15.000 20.000; Exponential....... 15.000 100.000 15.000 20.000; Binomial(5,0.5)... 20.000 450.000 30.000 35.000; Binomial(15,0.5).. 60.000 1300.000 80.000 80.000; Poisson(3)........ 45.000 400.000 50.000 50.000; Poisson(10)....... 75.000 950.000 85.000 85.000; Poisson(70)....... 250.000 550.000 255.000 260.000; Poisson(100)...... 250.000 550.000 255.000 260.000; GausTF1........... 50.000 130.000 65.000 55.000; Lan",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:1946,Testability,test,testrandom,1946,"Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN........ 40.000 139.000 41.000 44.000; PoissonUNURAN(10). 85.000 271.000 92.000 102.000; PoissonUNURAN(100) 62.000 256.000 69.000 78.000; TRandom1The Ranlux Random number generator class.Definition TRandom1.h:27; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; Note that this tutorial can be executed in interpreted or compiled mode; Root > .x testrandom.C; Root > .x testrandom.C++; ; Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3 MixMax240 MixMax17 Mixmax256_0 MixMax256_2 MixMax256_4 MT_64 Ranlux48; Rndm.............. 5.000 100.000 5.000 10.000 10.000 10.000 10.000 25.000 35.000 20.000 200.000; ; RndmArray......... 5.000 50.000 5.000 5.000 10.000 5.000 10.000 20.000 30.000 20.000 200.000; Gaus.............. 25.000 150.000 30.000 30.000 40.000 40.000 35.000 60.000 70.000 45.000; Rannor............ 25.000 100.000 30.000 30.000 35.000 35.000 35.000 45.000 55.000 45.000; Landau............ 15.000 100.000 15.000 20.000; Exponential....... 15.000 100.000 15.000 20.000; Binomial(5,0.5)... 20.000 450.000 30.000 35.000; Binomial(15,0.5).. 60.000 1300.000 80.000 80.000; Poisson(3)........ 45.000 400.000 50.000 50.000; Poisson(10)....... 75.000 950.000 85.000 85.000; Poisson(70)....... 250.000 550.000 255.000 260.000; Poisson(100)...... 250.000 550.000 255.000 260.000; GausTF1........... 50.000 130.000 65.000 55.000; LandauTF1......... 50.000 1",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:3395,Testability,test,testAll,3395,"0 30.000 30.000 35.000 35.000 35.000 45.000 55.000 45.000; Landau............ 15.000 100.000 15.000 20.000; Exponential....... 15.000 100.000 15.000 20.000; Binomial(5,0.5)... 20.000 450.000 30.000 35.000; Binomial(15,0.5).. 60.000 1300.000 80.000 80.000; Poisson(3)........ 45.000 400.000 50.000 50.000; Poisson(10)....... 75.000 950.000 85.000 85.000; Poisson(70)....... 250.000 550.000 255.000 260.000; Poisson(100)...... 250.000 550.000 255.000 260.000; GausTF1........... 50.000 130.000 65.000 55.000; LandauTF1......... 50.000 135.000 55.000 55.000; GausUNURAN........ 20.000 110.000 25.000 20.000; PoissonUNURAN(10). 50.000 200.000 55.000 55.000; PoissonUNURAN(100) 45.000 205.000 50.000 50.000; ; #include <TRandom1.h>; #include <TRandom2.h>; #include <TRandom3.h>; #include <TRandomGen.h>; #include <TStopwatch.h>; #include <TF1.h>; #if __has_include(""TUnuran.h"") // handy check; #include <TUnuran.h>; #include <TUnuranContDist.h>; #endif; #include <TFile.h>; ; ; void testAll() {; int i, N = 2000000;; float cpn = 1000000000./N;; int N1 = N/10; float cpn1 = cpn*10; // for TRandom1; double x,y;; TRandom *rsave = gRandom;; TRandom *r0 = new TRandom();; TRandom *r1 = new TRandom1();; TRandom *r2 = new TRandom2();; TRandom *r3 = new TRandom3();; TRandom *r4 = new TRandomMixMax();; TRandom *r5 = new TRandomMixMax17();; TRandom *r6 = new TRandomGen<ROOT::Math::MixMaxEngine<256,0>>();; TRandom *r7 = new TRandomMixMax256();; TRandom *r8 = new TRandomGen<ROOT::Math::MixMaxEngine<256,4>>();; TRandom *r9 = new TRandomMT64();; TRandom *r10 = new TRandomRanlux48();; ; ; TStopwatch sw;; printf(""Distribution nanoseconds/call\n"");; printf("" TRandom TRandom1 TRandom2 TRandom3 MixMax240 MixMax17 Mixmax256_0 MixMax256_2 MixMax256_4 MT_64 Ranlux48\n"");; ; sw.Start();; for (i=0;i<N;i++) {; x = r0->Rndm(i);; }; printf(""Rndm.............. %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N1;i++) {; x = r1->Rndm(i);; }; printf("" %8.3f"",sw.CpuTime()*cpn1);; sw.Start();; for (i=0;i<N;i++) {; x = ",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:12668,Testability,test,test,12668," r0;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf(""GausTF1........... %8.3f"",sw.CpuTime()*cpn);; gRandom = r1;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r2;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r3;; sw.Start();; for (i=0;i<N;i++) {; x = f1->GetRandom();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; TF1 *f2 = new TF1(""f2"",""landau"",-5,15);; f2->SetParameters(1,0,1);; ; gRandom = r0;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf(""LandauTF1......... %8.3f"",sw.CpuTime()*cpn);; gRandom = r1;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r2;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; gRandom = r3;; sw.Start();; for (i=0;i<N;i++) {; x = f2->GetRandom();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; // test using Unuran; #if __has_include(""TUnuran.h""); TUnuran unr0(r0);; TUnuran unr1(r1);; TUnuran unr2(r2);; TUnuran unr3(r3);; ; // continuous distribution (ex. Gaus); TUnuranContDist dist(f1);; // use arou method (is probably the fastest); unr0.Init(dist,""arou"");; unr1.Init(dist,""arou"");; unr2.Init(dist,""arou"");; unr3.Init(dist,""arou"");; ; sw.Start();; for (i=0;i<N;i++) {; x = unr0.Sample();; }; printf(""GausUNURAN........ %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr1.Sample();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr2.Sample();; }; printf("" %8.3f"",sw.CpuTime()*cpn);; sw.Start();; for (i=0;i<N;i++) {; x = unr3.Sample();; }; printf("" %8.3f\n"",sw.CpuTime()*cpn);; ; // Poisson (need to initialize before with Poisson mu value); ; unr0.InitPoisson(10);; unr1.InitPoisson(10);; unr2.InitPoisson(10);; unr3.InitPoisson(10);; ; sw.Start();; for (i=0;i<N;i++) {; x = unr0.SampleDiscr();; }; printf(""PoissonUNURAN(10). %8.3f"",sw.CpuTime()*cpn);; s",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:29154,Testability,test,testrandom,29154,"618265, 0.749305866, 0.86126694,0.0346994482,0.0931224583, 0.655257095,; 0.959517847, 0.487057231, 0.859895745, 0.084794421, 0.718541715, 0.850918328, 0.818884782, 0.71627446,; 0.40822393, 0.63658567, 0.523838703, 0.372038872, 0.353426097, 0.598049047,0.0974868746, 0.276353038; };; ; Int_t rc1 = 0;; Int_t rc2 = 0;; TRandom3 r(4357);; Float_t x;; Int_t i;; ; // check whether the sequence is ok or not; for (i=0;i<1000;i++) {; x = r.Rndm();; // printf(""%e "",x-RefValue[i]); if(i%8==7) printf(""\n"");; if (TMath::Abs(x-RefValue[i]) > 10e-8) {; printf(""i=%d x=%.8f but should be %.8f\n"",i,x,RefValue[i]);; rc1 += 1;; }; }; ; // check whether a state can be saved and restored; TFile *file = new TFile(""random3.root"",""RECREATE"");; file->SetCompressionLevel(0);; r.Write(""r"");; delete file;; file = new TFile(""random3.root"");; TRandom3 *rs = (TRandom3*) file->Get(""r"");; for (i=0;i<1000;i++) {; if (r.Rndm() - rs->Rndm() != 0) rc2 += 1;; }; if (rc2 != 0) printf(""state restoration failed\n"");; ; return rc1 + rc2;; }; ; ; void testrandom(); {; testRandom3();; testAll();; }; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TF1.h; TFile.h; N#define N; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom1.h; TRandom2.h; TRandom3.h; TRandomGen.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStopwatch.h; TUnuranContDist.h; TUnuran.h; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TF11-Dim function classDefinition TF1.h:233; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; TF1::SetP",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:29187,Testability,test,testAll,29187,"618265, 0.749305866, 0.86126694,0.0346994482,0.0931224583, 0.655257095,; 0.959517847, 0.487057231, 0.859895745, 0.084794421, 0.718541715, 0.850918328, 0.818884782, 0.71627446,; 0.40822393, 0.63658567, 0.523838703, 0.372038872, 0.353426097, 0.598049047,0.0974868746, 0.276353038; };; ; Int_t rc1 = 0;; Int_t rc2 = 0;; TRandom3 r(4357);; Float_t x;; Int_t i;; ; // check whether the sequence is ok or not; for (i=0;i<1000;i++) {; x = r.Rndm();; // printf(""%e "",x-RefValue[i]); if(i%8==7) printf(""\n"");; if (TMath::Abs(x-RefValue[i]) > 10e-8) {; printf(""i=%d x=%.8f but should be %.8f\n"",i,x,RefValue[i]);; rc1 += 1;; }; }; ; // check whether a state can be saved and restored; TFile *file = new TFile(""random3.root"",""RECREATE"");; file->SetCompressionLevel(0);; r.Write(""r"");; delete file;; file = new TFile(""random3.root"");; TRandom3 *rs = (TRandom3*) file->Get(""r"");; for (i=0;i<1000;i++) {; if (r.Rndm() - rs->Rndm() != 0) rc2 += 1;; }; if (rc2 != 0) printf(""state restoration failed\n"");; ; return rc1 + rc2;; }; ; ; void testrandom(); {; testRandom3();; testAll();; }; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TF1.h; TFile.h; N#define N; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom1.h; TRandom2.h; TRandom3.h; TRandomGen.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStopwatch.h; TUnuranContDist.h; TUnuran.h; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TF11-Dim function classDefinition TF1.h:233; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; TF1::SetP",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testrandom_8C.html:33994,Testability,test,testrandom,33994,"ing to the binomial law.Definition TRandom.cxx:212; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::CpuTimeDouble_t CpuTime()Stop the stopwatch (if it is running) and return the cputime (in seconds) passed between the start an...Definition TStopwatch.cxx:125; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranTUnuran class.Definition TUnuran.h:79; TRandomMixMaxTRandomGen< ROOT::Math::MixMaxEngine< 240, 0 > > TRandomMixMaxMIXMAX generator based on a state of N=240.Definition TRandomGen.h:105; TRandomMT64TRandomGen< ROOT::Math::StdEngine< std::mt19937_64 > > TRandomMT64Generator based on a the Mersenne-Twister generator with 64 bits, using the implementation provided b...Definition TRandomGen.h:141; TRandomMixMax256TRandomGen< ROOT::Math::MixMaxEngine< 256, 2 > > TRandomMixMax256MIXMAX generator based on a state of N=256, based on the generator described in this paper:Definition TRandomGen.h:130; TRandomMixMax17TRandomGen< ROOT::Math::MixMaxEngine< 17, 0 > > TRandomMixMax17MIXMAX generator based on a state of N=17.Definition TRandomGen.h:116; TRandomRanlux48TRandomGen< ROOT::Math::StdEngine< std::ranlux48 > > TRandomRanlux48Generator based on a the RanLux generator with 48 bits, using the implementation provided by the stan...Definition TRandomGen.h:149; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; ROOT::Math::gv_detail::distdouble dist(Rotation3D const &r1, Rotation3D const &r2)Definition 3DDistances.cxx:48; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; AuthorsRene Brun, Lorenzo Moneta ; Definition in file testrandom.C. tutorialsmathtestrandom.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testrandom_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testrandom_8C.html
https://root.cern/doc/master/testSmooth_8C.html:1941,Availability,error,error,1941," histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrid",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:23,Testability,test,testSmooth,23,". ROOT: tutorials/hist/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefi",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:133,Testability,test,testSmooth,133,". ROOT: tutorials/hist/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefi",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:750,Testability,test,testSmooth,750,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:853,Testability,test,test,853,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:920,Testability,test,test,920,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:1071,Testability,test,test,1071,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:1136,Testability,test,test,1136,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:1277,Testability,test,test,1277,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:1342,Testability,test,test,1342,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:1551,Testability,test,testSmooth,1551,"/testSmooth.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. testSmooth.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Histogram smoothing. . ; int ipad = 1;; TCanvas * c1 = 0;; ; void smooth_hist(const char * fname, double xmin, double xmax, int n1, int n2) {; ; std::cout << ""smoothing a "" << fname << "" histogram"" << std::endl;; ; TH1D * h1 = new TH1D(""h1"",""h1"",100,xmin,xmax);; TH1D * h2 = new TH1D(""h2"",""h2"",100,xmin,xmax);; h1->FillRandom(fname,n1);; ; TH1D * h1_s = new TH1D(*h1);; h1_s->SetName(""h1_s"");; h1_s->Smooth();; ; h2->FillRandom(fname,n2);; ; double p1 = h1->Chi2Test(h2,"""");; double p2 = h1_s->Chi2Test(h2,""UU"");; if (p2 < p1) Error(""testSmooth"",""TH1::Smooth is not working correctly - a worst chi2 is obtained"");; ; std::cout << "" chi2 test non-smoothed histo "" << p1 << std::endl;; std::cout << "" chi2 test smoothed histo "" << p2 << std::endl;; ; double a1 = h1->AndersonDarlingTest(h2);; double a2 = h1_s->AndersonDarlingTest(h2);; ; std::cout << "" AD test non-smoothed histo "" << a1 << std::endl;; std::cout << "" AD test smoothed histo "" << a2 << std::endl;; ; double k1 = h1->KolmogorovTest(h2);; double k2 = h1_s->KolmogorovTest(h2);; ; std::cout << "" KS test non-smoothed histo "" << k1 << std::endl;; std::cout << "" KS test smoothed histo "" << k2 << std::endl;; ; c1->cd(ipad++);; h1->Draw(""E"");; h1_s->SetLineColor(kRed);; h1_s->Draw(""same"");; h2->Scale(double(n1)/n2);; h2->SetLineColor(kGreen);; h2->Draw(""same"");; }; ; void testSmooth(int n1 = 1000, int n2 = 1000000) {; ; TH1::AddDirectory(false);; ; c1 = new TCanvas();; c1->Divide(1,3);; ; ; smooth_hist(""gaus"",-5,5,n1,n2);; smooth_hist(""landau"",-5,15,n1,n2);; smooth_hist(""expo"",-5,0,n1,n2);; ; }; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:3108,Testability,test,test,3108,"ar *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::Chi2Testvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; AuthorRene Brun ; Definition in file testSmooth.C. tutorialshisttestSmooth.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:3513,Testability,test,test,3513,"ar *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::Chi2Testvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; AuthorRene Brun ; Definition in file testSmooth.C. tutorialshisttestSmooth.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:3592,Testability,test,test,3592,"ar *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::Chi2Testvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; AuthorRene Brun ; Definition in file testSmooth.C. tutorialshisttestSmooth.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/testSmooth_8C.html:3730,Testability,test,testSmooth,3730,"ar *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::AddDirectorystatic void AddDirectory(Bool_t add=kTRUE)Sets the flag controlling the automatic add of histograms in memory.Definition TH1.cxx:1294; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::AndersonDarlingTestvirtual Double_t AndersonDarlingTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling ...Definition TH1.cxx:8062; TH1::Chi2Testvirtual Double_t Chi2Test(const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) consttest for comparing weighted and unweighted histograms.Definition TH1.cxx:2008; TH1::KolmogorovTestvirtual Double_t KolmogorovTest(const TH1 *h2, Option_t *option="""") constStatistical test of compatibility in shape between this histogram and h2, using Kolmogorov test.Definition TH1.cxx:8178; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; AuthorRene Brun ; Definition in file testSmooth.C. tutorialshisttestSmooth.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/testSmooth_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/testSmooth_8C.html
https://root.cern/doc/master/TEventList_8cxx_source.html:21779,Availability,error,error,21779,"errideChange the name of this TEventList.Definition TEventList.cxx:367; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347. treetreesrcTEventList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:22242,Availability,down,down,22242,"errideChange the name of this TEventList.Definition TEventList.cxx:367; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347. treetreesrcTEventList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:5007,Deployability,update,updated,5007,"nullptr;; 104}; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// Default destructor for a EventList.; 108 ; 109TEventList::~TEventList(); 110{; 111 delete [] fList; fList = nullptr;; 112 if (fDirectory) fDirectory->Remove(this);; 113 fDirectory = nullptr;; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Merge contents of alist with this list.; 118///; 119/// Both alist and this list are assumed to be sorted prior to this call; 120 ; 121void TEventList::Add(const TEventList *alist); 122{; 123 Int_t i;; 124 Int_t an = alist->GetN();; 125 if (!an) return;; 126 Long64_t *alst = alist->GetList();; 127 if (!fList) {; 128 fList = new Long64_t[an];; 129 for (i=0;i<an;i++) fList[i] = alst[i];; 130 fN = an;; 131 fSize = an;; 132 return;; 133 }; 134 Int_t newsize = fN + an;; 135 Long64_t *newlist = new Long64_t[newsize];; 136 Int_t newpos, alpos;; 137 newpos = alpos = 0;; 138 for (i=0;i<fN;i++) {; 139 while (alpos < an && fList[i] > alst[alpos]) {; 140 newlist[newpos] = alst[alpos];; 141 newpos++;; 142 alpos++;; 143 }; 144 if (alpos < an && fList[i] == alst[alpos]) alpos++;; 145 newlist[newpos] = fList[i];; 146 newpos++;; 147 }; 148 while (alpos < an) {; 149 newlist[newpos] = alst[alpos];; 150 newpos++;; 151 alpos++;; 152 }; 153 delete [] fList;; 154 fN = newpos;; 155 fSize = newsize;; 156 fList = newlist;; 157 ; 158 TCut orig = GetTitle();; 159 TCut added = alist->GetTitle();; 160 TCut updated = orig || added;; 161 SetTitle(updated.GetTitle());; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////; 165/// Return TRUE if list contains entry.; 166 ; 167bool TEventList::Contains(Long64_t entry); 168{; 169 if (GetIndex(entry) < 0) return false;; 170 return true;; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Return TRUE if list contains entries from entrymin to entrymax include",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:5046,Deployability,update,updated,5046,"nullptr;; 104}; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// Default destructor for a EventList.; 108 ; 109TEventList::~TEventList(); 110{; 111 delete [] fList; fList = nullptr;; 112 if (fDirectory) fDirectory->Remove(this);; 113 fDirectory = nullptr;; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Merge contents of alist with this list.; 118///; 119/// Both alist and this list are assumed to be sorted prior to this call; 120 ; 121void TEventList::Add(const TEventList *alist); 122{; 123 Int_t i;; 124 Int_t an = alist->GetN();; 125 if (!an) return;; 126 Long64_t *alst = alist->GetList();; 127 if (!fList) {; 128 fList = new Long64_t[an];; 129 for (i=0;i<an;i++) fList[i] = alst[i];; 130 fN = an;; 131 fSize = an;; 132 return;; 133 }; 134 Int_t newsize = fN + an;; 135 Long64_t *newlist = new Long64_t[newsize];; 136 Int_t newpos, alpos;; 137 newpos = alpos = 0;; 138 for (i=0;i<fN;i++) {; 139 while (alpos < an && fList[i] > alst[alpos]) {; 140 newlist[newpos] = alst[alpos];; 141 newpos++;; 142 alpos++;; 143 }; 144 if (alpos < an && fList[i] == alst[alpos]) alpos++;; 145 newlist[newpos] = fList[i];; 146 newpos++;; 147 }; 148 while (alpos < an) {; 149 newlist[newpos] = alst[alpos];; 150 newpos++;; 151 alpos++;; 152 }; 153 delete [] fList;; 154 fN = newpos;; 155 fSize = newsize;; 156 fList = newlist;; 157 ; 158 TCut orig = GetTitle();; 159 TCut added = alist->GetTitle();; 160 TCut updated = orig || added;; 161 SetTitle(updated.GetTitle());; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////; 165/// Return TRUE if list contains entry.; 166 ; 167bool TEventList::Contains(Long64_t entry); 168{; 169 if (GetIndex(entry) < 0) return false;; 170 return true;; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Return TRUE if list contains entries from entrymin to entrymax include",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:8611,Deployability,update,updated,8611,"n the list of element with value entry; 236/// array is supposed to be sorted prior to this call.; 237/// If match is found, function returns position of element.; 238/// If no match found, function returns -1.; 239 ; 240Int_t TEventList::GetIndex(Long64_t entry) const; 241{; 242 Long64_t nabove, nbelow, middle;; 243 nabove = fN+1;; 244 nbelow = 0;; 245 while(nabove-nbelow > 1) {; 246 middle = (nabove+nbelow)/2;; 247 if (entry == fList[middle-1]) return middle-1;; 248 if (entry < fList[middle-1]) nabove = middle;; 249 else nbelow = middle;; 250 }; 251 return -1;; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// Remove elements from this list that are NOT present in alist.; 256 ; 257void TEventList::Intersect(const TEventList *alist); 258{; 259 if (!alist) return;; 260 if (!fList) return;; 261 ; 262 Long64_t *newlist = new Long64_t[fN];; 263 Int_t newpos = 0;; 264 Int_t i;; 265 for (i=0;i<fN;i++) {; 266 if (alist->GetIndex(fList[i]) >= 0) {; 267 newlist[newpos] = fList[i];; 268 newpos++;; 269 }; 270 }; 271 delete [] fList;; 272 fN = newpos;; 273 fList = newlist;; 274 ; 275 TCut orig = GetTitle();; 276 TCut removed = alist->GetTitle();; 277 TCut updated = orig && removed;; 278 SetTitle(updated.GetTitle());; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Merge entries in all the TEventList in the collection in this event list.; 283 ; 284Int_t TEventList::Merge(TCollection *list); 285{; 286 if (!list) return -1;; 287 TIter next(list);; 288 ; 289 //first loop to count the number of entries; 290 TEventList *el;; 291 Int_t nevents = 0;; 292 while ((el = (TEventList*)next())) {; 293 if (!el->InheritsFrom(TEventList::Class())) {; 294 Error(""Add"",""Attempt to add object of class: %s to a %s"",el->ClassName(),this->ClassName());; 295 return -1;; 296 }; 297 Add(el);; 298 nevents += el->GetN();; 299 }; 300 ; 301 return nevents;; 302}; 303 ; 304////////////////////////////",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:8652,Deployability,update,updated,8652,"n the list of element with value entry; 236/// array is supposed to be sorted prior to this call.; 237/// If match is found, function returns position of element.; 238/// If no match found, function returns -1.; 239 ; 240Int_t TEventList::GetIndex(Long64_t entry) const; 241{; 242 Long64_t nabove, nbelow, middle;; 243 nabove = fN+1;; 244 nbelow = 0;; 245 while(nabove-nbelow > 1) {; 246 middle = (nabove+nbelow)/2;; 247 if (entry == fList[middle-1]) return middle-1;; 248 if (entry < fList[middle-1]) nabove = middle;; 249 else nbelow = middle;; 250 }; 251 return -1;; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// Remove elements from this list that are NOT present in alist.; 256 ; 257void TEventList::Intersect(const TEventList *alist); 258{; 259 if (!alist) return;; 260 if (!fList) return;; 261 ; 262 Long64_t *newlist = new Long64_t[fN];; 263 Int_t newpos = 0;; 264 Int_t i;; 265 for (i=0;i<fN;i++) {; 266 if (alist->GetIndex(fList[i]) >= 0) {; 267 newlist[newpos] = fList[i];; 268 newpos++;; 269 }; 270 }; 271 delete [] fList;; 272 fN = newpos;; 273 fList = newlist;; 274 ; 275 TCut orig = GetTitle();; 276 TCut removed = alist->GetTitle();; 277 TCut updated = orig && removed;; 278 SetTitle(updated.GetTitle());; 279}; 280 ; 281////////////////////////////////////////////////////////////////////////////////; 282/// Merge entries in all the TEventList in the collection in this event list.; 283 ; 284Int_t TEventList::Merge(TCollection *list); 285{; 286 if (!list) return -1;; 287 TIter next(list);; 288 ; 289 //first loop to count the number of entries; 290 TEventList *el;; 291 Int_t nevents = 0;; 292 while ((el = (TEventList*)next())) {; 293 if (!el->InheritsFrom(TEventList::Class())) {; 294 Error(""Add"",""Attempt to add object of class: %s to a %s"",el->ClassName(),this->ClassName());; 295 return -1;; 296 }; 297 Add(el);; 298 nevents += el->GetN();; 299 }; 300 ; 301 return nevents;; 302}; 303 ; 304////////////////////////////",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:11465,Deployability,update,update,11465,"ew directory dir. dir can be 0 in which case the list; 354/// does not belong to any directory.; 355 ; 356void TEventList::SetDirectory(TDirectory *dir); 357{; 358 if (fDirectory == dir) return;; 359 if (fDirectory) fDirectory->Remove(this);; 360 fDirectory = dir;; 361 if (fDirectory) fDirectory->Append(this);; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Change the name of this TEventList.; 366 ; 367void TEventList::SetName(const char *name); 368{; 369 // TEventLists are named objects in a THashList.; 370 // We must update the hashlist if we change the name; 371 if (fDirectory) fDirectory->Remove(this);; 372 fName = name;; 373 if (fDirectory) fDirectory->Append(this);; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Sort list entries in increasing order; 378 ; 379void TEventList::Sort(); 380{; 381 Int_t *index = new Int_t[fN];; 382 Long64_t *newlist = new Long64_t[fSize];; 383 Int_t i,ind;; 384 TMath::Sort(fN,fList,index); //sort in decreasing order; 385 for (i=0;i<fN;i++) {; 386 ind = index[fN-i-1];; 387 newlist[i] = fList[ind];; 388 }; 389 for (i=fN;i<fSize;i++) {; 390 newlist[i] = 0;; 391 }; 392 delete [] index;; 393 delete [] fList;; 394 fList = newlist;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Stream an object of class TEventList.; 399 ; 400void TEventList::Streamer(TBuffer &b); 401{; 402 if (b.IsReading()) {; 403 UInt_t R__s, R__c;; 404 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 405 fDirectory = nullptr;; 406 if (R__v > 1) {; 407 b.ReadClassBuffer(TEventList::Class(), this, R__v, R__s, R__c);; 408 ResetBit(kMustCleanup);; 409 return;; 410 }; 411 //====process old versions before automatic schema evolution; 412 TNamed::Streamer(b);; 413 b >> fN;; 414 b >> fSize;; 415 b >> fDelta;; 416 if (fN) {; 417 Int_t *tlist = new Int_t[fSize];; 418 b.ReadFastArray(tlist,fN);; 419 fList = new ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:13815,Deployability,update,updated,13815,"tBit(kMustCleanup);; 409 return;; 410 }; 411 //====process old versions before automatic schema evolution; 412 TNamed::Streamer(b);; 413 b >> fN;; 414 b >> fSize;; 415 b >> fDelta;; 416 if (fN) {; 417 Int_t *tlist = new Int_t[fSize];; 418 b.ReadFastArray(tlist,fN);; 419 fList = new Long64_t[fSize];; 420 for (Int_t i=0;i<fN;i++) fList[i] = tlist[i];; 421 delete [] tlist;; 422 }; 423 ResetBit(kMustCleanup);; 424 b.CheckByteCount(R__s, R__c, TEventList::IsA());; 425 //====end of old versions; 426 ; 427 } else {; 428 b.WriteClassBuffer(TEventList::Class(), this);; 429 }; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Remove elements from this list that are present in alist.; 434 ; 435void TEventList::Subtract(const TEventList *alist); 436{; 437 if (!alist) return;; 438 if (!fList) return;; 439 ; 440 Long64_t *newlist = new Long64_t[fN];; 441 Int_t newpos = 0;; 442 Int_t i;; 443 for (i=0;i<fN;i++) {; 444 if (alist->GetIndex(fList[i]) < 0) {; 445 newlist[newpos] = fList[i];; 446 newpos++;; 447 }; 448 }; 449 delete [] fList;; 450 fN = newpos;; 451 fList = newlist;; 452 ; 453 TCut orig = GetTitle();; 454 TCut removed = alist->GetTitle();; 455 TCut updated = orig && !removed;; 456 SetTitle(updated.GetTitle());; 457}; 458 ; 459////////////////////////////////////////////////////////////////////////////////; 460/// Assingment.; 461 ; 462TEventList& TEventList::operator=(const TEventList &list); 463{; 464 if (this != &list) {; 465 TNamed::operator=(list);; 466 if (fSize < list.fSize) {; 467 delete [] fList;; 468 fList = new Long64_t[list.fSize];; 469 }; 470 fN = list.fN;; 471 fSize = list.fSize;; 472 fDelta = list.fDelta;; 473 for (Int_t i=0; i<fN; i++); 474 fList[i] = list.fList[i];; 475 }; 476 return *this;; 477}; 478 ; 479////////////////////////////////////////////////////////////////////////////////; 480/// Addition.; 481 ; 482TEventList operator+(const TEventList &list1, const TEventList &list2); 483{; 484 TEventLis",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:13857,Deployability,update,updated,13857,"tBit(kMustCleanup);; 409 return;; 410 }; 411 //====process old versions before automatic schema evolution; 412 TNamed::Streamer(b);; 413 b >> fN;; 414 b >> fSize;; 415 b >> fDelta;; 416 if (fN) {; 417 Int_t *tlist = new Int_t[fSize];; 418 b.ReadFastArray(tlist,fN);; 419 fList = new Long64_t[fSize];; 420 for (Int_t i=0;i<fN;i++) fList[i] = tlist[i];; 421 delete [] tlist;; 422 }; 423 ResetBit(kMustCleanup);; 424 b.CheckByteCount(R__s, R__c, TEventList::IsA());; 425 //====end of old versions; 426 ; 427 } else {; 428 b.WriteClassBuffer(TEventList::Class(), this);; 429 }; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Remove elements from this list that are present in alist.; 434 ; 435void TEventList::Subtract(const TEventList *alist); 436{; 437 if (!alist) return;; 438 if (!fList) return;; 439 ; 440 Long64_t *newlist = new Long64_t[fN];; 441 Int_t newpos = 0;; 442 Int_t i;; 443 for (i=0;i<fN;i++) {; 444 if (alist->GetIndex(fList[i]) < 0) {; 445 newlist[newpos] = fList[i];; 446 newpos++;; 447 }; 448 }; 449 delete [] fList;; 450 fN = newpos;; 451 fList = newlist;; 452 ; 453 TCut orig = GetTitle();; 454 TCut removed = alist->GetTitle();; 455 TCut updated = orig && !removed;; 456 SetTitle(updated.GetTitle());; 457}; 458 ; 459////////////////////////////////////////////////////////////////////////////////; 460/// Assingment.; 461 ; 462TEventList& TEventList::operator=(const TEventList &list); 463{; 464 if (this != &list) {; 465 TNamed::operator=(list);; 466 if (fSize < list.fSize) {; 467 delete [] fList;; 468 fList = new Long64_t[list.fSize];; 469 }; 470 fN = list.fN;; 471 fSize = list.fSize;; 472 fDelta = list.fDelta;; 473 for (Int_t i=0; i<fN; i++); 474 fList[i] = list.fList[i];; 475 }; 476 return *this;; 477}; 478 ; 479////////////////////////////////////////////////////////////////////////////////; 480/// Addition.; 481 ; 482TEventList operator+(const TEventList &list1, const TEventList &list2); 483{; 484 TEventLis",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:17067,Integrability,interface,interface,17067,"Proxy.cxx:44; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TList.h; TMath.h; snprintf#define snprintfDefinition civetweb.c:1540; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::fListLong64_t * fList[fN]Array of elementsDefinition TEventList.h:38; TEventList::Classstatic TClass * Class(); TEventList::~TEventList~TEventList() overrideDefault destructor for a EventList.Definition TEventList.cxx:109; TEventList::Streamervoid Streamer(TBuffer &) overrideStream an object of class TEventList.Definition TEventList.cxx:400; TEventList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEventList.h:37; TEventList::TEventListTEventList()Default constructor for a EventList.Definition TEventList.cxx:63; TEventList::Resetvirtual void Reset(Option_t *option="""")Reset number of entries in event list.Definition TEventList.cxx:333; TEventList::ContainsRangevirtual bool ContainsRange(Long64_t entrymin, Long64_t entrymax)Return TRUE if list contains entries from entrymin to entrymax included.Definition TEventList.cxx:176; TEventList::fDirectory",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:21785,Integrability,message,message,21785,"errideChange the name of this TEventList.Definition TEventList.cxx:367; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347. treetreesrcTEventList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:21631,Modifiability,inherit,inherits,21631,"ntList::SetNamevoid SetName(const char *name) overrideChange the name of this TEventList.Definition TEventList.cxx:367; TIterDefinition TCollection.h:235; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347. treetreesrcTEventList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 202",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8cxx_source.html:11476,Security,hash,hashlist,11476,"ew directory dir. dir can be 0 in which case the list; 354/// does not belong to any directory.; 355 ; 356void TEventList::SetDirectory(TDirectory *dir); 357{; 358 if (fDirectory == dir) return;; 359 if (fDirectory) fDirectory->Remove(this);; 360 fDirectory = dir;; 361 if (fDirectory) fDirectory->Append(this);; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Change the name of this TEventList.; 366 ; 367void TEventList::SetName(const char *name); 368{; 369 // TEventLists are named objects in a THashList.; 370 // We must update the hashlist if we change the name; 371 if (fDirectory) fDirectory->Remove(this);; 372 fName = name;; 373 if (fDirectory) fDirectory->Append(this);; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Sort list entries in increasing order; 378 ; 379void TEventList::Sort(); 380{; 381 Int_t *index = new Int_t[fN];; 382 Long64_t *newlist = new Long64_t[fSize];; 383 Int_t i,ind;; 384 TMath::Sort(fN,fList,index); //sort in decreasing order; 385 for (i=0;i<fN;i++) {; 386 ind = index[fN-i-1];; 387 newlist[i] = fList[ind];; 388 }; 389 for (i=fN;i<fSize;i++) {; 390 newlist[i] = 0;; 391 }; 392 delete [] index;; 393 delete [] fList;; 394 fList = newlist;; 395}; 396 ; 397////////////////////////////////////////////////////////////////////////////////; 398/// Stream an object of class TEventList.; 399 ; 400void TEventList::Streamer(TBuffer &b); 401{; 402 if (b.IsReading()) {; 403 UInt_t R__s, R__c;; 404 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 405 fDirectory = nullptr;; 406 if (R__v > 1) {; 407 b.ReadClassBuffer(TEventList::Class(), this, R__v, R__s, R__c);; 408 ResetBit(kMustCleanup);; 409 return;; 410 }; 411 //====process old versions before automatic schema evolution; 412 TNamed::Streamer(b);; 413 b >> fN;; 414 b >> fSize;; 415 b >> fDelta;; 416 if (fN) {; 417 Int_t *tlist = new Int_t[fSize];; 418 b.ReadFastArray(tlist,fN);; 419 fList = new ",MatchSource.WIKI,doc/master/TEventList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8cxx_source.html
https://root.cern/doc/master/TEventList_8h_source.html:4078,Integrability,interface,interface,4078,"st2);; 75 friend TEventList operator*(const TEventList &list1, const TEventList &list2);; 76 ; 77 ClassDefOverride(TEventList,4); //A list of selected entries in a TTree.; 78};; 79 ; 80#endif; 81 ; Int_tint Int_tDefinition RtypesCore.h:45; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::SetReapplyCutvirtual void SetReapplyCut(bool apply=false)Definition TEventList.h:67; TEventList::fListLong64_t * fList[fN]Array of elementsDefinition TEventList.h:38; TEventList::~TEventList~TEventList() overrideDefault destructor for a EventList.Definition TEventList.cxx:109; TEventList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEventList.h:37; TEventList::TEventListTEventList()Default constructor for a EventList.Definition TEventList.cxx:63; TEventList::Resetvirtual void Reset(Option_t *option="""")Reset number of entries in event list.Definition TEventList.cxx:333; TEventList::ContainsRangevirtual bool ContainsRange(Long64_t entrymin, Long64_t entrymax)Return TRUE if list contains entries from entrymin to entrymax included.Definition TEventList.cxx:176; TEventList::operator-friend TEventList operator-(const TEventList &list1, const TEventList",MatchSource.WIKI,doc/master/TEventList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEventList_8h_source.html
https://root.cern/doc/master/TExec_8h.html:190,Integrability,depend,dependency,190,". ROOT: core/base/inc/TExec.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TExec.h File Reference. #include ""TNamed.h"". Include dependency graph for TExec.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  . corebaseincTExec.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TExec_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TExec_8h.html
https://root.cern/doc/master/textalign_8C_source.html:1654,Usability,simpl,simple,1654,"olor(kBlue);; 8 lv.DrawLine(0.33,0.0,0.33,1.0);; 9 lv.DrawLine(0.6,0.165,1.,0.165);; 10 lv.DrawLine(0.6,0.493,1.,0.493);; 11 lv.DrawLine(0.6,0.823,1.,0.823);; 12 ; 13 // Horizontal alignment.; 14 auto *th1 = new TText(0.33,0.165,""Left adjusted"");; 15 th1->SetTextAlign(11); th1->SetTextSize(0.12);; 16 th1->Draw();; 17 ; 18 auto *th2 = new TText(0.33,0.493,""Center adjusted"");; 19 th2->SetTextAlign(21); th2->SetTextSize(0.12);; 20 th2->Draw();; 21 ; 22 auto *th3 = new TText(0.33,0.823,""Right adjusted"");; 23 th3->SetTextAlign(31); th3->SetTextSize(0.12);; 24 th3->Draw();; 25 ; 26 // Vertical alignment.; 27 auto *tv1 = new TText(0.66,0.165,""Bottom adjusted"");; 28 tv1->SetTextAlign(11); tv1->SetTextSize(0.12);; 29 tv1->Draw();; 30 ; 31 auto *tv2 = new TText(0.66,0.493,""Center adjusted"");; 32 tv2->SetTextAlign(12); tv2->SetTextSize(0.12);; 33 tv2->Draw();; 34 ; 35 auto *tv3 = new TText(0.66,0.823,""Top adjusted"");; 36 tv3->SetTextAlign(13); tv3->SetTextSize(0.12);; 37 tv3->Draw();; 38}; kBlue@ kBlueDefinition Rtypes.h:66; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TTextBase class for several text objects.Definition TText.h:22; th3auto * th3Definition textalign.C:22; lvTLine lvDefinition textalign.C:5; tv3auto * tv3Definition textalign.C:35; th2auto * th2Definition textalign.C:18; tv1auto * tv1Definition textalign.C:27; tv2auto * tv2Definition textalign.C:31; th1auto * th1Definition textalign.C:14. corebasedocmacrostextalign.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/textalign_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/textalign_8C_source.html
https://root.cern/doc/master/textangle_8C_source.html:1840,Usability,simpl,simple,1840,"; 16 auto *tt = new TText(0.1,0.1,""Text angle is 45 degrees"");; 17 tt->SetTextAlign(11); tt->SetTextSize(0.1);; 18 tt->SetTextAngle(45);; 19 tt->Draw();; 20 auto *t1 = new TLatex(0.3,0.18,""45^{o}"");; 21 t1->Draw();; 22}; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TArcCreate an Arc.Definition TArc.h:26; TArc::DrawArcvirtual TArc * DrawArc(Double_t x1, Double_t y1, Double_t radius, Double_t phimin=0, Double_t phimax=360, Option_t *option="""")Draw this arc with new coordinates.Definition TArc.cxx:79; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TMarkerManages Markers.Definition TMarker.h:22; TMarker::DrawMarkervirtual TMarker * DrawMarker(Double_t x, Double_t y)Draw this marker with new coordinates.Definition TMarker.cxx:208; TTextBase class for several text objects.Definition TText.h:22; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; aTArc aDefinition textangle.C:12; ttauto * ttDefinition textangle.C:16; t1auto * t1Definition textangle.C:20. corebasedocmacrostextangle.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/textangle_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/textangle_8C_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:1246,Availability,avail,available,1246,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:2769,Availability,error,error,2769,"///////////////////////////////////////////////; 70/// Internal function to initialize data members.; 71/// Use TF1::Copy instead of Clone.; 72 ; 73void TF1Convolution::InitializeDataMembers(TF1* function1, TF1* function2, Bool_t useFFT); 74{; 75 if (function1) {; 76 // functions must be 1d- if not flag an error; 77 if (function1->GetNdim() != 1); 78 Error(""InitializeDataMembers"",""function1 %s is not of dimension 1 "",function1->GetName());; 79 //TF1 * fnew1 = (TF1*) function1->IsA()->New();; 80 // since function1 is a TF1 (cannot be a derived class) we can instantiate it directly; 81 fFunction1 = std::make_unique<TF1> ();; 82 function1->Copy(*fFunction1);; 83 }; 84 if (function2) {; 85 if (function2->GetNdim() != 1); 86 Error(""InitializeDataMembers"",""function2 %s is not of dimension 1 "",function2->GetName());; 87 //TF1 * fnew2 = (TF1*) function2->IsA()->New();; 88 fFunction2 = std::make_unique<TF1>();; 89 function2->Copy(*fFunction2);; 90 }; 91 if (fFunction1 == nullptr|| fFunction2 == nullptr); 92 Fatal(""InitializeDataMembers"",""Invalid functions - Abort"");; 93 ; 94 // Set kNotGlobal bit; 95 fFunction1->SetBit(TF1::kNotGlobal, kTRUE);; 96 fFunction2->SetBit(TF1::kNotGlobal, kTRUE);; 97 ; 98 // use by default range of first function; 99 fFunction1->GetRange(fXmin, fXmax);; 100 // when using FFT add by default an extra 10% on each side; 101 if (useFFT) {; 102 SetExtraRange(fgExtraRangeFraction);; 103 }; 104 fNofParams1 = fFunction1->GetNpar();; 105 fNofParams2 = fFunction2->GetNpar();; 106 fParams1 = std::vector<Double_t>(fNofParams1);; 107 fParams2 = std::vector<Double_t>(fNofParams2);; 108 fCstIndex = (fFunction1->GetParNumber(""Constant"") == -1); 109 ? -1; 110 : fFunction2->GetParNumber(""Constant""); // TODO: add dropConstantParam flag?; 111 fFlagFFT = useFFT;; 112 fFlagGraph = false;; 113 fNofPoints = 10000;; 114 ; 115 fParNames.reserve( fNofParams1 + fNofParams2);; 116 for (int i=0; i<fNofParams1; i++); 117 {; 118 fParams1[i] = fFunction1 -> GetParameter(i);; 119 f",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:10293,Availability,avail,available,10293,"237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Copy constructor (necessary to hold unique_ptr as member variable).; 240 ; 241TF1Convolution::TF1Convolution(const TF1Convolution &conv); 242{; 243 conv.TF1Convolution::Copy(*this);; 244}; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// Operator =; 248 ; 249TF1Convolution &TF1Convolution::operator=(const TF1Convolution &rhs); 250{; 251 if (this != &rhs); 252 rhs.TF1Convolution::Copy(*this);; 253 return *this;; 254}; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Perform the FFT of the two functions.; 258 ; 259void TF1Convolution::MakeFFTConv(); 260{; 261 if (gDebug); 262 Info(""MakeFFTConv"",""Making FFT convolution using %d points in range [%g,%g]"",fNofPoints,fXmin,fXmax);; 263 ; 264 std::vector < Double_t > x (fNofPoints);; 265 std::vector < Double_t > in1(fNofPoints);; 266 std::vector < Double_t > in2(fNofPoints);; 267 ; 268 TVirtualFFT *fft1 = TVirtualFFT::FFT(1, &fNofPoints, ""R2C K"");; 269 TVirtualFFT *fft2 = TVirtualFFT::FFT(1, &fNofPoints, ""R2C K"");; 270 if (fft1 == nullptr || fft2 == nullptr) {; 271 Warning(""MakeFFTConv"",""Cannot use FFT, probably FFTW package is not available. Switch to numerical convolution"");; 272 fFlagFFT = false;; 273 return;; 274 }; 275 ; 276 // apply a shift in order to have the second function centered around middle of the range of the convolution; 277 Double_t shift2 = 0.5*(fXmin+fXmax);; 278 Double_t x2;; 279 for (int i=0; i<fNofPoints; i++); 280 {; 281 x[i] = fXmin + (fXmax-fXmin)/(fNofPoints-1)*i;; 282 x2 = x[i] - shift2;; 283 in1[i] = fFunction1 -> EvalPar( &x[i], nullptr);; 284 in2[i] = fFunction2 -> EvalPar( &x2, nullptr);; 285 fft1 -> SetPoint(i, in1[i]);; 286 fft2 -> SetPoint(i, in2[i]);; 287 }; 288 fft1 -> Transform();; 289 fft2 -> Transform();; 290 ; 291 //inverse transformation of the product; 292 ; 293 TVirtualFFT *fftinverse = T",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:28711,Availability,error,error,28711,"TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFF",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:28847,Availability,error,error,28847,"tr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13003,Deployability,integrat,integrator,13003,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13180,Deployability,integrat,integrator,13180,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13304,Deployability,integrat,integrator,13304,"//////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 Double_t result = 0.;; 372 if (fFlagFFT); 373 result = EvalFFTConv(x[0]);; 374 else; 375 result = EvalNumConv(x[0]);; 376 return result;; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set the number of points used for the FFT convolution.; 381 ;",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13424,Deployability,integrat,integrator,13424,"Conv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 Double_t result = 0.;; 372 if (fFlagFFT); 373 result = EvalFFTConv(x[0]);; 374 else; 375 result = EvalNumConv(x[0]);; 376 return result;; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set the number of points used for the FFT convolution.; 381 ; 382void TF1Convolution::SetNofPointsFFT(Int_t n); 383{; 384 if (n<0) return;; 385 fNofPoints = n;; 386 if (fGraphConv) fG",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13543,Deployability,integrat,integrator,13543,"; 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 Double_t result = 0.;; 372 if (fFlagFFT); 373 result = EvalFFTConv(x[0]);; 374 else; 375 result = EvalNumConv(x[0]);; 376 return result;; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set the number of points used for the FFT convolution.; 381 ; 382void TF1Convolution::SetNofPointsFFT(Int_t n); 383{; 384 if (n<0) return;; 385 fNofPoints = n;; 386 if (fGraphConv) fGraphConv -> Set(fNofPoints);; 387 fFlagGraph = false; // to indicate we need to re-do the graph; 388}; 389 ; 390////////",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:22020,Deployability,integrat,integration,22020,"r const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; TObjArray.h; TObjString.h; TObject.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; TF1Convolution_EvalWrapperDefinition TF1Convolution.cxx:48; TF1Convolution_EvalWrapper::fT0Double_t fT0Definition TF1Convolution.cxx:51; TF1Convolution_EvalWrapper::TF1Convolution_EvalWrapperTF1Convolution_EvalWrapper(TF1 &f1, TF1 &f2, Double_t t)Definition TF1Convolution.cxx:54; TF1Convolution_EvalWrapper::fFunc1TF1 * fFu",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:1049,Integrability,wrap,wrapping,1049,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:1101,Integrability,wrap,wrapping,1101,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13003,Integrability,integrat,integrator,13003,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13180,Integrability,integrat,integrator,13180,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13304,Integrability,integrat,integrator,13304,"//////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 Double_t result = 0.;; 372 if (fFlagFFT); 373 result = EvalFFTConv(x[0]);; 374 else; 375 result = EvalNumConv(x[0]);; 376 return result;; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set the number of points used for the FFT convolution.; 381 ;",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13424,Integrability,integrat,integrator,13424,"Conv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 Double_t result = 0.;; 372 if (fFlagFFT); 373 result = EvalFFTConv(x[0]);; 374 else; 375 result = EvalNumConv(x[0]);; 376 return result;; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set the number of points used for the FFT convolution.; 381 ; 382void TF1Convolution::SetNofPointsFFT(Int_t n); 383{; 384 if (n<0) return;; 385 fNofPoints = n;; 386 if (fGraphConv) fG",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:13543,Integrability,integrat,integrator,13543,"; 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 Double_t result = 0.;; 372 if (fFlagFFT); 373 result = EvalFFTConv(x[0]);; 374 else; 375 result = EvalNumConv(x[0]);; 376 return result;; 377}; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Set the number of points used for the FFT convolution.; 381 ; 382void TF1Convolution::SetNofPointsFFT(Int_t n); 383{; 384 if (n<0) return;; 385 fNofPoints = n;; 386 if (fGraphConv) fGraphConv -> Set(fNofPoints);; 387 fFlagGraph = false; // to indicate we need to re-do the graph; 388}; 389 ; 390////////",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:22020,Integrability,integrat,integration,22020,"r const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; TObjArray.h; TObjString.h; TObject.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; TF1Convolution_EvalWrapperDefinition TF1Convolution.cxx:48; TF1Convolution_EvalWrapper::fT0Double_t fT0Definition TF1Convolution.cxx:51; TF1Convolution_EvalWrapper::TF1Convolution_EvalWrapperTF1Convolution_EvalWrapper(TF1 &f1, TF1 &f2, Double_t t)Definition TF1Convolution.cxx:54; TF1Convolution_EvalWrapper::fFunc1TF1 * fFu",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:23251,Integrability,wrap,wrapping,23251,"nf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; TF1Convolution_EvalWrapperDefinition TF1Convolution.cxx:48; TF1Convolution_EvalWrapper::fT0Double_t fT0Definition TF1Convolution.cxx:51; TF1Convolution_EvalWrapper::TF1Convolution_EvalWrapperTF1Convolution_EvalWrapper(TF1 &f1, TF1 &f2, Double_t t)Definition TF1Convolution.cxx:54; TF1Convolution_EvalWrapper::fFunc1TF1 * fFunc1Definition TF1Convolution.cxx:49; TF1Convolution_EvalWrapper::fFunc2TF1 * fFunc2Definition TF1Convolution.cxx:50; TF1Convolution_EvalWrapper::operator()Double_t operator()(Double_t x) constDefinition TF1Convolution.cxx:59; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::fNofParams2Int_t fNofParams2Definition TF1Convolution.h:33; TF1Convolution::fParams1std::vector< Double_t > fParams1Definition TF1Convolution.h:25; TF1Convolution::operator()Double_t operator()(const Double_t *x, const Double_t *p) overrideUsed in TF1 when doing the fit, will be evaluated at each point.Definition TF1Convolution.cxx:367; TF1Convolution::SetParametersvoid SetParameters(const Double_t *params) overrideSet the vector of parameters p for the convolution function g(x,p) = f1 * f2.Definition TF1Convolution.cxx:393; TF1Convolution::fCstIndexInt_t fCstIndexIndex of the constant parameter f the first function.Definition TF1Convolution.h:34; TF1Convolution::GetRangevoid GetRange(Double_t &a, Double_t &b) constGet the range used for the convolution.Definition TF1Convolution.cxx:487; TF1Convolution::fParNamesstd::vector< TString > fParNamesParameters' names.Definition TF1Convolution.h:28; TF1Convolutio",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:28451,Integrability,message,message,28451,"h:23; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fm",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:28717,Integrability,message,message,28717,"TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFF",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:28853,Integrability,message,message,28853,"tr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:28981,Integrability,message,message,28981,"ion TF1.h:513; TGraph::kIsSortedX@ kIsSortedXGraph is sorted in X points.Definition TGraph.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131; TVirtualFFT::GetPointRealvirtual Double_t GetPointReal(Int_t ipoint, Bool_t fromInput=kFALSE) const =0; bool; double; int; xDoubl",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:29606,Integrability,interface,interface,29606,"rningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131; TVirtualFFT::GetPointRealvirtual Double_t GetPointReal(Int_t ipoint, Bool_t fromInput=kFALSE) const =0; bool; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; formula1Definition formula1.py:1. histhistsrcTF1Convolution.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:9161,Modifiability,variab,variable,9161,"FT); 210{; 211 TF1::InitStandardFunctions();; 212 (TString)formula1.ReplaceAll("" "","""");; 213 (TString)formula2.ReplaceAll("" "","""");; 214 TF1* f1 = (TF1*)(gROOT -> GetListOfFunctions() -> FindObject(formula1));; 215 TF1* f2 = (TF1*)(gROOT -> GetListOfFunctions() -> FindObject(formula2));; 216 // if function do not exists try using TFormula; 217 if (!f1) {; 218 fFunction1 = std::make_unique<TF1>(""f_conv_1"", formula1);; 219 if (!fFunction1->GetFormula()->IsValid() ); 220 Error(""TF1Convolution"",""Invalid formula for : %s"",formula1.Data() );; 221 }; 222 if (!f2) {; 223 fFunction2 = std::make_unique<TF1>(""f_conv_1"", formula2);; 224 if (!fFunction2->GetFormula()->IsValid() ); 225 Error(""TF1Convolution"",""Invalid formula for : %s"",formula2.Data() );; 226 }; 227 // if f1 or f2 are null ptr are not used in InitializeDataMembers; 228 InitializeDataMembers(f1, f2,useFFT);; 229 if (xmin < xmax) {; 230 fXmin = xmin;; 231 fXmax = xmax;; 232 } else {; 233 Info(""TF1Convolution"", ""Using default range [-inf, inf] for TF1Convolution"");; 234 SetRange(-TMath::Infinity(), TMath::Infinity());; 235 }; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Copy constructor (necessary to hold unique_ptr as member variable).; 240 ; 241TF1Convolution::TF1Convolution(const TF1Convolution &conv); 242{; 243 conv.TF1Convolution::Copy(*this);; 244}; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// Operator =; 248 ; 249TF1Convolution &TF1Convolution::operator=(const TF1Convolution &rhs); 250{; 251 if (this != &rhs); 252 rhs.TF1Convolution::Copy(*this);; 253 return *this;; 254}; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Perform the FFT of the two functions.; 258 ; 259void TF1Convolution::MakeFFTConv(); 260{; 261 if (gDebug); 262 Info(""MakeFFTConv"",""Making FFT convolution using %d points in range [%g,%g]"",fNofPoints,fXmin,fXmax);; 263 ; 264 std::vector < ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:16837,Modifiability,extend,extended,16837," p5, Double_t p6, Double_t p7); 427{; 428 Double_t params[]={p0,p1,p2,p3,p4,p5,p6,p7};; 429 TF1Convolution::SetParameters(params);; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Set the fraction of extra range used when doing an FFT convolution.; 434/// The extra range is often needed to avoid mirroring effect of the resulting convolution; 435/// function at the borders.; 436/// By default an extra range of 0.1 is used.; 437 ; 438void TF1Convolution::SetExtraRange(Double_t percentage); 439{; 440 if (percentage<0) return;; 441 double range = fXmax - fXmin;; 442 fXmin -= percentage * range;; 443 fXmax += percentage * range;; 444 fFlagGraph = false; // to indicate we need to re-do the convolution; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Set the actual range used for the convolution.; 449/// In case a or b are -inf or +inf and FFT convolution is used, then the; 450/// range of the first function will be used and extended by the default extra range fraction.; 451 ; 452void TF1Convolution::SetRange(Double_t a, Double_t b); 453{; 454 if (a >= b) {; 455 Warning(""SetRange"", ""Invalid range: %f >= %f"", a, b);; 456 return;; 457 }; 458 ; 459 fXmin = a;; 460 fXmax = b;; 461 if (fFlagFFT && ( a==-TMath::Infinity() || b==TMath::Infinity() ) ); 462 {; 463 Warning(""TF1Convolution::SetRange()"",""In FFT mode, range can not be infinite. Infinity has been replaced by range of first function plus a bufferzone to avoid spillover."");; 464 if (a ==-TMath::Infinity()) fXmin = fFunction1 -> GetXmin();; 465 if ( b== TMath::Infinity()) fXmax = fFunction1 -> GetXmax();; 466 // add a spill over of 10% in this case; 467 SetExtraRange(fgExtraRangeFraction);; 468 }; 469 fFlagGraph = false; // to indicate we need to re-do the convolution; 470}; 471 ; 472////////////////////////////////////////////////////////////////////////////////; 473/// Set the default extra range fraction used w",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:1205,Performance,perform,performed,1205,"hing...; No Matches. TF1Convolution.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Authors: Lorenzo Moneta, Aurélie Flandi 27/08/14; 3//; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2015 ROOT Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#include <memory>; 12 ; 13#include ""TF1Convolution.h""; 14#include ""TROOT.h""; 15#include ""TObject.h""; 16#include ""TObjString.h""; 17#include ""TObjArray.h""; 18#include ""TMath.h""; 19#include ""Math/Integrator.h""; 20#include ""Math/IntegratorMultiDim.h""; 21#include ""Math/IntegratorOptions.h""; 22#include ""Math/GaussIntegrator.h""; 23#include ""Math/GaussLegendreIntegrator.h""; 24#include ""Math/AdaptiveIntegratorMultiDim.h""; 25#include ""Math/Functor.h""; 26#include ""TVirtualFFT.h""; 27 ; 28/** \class TF1Convolution; 29 \ingroup Functions; 30 \brief Class wrapping convolution of two functions; 31 ; 32Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$; 33 ; 34The convolution is performed by default using FFTW if it is available .; 35One can pass optionally the range of the convolution (by default the first function range is used).; 36Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; 37approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); 38a spill over will occur on the other side (e.g right side).; 39If no function range is given by default the function1 range + 10% is used; 40One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; 41*/; 42 ; 43ClassImp(TF1Convolution);; 44 ; 45Double_t TF1Convolution::fgExtraRangeFraction = 0.1;; 46 ; 47class TF1Convolution_EvalWrapper; 48{; 49 TF1 * fFunc1;; 50 TF1 * fFunc2;; 51 Double_t fT0;; 52 ; 53public:; 54 TF1Convolution_EvalWrapper",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:12811,Performance,cache,cache,12811,"18 fGraphConv->SetBit(TGraph::kIsSortedX); // indicate that points are sorted in X to speed up TGraph::Eval; 319 fFlagGraph = true; // we can use the graph; 320 ; 321 // delete the fft objects; 322 delete fft1;; 323 delete fft2;; 324 delete fftinverse;; 325}; 326 ; 327////////////////////////////////////////////////////////////////////////////////; 328/// Perform FFT convolution.; 329 ; 330Double_t TF1Convolution::EvalFFTConv(Double_t t); 331{; 332 if (!fFlagGraph) MakeFFTConv();; 333 // if cannot make FFT use numconv; 334 if (fGraphConv); 335 return fGraphConv -> Eval(t);; 336 else; 337 ; 338 return EvalNumConv(t);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Perform numerical convolution.; 343///; 344 ; 345Double_t TF1Convolution::EvalNumConv(Double_t t); 346{; 347 /// Could in principle cache the integral in a Graph as it is done for the FFTW; 348 TF1Convolution_EvalWrapper fconv( *fFunction1, *fFunction2, t);; 349 Double_t result = 0;; 350 ; 351 ROOT::Math::IntegratorOneDim integrator(fconv, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), 1e-9, 1e-9);; 352 if (fXmin != - TMath::Infinity() && fXmax != TMath::Infinity() ); 353 result = integrator.Integral(fXmin, fXmax);; 354 else if (fXmin == - TMath::Infinity() && fXmax != TMath::Infinity() ); 355 result = integrator.IntegralLow(fXmax);; 356 else if (fXmin != - TMath::Infinity() && fXmax == TMath::Infinity() ); 357 result = integrator.IntegralUp(fXmin);; 358 else if (fXmin == - TMath::Infinity() && fXmax == TMath::Infinity() ); 359 result = integrator.Integral();; 360 ; 361 return result;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Used in TF1 when doing the fit, will be evaluated at each point.; 366 ; 367Double_t TF1Convolution::operator()(const Double_t *x, const Double_t *p); 368{; 369 if (p!=nullptr) TF1Convolution::SetParameters(p); // first refresh the parameters; 370 ; 371 ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:21999,Performance,perform,performing,21999,"r const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; TObjArray.h; TObjString.h; TObject.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; TF1Convolution_EvalWrapperDefinition TF1Convolution.cxx:48; TF1Convolution_EvalWrapper::fT0Double_t fT0Definition TF1Convolution.cxx:51; TF1Convolution_EvalWrapper::TF1Convolution_EvalWrapperTF1Convolution_EvalWrapper(TF1 &f1, TF1 &f2, Double_t t)Definition TF1Convolution.cxx:54; TF1Convolution_EvalWrapper::fFunc1TF1 * fFu",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:16140,Safety,avoid,avoid,16140,"tIndex); 408 {; 409 k++;; 410 offset2=1;; 411 continue;; 412 }; 413 fFunction2->SetParameter(k, params[i - offset2]);; 414 equalParams &= (fParams2[k - offset2] == params[i - offset2]);; 415 fParams2[k - offset2] = params[i - offset2];; 416 k++;; 417 }; 418 ; 419 if (!equalParams) fFlagGraph = false; // to indicate we need to re-do the convolution; 420}; 421 ; 422////////////////////////////////////////////////////////////////////////////////; 423/// Set the parameter values for the convolution function.; 424 ; 425void TF1Convolution::SetParameters(Double_t p0, Double_t p1, Double_t p2, Double_t p3,; 426 Double_t p4, Double_t p5, Double_t p6, Double_t p7); 427{; 428 Double_t params[]={p0,p1,p2,p3,p4,p5,p6,p7};; 429 TF1Convolution::SetParameters(params);; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// Set the fraction of extra range used when doing an FFT convolution.; 434/// The extra range is often needed to avoid mirroring effect of the resulting convolution; 435/// function at the borders.; 436/// By default an extra range of 0.1 is used.; 437 ; 438void TF1Convolution::SetExtraRange(Double_t percentage); 439{; 440 if (percentage<0) return;; 441 double range = fXmax - fXmin;; 442 fXmin -= percentage * range;; 443 fXmax += percentage * range;; 444 fFlagGraph = false; // to indicate we need to re-do the convolution; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Set the actual range used for the convolution.; 449/// In case a or b are -inf or +inf and FFT convolution is used, then the; 450/// range of the first function will be used and extended by the default extra range fraction.; 451 ; 452void TF1Convolution::SetRange(Double_t a, Double_t b); 453{; 454 if (a >= b) {; 455 Warning(""SetRange"", ""Invalid range: %f >= %f"", a, b);; 456 return;; 457 }; 458 ; 459 fXmin = a;; 460 fXmax = b;; 461 if (fFlagFFT && ( a==-TMath::Infinity() || b==TMath::Infinity() ) ",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8cxx_source.html:17327,Safety,avoid,avoid,17327,"olution::SetExtraRange(Double_t percentage); 439{; 440 if (percentage<0) return;; 441 double range = fXmax - fXmin;; 442 fXmin -= percentage * range;; 443 fXmax += percentage * range;; 444 fFlagGraph = false; // to indicate we need to re-do the convolution; 445}; 446 ; 447////////////////////////////////////////////////////////////////////////////////; 448/// Set the actual range used for the convolution.; 449/// In case a or b are -inf or +inf and FFT convolution is used, then the; 450/// range of the first function will be used and extended by the default extra range fraction.; 451 ; 452void TF1Convolution::SetRange(Double_t a, Double_t b); 453{; 454 if (a >= b) {; 455 Warning(""SetRange"", ""Invalid range: %f >= %f"", a, b);; 456 return;; 457 }; 458 ; 459 fXmin = a;; 460 fXmax = b;; 461 if (fFlagFFT && ( a==-TMath::Infinity() || b==TMath::Infinity() ) ); 462 {; 463 Warning(""TF1Convolution::SetRange()"",""In FFT mode, range can not be infinite. Infinity has been replaced by range of first function plus a bufferzone to avoid spillover."");; 464 if (a ==-TMath::Infinity()) fXmin = fFunction1 -> GetXmin();; 465 if ( b== TMath::Infinity()) fXmax = fFunction1 -> GetXmax();; 466 // add a spill over of 10% in this case; 467 SetExtraRange(fgExtraRangeFraction);; 468 }; 469 fFlagGraph = false; // to indicate we need to re-do the convolution; 470}; 471 ; 472////////////////////////////////////////////////////////////////////////////////; 473/// Set the default extra range fraction used when doing a FFT convolution.; 474/// By default the value is 0.1 (10%).; 475/// The function return the previous default defined value.; 476 ; 477Double_t TF1Convolution::SetDefaultExtraRange(Double_t fraction); 478{; 479 Double_t prevValue = fgExtraRangeFraction;; 480 fgExtraRangeFraction = fraction;; 481 return prevValue;; 482}; 483 ; 484////////////////////////////////////////////////////////////////////////////////; 485/// Get the range used for the convolution.; 486 ; 487void TF1Convolution::G",MatchSource.WIKI,doc/master/TF1Convolution_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html
https://root.cern/doc/master/TF1Convolution_8h.html:296,Integrability,depend,dependency,296,". ROOT: hist/hist/inc/TF1Convolution.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF1Convolution.h File Reference. #include ""TF1AbsComposition.h""; #include <memory>; #include <vector>; #include ""TF1.h""; #include ""TGraph.h"". Include dependency graph for TF1Convolution.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF1Convolution;  Class wrapping convolution of two functions. More...;  . histhistincTF1Convolution.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1Convolution_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8h.html
https://root.cern/doc/master/TF1Convolution_8h.html:617,Integrability,wrap,wrapping,617,". ROOT: hist/hist/inc/TF1Convolution.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF1Convolution.h File Reference. #include ""TF1AbsComposition.h""; #include <memory>; #include <vector>; #include ""TF1.h""; #include ""TGraph.h"". Include dependency graph for TF1Convolution.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF1Convolution;  Class wrapping convolution of two functions. More...;  . histhistincTF1Convolution.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1Convolution_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8h.html
https://root.cern/doc/master/TF1Convolution_8h_source.html:4034,Integrability,wrap,wrapping,4034,"; 69 Double_t GetXmin() const { return fXmin; }; 70 Double_t GetXmax() const { return fXmax; }; 71 const char *GetParName(Int_t ipar) const { return fParNames.at(ipar).Data(); }; 72 void GetRange(Double_t &a, Double_t &b) const;; 73 ; 74 void Update() override;; 75 ; 76 Double_t operator()(const Double_t *x, const Double_t *p) override;; 77 ; 78 void Copy(TObject &obj) const override;; 79 ; 80 ClassDefOverride(TF1Convolution, 1);; 81};; 82 ; 83 ; 84#endif; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TF1AbsComposition.h; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TGraph.h; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TF1AbsCompositionDefinition TF1AbsComposition.h:16; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::SetNumConvvoid SetNumConv(Bool_t flag=true)Definition TF1Convolution.h:64; TF1Convolution::fNofParams2Int_t fNofParams2Definition TF1Convolution.h:33; TF1Convolution::fParams1std::vector< Double_t > fParams1Definition TF1Convolution.h:25; TF1Convolution::operator()Double_t operator()(const Double_t *x, const Double_t *p) overrideUsed in TF1 when doing the fit, will be evaluated at each point.Definition TF1Convolution.cxx:367; TF1Convolution::SetParametersvoid SetParameters(const Double_t *params) overrideSet the vector of parameters p for the convolution function g(x,p) = f1 * f2.Definition TF1Convolution.cxx:393; TF1Convolution::~TF1Convolution~TF1Convolution() overrideDefinition TF1Convolution.h:56; TF1Convolution::fCstIndexInt_t fCstIndexIndex of the constant parameter f the first function.Definition TF1Convolution.h:34; TF1Convolution::GetRangevoid GetRange(Double_t &a, Double_t &b) constGet the range u",MatchSource.WIKI,doc/master/TF1Convolution_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1Convolution_8h_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:20106,Availability,error,error,20106,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:20242,Availability,error,error,20242,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:12217,Deployability,update,update,12217," params[k+fNOfFunctions+offset] = fFunctions[n]->GetParameter(j);; 301 k++;; 302 }; 303 }; 304 nOfNonCstParams = k;; 305 }; 306 return params;; 307}; 308////////////////////////////////////////////////////////////////////////////////; 309/// Initialize array of all parameters.; 310///; 311/// double *params must contains first an array of the coefficients, then an array of the parameters.; 312 ; 313void TF1NormSum::SetParameters(const Double_t *params) // params should have the size [fNOfFunctions][fNOfNonCstParams]; 314{; 315 for (unsigned int n=0; n<fNOfFunctions; n++) //initialization of the coefficients; 316 {; 317 fCoeffs[n] = params[n];; 318 }; 319 Int_t offset = 0;; 320 int k = 0; // k indicates the number of non-constant parameter per function; 321 for (unsigned int n=0; n<fNOfFunctions; n++); 322 {; 323 bool equalParams = true;; 324 Double_t * funcParams = fFunctions[n]->GetParameters();; 325 int npar = fFunctions[n]->GetNpar();; 326 offset += k; // offset to go along the list of parameters; 327 k = 0; // reset k value for next function; 328 for (int i = 0; i < npar; ++i) {; 329 // constant parameters can be only one; 330 if (i != fCstIndexes[n]); 331 {; 332 // check if they are equal; 333 equalParams &= (funcParams[i] == params[k+fNOfFunctions+offset] );; 334 funcParams[i] = params[k+fNOfFunctions+offset];; 335 k++;; 336 }; 337 }; 338 // update function integral if not equal; 339 if (!equalParams) fFunctions[n]->Update();; 340 ; 341 }; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Initialize array of all parameters.; 346///; 347/// Overload the TF1::SetParameters() method.; 348/// A maximum of 10 parameters must be used, with first the coefficients, then the parameters; 349 ; 350void TF1NormSum::SetParameters(Double_t p0, Double_t p1, Double_t p2, Double_t p3, Double_t p4,; 351 Double_t p5, Double_t p6, Double_t p7, Double_t p8, Double_t p9, Double_t p10); 352{; 353 const double params[] = {p0,p1,p2",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:16807,Energy Efficiency,allocate,allocated,16807,"e GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TObjArray.h; TObjString.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; WrappedFunction.h; WrappedTF1.h; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::Copyvoid Copy(TObject &obj) const overrideCopy this to obj.Definition TF1NormSum.cxx:409; TF1NormSum::fScaleDouble_t fScaleFixed Scale parameter to normalize function (e.g. bin width)Definition TF1NormSum.h:23; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1NormSum::GetRangevoid GetRange(Double_t &a, Double_t &b) constDefinition TF1NormSum.cxx:392; TF1NormSum::TF1NormSumTF1NormSum()Definition TF1NormSum.cxx:129; TF1NormSum::operator=TF1NormSum & operator=(const TF1NormSum &rhs)Operator =.Definition TF1NormSum.cxx:262; TF1NormSum::IsATClass * IsA() const overrideDefinition TF1NormSum.h:78; TF1NormSum::fXmaxDouble_t fXmaxMaximal bound of range of NormSum.Definition TF1NormSum.h:25; TF1NormSum::fParNamesstd::vector< TString > fParNamesParameter names.Defin",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:19982,Integrability,message,message,19982,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:20112,Integrability,message,message,20112,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:20248,Integrability,message,message,20248,"fficients in front of each function.Definition TF1NormSum.h:27; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1NormSum::fNOfFunctionsunsigned int fNOfFunctionsNumber of functions to add.Definition TF1NormSum.h:22; TF1NormSum::fCstIndexesstd::vector< Int_t > fCstIndexesVector with size of fNOfFunctions containing the index of the constant parameter/ function (the remov...Definition TF1NormSum.h:28; TF11-Dim function classDefinition TF1.h:233; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::kNotGlobal@ kNotGlobalDefinition TF1.h:345; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TStringBasic string class.Definition TString.h:139; TString::TokenizeTObjArray * Tokenize(const TString &delim) constThis function is used to isolate sequential tokens in a TString.Definition TString.cxx:2264; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; double; int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. histhistsrcTF1NormSum.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:9325,Modifiability,variab,variable,9325,"19 ; 220 Double_t old_xmin = 0.0, old_xmax = 0.0;; 221 k = 0; // index of term in funcstringall; 222 for (int i=0; i<noffunctions; i++); 223 {; 224 // first, handle coefficient; 225 if (isacoeff[k]) {; 226 coeffs[i] = funcstringall[k].Atof();; 227 k++;; 228 } else {; 229 coeffs[i] = 1.;; 230 }; 231 ; 232 // then, handle function; 233 functions[i] = (TF1 *)(gROOT->GetListOfFunctions()->FindObject(funcstringall[k]));; 234 if (!functions[i]); 235 Error(""TF1NormSum"", ""Function %s does not exist"", funcstringall[k].Data());; 236 // (set range for first function, which determines range of whole TF1NormSum); 237 else if (i == 0) {; 238 functions[i]->GetRange(old_xmin, old_xmax);; 239 functions[i]->SetRange(xmin, xmax);; 240 }; 241 ; 242 k++;; 243 }; 244 InitializeDataMembers(functions, coeffs,1.);; 245 ; 246 // Set range of first function back to original state; 247 if (noffunctions > 0 && functions[0]); 248 functions[0]->SetRange(old_xmin, old_xmax);; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Copy constructor (necessary to hold unique_ptr as member variable); 253 ; 254TF1NormSum::TF1NormSum(const TF1NormSum &nsum); 255{; 256 nsum.TF1NormSum::Copy(*this);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Operator =; 261 ; 262TF1NormSum &TF1NormSum::operator=(const TF1NormSum &rhs); 263{; 264 if (this != &rhs); 265 rhs.TF1NormSum::Copy(*this);; 266 return *this;; 267}; 268 ; 269////////////////////////////////////////////////////////////////////////////////; 270/// Overload the parenthesis to add the functions; 271 ; 272double TF1NormSum::operator()(const Double_t *x, const Double_t *p); 273{; 274 // first refresh the parameters; 275 if (p != nullptr); 276 SetParameters(p);; 277 ; 278 Double_t sum = 0.;; 279 for (unsigned int n=0; n<fNOfFunctions; n++); 280 sum += fCoeffs[n]*(fFunctions[n] -> EvalPar(x,nullptr));; 281 ; 282 // normalize by a scale parameter (ty",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8cxx_source.html:2745,Safety,abort,abort,2745,"/////////////////////////////////; 54 ; 55void TF1NormSum::InitializeDataMembers(const std::vector<TF1 *> &functions, const std::vector<Double_t> &coeffs,; 56 Double_t scale); 57{; 58 ; 59 fScale = scale;; 60 fCoeffs = coeffs;; 61 fNOfFunctions = functions.size();; 62 fCstIndexes = std::vector < Int_t > (fNOfFunctions);; 63 fParNames = std::vector<TString> (fNOfFunctions);; 64 fParNames.reserve(3*fNOfFunctions); // enlarge capacity for function parameters; 65 ; 66 // fill fFunctions with unique_ptr's; 67 fFunctions = std::vector<std::unique_ptr<TF1>>(functions.size());; 68 for (unsigned int n = 0; n < fNOfFunctions; n++) {; 69 // use TF1::Copy and not clone to copy the TF1 pointers; 70 // and use IsA()::New() in case we have base class pointers; 71 TF1 * f = (TF1*) functions[n]->IsA()->New();; 72 functions[n]->Copy(*f);; 73 fFunctions[n] = std::unique_ptr<TF1>(f);; 74 ; 75 ; 76 if (!fFunctions[n]); 77 Fatal(""InitializeDataMembers"", ""Invalid input function -- abort"");; 78 ; 79 fFunctions[n]->SetBit(TF1::kNotGlobal, kTRUE);; 80 }; 81 ; 82 for (unsigned int n=0; n < fNOfFunctions; n++); 83 {; 84 int npar = fFunctions[n] -> GetNpar();; 85 fCstIndexes[n] = fFunctions[n] -> GetParNumber(""Constant"");//return -1 if there is no constant parameter; 86 fParNames[n] = TString::Format(""Coeff%d"",n);; 87 if (fCstIndexes[n]!= -1) //if there exists a constant parameter; 88 {; 89 fFunctions[n] -> FixParameter(fCstIndexes[n], 1.); // fixes the parameters called ""Constant"" to 1; 90 for (int i=0; i<npar; i++) // go through all the parameter to; 91 {; 92 if (i==fCstIndexes[n]) continue; // go to next step if this is the constant parameter; 93 fParNames.push_back( fFunctions[n] -> GetParName(i) );; 94 }; 95 }; 96 else {; 97 for (int i=0; i < npar; i++) //go through all the parameter to; 98 {; 99 fParNames.push_back( fFunctions[n] -> GetParName(i) );; 100 }; 101 }; 102 //normalize the functions if it is not already done (do at the end so constant parameter is not zero); 103 if (!fFunctions",MatchSource.WIKI,doc/master/TF1NormSum_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8cxx_source.html
https://root.cern/doc/master/TF1NormSum_8h.html:267,Integrability,depend,dependency,267,". ROOT: hist/hist/inc/TF1NormSum.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF1NormSum.h File Reference. #include ""TF1AbsComposition.h""; #include <vector>; #include <memory>; #include ""TF1.h"". Include dependency graph for TF1NormSum.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF1NormSum;  Class adding two functions: c1*f1+c2*f2. More...;  . histhistincTF1NormSum.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF1NormSum_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1NormSum_8h.html
https://root.cern/doc/master/TF1_8cxx_source.html:2576,Availability,error,error,2576,"or.h""; 45#include ""Math/AdaptiveIntegratorMultiDim.h""; 46#include ""Math/RichardsonDerivator.h""; 47#include ""Math/Functor.h""; 48#include ""Math/Minimizer.h""; 49#include ""Math/MinimizerOptions.h""; 50#include ""Math/Factory.h""; 51#include ""Math/ChebyshevPol.h""; 52#include ""Fit/FitResult.h""; 53// for I/O backward compatibility; 54#include ""v5/TF1Data.h""; 55 ; 56#include ""AnalyticalIntegrals.h""; 57 ; 58std::atomic<Bool_t> TF1::fgAbsValue(kFALSE);; 59Bool_t TF1::fgRejectPoint = kFALSE;; 60std::atomic<Bool_t> TF1::fgAddToGlobList(kTRUE);; 61static Double_t gErrorTF1 = 0;; 62 ; 63using TF1Updater_t = void (*)(Int_t nobjects, TObject **from, TObject **to);; 64bool R__SetClonesArrayTF1Updater(TF1Updater_t func);; 65 ; 66 ; 67namespace {; 68struct TF1v5Convert : public TF1 {; 69public:; 70 void Convert(ROOT::v5::TF1Data &from); 71 {; 72 // convert old TF1 to new one; 73 fNpar = from.GetNpar();; 74 fNdim = from.GetNdim();; 75 if (from.fType == 0) {; 76 // formula functions; 77 // if ndim is not 1 set xmin max to zero to avoid error in ctor; 78 double xmin = from.fXmin;; 79 double xmax = from.fXmax;; 80 if (fNdim > 1) {; 81 xmin = 0;; 82 xmax = 0;; 83 }; 84 TF1 fnew(from.GetName(), from.GetExpFormula(), xmin, xmax);; 85 if (fNdim > 1) {; 86 fnew.SetRange(from.fXmin, from.fXmax);; 87 }; 88 fnew.Copy(*this);; 89 // need to set parameter values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXm",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:22814,Availability,avail,available,22814,"68 ; 669TF1::EAddToList GetGlobalListOption(Option_t * opt); 670{; 671 if (opt == nullptr) return TF1::EAddToList::kDefault;; 672 TString option(opt);; 673 option.ToUpper();; 674 if (option.Contains(""NL"")) return TF1::EAddToList::kNo;; 675 if (option.Contains(""GL"")) return TF1::EAddToList::kAdd;; 676 return TF1::EAddToList::kDefault;; 677}; 678 ; 679bool GetVectorizedOption(Option_t * opt); 680{; 681 if (!opt) return false;; 682 TString option(opt);; 683 option.ToUpper();; 684 if (option.Contains(""VEC"")) return true;; 685 return false;; 686}; 687 ; 688TF1::TF1(const char *name, const char *formula, Double_t xmin, Double_t xmax, Option_t * opt) :; 689////////////////////////////////////////////////////////////////////////////////; 690/// Same constructor as above (for TFormula based function) but passing an option strings; 691/// available options; 692/// VEC - vectorize the formula expressions (not possible for lambda based expressions); 693/// NL - function is not stores in the global list of functions; 694/// GL - function will be always stored in the global list of functions ,; 695/// independently of the global setting of TF1::DefaultAddToGlobalList; 696///////////////////////////////////////////////////////////////////////////////////; 697 TF1(name, formula, xmin, xmax, GetGlobalListOption(opt), GetVectorizedOption(opt) ); 698{}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// F1 constructor using name of an interpreted function.; 702///; 703/// Creates a function of type C between xmin and xmax.; 704/// name is the name of an interpreted C++ function.; 705/// The function is defined with npar parameters; 706/// fcn must be a function of type:; 707///; 708/// Double_t fcn(Double_t *x, Double_t *params); 709///; 710/// This constructor is called for functions of type C by the C++ interpreter.; 711///; 712/// \warning A function created with this constructor cannot be Cloned.; 713 ; 714TF1::TF1(const char *name, Do",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:39164,Availability,error,error,39164,"l difference formulas; 1083/// \f[; 1084/// D(h) = \frac{f(x+h) - f(x-h)}{2h}; 1085/// \f]; 1086/// the final estimate; 1087/// \f[; 1088/// D = \frac{4D(h/2) - D(h)}{3}; 1089/// \f]; 1090/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1091///; 1092/// if the argument params is null, the current function parameters are used,; 1093/// otherwise the parameters in params are used.; 1094///; 1095/// the argument eps may be specified to control the step size (precision).; 1096/// the step size is taken as eps*(xmax-xmin).; 1097/// the default value (0.001) should be good enough for the vast majority; 1098/// of functions. Give a smaller value if your function has many changes; 1099/// of the second derivative in the function range.; 1100///; 1101/// Getting the error via TF1::DerivativeError:; 1102/// (total error = roundoff error + interpolation error); 1103/// the estimate of the roundoff error is taken as follows:; 1104/// \f[; 1105/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid alloc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:39212,Availability,error,error,39212,"l difference formulas; 1083/// \f[; 1084/// D(h) = \frac{f(x+h) - f(x-h)}{2h}; 1085/// \f]; 1086/// the final estimate; 1087/// \f[; 1088/// D = \frac{4D(h/2) - D(h)}{3}; 1089/// \f]; 1090/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1091///; 1092/// if the argument params is null, the current function parameters are used,; 1093/// otherwise the parameters in params are used.; 1094///; 1095/// the argument eps may be specified to control the step size (precision).; 1096/// the step size is taken as eps*(xmax-xmin).; 1097/// the default value (0.001) should be good enough for the vast majority; 1098/// of functions. Give a smaller value if your function has many changes; 1099/// of the second derivative in the function range.; 1100///; 1101/// Getting the error via TF1::DerivativeError:; 1102/// (total error = roundoff error + interpolation error); 1103/// the estimate of the roundoff error is taken as follows:; 1104/// \f[; 1105/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid alloc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:39229,Availability,error,error,39229,"l difference formulas; 1083/// \f[; 1084/// D(h) = \frac{f(x+h) - f(x-h)}{2h}; 1085/// \f]; 1086/// the final estimate; 1087/// \f[; 1088/// D = \frac{4D(h/2) - D(h)}{3}; 1089/// \f]; 1090/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1091///; 1092/// if the argument params is null, the current function parameters are used,; 1093/// otherwise the parameters in params are used.; 1094///; 1095/// the argument eps may be specified to control the step size (precision).; 1096/// the step size is taken as eps*(xmax-xmin).; 1097/// the default value (0.001) should be good enough for the vast majority; 1098/// of functions. Give a smaller value if your function has many changes; 1099/// of the second derivative in the function range.; 1100///; 1101/// Getting the error via TF1::DerivativeError:; 1102/// (total error = roundoff error + interpolation error); 1103/// the estimate of the roundoff error is taken as follows:; 1104/// \f[; 1105/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid alloc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:39251,Availability,error,error,39251,"l difference formulas; 1083/// \f[; 1084/// D(h) = \frac{f(x+h) - f(x-h)}{2h}; 1085/// \f]; 1086/// the final estimate; 1087/// \f[; 1088/// D = \frac{4D(h/2) - D(h)}{3}; 1089/// \f]; 1090/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1091///; 1092/// if the argument params is null, the current function parameters are used,; 1093/// otherwise the parameters in params are used.; 1094///; 1095/// the argument eps may be specified to control the step size (precision).; 1096/// the step size is taken as eps*(xmax-xmin).; 1097/// the default value (0.001) should be good enough for the vast majority; 1098/// of functions. Give a smaller value if your function has many changes; 1099/// of the second derivative in the function range.; 1100///; 1101/// Getting the error via TF1::DerivativeError:; 1102/// (total error = roundoff error + interpolation error); 1103/// the estimate of the roundoff error is taken as follows:; 1104/// \f[; 1105/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid alloc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:39296,Availability,error,error,39296,"l difference formulas; 1083/// \f[; 1084/// D(h) = \frac{f(x+h) - f(x-h)}{2h}; 1085/// \f]; 1086/// the final estimate; 1087/// \f[; 1088/// D = \frac{4D(h/2) - D(h)}{3}; 1089/// \f]; 1090/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1091///; 1092/// if the argument params is null, the current function parameters are used,; 1093/// otherwise the parameters in params are used.; 1094///; 1095/// the argument eps may be specified to control the step size (precision).; 1096/// the step size is taken as eps*(xmax-xmin).; 1097/// the default value (0.001) should be good enough for the vast majority; 1098/// of functions. Give a smaller value if your function has many changes; 1099/// of the second derivative in the function range.; 1100///; 1101/// Getting the error via TF1::DerivativeError:; 1102/// (total error = roundoff error + interpolation error); 1103/// the estimate of the roundoff error is taken as follows:; 1104/// \f[; 1105/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid alloc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:39547,Availability,error,error,39547,"l difference formulas; 1083/// \f[; 1084/// D(h) = \frac{f(x+h) - f(x-h)}{2h}; 1085/// \f]; 1086/// the final estimate; 1087/// \f[; 1088/// D = \frac{4D(h/2) - D(h)}{3}; 1089/// \f]; 1090/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1091///; 1092/// if the argument params is null, the current function parameters are used,; 1093/// otherwise the parameters in params are used.; 1094///; 1095/// the argument eps may be specified to control the step size (precision).; 1096/// the step size is taken as eps*(xmax-xmin).; 1097/// the default value (0.001) should be good enough for the vast majority; 1098/// of functions. Give a smaller value if your function has many changes; 1099/// of the second derivative in the function range.; 1100///; 1101/// Getting the error via TF1::DerivativeError:; 1102/// (total error = roundoff error + interpolation error); 1103/// the estimate of the roundoff error is taken as follows:; 1104/// \f[; 1105/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid alloc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:41772,Availability,error,error,41772,"e formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in params are used.; 1159///; 1160/// the argument eps may be specified to control the step size (precision).; 1161/// the step size is taken as eps*(xmax-xmin).; 1162/// the default value (0.001) should be good enough for the vast majority; 1163/// of functions. Give a smaller value if your function has many changes; 1164/// of the second derivative in the function range.; 1165///; 1166/// Getting the error via TF1::DerivativeError:; 1167/// (total error = roundoff error + interpolation error); 1168/// the estimate of the roundoff error is taken as follows:; 1169/// \f[; 1170/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:41820,Availability,error,error,41820,"e formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in params are used.; 1159///; 1160/// the argument eps may be specified to control the step size (precision).; 1161/// the step size is taken as eps*(xmax-xmin).; 1162/// the default value (0.001) should be good enough for the vast majority; 1163/// of functions. Give a smaller value if your function has many changes; 1164/// of the second derivative in the function range.; 1165///; 1166/// Getting the error via TF1::DerivativeError:; 1167/// (total error = roundoff error + interpolation error); 1168/// the estimate of the roundoff error is taken as follows:; 1169/// \f[; 1170/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:41837,Availability,error,error,41837,"e formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in params are used.; 1159///; 1160/// the argument eps may be specified to control the step size (precision).; 1161/// the step size is taken as eps*(xmax-xmin).; 1162/// the default value (0.001) should be good enough for the vast majority; 1163/// of functions. Give a smaller value if your function has many changes; 1164/// of the second derivative in the function range.; 1165///; 1166/// Getting the error via TF1::DerivativeError:; 1167/// (total error = roundoff error + interpolation error); 1168/// the estimate of the roundoff error is taken as follows:; 1169/// \f[; 1170/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:41859,Availability,error,error,41859,"e formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in params are used.; 1159///; 1160/// the argument eps may be specified to control the step size (precision).; 1161/// the step size is taken as eps*(xmax-xmin).; 1162/// the default value (0.001) should be good enough for the vast majority; 1163/// of functions. Give a smaller value if your function has many changes; 1164/// of the second derivative in the function range.; 1165///; 1166/// Getting the error via TF1::DerivativeError:; 1167/// (total error = roundoff error + interpolation error); 1168/// the estimate of the roundoff error is taken as follows:; 1169/// \f[; 1170/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:41904,Availability,error,error,41904,"e formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in params are used.; 1159///; 1160/// the argument eps may be specified to control the step size (precision).; 1161/// the step size is taken as eps*(xmax-xmin).; 1162/// the default value (0.001) should be good enough for the vast majority; 1163/// of functions. Give a smaller value if your function has many changes; 1164/// of the second derivative in the function range.; 1165///; 1166/// Getting the error via TF1::DerivativeError:; 1167/// (total error = roundoff error + interpolation error); 1168/// the estimate of the roundoff error is taken as follows:; 1169/// \f[; 1170/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:42155,Availability,error,error,42155,"e formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in params are used.; 1159///; 1160/// the argument eps may be specified to control the step size (precision).; 1161/// the step size is taken as eps*(xmax-xmin).; 1162/// the default value (0.001) should be good enough for the vast majority; 1163/// of functions. Give a smaller value if your function has many changes; 1164/// of the second derivative in the function range.; 1165///; 1166/// Getting the error via TF1::DerivativeError:; 1167/// (total error = roundoff error + interpolation error); 1168/// the estimate of the roundoff error is taken as follows:; 1169/// \f[; 1170/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:44396,Availability,error,error,44396,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:44444,Availability,error,error,44444,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:44461,Availability,error,error,44461,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:44483,Availability,error,error,44483,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:44528,Availability,error,error,44528,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:44779,Availability,error,error,44779,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:45960,Availability,error,error,45960," ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1262 // an array with parameter values; 1263 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1264 der = rd.Derivative3(wf, x, h);; 1265 }; 1266 ; 1267 gErrorTF1 = rd.Error();; 1268 return der;; 1269 ; 1270}; 1271 ; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Static function returning the error of the last call to the of Derivative's; 1275/// functions; 1276 ; 1277Double_t TF1::DerivativeError(); 1278{; 1279 return gErrorTF1;; 1280}; 1281 ; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Compute distance from point px,py to a function.; 1285///; 1286/// Compute the closest distance of approach from point px,py to this; 1287/// function. The distance is computed in pixels units.; 1288///; 1289/// Note that px is called with a negative value when the TF1 is in; 1290/// TGraph or TH1 list of functions. In this case there is no point; 1291/// looking at the histogram axis.; 1292 ; 1293Int_t TF1::DistancetoPrimitive(Int_t px, Int_t py); 1294{; 1295 if (!fHistogram) return 9999;; 1296 Int_t distance = 9999;; 1297 if (px >= 0) {; 1298 distance = fHistogram->DistancetoPrimitive(px, py);; 1299 if (distance <= 1) return distance;; 1300 } else {; 1301 px = -px;; 1302 }; 1303 ; 1304 Double_t xx[1];; 1305 Double_t x = gPad->AbsPixeltoX(px);; 1306 xx[0] = gPad->PadtoX(x);; 1307 if (xx[0] < fX",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:75449,Availability,toler,tolerance,75449,"ion is zero"");; 2026 return 0;; 2027 }; 2028 ; 2029 const Double_t total = integral[npx];; 2030 for (i = 1; i <= npx; i++) integral[i] /= total;; 2031 //the integral r for each bin is approximated by a parabola; 2032 // x = alpha + beta*r +gamma*r**2; 2033 // compute the coefficients alpha, beta, gamma for each bin; 2034 for (i = 0; i < npx; i++) {; 2035 const Double_t x0 = xMin + dx * i;; 2036 const Double_t r2 = integral[i + 1] - integral[i];; 2037 const Double_t r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2038 gamma[i] = (2 * r2 - 4 * r1) / (dx * dx);; 2039 beta[i] = r2 / dx - gamma[i] * dx;; 2040 alpha[i] = x0;; 2041 gamma[i] *= 2;; 2042 }; 2043 ; 2044 // Be careful because of finite precision in the integral; Use the fact that the integral; 2045 // is monotone increasing; 2046 for (i = 0; i < n; i++) {; 2047 const Double_t r = p[i];; 2048 Int_t bin = TMath::Max(TMath::BinarySearch(npx + 1, integral.GetArray(), r), (Long64_t)0);; 2049 // in case the prob is 1; 2050 if (bin == npx) {; 2051 xp[i] = xMax;; 2052 continue;; 2053 }; 2054 // LM use a tolerance 1.E-12 (integral precision); 2055 while (bin < npx - 1 && TMath::AreEqualRel(integral[bin + 1], r, 1E-12)) {; 2056 if (TMath::AreEqualRel(integral[bin + 2], r, 1E-12)) bin++;; 2057 else break;; 2058 }; 2059 ; 2060 const Double_t rr = r - integral[bin];; 2061 if (rr != 0.0) {; 2062 Double_t xx = 0.0;; 2063 const Double_t fac = -2.*gamma[bin] * rr / beta[bin] / beta[bin];; 2064 if (fac != 0 && fac <= 1); 2065 xx = (-beta[bin] + TMath::Sqrt(beta[bin] * beta[bin] + 2 * gamma[bin] * rr)) / gamma[bin];; 2066 else if (beta[bin] != 0.); 2067 xx = rr / beta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can b",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:89051,Availability,error,errors,89051,"////////////////////////////////////////////////////////////////////////////////; 2398/// Get x axis of the function.; 2399 ; 2400TAxis *TF1::GetXaxis() const; 2401{; 2402 TH1 *h = GetHistogram();; 2403 if (!h) return nullptr;; 2404 return h->GetXaxis();; 2405}; 2406 ; 2407 ; 2408////////////////////////////////////////////////////////////////////////////////; 2409/// Get y axis of the function.; 2410 ; 2411TAxis *TF1::GetYaxis() const; 2412{; 2413 TH1 *h = GetHistogram();; 2414 if (!h) return nullptr;; 2415 return h->GetYaxis();; 2416}; 2417 ; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// Get z axis of the function. (In case this object is a TF2 or TF3); 2421 ; 2422TAxis *TF1::GetZaxis() const; 2423{; 2424 TH1 *h = GetHistogram();; 2425 if (!h) return nullptr;; 2426 return h->GetZaxis();; 2427}; 2428 ; 2429 ; 2430 ; 2431////////////////////////////////////////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:89193,Availability,error,errors,89193," axis of the function.; 2410 ; 2411TAxis *TF1::GetYaxis() const; 2412{; 2413 TH1 *h = GetHistogram();; 2414 if (!h) return nullptr;; 2415 return h->GetYaxis();; 2416}; 2417 ; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// Get z axis of the function. (In case this object is a TF2 or TF3); 2421 ; 2422TAxis *TF1::GetZaxis() const; 2423{; 2424 TH1 *h = GetHistogram();; 2425 if (!h) return nullptr;; 2426 return h->GetZaxis();; 2427}; 2428 ; 2429 ; 2430 ; 2431////////////////////////////////////////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called; 2454/// automatic differentiation using CLAD is used instead of the default; 2455/// numerical differentiation; 2456///; 2457/// \param x point, were the gradient is computed; 2458/// \param grad used to return the computed gradient, assumed to be of at least fNpar size; 2459/// \param eps if the errors of parameters have been computed, the step used in; 2460/// numerica",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:90146,Availability,error,errors,90146,"/////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called; 2454/// automatic differentiation using CLAD is used instead of the default; 2455/// numerical differentiation; 2456///; 2457/// \param x point, were the gradient is computed; 2458/// \param grad used to return the computed gradient, assumed to be of at least fNpar size; 2459/// \param eps if the errors of parameters have been computed, the step used in; 2460/// numerical differentiation is eps*parameter_error.; 2461///; 2462/// if the errors have not been computed, step=eps is used; 2463/// default value of eps = 0.01; 2464/// Method is the same as in Derivative() function; 2465///; 2466/// If a parameter is fixed, the gradient on this parameter = 0; 2467 ; 2468void TF1::GradientPar(const Double_t *x, Double_t *grad, Double_t eps); 2469{; 2470 if (fFormula && fFormula->HasGeneratedGradient()) {; 2471 // need to zero the gradient buffer; 2472 std::fill(grad, grad + fNpar, 0.);; 2473 fFormula->GradientPar(x,g",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:90288,Availability,error,errors,90288,"vative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called; 2454/// automatic differentiation using CLAD is used instead of the default; 2455/// numerical differentiation; 2456///; 2457/// \param x point, were the gradient is computed; 2458/// \param grad used to return the computed gradient, assumed to be of at least fNpar size; 2459/// \param eps if the errors of parameters have been computed, the step used in; 2460/// numerical differentiation is eps*parameter_error.; 2461///; 2462/// if the errors have not been computed, step=eps is used; 2463/// default value of eps = 0.01; 2464/// Method is the same as in Derivative() function; 2465///; 2466/// If a parameter is fixed, the gradient on this parameter = 0; 2467 ; 2468void TF1::GradientPar(const Double_t *x, Double_t *grad, Double_t eps); 2469{; 2470 if (fFormula && fFormula->HasGeneratedGradient()) {; 2471 // need to zero the gradient buffer; 2472 std::fill(grad, grad + fNpar, 0.);; 2473 fFormula->GradientPar(x,grad);; 2474 }; 2475 else; 2476 GradientParTempl<Double_t>(x, grad, eps);; 2477}; 2478 ; 2479////////////////////////////////////////////////////////////////////////////////; 2480/// Initialize parameters addresses.; 2481 ; 2482void TF1::InitArgs(const Double_t *x, const Double_t *params); 2483{; 2484 if (fMethodCall) {; 2485 Longptr_t args[2];; 2486 args[0] = (Longptr_t)x;; 2487 if (params) args[1] = (Longptr_t)params;; 2488 else args[1] = (Longptr_t)GetParameters();; 2489 fMethodCall->SetParamPtrs(args);; 2490 }; 2491}; 2492 ; 2493 ; 2494//",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:92858,Availability,error,error,92858,"D(gROOTMutex);; 2501 if (!gROOT->GetListOfFunctions()->FindObject(""gaus"")) {; 2502 f1 = new TF1(""gaus"", ""gaus"", -1, 1);; 2503 f1->SetParameters(1, 0, 1);; 2504 f1 = new TF1(""gausn"", ""gausn"", -1, 1);; 2505 f1->SetParameters(1, 0, 1);; 2506 f1 = new TF1(""landau"", ""landau"", -1, 1);; 2507 f1->SetParameters(1, 0, 1);; 2508 f1 = new TF1(""landaun"", ""landaun"", -1, 1);; 2509 f1->SetParameters(1, 0, 1);; 2510 f1 = new TF1(""expo"", ""expo"", -1, 1);; 2511 f1->SetParameters(1, 1);; 2512 for (Int_t i = 0; i < 10; i++) {; 2513 auto f1name = TString::Format(""pol%d"", i);; 2514 f1 = new TF1(f1name.Data(), f1name.Data(), -1, 1);; 2515 f1->SetParameters(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);; 2516 // create also chebyshev polynomial; 2517 // (note polynomial object will not be deleted); 2518 // note that these functions cannot be stored; 2519 ROOT::Math::ChebyshevPol *pol = new ROOT::Math::ChebyshevPol(i);; 2520 Double_t min = -1;; 2521 Double_t max = 1;; 2522 f1 = new TF1(TString::Format(""chebyshev%d"", i), pol, min, max, i + 1, 1);; 2523 f1->SetParameters(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);; 2524 }; 2525 ; 2526 }; 2527}; 2528////////////////////////////////////////////////////////////////////////////////; 2529/// IntegralOneDim or analytical integral; 2530 ; 2531Double_t TF1::Integral(Double_t a, Double_t b, Double_t epsrel); 2532{; 2533 Double_t error = 0;; 2534 if (GetNumber() > 0) {; 2535 Double_t result = 0.;; 2536 if (gDebug) {; 2537 Info(""computing analytical integral for function %s with number %d"", GetName(), GetNumber());; 2538 }; 2539 result = AnalyticalIntegral(this, a, b);; 2540 // if it is a formula that havent been implemented in analytical integral a NaN is return; 2541 if (!TMath::IsNaN(result)) return result;; 2542 if (gDebug); 2543 Warning(""analytical integral not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548/////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93302,Availability,avail,available,93302,"hat these functions cannot be stored; 2519 ROOT::Math::ChebyshevPol *pol = new ROOT::Math::ChebyshevPol(i);; 2520 Double_t min = -1;; 2521 Double_t max = 1;; 2522 f1 = new TF1(TString::Format(""chebyshev%d"", i), pol, min, max, i + 1, 1);; 2523 f1->SetParameters(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);; 2524 }; 2525 ; 2526 }; 2527}; 2528////////////////////////////////////////////////////////////////////////////////; 2529/// IntegralOneDim or analytical integral; 2530 ; 2531Double_t TF1::Integral(Double_t a, Double_t b, Double_t epsrel); 2532{; 2533 Double_t error = 0;; 2534 if (GetNumber() > 0) {; 2535 Double_t result = 0.;; 2536 if (gDebug) {; 2537 Info(""computing analytical integral for function %s with number %d"", GetName(), GetNumber());; 2538 }; 2539 result = AnalyticalIntegral(this, a, b);; 2540 // if it is a formula that havent been implemented in analytical integral a NaN is return; 2541 if (!TMath::IsNaN(result)) return result;; 2542 if (gDebug); 2543 Warning(""analytical integral not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93448,Availability,error,error,93448,"hat these functions cannot be stored; 2519 ROOT::Math::ChebyshevPol *pol = new ROOT::Math::ChebyshevPol(i);; 2520 Double_t min = -1;; 2521 Double_t max = 1;; 2522 f1 = new TF1(TString::Format(""chebyshev%d"", i), pol, min, max, i + 1, 1);; 2523 f1->SetParameters(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);; 2524 }; 2525 ; 2526 }; 2527}; 2528////////////////////////////////////////////////////////////////////////////////; 2529/// IntegralOneDim or analytical integral; 2530 ; 2531Double_t TF1::Integral(Double_t a, Double_t b, Double_t epsrel); 2532{; 2533 Double_t error = 0;; 2534 if (GetNumber() > 0) {; 2535 Double_t result = 0.;; 2536 if (gDebug) {; 2537 Info(""computing analytical integral for function %s with number %d"", GetName(), GetNumber());; 2538 }; 2539 result = AnalyticalIntegral(this, a, b);; 2540 // if it is a formula that havent been implemented in analytical integral a NaN is return; 2541 if (!TMath::IsNaN(result)) return result;; 2542 if (gDebug); 2543 Warning(""analytical integral not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93677,Availability,toler,tolerance,93677,"hat these functions cannot be stored; 2519 ROOT::Math::ChebyshevPol *pol = new ROOT::Math::ChebyshevPol(i);; 2520 Double_t min = -1;; 2521 Double_t max = 1;; 2522 f1 = new TF1(TString::Format(""chebyshev%d"", i), pol, min, max, i + 1, 1);; 2523 f1->SetParameters(1, 1, 1, 1, 1, 1, 1, 1, 1, 1);; 2524 }; 2525 ; 2526 }; 2527}; 2528////////////////////////////////////////////////////////////////////////////////; 2529/// IntegralOneDim or analytical integral; 2530 ; 2531Double_t TF1::Integral(Double_t a, Double_t b, Double_t epsrel); 2532{; 2533 Double_t error = 0;; 2534 if (GetNumber() > 0) {; 2535 Double_t result = 0.;; 2536 if (gDebug) {; 2537 Info(""computing analytical integral for function %s with number %d"", GetName(), GetNumber());; 2538 }; 2539 result = AnalyticalIntegral(this, a, b);; 2540 // if it is a formula that havent been implemented in analytical integral a NaN is return; 2541 if (!TMath::IsNaN(result)) return result;; 2542 if (gDebug); 2543 Warning(""analytical integral not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:96857,Availability,error,error,96857,"\n"",r2);; 2601/// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; 2602/// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; 2603/// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; 2604/// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; 2605/// delete [] x;; 2606/// delete [] w;; 2607/// }; 2608/// ~~~; 2609///; 2610/// This example produces the following results:; 2611///; 2612/// ~~~ {.cpp}; 2613/// g->Integral(0,5) = 1.25331; 2614/// g->Integral(0,1000) = 1.25319; 2615/// g->IntegralFast(n,x,w,0,5) = 1.25331; 2616/// g->IntegralFast(n,x,w,0,1000) = 1.25331; 2617/// g->IntegralFast(n,x,w,0,10000) = 1.25331; 2618/// g->IntegralFast(n,x,w,0,100000)= 1.253; 2619/// ~~~; 2620 ; 2621Double_t TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &error); 2622{; 2623 //Double_t *parameters = GetParameters();; 2624 TF1_EvalWrapper wf1(this, nullptr, fgAbsValue);; 2625 Double_t result = 0;; 2626 Int_t status = 0;; 2627 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerance();; 2628 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerance();; 2629 if (ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationOneDim::kGAUSS) {; 2630 ROOT::Math::GaussIntegrator iod(epsabs, epsrel);; 2631 iod.SetFunction(wf1);; 2632 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2633 result = iod.Integral(a, b);; 2634 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2635 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity());",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:97810,Availability,error,error,97810,"_t b, Double_t epsrel, Double_t epsabs, Double_t &error); 2622{; 2623 //Double_t *parameters = GetParameters();; 2624 TF1_EvalWrapper wf1(this, nullptr, fgAbsValue);; 2625 Double_t result = 0;; 2626 Int_t status = 0;; 2627 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerance();; 2628 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerance();; 2629 if (ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationOneDim::kGAUSS) {; 2630 ROOT::Math::GaussIntegrator iod(epsabs, epsrel);; 2631 iod.SetFunction(wf1);; 2632 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2633 result = iod.Integral(a, b);; 2634 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2635 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2645 result = iod.Integral(a, b);; 2646 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2647 result = iod.IntegralLow(b);; 2648 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2649 result = iod.IntegralUp(a);; 2650 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2651 result = iod.Integral();; 2652 error = iod.Error();; 2653 status = iod.Status();; 2654 }; 2655 if (status != 0) {; 2656 std::string igName = ROOT::Math::IntegratorOneDim::GetName(ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());; 2657 Warning(""IntegralOneDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TSt",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:98402,Availability,error,error,98402,"(wf1);; 2632 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2633 result = iod.Integral(a, b);; 2634 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2635 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2645 result = iod.Integral(a, b);; 2646 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2647 result = iod.IntegralLow(b);; 2648 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2649 result = iod.IntegralUp(a);; 2650 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2651 result = iod.Integral();; 2652 error = iod.Error();; 2653 status = iod.Status();; 2654 }; 2655 if (status != 0) {; 2656 std::string igName = ROOT::Math::IntegratorOneDim::GetName(ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());; 2657 Warning(""IntegralOneDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TString msg(""\t\tFunction Parameters = {"");; 2659 for (int ipar = 0; ipar < GetNpar(); ++ipar) {; 2660 msg += TString::Format("" %s = %f "", GetParName(ipar), GetParameter(ipar));; 2661 if (ipar < GetNpar() - 1) msg += TString("","");; 2662 else msg += TString(""}"");; 2663 }; 2664 Info(""IntegralOneDim"", ""%s"", msg.Data());; 2665 }; 2666 return result;; 2667}; 2668 ; 2669////////////////////////////////////////////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:98782,Availability,error,error,98782,"orOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2645 result = iod.Integral(a, b);; 2646 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2647 result = iod.IntegralLow(b);; 2648 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2649 result = iod.IntegralUp(a);; 2650 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2651 result = iod.Integral();; 2652 error = iod.Error();; 2653 status = iod.Status();; 2654 }; 2655 if (status != 0) {; 2656 std::string igName = ROOT::Math::IntegratorOneDim::GetName(ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());; 2657 Warning(""IntegralOneDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TString msg(""\t\tFunction Parameters = {"");; 2659 for (int ipar = 0; ipar < GetNpar(); ++ipar) {; 2660 msg += TString::Format("" %s = %f "", GetParName(ipar), GetParameter(ipar));; 2661 if (ipar < GetNpar() - 1) msg += TString("","");; 2662 else msg += TString(""}"");; 2663 }; 2664 Info(""IntegralOneDim"", ""%s"", msg.Data());; 2665 }; 2666 return result;; 2667}; 2668 ; 2669////////////////////////////////////////////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatr",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:100279,Availability,error,error,100279,"//////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 27",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:100700,Availability,error,error,100700,"2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 2702///; 2703/// The user must pass a pointer to the elements of the full covariance matrix; 2704/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2705/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2706/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2707 ; 2708Double_t TF1::IntegralError(Double_t a, Double_t b, const Double_t ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:100956,Availability,error,error,100956,"varianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 2702///; 2703/// The user must pass a pointer to the elements of the full covariance matrix; 2704/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2705/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2706/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2707 ; 2708Double_t TF1::IntegralError(Double_t a, Double_t b, const Double_t *params, const Double_t *covmat, Double_t epsilon); 2709{; 2710 Double_t x1[1];; 2711 Double_t x2[1];; 2712 x1[0] = a, x2[0] = b;; 2713 return ROOT::TF1Helper::IntegralError(this, 1, x1, x2, params, covmat, epsilon);; 2714}; 2715 ; 2716",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:103186,Availability,error,error,103186," a[] and b[] due to the parameters uncertainties.; 2719/// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); 2720/// TF1::IntegralMultiple is used for the integral calculation; 2721///; 2722/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2723/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2724/// previously performed fit using the TFitResult class.; 2725/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 27",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:103607,Availability,error,error,103607,"25/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2757 ; 2758Double_t TF1::IntegralError(Int_t n, const Double_t *a, const Doubl",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:103863,Availability,error,error,103863,"varianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2757 ; 2758Double_t TF1::IntegralError(Int_t n, const Double_t *a, const Double_t *b, const Double_t *params, const Double_t *covmat, Double_t epsilon); 2759{; 2760 return ROOT::TF1Helper::IntegralError(this, n, a, b, params, covmat, epsilon);; 2761}; 2762 ; 2763#ifdef INTHEFUTURE; 2764///////////////////////////",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:109753,Availability,toler,tolerance,109753,"s; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(result) : imd.Error();; 2870 nfnevl = 0;; 2871 ifail = imd.Status();; 2872 }; 2873 ; 2874 ; 2875 return result;; 2876}; 2877 ; 2878 ; 2879////////////////////////////////////////////////////////////////////////////////; 2880/// Return kTRUE if the function is valid; 2881 ; 2882Bool_t TF1::IsValid() const; 2883{; 2884 if (fFormula) return fFormula->IsValid();; 2885 if (fMethodCall) return fMethodCall->IsValid();; 2886 // function built on compiled functors are always valid by definition; 2887 // (checked at compiled time); 2888 // invalid is a TF1 where the functor is null pointer and has not been saved; 2889 if (!fFunctor && fSave.empty()) return kFALSE;; 2890 return kTRUE;; 2891}; 2892 ; 2893 ; 2894//______________________________________________________________________________; 2895 ; 2896 ; 2897void",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:109774,Availability,toler,tolerance,109774,"s; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(result) : imd.Error();; 2870 nfnevl = 0;; 2871 ifail = imd.Status();; 2872 }; 2873 ; 2874 ; 2875 return result;; 2876}; 2877 ; 2878 ; 2879////////////////////////////////////////////////////////////////////////////////; 2880/// Return kTRUE if the function is valid; 2881 ; 2882Bool_t TF1::IsValid() const; 2883{; 2884 if (fFormula) return fFormula->IsValid();; 2885 if (fMethodCall) return fMethodCall->IsValid();; 2886 // function built on compiled functors are always valid by definition; 2887 // (checked at compiled time); 2888 // invalid is a TF1 where the functor is null pointer and has not been saved; 2889 if (!fFunctor && fSave.empty()) return kFALSE;; 2890 return kTRUE;; 2891}; 2892 ; 2893 ; 2894//______________________________________________________________________________; 2895 ; 2896 ; 2897void",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:127849,Availability,error,errors,127849," Double_t parmin, parmax;; 3325 for (i = 0; i < GetNpar(); i++) {; 3326 out << "" "" << f1Name.Data() << ""->SetParameter("" << i << "","" << GetParameter(i) << "");"" << std::endl;; 3327 out << "" "" << f1Name.Data() << ""->SetParError("" << i << "","" << GetParError(i) << "");"" << std::endl;; 3328 GetParLimits(i, parmin, parmax);; 3329 out << "" "" << f1Name.Data() << ""->SetParLimits("" << i << "","" << parmin << "","" << parmax << "");"" << std::endl;; 3330 }; 3331 if (!strstr(option, ""nodraw"")) {; 3332 out << "" "" << f1Name.Data() << ""->Draw(""; 3333 << quote << option << quote << "");"" << std::endl;; 3334 }; 3335}; 3336 ; 3337 ; 3338////////////////////////////////////////////////////////////////////////////////; 3339/// Static function setting the current function.; 3340/// the current function may be accessed in static C-like functions; 3341/// when fitting or painting a function.; 3342 ; 3343void TF1::SetCurrent(TF1 *f1); 3344{; 3345 fgCurrent = f1;; 3346}; 3347 ; 3348////////////////////////////////////////////////////////////////////////////////; 3349/// Set the result from the fit; 3350/// parameter values, errors, chi2, etc...; 3351/// Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; 3352/// This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; 3353/// By default it is assume that indpar = {0,1,2,....,fNpar-1}.; 3354 ; 3355void TF1::SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar); 3356{; 3357 Int_t npar = GetNpar();; 3358 if (result.IsEmpty()) {; 3359 Warning(""SetFitResult"", ""Empty Fit result - nothing is set in TF1"");; 3360 return;; 3361 }; 3362 if (indpar == nullptr && npar != (int) result.NPar()) {; 3363 Error(""SetFitResult"", ""Invalid Fit result passed - number of parameter is %d , different than TF1::GetNpar() = %d"", npar, result.NPar());; 3364 return;; 3365 }; 3366 if (result.Chi2() > 0); 3367 SetChisquare(result.Chi2());; 3368 else; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:129092,Availability,error,errors,129092,"t; 3353/// By default it is assume that indpar = {0,1,2,....,fNpar-1}.; 3354 ; 3355void TF1::SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar); 3356{; 3357 Int_t npar = GetNpar();; 3358 if (result.IsEmpty()) {; 3359 Warning(""SetFitResult"", ""Empty Fit result - nothing is set in TF1"");; 3360 return;; 3361 }; 3362 if (indpar == nullptr && npar != (int) result.NPar()) {; 3363 Error(""SetFitResult"", ""Invalid Fit result passed - number of parameter is %d , different than TF1::GetNpar() = %d"", npar, result.NPar());; 3364 return;; 3365 }; 3366 if (result.Chi2() > 0); 3367 SetChisquare(result.Chi2());; 3368 else; 3369 SetChisquare(result.MinFcnValue());; 3370 ; 3371 SetNDF(result.Ndf());; 3372 SetNumberFitPoints(result.Ndf() + result.NFreeParameters());; 3373 ; 3374 ; 3375 for (Int_t i = 0; i < npar; ++i) {; 3376 Int_t ipar = (indpar != nullptr) ? indpar[i] : i;; 3377 if (ipar < 0) continue;; 3378 GetParameters()[i] = result.Parameter(ipar);; 3379 // in case errors are not present do not set them; 3380 if (ipar < (int) result.Errors().size()); 3381 fParErrors[i] = result.Error(ipar);; 3382 }; 3383 //invalidate cached integral since parameters have changed; 3384 Update();; 3385 ; 3386}; 3387 ; 3388 ; 3389////////////////////////////////////////////////////////////////////////////////; 3390/// Set the maximum value along Y for this function; 3391/// In case the function is already drawn, set also the maximum in the; 3392/// helper histogram; 3393 ; 3394void TF1::SetMaximum(Double_t maximum); 3395{; 3396 fMaximum = maximum;; 3397 if (fHistogram) fHistogram->SetMaximum(maximum);; 3398 if (gPad) gPad->Modified();; 3399}; 3400 ; 3401 ; 3402////////////////////////////////////////////////////////////////////////////////; 3403/// Set the minimum value along Y for this function; 3404/// In case the function is already drawn, set also the minimum in the; 3405/// helper histogram; 3406 ; 3407void TF1::SetMinimum(Double_t minimum); 3408{; 3409 fMinimum = minimum;; 3410",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133009,Availability,error,error,133009,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133096,Availability,error,error,133096,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133187,Availability,error,error,133187,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133314,Availability,error,errors,133314,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133394,Availability,error,errors,133394,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133484,Availability,error,errors,133484,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133510,Availability,error,errors,133510,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:133586,Availability,error,errors,133586,"464 const char *name5, const char *name6, const char *name7, const char *name8, const char *name9, const char *name10); 3465{; 3466 // Note: this is not made a variadic template method because it would; 3467 // presumably break the context menu in the TBrowser. Also, probably this; 3468 // method should not be virtual, because if the user wants to change; 3469 // parameter name setting behavior, the SetParName() method can be; 3470 // overridden.; 3471 if (fFormula); 3472 fFormula->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3473 else; 3474 fParams->SetParNames(name0, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10);; 3475}; 3476////////////////////////////////////////////////////////////////////////////////; 3477/// Set error for parameter number ipar; 3478 ; 3479void TF1::SetParError(Int_t ipar, Double_t error); 3480{; 3481 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3482 fParErrors[ipar] = error;; 3483}; 3484 ; 3485 ; 3486////////////////////////////////////////////////////////////////////////////////; 3487/// Set errors for all active parameters; 3488/// when calling this function, the array errors must have at least fNpar values; 3489 ; 3490void TF1::SetParErrors(const Double_t *errors); 3491{; 3492 if (!errors) return;; 3493 for (Int_t i = 0; i < GetNpar(); i++) fParErrors[i] = errors[i];; 3494}; 3495 ; 3496 ; 3497////////////////////////////////////////////////////////////////////////////////; 3498/// Set lower and upper limits for parameter ipar.; 3499/// The specified limits will be used in a fit operation.; 3500/// Note that when this function is a pre-defined function (e.g. gaus); 3501/// one needs to use the fit option ""B"" to have the limits used in the fit.; 3502/// See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation; 3503/// and the [fitting options](\ref HFitOpt); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void T",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:147756,Availability,error,error,147756,"nition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; RichardsonDerivator.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; Version_tshort Version_tDefinition RtypesCore.h:65; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBuffer.h; TColor.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TF1Convolution.h; TF1Data.h; TF1Helper.h; TF1NormSum.h; R__SetClonesArrayTF1Updaterbool R__SetClonesArrayTF1Updater(TF1Updater_t func)Definition TClonesArray.cxx:146; GetGlobalListOptionTF1::EAddToList GetGlobalListOption(Option_t *opt)Definition TF1.cxx:669; R__RegisterTF1UpdaterTriggerint R__RegisterTF1UpdaterTriggerDefinition TF1.cxx:146; TF1Updater_tvoid(*)(Int_t nobjects, TObject **from, TObject **to) TF1Updater_tDefinition TF1.cxx:63; gErrorTF1static Double_t gErrorTF1Definition TF1.cxx:61; R__v5TF1Updaterstatic void R__v5TF1Updater(Int_t nobjects, TObject **from, TObject **to)Definition TF1.cxx:135; GetVectorizedOptionbool GetVectorizedOption(Option_t *opt)Definition TF1.cxx:679; TF1.h; GetParametersvoid GetParameters(TFitEditor::FuncParams_t &pars, TF1 *func)Stores the parameters of the given function into pars.Definition TFitEditor.cxx:256; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwin",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154810,Availability,error,errorDefinition,154810,"GInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentMinimizer1D.h:122; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinim",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:155358,Availability,toler,tolerance,155358,"::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentMinimizer1D.h:122; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; ROOT::Math::BrentMinimizer1D::FValMinimumdouble FValMinimum() const overrideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Math::BrentRootFinderClass for finding the root of a one dimensional function using the Brent algorithm.Definition BrentRootFinder.h:51; ROOT::Math::BrentRootFinder::SetFunctionbool SetFunction(const ROOT::Math::IGenFunction &f, double xlow, dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:160433,Availability,error,errorDefinition,160433,"nMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:367; ROOT::Math::IntegratorMultiDimUser class for performing multidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, d",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:163096,Availability,toler,toleranceDefinition,163096,"le b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT::Math::MinimizerOptions::DefaultMinimizerAlgostatic const std::string & DefaultMinimizerAlgo()Definition MinimizerOptions.cxx:85; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetLimitedVariablevirtual bool SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower, double upper)set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition Minimizer.cxx:34; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::MinValuevirtual double MinValue() const =0return minimum function value; ROOT::Math::ParamFunctorTemplParam Functor class for Multidimensional functions.Definition ParamFunctor.h:274; ROOT::Math::RichardsonDerivatorUser class for calculating the derivatives of a function.Definition RichardsonDerivator.h:55; ROOT::Math::RichardsonDerivator::Derivative2double Derivative2(double x)Returns the second derivati",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:174514,Availability,error,error,174514,"F1.cxx:190; TF1_EvalWrapper::fAbsValBool_t fAbsValDefinition TF1.cxx:233; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Defin",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:174524,Availability,error,error,174524,"F1.cxx:190; TF1_EvalWrapper::fAbsValBool_t fAbsValDefinition TF1.cxx:233; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Defin",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:175463,Availability,error,errors,175463,"x:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::S",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:179905,Availability,error,errors,179905,"ZaxisTAxis * GetZaxis() constGet z axis of the function. (In case this object is a TF2 or TF3)Definition TF1.cxx:2422; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:179916,Availability,error,errors,179916,"ZaxisTAxis * GetZaxis() constGet z axis of the function. (In case this object is a TF2 or TF3)Definition TF1.cxx:2422; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:179987,Availability,error,errors,179987,"ZaxisTAxis * GetZaxis() constGet z axis of the function. (In case this object is a TF2 or TF3)Definition TF1.cxx:2422; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:181721,Availability,error,error,181721,"1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetTitlevoid SetTitle(const char *title="""") overrideSet function title if title has the form ""fffffff;xxxx;yyyy"", it is assumed that the function title i...Definition TF1.cxx:3558; TF1::fFormulastd::unique_ptr< TFormula > fFormulaPointer to TFormula in case when user define formula.Definition TF1.h:288; TF1::SetParNamesvirtual void SetParNames(const char *name0="""", const char *name1="""", const char *name2="""", const char *name3="""", const char *name4="""", const char *name5="""", const char *name6="""", const char *name7="""", const char *name8="""", const char *name9="""", const char *name10="""")Set up to 10 parameter names.Definition TF1.cxx:3463; TF1::DerivativeErrorstatic Double_t DerivativeError()Static function returning the error of the last call to the of Derivative's functions.Definition TF1.cxx:1277; TF1::fParMinstd::vector< Double_t > fParMinArray of lower limits of the fNpar parameters.Definition TF1.h:275; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TF1.h:273; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TF1.h:272; TF1::TermCoeffLengthint TermCoeffLength(TString &term)Definition TF1.cxx:924; TF1::fgRejectPointstatic Bool_t fgRejectPointDefinition TF1.h:325; TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::Streamervoid Streamer(TBuffer &) overrideStream a class object.De",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:192512,Availability,error,errors,192512,"false) constReturns the X value corresponding to the maximum value of the function.Definition TF1.cxx:1655; TF1::IsATClass * IsA() const overrideDefinition TF1.h:755; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TF1::GetXminvirtual Double_t GetXmin() constDefinition TF1.h:580; TF1::AddToGlobalListvirtual Bool_t AddToGlobalList(Bool_t on=kTRUE)Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the fu...Definition TF1.cxx:847; TF1::IntegralOneDimvirtual Double_t IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)Return Integral of function between a and b using the given parameter values and relative and absolut...Definition TF1.cxx:2621; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF1::GetParNumbervirtual Int_t GetParNumber(const char *name) constDefinition TF1.h:561; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF1::GetXaxisTAxis * GetXaxis() constGet x axis of the function.Definition TF1.cxx:2400; TFormulaThe Formula class.Definition TFormula.h:89; TFormula::fFormulaTString fFormulaString representing the formula expression.Definition TFormula.h:148; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::GetBinCentervirtual Do",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:197864,Availability,error,error,197864,"bject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind firs",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:5712,Deployability,integrat,integration,5712,"; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function , double y): fFunction(function), fY0(y) {}; 156 double operator()(double x) const; 157 {; 158 return fFunction->Eval(x) - fY0;; 159 }; 160};; 161 ; 162// class wrapping evaluation of -TF1(x); 163class GInverseFunc {; 164 const TF1 *fFunction;; 165public:; 166 GInverseFunc(const TF1 *function): fFunction(function) {}; 167 ; 168 double operator()(double x) const; 169 {; 170 return - fFunction->Eval(x);; 171 }; 172};; 173// class wrapping evaluation of -TF1(x) for multi-dimension; 174class GInverseFuncNdim {; 175 TF1 *fFunction;; 176public:; 177 GInverseFuncNdim(TF1 *function): fFunction(function) {}; 178 ; 179 double operator()(const double *x) const; 180 {; 181 return - fFunction->EvalPar(x, (Double_t *)nullptr);; 182 }; 183};; 184 ; 185// class wrapping function evaluation directly in 1D interface (used for integration); 186// and implementing the methods for the momentum calculations; 187 ; 188class TF1_EvalWrapper : public ROOT::Math::IGenFunction {; 189public:; 190 TF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n = 1, Double_t x0 = 0) :; 191 fFunc(f),; 192 fPar(((par) ? par : f->GetParameters())),; 193 fAbsVal(useAbsVal),; 194 fN(n),; 195 fX0(x0); 196 {; 197 fFunc->InitArgs(fX, fPar);; 198 if (par) fFunc->SetParameters(par);; 199 }; 200 ; 201 ROOT::Math::IGenFunction *Clone() const override; 202 {; 203 // use default copy constructor; 204 TF1_EvalWrapper *f = new TF1_EvalWrapper(*this);; 205 f->fFunc->InitArgs(f->fX, f->fPar);; 206 return f;; 207 }; 208 // evaluate |f(x)|; 209 Double_t DoEval(Double_t x) const override; 210 {; 211 // use evaluation with stored parameters (i.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:79793,Deployability,integrat,integrated,79793," = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; 2165/// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; 2166/// xmax, xmin and Npx (function points).; 2167/// Possible values are:; 2168/// - ""LOG"" to force usage of log scale for tabulating the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never d",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:81895,Deployability,integrat,integrated,81895,"/// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; 2187/// whatever the fXmax/fXmin ratio is; 2188///; 2189/// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.; 2190 ; 2191 ; 2192Double_t TF1::GetRandom(TRandom * rng, Option_t * option); 2193{; 2194 // Check if integral array must be built; 2195 if (fIntegral.empty()) {; 2196 Bool_t ret = ComputeCdfTable(option);; 2197 if (!ret) return TMath::QuietNaN();; 2198 }; 2199 ; 2200 ; 2201 // return random number; 2202 Double_t r = (rng) ? rng->Rndm() : gRandom->Rndm();; 2203 Int_t bin = TMath::BinarySearch(fNpx, fIntegral.data(), r);; 2204 Double_t rr = r - fIntegral[bin];; 2205 ; 2206 Double_t yy;; 2207 if (fGamma[bin] != 0); 2208 yy = (-fBeta[bin] + TMath::Sqrt(fBeta[bin] * fBeta[bin] + 2 * fGamma[bin] * rr)) / fGamma[bin];; 2209 else; 2210 yy = rr / fBeta[bin];; 2211 Double_t x = fAlpha[bin] + yy;; 2212 if (fAlpha[fNpx] > 0) return TMath::Power(10, x);; 2213 return x;; 2214}; 2215 ; 2216 ; 2217////////////////////////////////////////////////////////////////////////////////; 2218/// Return a random number following this function shape in [xmin,xmax]; 2219///; 2220/// The distribution contained in the function fname (TF1) is integrated; 2221/// over the channel contents.; 2222/// It is normalized to 1.; 2223/// For each bin the integral is approximated by a parabola.; 2224/// The parabola coefficients are stored as non persistent data members; 2225/// Getting one random number implies:; 2226/// - Generating a random number between 0 and 1 (say r1); 2227/// - Look in which bin in the normalized integral r1 corresponds to; 2228/// - Evaluate the parabolic curve in the selected bin to find; 2229/// the corresponding X value.; 2230///; 2231/// The parabolic approximation is very good as soon as the number; 2232/// of bins is greater than 50.; 2233///; 2234/// @param xmin minimum value for generated random numbers; 2235/// @param x",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93718,Deployability,integrat,integrator,93718,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93864,Deployability,integrat,integrator,93864,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94116,Deployability,integrat,integration,94116,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94158,Deployability,integrat,integration,94158,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94289,Deployability,integrat,integrator,94289,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94711,Deployability,integrat,integrators,94711,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94762,Deployability,install,installed,94762,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:95368,Deployability,integrat,integration,95368," interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",""gaus"",-5,5);; 2584/// g->SetParameters(1,0,1);; 2585/// //default gaus integration method uses 6 points; 2586/// //not suitable to integrate on a large domain; 2587/// double r1 = g->Integral(0,5);; 2588/// double r2 = g->Integral(0,1000);; 2589///; 2590/// //try with user directives computing more points; 2591/// Int_t np = 1000;; 2592/// double *x=new double[np];; 2593/// double *w=new double[np];; 2594/// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; 2595/// double r3 = g->IntegralFast(np,x,w,0,5);; 2596/// double r4 = g->IntegralFast(np,x,w,0,1000);; 2597/// double r5 = g->IntegralFast(np,x,w,0,10000);; 2598/// double r6 = g->IntegralFast(np,x,w,0,100000);; 2599/// printf(""g->Integral(0,5) = %g\n"",r1);; 2600/// printf(""g->Integral(0,1000) = %g\n"",r2);; 2601/// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; 2602/// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; 2603/// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; 2604/// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; 2605/// delete [] x;; 2606/// delete [] w;; 2607/// }; 2608/// ~~~; 2609///; 2610/// This example produces the following results:; 2611///; 2612/// ~~~ {.cpp}; 2613/// g->Integral(0,5) = 1.25331; 2614/// g->Integral(0,1000) = 1.25319; 2615/// g->IntegralFast(n,x,w,0,5) = 1.25331; 2616/// g->IntegralFast(n,x,w,0,1000) = 1.25331; 2617/// g->IntegralFast(n,x,w,0,10000) = 1.25331; 2618/// g->IntegralFast(n,x,w,0,100000)= 1.253; 2619/// ~~~; 2620 ; 2621Double_t TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:95428,Deployability,integrat,integrate,95428," interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",""gaus"",-5,5);; 2584/// g->SetParameters(1,0,1);; 2585/// //default gaus integration method uses 6 points; 2586/// //not suitable to integrate on a large domain; 2587/// double r1 = g->Integral(0,5);; 2588/// double r2 = g->Integral(0,1000);; 2589///; 2590/// //try with user directives computing more points; 2591/// Int_t np = 1000;; 2592/// double *x=new double[np];; 2593/// double *w=new double[np];; 2594/// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; 2595/// double r3 = g->IntegralFast(np,x,w,0,5);; 2596/// double r4 = g->IntegralFast(np,x,w,0,1000);; 2597/// double r5 = g->IntegralFast(np,x,w,0,10000);; 2598/// double r6 = g->IntegralFast(np,x,w,0,100000);; 2599/// printf(""g->Integral(0,5) = %g\n"",r1);; 2600/// printf(""g->Integral(0,1000) = %g\n"",r2);; 2601/// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; 2602/// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; 2603/// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; 2604/// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; 2605/// delete [] x;; 2606/// delete [] w;; 2607/// }; 2608/// ~~~; 2609///; 2610/// This example produces the following results:; 2611///; 2612/// ~~~ {.cpp}; 2613/// g->Integral(0,5) = 1.25331; 2614/// g->Integral(0,1000) = 1.25319; 2615/// g->IntegralFast(n,x,w,0,5) = 1.25331; 2616/// g->IntegralFast(n,x,w,0,1000) = 1.25331; 2617/// g->IntegralFast(n,x,w,0,10000) = 1.25331; 2618/// g->IntegralFast(n,x,w,0,100000)= 1.253; 2619/// ~~~; 2620 ; 2621Double_t TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:98661,Deployability,integrat,integrating,98661,"35 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2645 result = iod.Integral(a, b);; 2646 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2647 result = iod.IntegralLow(b);; 2648 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2649 result = iod.IntegralUp(a);; 2650 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2651 result = iod.Integral();; 2652 error = iod.Error();; 2653 status = iod.Status();; 2654 }; 2655 if (status != 0) {; 2656 std::string igName = ROOT::Math::IntegratorOneDim::GetName(ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());; 2657 Warning(""IntegralOneDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TString msg(""\t\tFunction Parameters = {"");; 2659 for (int ipar = 0; ipar < GetNpar(); ++ipar) {; 2660 msg += TString::Format("" %s = %f "", GetParName(ipar), GetParameter(ipar));; 2661 if (ipar < GetNpar() - 1) msg += TString("","");; 2662 else msg += TString(""}"");; 2663 }; 2664 Info(""IntegralOneDim"", ""%s"", msg.Data());; 2665 }; 2666 return result;; 2667}; 2668 ; 2669////////////////////////////////////////////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix fro",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:107015,Deployability,integrat,integration,107015,"commended to use the other interface where one can specify also epsabs and the maximum number of; 2796/// points; 2797 ; 2798Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Double_t epsrel, Double_t &relerr); 2799{; 2800 Int_t nfnevl, ifail;; 2801 UInt_t maxpts = TMath::Max(UInt_t(20 * TMath::Power(fNpx, GetNdim())), ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls());; 2802 Double_t result = IntegralMultiple(n, a, b, maxpts, epsrel, epsrel, relerr, nfnevl, ifail);; 2803 if (ifail > 0) {; 2804 Warning(""IntegralMultiple"", ""failed code=%d, "", ifail);; 2805 }; 2806 return result;; 2807}; 2808 ; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr conta",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:107339,Deployability,integrat,integration,107339,"s::DefaultNCalls());; 2802 Double_t result = IntegralMultiple(n, a, b, maxpts, epsrel, epsrel, relerr, nfnevl, ifail);; 2803 if (ifail > 0) {; 2804 Warning(""IntegralMultiple"", ""failed code=%d, "", ifail);; 2805 }; 2806 return result;; 2807}; 2808 ; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other meth",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108488,Deployability,integrat,integrators,108488,"param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions:",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108525,Deployability,integrat,integrators,108525,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108544,Deployability,integrat,integrators,108544,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108680,Deployability,integrat,integration,108680,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:119690,Deployability,update,update,119690," 3111 if (fMaximum != -1111) histogram->SetMaximum(fMaximum);; 3112 histogram->SetDirectory(nullptr);; 3113 }; 3114 R__ASSERT(histogram);; 3115 ; 3116 // Restore axis titles.; 3117 histogram->GetXaxis()->SetTitle(xtitle.Data());; 3118 histogram->GetYaxis()->SetTitle(ytitle.Data());; 3119 Double_t *parameters = GetParameters();; 3120 ; 3121 InitArgs(xv, parameters);; 3122 for (i = 1; i <= fNpx; i++) {; 3123 xv[0] = histogram->GetBinCenter(i);; 3124 histogram->SetBinContent(i, EvalPar(xv, parameters));; 3125 }; 3126 ; 3127 // Copy Function attributes to histogram attributes.; 3128 histogram->SetBit(TH1::kNoStats);; 3129 histogram->SetLineColor(GetLineColor());; 3130 histogram->SetLineStyle(GetLineStyle());; 3131 histogram->SetLineWidth(GetLineWidth());; 3132 histogram->SetFillColor(GetFillColor());; 3133 histogram->SetFillStyle(GetFillStyle());; 3134 histogram->SetMarkerColor(GetMarkerColor());; 3135 histogram->SetMarkerStyle(GetMarkerStyle());; 3136 histogram->SetMarkerSize(GetMarkerSize());; 3137 ; 3138 // update saved histogram in case it was deleted or if it is the first time the method is called; 3139 // for example when called from TF1::GetHistogram(); 3140 if (!fHistogram) fHistogram = histogram;; 3141 return histogram;; 3142 ; 3143}; 3144 ; 3145 ; 3146////////////////////////////////////////////////////////////////////////////////; 3147/// Release parameter number ipar during a fit operation.; 3148/// After releasing it, the parameter; 3149/// can vary freely in the fit. The parameter limits are reset to 0,0.; 3150 ; 3151void TF1::ReleaseParameter(Int_t ipar); 3152{; 3153 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3154 SetParLimits(ipar, 0, 0);; 3155}; 3156 ; 3157 ; 3158////////////////////////////////////////////////////////////////////////////////; 3159/// Save values of function in array fSave; 3160 ; 3161void TF1::Save(Double_t xmin, Double_t xmax, Double_t, Double_t, Double_t, Double_t); 3162{; 3163 if (!fSave.empty()); 3164 fSave.clear();; 3165 ; 316",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:135098,Deployability,update,updates,135098,"t); 3504///; 3505/// To fix a parameter, use TF1::FixParameter; 3506 ; 3507void TF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); 3508{; 3509 Int_t npar = GetNpar();; 3510 if (ipar < 0 || ipar > npar - 1) return;; 3511 if (int(fParMin.size()) != npar) {; 3512 fParMin.resize(npar);; 3513 }; 3514 if (int(fParMax.size()) != npar) {; 3515 fParMax.resize(npar);; 3516 }; 3517 fParMin[ipar] = parmin;; 3518 fParMax[ipar] = parmax;; 3519}; 3520 ; 3521 ; 3522////////////////////////////////////////////////////////////////////////////////; 3523/// Initialize the upper and lower bounds to draw the function.; 3524///; 3525/// The function range is also used in an histogram fit operation; 3526/// when the option ""R"" is specified.; 3527 ; 3528void TF1::SetRange(Double_t xmin, Double_t xmax); 3529{; 3530 fXmin = xmin;; 3531 fXmax = xmax;; 3532 if (fType == EFType::kCompositionFcn && fComposition) {; 3533 fComposition->SetRange(xmin, xmax); // automatically updates sub-functions; 3534 }; 3535 Update();; 3536}; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Restore value of function saved at point; 3541 ; 3542void TF1::SetSavedPoint(Int_t point, Double_t value); 3543{; 3544 if (fSave.empty()) {; 3545 fSave.resize(fNpx + 3);; 3546 }; 3547 if (point < 0 || point >= int(fSave.size())) return;; 3548 fSave[point] = value;; 3549}; 3550 ; 3551 ; 3552////////////////////////////////////////////////////////////////////////////////; 3553/// Set function title; 3554/// if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; 3555/// the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; 3556/// titles for the X and Y axis respectively.; 3557 ; 3558void TF1::SetTitle(const char *title); 3559{; 3560 if (!title) return;; 3561 fTitle = title;; 3562 if (!fHistogram) return;; 3563 fHistogram->SetTitle(title);; 3564 if (gPad) gPad->Modified();; 3565}; 3566 ; 3567 ; 3568/////////////////////////////////////////////",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:141654,Deployability,integrat,integrator,141654,"////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3703{; 3704 // wrapped function in interface for integral calculation; 3705 // using abs value of integral; 3706 ; 3707 TF1_EvalWrapper func(this, params, kTRUE, n);; 3708 ; 3709 ROOT::Math::GaussIntegrator giod;; 3710 ; 3711 giod.SetFunction(func);; 3712 giod.SetRelTolerance(epsilon);; 3713 ; 3714 Double_t norm = giod.Integral(a, b);; 3715 if (norm == 0) {; 3716 Error(""Moment"", ""Integral zero over range"");; 3717 return 0;; 3718 }; 3719 ; 3720 // calculate now integral of x^n f(x); 3721 // wrapped the member function EvalNum in interface required by integrator using the functor class; 3722 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Er",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:142785,Deployability,integrat,integrator,142785,"unc, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Error(""Moment"", ""Integral zero over range"");; 3751 return 0;; 3752 }; 3753 ; 3754 // calculate now integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegen",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154055,Deployability,integrat,integration,154055,"ouble operator()(double x) constDefinition TF1.cxx:156; GFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:152; GFunc::fY0const double fY0Definition TF1.cxx:153; GFunc::GFuncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::I",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154247,Deployability,integrat,integrationDefinition,154247,"uncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:157560,Deployability,integrat,integration,157560," the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFinder.cxx:66; ROOT::Math::BrentRootFinder::Rootdouble Root() const overrideReturns root value.Definition BrentRootFinder.h:98; ROOT::Math::BrentRootFinder::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentRootFinder.h:89; ROOT::Math::BrentRootFinder::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentRootFinder.h:95; ROOT::Math::ChebyshevPolDefinition ChebyshevPol.h:129; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) ove",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158354,Deployability,integrat,integration,158354,"ring Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Ma",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158727,Deployability,integrat,integration,158727,"or of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Defi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158867,Deployability,integrat,integration,158867,"lTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance(",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:159946,Deployability,integrat,integration,159946,"or.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:367; ROOT::Math::IntegratorMultiDimUser class for performing multidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDim",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:160421,Deployability,integrat,integration,160421,"nMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:367; ROOT::Math::IntegratorMultiDimUser class for performing multidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, d",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:160947,Deployability,integrat,integration,160947,"tidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::Errordouble Error() constreturn the estimate of the absolute Error of the last Integral calculationDefinition Integrator.h:416; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:200137,Deployability,integrat,integration,200137,"hange string to upper case.Definition TString.cxx:1195; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::GetFuncWidthWidth_t GetFuncWidth() constDefinition TStyle.h:221; TStyle::GetFuncStyleStyle_t GetFuncStyle() constDefinition TStyle.h:220; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; ROOT::Math::IntegrationOneDim::kGAUSS@ kGAUSSsimple Gauss integration method with fixed ruleDefinition AllIntegrationTypes.h:34; ROOT::Math::IntegrationMultiDim::kADAPTIVE@ kADAPTIVEadaptive multi-dimensional integrationDefinition AllIntegrationTypes.h:49; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; Factory.h; MathNamespace for new Math classes and functions.; ROOT::TF1Helper::IntegralErrordouble IntegralError(TF1 *func, Int_t ndim, const double *a, const double *b, const double *params, const double *covmat, double epsilon)Definition TF1Helper.cxx:39; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(D",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:200288,Deployability,integrat,integrationDefinition,200288,"pend(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::GetFuncWidthWidth_t GetFuncWidth() constDefinition TStyle.h:221; TStyle::GetFuncStyleStyle_t GetFuncStyle() constDefinition TStyle.h:220; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; ROOT::Math::IntegrationOneDim::kGAUSS@ kGAUSSsimple Gauss integration method with fixed ruleDefinition AllIntegrationTypes.h:34; ROOT::Math::IntegrationMultiDim::kADAPTIVE@ kADAPTIVEadaptive multi-dimensional integrationDefinition AllIntegrationTypes.h:49; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; Factory.h; MathNamespace for new Math classes and functions.; ROOT::TF1Helper::IntegralErrordouble IntegralError(TF1 *func, Int_t ndim, const double *a, const double *b, const double *params, const double *covmat, double epsilon)Definition TF1Helper.cxx:39; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:10298,Energy Efficiency,power,power,10298,"1,value_second_parameter);; 310~~~~; 311 ; 312 ; 313Parameters may be given a name:; 314 ; 315~~~~{.cpp}; 316 fa->SetParName(0,""Constant"");; 317~~~~; 318 ; 319* Example b:; 320 ; 321~~~~{.cpp}; 322 auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; 323~~~~; 324 ; 325 ; 326``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``.; 327 ; 328#### Case 2: inline expression using TMath functions with parameters; 329 ; 330Begin_Macro(source); 331{; 332 auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; 333 fb2->SetParameters(0.2,1.3);; 334 fb2->Draw();; 335}; 336End_Macro; 337 ; 338\anchor F3; 339### 3 - A lambda expression with variables and parameters; 340 ; 341\since **6.00/00:**; 342TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; 343functions and still maintain the capability of storing the function in a file which cannot be done with; 344function pointer or lambda written not as expression, but as code (see items below).; 345 ; 346Example on how using lambda to define a sum of two functions.; 347Note that is necessary to provide the number of parameters; 348 ; 349~~~~{.cpp}; 350TF1 f1(""f1"",""sin(x)"",0,10);; 351TF1 f2(""f2"",""cos(x)"",0,10);; 352TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; 353~~~~; 354 ; 355\anchor F4; 356### 4 - A general C function with parameters; 357 ; 358Consider the macro myfunc.C below:; 359 ; 360~~~~{.cpp}; 361 // Macro myfunc.C; 362 Double_t myfunction(Double_t *x, Double_t *par); 363 {; 364 Float_t xx =x[0];; 365 Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; 366 return f;; 367 }; 368 void myfunc(); 369 {; 370 auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; 371 f1->SetParameters(2,1);; 372 f1->SetParNames(""constant"",""coefficient"");; 373 f1->Draw();; 374 }; 375 void myfit(); 376 {; 377 auto h1 = new TH1F(""",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:73528,Energy Efficiency,efficient,efficient,73528,"_{\frac{1}{2}}) = \frac{1}{2}; 1973/// \f]; 1974///; 1975/// \param[in] n maximum size of array xp and size of array p; 1976/// \param[out] xp array filled with n quantiles evaluated at p. Memory has to be preallocated by caller.; 1977/// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; 1978/// It is assumed to contain at least n values.; 1979/// \return n, the number of quantiles computed (same as input argument n); 1980///; 1981/// Getting quantiles from two histograms and storing results in a TGraph,; 1982/// a so-called QQ-plot; 1983///; 1984/// TGraph *gr = new TGraph(nprob);; 1985/// f1->GetQuantiles(nprob,gr->GetX(),p);; 1986/// f2->GetQuantiles(nprob,gr->GetY(),p);; 1987/// gr->Draw(""alp"");; 1988///; 1989/// \author Eddy Offermann; 1990/// \warning Function leads to undefined behavior if xp or p are null or; 1991/// their size does not match with n; 1992 ; 1993 ; 1994Int_t TF1::GetQuantiles(Int_t n, Double_t *xp, const Double_t *p); 1995{; 1996 // LM: change to use fNpx; 1997 // should we change code to use a root finder ?; 1998 // It should be more precise and more efficient; 1999 const Int_t npx = TMath::Max(fNpx, 2 * n);; 2000 const Double_t xMin = GetXmin();; 2001 const Double_t xMax = GetXmax();; 2002 const Double_t dx = (xMax - xMin) / npx;; 2003 ; 2004 TArrayD integral(npx + 1);; 2005 TArrayD alpha(npx);; 2006 TArrayD beta(npx);; 2007 TArrayD gamma(npx);; 2008 ; 2009 integral[0] = 0;; 2010 Int_t intNegative = 0;; 2011 Int_t i;; 2012 for (i = 0; i < npx; i++) {; 2013 Double_t integ = Integral(Double_t(xMin + i * dx), Double_t(xMin + i * dx + dx), 0.0);; 2014 if (integ < 0) {; 2015 intNegative++;; 2016 integ = -integ;; 2017 }; 2018 integral[i + 1] = integral[i] + integ;; 2019 }; 2020 ; 2021 if (intNegative > 0); 2022 Warning(""GetQuantiles"", ""function:%s has %d negative values: abs assumed"",; 2023 GetName(), intNegative);; 2024 if (integral[npx] == 0) {; 2025 Error(""GetQuantiles"", ""Integral of function is zero"");; 2026",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93901,Energy Efficiency,adapt,adaptive,93901,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94481,Energy Efficiency,adapt,adaptive,94481,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94563,Energy Efficiency,adapt,adaptive,94563,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94654,Energy Efficiency,adapt,adaptive,94654,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108202,Energy Efficiency,adapt,adaptive,108202,"param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions:",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:145870,Energy Efficiency,efficient,efficient,145870,"f length num, containing the abscissa and weight of the Gauss-Legendre; 3810/// n-point quadrature formula.; 3811///; 3812/// Gauss-Legendre:; 3813/** \f[; 3814 W(x)=1 -1<x<1 \\; 3815 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; 3816 \f]; 3817**/; 3818/// num is the number of sampling points (>0); 3819/// x and w are arrays of size num; 3820/// eps is the relative precision; 3821///; 3822/// If num<=0 or eps<=0 no action is done.; 3823///; 3824/// Reference: Numerical Recipes in C, Second Edition; 3825 ; 3826void TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps); 3827{; 3828 // This function is just kept like this for backward compatibility!; 3829 ; 3830 ROOT::Math::GaussLegendreIntegrator gli(num, eps);; 3831 gli.GetWeightVectors(x, w);; 3832 ; 3833 ; 3834}; 3835 ; 3836 ; 3837/** \class TF1Parameters; 3838TF1 Parameters class; 3839*/; 3840 ; 3841////////////////////////////////////////////////////////////////////////////////; 3842/// Returns the parameter number given a name; 3843/// not very efficient but list of parameters is typically small; 3844/// could use a map if needed; 3845 ; 3846Int_t TF1Parameters::GetParNumber(const char *name) const; 3847{; 3848 for (unsigned int i = 0; i < fParNames.size(); ++i) {; 3849 if (fParNames[i] == std::string(name)) return i;; 3850 }; 3851 return -1;; 3852}; AdaptiveIntegratorMultiDim.h; AnalyticalIntegralDouble_t AnalyticalIntegral(TF1 *f, Double_t a, Double_t b)Definition AnalyticalIntegrals.cxx:28; AnalyticalIntegrals.h; BrentMethods.h; BrentMinimizer1D.h; BrentRootFinder.h; kMouseMotion@ kMouseMotionDefinition Buttons.h:23; ChebyshevPol.h; FitResult.h; Functor.h; GaussIntegrator.h; GaussLegendreIntegrator.h; kHand@ kHandDefinition GuiTypes.h:374; IntegratorMultiDim.h; IntegratorOptions.h; Integrator.h; MinimizerOptions.h; Minimizer.h; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:9",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154035,Energy Efficiency,adapt,adaptive,154035,"ouble operator()(double x) constDefinition TF1.cxx:156; GFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:152; GFunc::fY0const double fY0Definition TF1.cxx:153; GFunc::GFuncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::I",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:171160,Energy Efficiency,allocate,allocated,171160," axis.Definition TAxis.h:31; TAxis::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TAxis.h:135; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TAxis::SaveAttributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::SetLimitsvirtual void SetLimits(Double_t xmin, Double_t xmax)Definition TAxis.h:164; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TF1AbsCompositionDefinition TF1AbsComposition.h:16; TF1AbsComposition::IsATClass * IsA() const overrideDefinition TF1AbsComposition.h:28; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1Convolution.h:71; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1NormSum::GetParametersstd::vector< double > GetParameters() constReturn array of parameters.Definition TF1NormSum.cxx:289; TF1NormSum::GetNparInt_t GetNpar()",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:172509,Energy Efficiency,efficient,efficient,172509,"() const overrideDefinition TF1AbsComposition.h:28; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1Convolution.h:71; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1NormSum::GetParametersstd::vector< double > GetParameters() constReturn array of parameters.Definition TF1NormSum.cxx:289; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1ParametersTF1 Parameters class.Definition TF1.h:53; TF1Parameters::fParNamesstd::vector< std::string > fParNamesDefinition TF1.h:139; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1_EvalWrapperDefinition TF1.cxx:188; TF1_EvalWrapper::fParconst double * fParDefinition TF1.cxx:232; TF1_EvalWrapper::CloneROOT::Math::IGenFunction * Clone() const overrideClone a function.Definition TF1.cxx:201; TF1_EvalWrapper::fX0Double_t fX0Definition TF1.cxx:235; TF1_EvalWrapper::fNDouble_t fNDefinition TF1.cxx:234; TF1_EvalWrapper::fXDouble_t fX[1]Definition TF1.cxx:231; TF1_EvalWrapper::EvalFirstMomDouble_t EvalFirstMom(Double_t x)Definition TF1.cxx:218; TF1_EvalWrapper::fFuncTF1 * fFuncDefinition TF1.cxx:230; TF1_EvalWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition TF1.cxx:209; TF1_EvalWrapper::EvalNMomDouble_t EvalNMom(Double_t x) constDefinition TF1.cxx:224; TF1_EvalWrapper::TF1_EvalWrapperTF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n=1",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:201551,Energy Efficiency,power,power,201551,"efinition legend1.C:11; Factory.h; MathNamespace for new Math classes and functions.; ROOT::TF1Helper::IntegralErrordouble IntegralError(TF1 *func, Int_t ndim, const double *a, const double *b, const double *params, const double *covmat, double epsilon)Definition TF1Helper.cxx:39; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; formula1Definition formula1.py:1; v@ vDefinition rootcling_impl.cxx:3699; ROOT::v5::TF1DataDefinition TF1Data.h:37; ROOT::v5::TF1Data::fParMinDouble_t * fParMinDefinition TF1Data.h:48; ROOT::v5::TF1Data::fNsa",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:4746,Integrability,wrap,wrapping,4746,,MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:5053,Integrability,wrap,wrapping,5053,,MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:5324,Integrability,wrap,wrapping,5324,"1Updater(Int_t nobjects, TObject **from, TObject **to); 136{; 137 auto **fromv5 = (ROOT::v5::TF1Data **)from;; 138 auto **target = (TF1v5Convert **)to;; 139 ; 140 for (int i = 0; i < nobjects; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function , double y): fFunction(function), fY0(y) {}; 156 double operator()(double x) const; 157 {; 158 return fFunction->Eval(x) - fY0;; 159 }; 160};; 161 ; 162// class wrapping evaluation of -TF1(x); 163class GInverseFunc {; 164 const TF1 *fFunction;; 165public:; 166 GInverseFunc(const TF1 *function): fFunction(function) {}; 167 ; 168 double operator()(double x) const; 169 {; 170 return - fFunction->Eval(x);; 171 }; 172};; 173// class wrapping evaluation of -TF1(x) for multi-dimension; 174class GInverseFuncNdim {; 175 TF1 *fFunction;; 176public:; 177 GInverseFuncNdim(TF1 *function): fFunction(function) {}; 178 ; 179 double operator()(const double *x) const; 180 {; 181 return - fFunction->EvalPar(x, (Double_t *)nullptr);; 182 }; 183};; 184 ; 185// class wrapping function evaluation directly in 1D interface (used for integration); 186// and implementing the methods for the momentum calculations; 187 ; 188class TF1_EvalWrapper : public ROOT::Math::IGenFunction {; 189public:; 190 TF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n = 1, Double_t x0 = 0) :; 191 fFunc(f),; 192 fPar(((par) ? par : f->GetParameters())),; 193 fAbsVal(useAbsVal),; 194 fN(n),; 195 fX0(x0); 196 {; 197 fFunc->InitArgs(fX, fPar);; 198 if (par) fFunc->SetParameters(par);; 199 }; 200 ; 201 ROOT::Math::IGenFunction *Clone() const override; 202 {; 203 // use default copy constructor; 204 TF1_EvalWrapper *f = new TF1_EvalWrapper(*this);;",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:5648,Integrability,wrap,wrapping,5648,"; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function , double y): fFunction(function), fY0(y) {}; 156 double operator()(double x) const; 157 {; 158 return fFunction->Eval(x) - fY0;; 159 }; 160};; 161 ; 162// class wrapping evaluation of -TF1(x); 163class GInverseFunc {; 164 const TF1 *fFunction;; 165public:; 166 GInverseFunc(const TF1 *function): fFunction(function) {}; 167 ; 168 double operator()(double x) const; 169 {; 170 return - fFunction->Eval(x);; 171 }; 172};; 173// class wrapping evaluation of -TF1(x) for multi-dimension; 174class GInverseFuncNdim {; 175 TF1 *fFunction;; 176public:; 177 GInverseFuncNdim(TF1 *function): fFunction(function) {}; 178 ; 179 double operator()(const double *x) const; 180 {; 181 return - fFunction->EvalPar(x, (Double_t *)nullptr);; 182 }; 183};; 184 ; 185// class wrapping function evaluation directly in 1D interface (used for integration); 186// and implementing the methods for the momentum calculations; 187 ; 188class TF1_EvalWrapper : public ROOT::Math::IGenFunction {; 189public:; 190 TF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n = 1, Double_t x0 = 0) :; 191 fFunc(f),; 192 fPar(((par) ? par : f->GetParameters())),; 193 fAbsVal(useAbsVal),; 194 fN(n),; 195 fX0(x0); 196 {; 197 fFunc->InitArgs(fX, fPar);; 198 if (par) fFunc->SetParameters(par);; 199 }; 200 ; 201 ROOT::Math::IGenFunction *Clone() const override; 202 {; 203 // use default copy constructor; 204 TF1_EvalWrapper *f = new TF1_EvalWrapper(*this);; 205 f->fFunc->InitArgs(f->fX, f->fPar);; 206 return f;; 207 }; 208 // evaluate |f(x)|; 209 Double_t DoEval(Double_t x) const override; 210 {; 211 // use evaluation with stored parameters (i.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:5692,Integrability,interface,interface,5692,"; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function , double y): fFunction(function), fY0(y) {}; 156 double operator()(double x) const; 157 {; 158 return fFunction->Eval(x) - fY0;; 159 }; 160};; 161 ; 162// class wrapping evaluation of -TF1(x); 163class GInverseFunc {; 164 const TF1 *fFunction;; 165public:; 166 GInverseFunc(const TF1 *function): fFunction(function) {}; 167 ; 168 double operator()(double x) const; 169 {; 170 return - fFunction->Eval(x);; 171 }; 172};; 173// class wrapping evaluation of -TF1(x) for multi-dimension; 174class GInverseFuncNdim {; 175 TF1 *fFunction;; 176public:; 177 GInverseFuncNdim(TF1 *function): fFunction(function) {}; 178 ; 179 double operator()(const double *x) const; 180 {; 181 return - fFunction->EvalPar(x, (Double_t *)nullptr);; 182 }; 183};; 184 ; 185// class wrapping function evaluation directly in 1D interface (used for integration); 186// and implementing the methods for the momentum calculations; 187 ; 188class TF1_EvalWrapper : public ROOT::Math::IGenFunction {; 189public:; 190 TF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n = 1, Double_t x0 = 0) :; 191 fFunc(f),; 192 fPar(((par) ? par : f->GetParameters())),; 193 fAbsVal(useAbsVal),; 194 fN(n),; 195 fX0(x0); 196 {; 197 fFunc->InitArgs(fX, fPar);; 198 if (par) fFunc->SetParameters(par);; 199 }; 200 ; 201 ROOT::Math::IGenFunction *Clone() const override; 202 {; 203 // use default copy constructor; 204 TF1_EvalWrapper *f = new TF1_EvalWrapper(*this);; 205 f->fFunc->InitArgs(f->fX, f->fPar);; 206 return f;; 207 }; 208 // evaluate |f(x)|; 209 Double_t DoEval(Double_t x) const override; 210 {; 211 // use evaluation with stored parameters (i.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:5712,Integrability,integrat,integration,5712,"; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function , double y): fFunction(function), fY0(y) {}; 156 double operator()(double x) const; 157 {; 158 return fFunction->Eval(x) - fY0;; 159 }; 160};; 161 ; 162// class wrapping evaluation of -TF1(x); 163class GInverseFunc {; 164 const TF1 *fFunction;; 165public:; 166 GInverseFunc(const TF1 *function): fFunction(function) {}; 167 ; 168 double operator()(double x) const; 169 {; 170 return - fFunction->Eval(x);; 171 }; 172};; 173// class wrapping evaluation of -TF1(x) for multi-dimension; 174class GInverseFuncNdim {; 175 TF1 *fFunction;; 176public:; 177 GInverseFuncNdim(TF1 *function): fFunction(function) {}; 178 ; 179 double operator()(const double *x) const; 180 {; 181 return - fFunction->EvalPar(x, (Double_t *)nullptr);; 182 }; 183};; 184 ; 185// class wrapping function evaluation directly in 1D interface (used for integration); 186// and implementing the methods for the momentum calculations; 187 ; 188class TF1_EvalWrapper : public ROOT::Math::IGenFunction {; 189public:; 190 TF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n = 1, Double_t x0 = 0) :; 191 fFunc(f),; 192 fPar(((par) ? par : f->GetParameters())),; 193 fAbsVal(useAbsVal),; 194 fN(n),; 195 fX0(x0); 196 {; 197 fFunc->InitArgs(fX, fPar);; 198 if (par) fFunc->SetParameters(par);; 199 }; 200 ; 201 ROOT::Math::IGenFunction *Clone() const override; 202 {; 203 // use default copy constructor; 204 TF1_EvalWrapper *f = new TF1_EvalWrapper(*this);; 205 f->fFunc->InitArgs(f->fX, f->fPar);; 206 return f;; 207 }; 208 // evaluate |f(x)|; 209 Double_t DoEval(Double_t x) const override; 210 {; 211 // use evaluation with stored parameters (i.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:25474,Integrability,interface,interface,25474,"; 724 ; 725 fMethodCall = std::make_unique<TMethodCall>();; 726 fMethodCall->InitWithPrototype(fName, ""Double_t*,Double_t*"");; 727 ; 728 if (! fMethodCall->IsValid()) {; 729 Error(""TF1"", ""No function found with the signature %s(Double_t*,Double_t*)"", name);; 730 return;; 731 }; 732}; 733 ; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Constructor using a pointer to a real function.; 737///; 738/// \param[in] name object name; 739/// \param[in] fcn pointer to function; 740/// \param[in] xmin,xmax x axis limits; 741/// \param[in] npar is the number of free parameters used by the function; 742/// \param[in] ndim number of dimensions; 743/// \param[in] addToGlobList boolean marking if it should be added to global list; 744///; 745/// This constructor creates a function of type C when invoked; 746/// with the normal C++ compiler.; 747///; 748/// see test program test/stress.cxx (function stress1) for an example.; 749/// note the interface with an intermediate pointer.; 750///; 751/// \warning A function created with this constructor cannot be Cloned.; 752 ; 753TF1::TF1(const char *name, Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if it should be added to global list; 766///; 767/// This constructor creates a function of t",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:26643,Integrability,interface,interface,26643,"uble_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if it should be added to global list; 766///; 767/// This constructor creates a function of type C when invoked; 768/// with the normal C++ compiler.; 769///; 770/// see test program test/stress.cxx (function stress1) for an example.; 771/// note the interface with an intermediate pointer.; 772///; 773/// \warning A function created with this constructor cannot be Cloned.; 774 ; 775TF1::TF1(const char *name, Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 776 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 777{}; 778 ; 779////////////////////////////////////////////////////////////////////////////////; 780/// Constructor using the Functor class.; 781///; 782/// \param[in] name object name; 783/// \param f parameterized functor; 784/// \param xmin and; 785/// \param xmax define the plotting range of the function; 786/// \param[in] npar is the number of free parameters used by the function; 787/// \param[in] ndim number of dimensions; 788/// \param[in] addToGlobList boolean marking if it should be added to global list; 789///; 790/// This c",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:40345,Integrability,wrap,wrapper,40345," x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1132 // an array with parameter values; 1133 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1134 der = rd.Derivative1(wf, x, h);; 1135 }; 1136 ; 1137 gErrorTF1 = rd.Error();; 1138 return der;; 1139 ; 1140}; 1141 ; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Returns the second derivative of the function at point x,; 1145/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1146/// to compute a third, more accurate estimation); 1147/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:42955,Integrability,wrap,wrapper,42955,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1197 // an array with parameter values; 1198 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1199 der = rd.Derivative2(wf, x, h);; 1200 }; 1201 ; 1202 gErrorTF1 = rd.Error();; 1203 ; 1204 return der;; 1205}; 1206 ; 1207 ; 1208////////////////////////////////////////////////////////////////////////////////; 1209/// Returns the third derivative of the function at point x,; 1210/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1211/// to compute a third, more accurate estimation); 1212/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1213/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:45579,Integrability,wrap,wrapper,45579,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1262 // an array with parameter values; 1263 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1264 der = rd.Derivative3(wf, x, h);; 1265 }; 1266 ; 1267 gErrorTF1 = rd.Error();; 1268 return der;; 1269 ; 1270}; 1271 ; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Static function returning the error of the last call to the of Derivative's; 1275/// functions; 1276 ; 1277Double_t TF1::DerivativeError(); 1278{; 1279 return gErrorTF1;; 1280}; 1281 ; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Compute distance from point px,py to a function.; 1285///; 1286/// Compute the closest distance of approach from point px,py to this; 1287/// function. The distance is computed in pixels units.; 1288///; 1289/// Note that px is called with a negative value when the TF1 is in; 1290/// TGraph or TH1 list of functions. In this case there is no point; 1291/// looking at the histogram axi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:62886,Integrability,interface,interface,62886," Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 1723Double_t TF1::GetMinMaxNDim(Double_t *x , bool findmax, Double_t epsilon, Int_t maxiter) const; 1724{; 1725 R__ASSERT(x != nullptr);; 1726 ; 1727 int ndim = GetNdim();; 1728 if (ndim == 0) {; 1729 Error(""GetMinimumNDim"", ""Function of dimension 0 - return Eval(x)"");; 1730 return (const_cast<TF1 &>(*this))(x);; 1731 }; 1732 ; 1733 // create minimizer class; 1734 const char *minimName = ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str();; 1735 const char *minimAlgo = ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str();; 1736 ROOT::Math::Minimizer *min = ROOT::Math::Factory::CreateMinimizer(minimName, minimAlgo);; 1737 ; 1738 if (min == nullptr) {; 1739 Error(""GetMinimumNDim"", ""Error creating minimizer %s"", minimName);; 1740 return 0;; 1741 }; 1742 ; 1743 // minimizer will be set using default values; 1744 if (epsilon > 0) min->SetTolerance(epsilon);; 1745 if (maxiter > 0) min->SetMaxFunctionCalls(maxiter);; 1746 ; 1747 // create wrapper class from TF1 (cannot use Functor, t.b.i.); 1748 ROOT::Math::WrappedMultiFunction<TF1 &> objFunc(const_cast<TF1 &>(*this), ndi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:63964,Integrability,wrap,wrapper,63964,"inimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 1723Double_t TF1::GetMinMaxNDim(Double_t *x , bool findmax, Double_t epsilon, Int_t maxiter) const; 1724{; 1725 R__ASSERT(x != nullptr);; 1726 ; 1727 int ndim = GetNdim();; 1728 if (ndim == 0) {; 1729 Error(""GetMinimumNDim"", ""Function of dimension 0 - return Eval(x)"");; 1730 return (const_cast<TF1 &>(*this))(x);; 1731 }; 1732 ; 1733 // create minimizer class; 1734 const char *minimName = ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str();; 1735 const char *minimAlgo = ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str();; 1736 ROOT::Math::Minimizer *min = ROOT::Math::Factory::CreateMinimizer(minimName, minimAlgo);; 1737 ; 1738 if (min == nullptr) {; 1739 Error(""GetMinimumNDim"", ""Error creating minimizer %s"", minimName);; 1740 return 0;; 1741 }; 1742 ; 1743 // minimizer will be set using default values; 1744 if (epsilon > 0) min->SetTolerance(epsilon);; 1745 if (maxiter > 0) min->SetMaxFunctionCalls(maxiter);; 1746 ; 1747 // create wrapper class from TF1 (cannot use Functor, t.b.i.); 1748 ROOT::Math::WrappedMultiFunction<TF1 &> objFunc(const_cast<TF1 &>(*this), ndim);; 1749 // create -f(x) when searching for the maximum; 1750 GInverseFuncNdim invFunc(const_cast<TF1 *>(this));; 1751 ROOT::Math::WrappedMultiFunction<GInverseFuncNdim &> objFuncInv(invFunc, ndim);; 1752 if (!findmax); 1753 min->SetFunction(objFunc);; 1754 else; 1755 min->SetFunction(objFuncInv);; 1756 ; 1757 std::vector<double> rmin(ndim);; 1758 std::vector<double> rmax(ndim);; 1759 GetRange(&rmin[0], &rmax[0]);; 1760 for (int i = 0; i < ndim; ++i) {; 1761 const char *xname = nullptr;; 1762 double stepSize = 0.1;; 1763 // use range for step size or give some value depending on x if range is not defined; 1764 if (rmax[i] > rmin[i]); 1765 stepSize = (rmax[i] - rmin[",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:64673,Integrability,depend,depending,64673,"ing minimizer %s"", minimName);; 1740 return 0;; 1741 }; 1742 ; 1743 // minimizer will be set using default values; 1744 if (epsilon > 0) min->SetTolerance(epsilon);; 1745 if (maxiter > 0) min->SetMaxFunctionCalls(maxiter);; 1746 ; 1747 // create wrapper class from TF1 (cannot use Functor, t.b.i.); 1748 ROOT::Math::WrappedMultiFunction<TF1 &> objFunc(const_cast<TF1 &>(*this), ndim);; 1749 // create -f(x) when searching for the maximum; 1750 GInverseFuncNdim invFunc(const_cast<TF1 *>(this));; 1751 ROOT::Math::WrappedMultiFunction<GInverseFuncNdim &> objFuncInv(invFunc, ndim);; 1752 if (!findmax); 1753 min->SetFunction(objFunc);; 1754 else; 1755 min->SetFunction(objFuncInv);; 1756 ; 1757 std::vector<double> rmin(ndim);; 1758 std::vector<double> rmax(ndim);; 1759 GetRange(&rmin[0], &rmax[0]);; 1760 for (int i = 0; i < ndim; ++i) {; 1761 const char *xname = nullptr;; 1762 double stepSize = 0.1;; 1763 // use range for step size or give some value depending on x if range is not defined; 1764 if (rmax[i] > rmin[i]); 1765 stepSize = (rmax[i] - rmin[i]) / 100;; 1766 else if (std::abs(x[i]) > 1.); 1767 stepSize = 0.1 * x[i];; 1768 ; 1769 // set variable names; 1770 if (ndim <= 3) {; 1771 if (i == 0) {; 1772 xname = ""x"";; 1773 } else if (i == 1) {; 1774 xname = ""y"";; 1775 } else {; 1776 xname = ""z"";; 1777 }; 1778 } else {; 1779 xname = TString::Format(""x_%d"", i);; 1780 // arbitrary step sie (should be computed from range); 1781 }; 1782 ; 1783 if (rmin[i] < rmax[i]) {; 1784 //Info(""GetMinMax"",""setting limits on %s - [ %f , %f ]"",xname,rmin[i],rmax[i]);; 1785 min->SetLimitedVariable(i, xname, x[i], stepSize, rmin[i], rmax[i]);; 1786 } else {; 1787 min->SetVariable(i, xname, x[i], stepSize);; 1788 }; 1789 }; 1790 ; 1791 bool ret = min->Minimize();; 1792 if (!ret) {; 1793 Error(""GetMinimumNDim"", ""Error minimizing function %s"", GetName());; 1794 }; 1795 if (min->X()) std::copy(min->X(), min->X() + ndim, x);; 1796 double fmin = min->MinValue();; 1797 delete min;; 1798 // need to rever",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:79477,Integrability,depend,depending,79477,"icients alpha, beta, gamma for each bin; 2141 Double_t x0, r1, r2, r3;; 2142 for (i = 0; i < fNpx; i++) {; 2143 x0 = xx[i];; 2144 r2 = fIntegral[i + 1] - fIntegral[i];; 2145 if (logbin); 2146 r1 = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; 2165/// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; 2166/// xmax, xmin and Npx (function points).; 2167/// Possible values are:; 2168/// - ""LOG"" to force usage of log scale for tabulating the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:79793,Integrability,integrat,integrated,79793," = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; 2165/// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; 2166/// xmax, xmin and Npx (function points).; 2167/// Possible values are:; 2168/// - ""LOG"" to force usage of log scale for tabulating the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never d",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:81895,Integrability,integrat,integrated,81895,"/// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; 2187/// whatever the fXmax/fXmin ratio is; 2188///; 2189/// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.; 2190 ; 2191 ; 2192Double_t TF1::GetRandom(TRandom * rng, Option_t * option); 2193{; 2194 // Check if integral array must be built; 2195 if (fIntegral.empty()) {; 2196 Bool_t ret = ComputeCdfTable(option);; 2197 if (!ret) return TMath::QuietNaN();; 2198 }; 2199 ; 2200 ; 2201 // return random number; 2202 Double_t r = (rng) ? rng->Rndm() : gRandom->Rndm();; 2203 Int_t bin = TMath::BinarySearch(fNpx, fIntegral.data(), r);; 2204 Double_t rr = r - fIntegral[bin];; 2205 ; 2206 Double_t yy;; 2207 if (fGamma[bin] != 0); 2208 yy = (-fBeta[bin] + TMath::Sqrt(fBeta[bin] * fBeta[bin] + 2 * fGamma[bin] * rr)) / fGamma[bin];; 2209 else; 2210 yy = rr / fBeta[bin];; 2211 Double_t x = fAlpha[bin] + yy;; 2212 if (fAlpha[fNpx] > 0) return TMath::Power(10, x);; 2213 return x;; 2214}; 2215 ; 2216 ; 2217////////////////////////////////////////////////////////////////////////////////; 2218/// Return a random number following this function shape in [xmin,xmax]; 2219///; 2220/// The distribution contained in the function fname (TF1) is integrated; 2221/// over the channel contents.; 2222/// It is normalized to 1.; 2223/// For each bin the integral is approximated by a parabola.; 2224/// The parabola coefficients are stored as non persistent data members; 2225/// Getting one random number implies:; 2226/// - Generating a random number between 0 and 1 (say r1); 2227/// - Look in which bin in the normalized integral r1 corresponds to; 2228/// - Evaluate the parabolic curve in the selected bin to find; 2229/// the corresponding X value.; 2230///; 2231/// The parabolic approximation is very good as soon as the number; 2232/// of bins is greater than 50.; 2233///; 2234/// @param xmin minimum value for generated random numbers; 2235/// @param x",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93718,Integrability,integrat,integrator,93718,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93864,Integrability,integrat,integrator,93864,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94116,Integrability,integrat,integration,94116,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94158,Integrability,integrat,integration,94158,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94289,Integrability,integrat,integrator,94289,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94711,Integrability,integrat,integrators,94711,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:95368,Integrability,integrat,integration,95368," interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",""gaus"",-5,5);; 2584/// g->SetParameters(1,0,1);; 2585/// //default gaus integration method uses 6 points; 2586/// //not suitable to integrate on a large domain; 2587/// double r1 = g->Integral(0,5);; 2588/// double r2 = g->Integral(0,1000);; 2589///; 2590/// //try with user directives computing more points; 2591/// Int_t np = 1000;; 2592/// double *x=new double[np];; 2593/// double *w=new double[np];; 2594/// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; 2595/// double r3 = g->IntegralFast(np,x,w,0,5);; 2596/// double r4 = g->IntegralFast(np,x,w,0,1000);; 2597/// double r5 = g->IntegralFast(np,x,w,0,10000);; 2598/// double r6 = g->IntegralFast(np,x,w,0,100000);; 2599/// printf(""g->Integral(0,5) = %g\n"",r1);; 2600/// printf(""g->Integral(0,1000) = %g\n"",r2);; 2601/// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; 2602/// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; 2603/// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; 2604/// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; 2605/// delete [] x;; 2606/// delete [] w;; 2607/// }; 2608/// ~~~; 2609///; 2610/// This example produces the following results:; 2611///; 2612/// ~~~ {.cpp}; 2613/// g->Integral(0,5) = 1.25331; 2614/// g->Integral(0,1000) = 1.25319; 2615/// g->IntegralFast(n,x,w,0,5) = 1.25331; 2616/// g->IntegralFast(n,x,w,0,1000) = 1.25331; 2617/// g->IntegralFast(n,x,w,0,10000) = 1.25331; 2618/// g->IntegralFast(n,x,w,0,100000)= 1.253; 2619/// ~~~; 2620 ; 2621Double_t TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:95428,Integrability,integrat,integrate,95428," interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",""gaus"",-5,5);; 2584/// g->SetParameters(1,0,1);; 2585/// //default gaus integration method uses 6 points; 2586/// //not suitable to integrate on a large domain; 2587/// double r1 = g->Integral(0,5);; 2588/// double r2 = g->Integral(0,1000);; 2589///; 2590/// //try with user directives computing more points; 2591/// Int_t np = 1000;; 2592/// double *x=new double[np];; 2593/// double *w=new double[np];; 2594/// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; 2595/// double r3 = g->IntegralFast(np,x,w,0,5);; 2596/// double r4 = g->IntegralFast(np,x,w,0,1000);; 2597/// double r5 = g->IntegralFast(np,x,w,0,10000);; 2598/// double r6 = g->IntegralFast(np,x,w,0,100000);; 2599/// printf(""g->Integral(0,5) = %g\n"",r1);; 2600/// printf(""g->Integral(0,1000) = %g\n"",r2);; 2601/// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; 2602/// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; 2603/// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; 2604/// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; 2605/// delete [] x;; 2606/// delete [] w;; 2607/// }; 2608/// ~~~; 2609///; 2610/// This example produces the following results:; 2611///; 2612/// ~~~ {.cpp}; 2613/// g->Integral(0,5) = 1.25331; 2614/// g->Integral(0,1000) = 1.25319; 2615/// g->IntegralFast(n,x,w,0,5) = 1.25331; 2616/// g->IntegralFast(n,x,w,0,1000) = 1.25331; 2617/// g->IntegralFast(n,x,w,0,10000) = 1.25331; 2618/// g->IntegralFast(n,x,w,0,100000)= 1.253; 2619/// ~~~; 2620 ; 2621Double_t TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:98661,Integrability,integrat,integrating,98661,"35 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2645 result = iod.Integral(a, b);; 2646 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2647 result = iod.IntegralLow(b);; 2648 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2649 result = iod.IntegralUp(a);; 2650 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2651 result = iod.Integral();; 2652 error = iod.Error();; 2653 status = iod.Status();; 2654 }; 2655 if (status != 0) {; 2656 std::string igName = ROOT::Math::IntegratorOneDim::GetName(ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());; 2657 Warning(""IntegralOneDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TString msg(""\t\tFunction Parameters = {"");; 2659 for (int ipar = 0; ipar < GetNpar(); ++ipar) {; 2660 msg += TString::Format("" %s = %f "", GetParName(ipar), GetParameter(ipar));; 2661 if (ipar < GetNpar() - 1) msg += TString("","");; 2662 else msg += TString(""}"");; 2663 }; 2664 Info(""IntegralOneDim"", ""%s"", msg.Data());; 2665 }; 2666 return result;; 2667}; 2668 ; 2669////////////////////////////////////////////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix fro",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:100706,Integrability,message,message,100706,"2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 2702///; 2703/// The user must pass a pointer to the elements of the full covariance matrix; 2704/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2705/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2706/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2707 ; 2708Double_t TF1::IntegralError(Double_t a, Double_t b, const Double_t ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:100933,Integrability,rout,routine,100933,"varianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 2702///; 2703/// The user must pass a pointer to the elements of the full covariance matrix; 2704/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2705/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2706/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2707 ; 2708Double_t TF1::IntegralError(Double_t a, Double_t b, const Double_t *params, const Double_t *covmat, Double_t epsilon); 2709{; 2710 Double_t x1[1];; 2711 Double_t x2[1];; 2712 x1[0] = a, x2[0] = b;; 2713 return ROOT::TF1Helper::IntegralError(this, 1, x1, x2, params, covmat, epsilon);; 2714}; 2715 ; 2716",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:103613,Integrability,message,message,103613,"25/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2757 ; 2758Double_t TF1::IntegralError(Int_t n, const Double_t *a, const Doubl",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:103840,Integrability,rout,routine,103840,"varianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2757 ; 2758Double_t TF1::IntegralError(Int_t n, const Double_t *a, const Double_t *b, const Double_t *params, const Double_t *covmat, Double_t epsilon); 2759{; 2760 return ROOT::TF1Helper::IntegralError(this, n, a, b, params, covmat, epsilon);; 2761}; 2762 ; 2763#ifdef INTHEFUTURE; 2764///////////////////////////",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:105936,Integrability,interface,interface,105936,"* /* w */, Double_t a, Double_t b, Double_t *params, Double_t epsilon); 2779{; 2780 // Now x and w are not used!; 2781 ; 2782 ROOT::Math::WrappedTF1 wf1(*this);; 2783 if (params); 2784 wf1.SetParameters(params);; 2785 ROOT::Math::GaussLegendreIntegrator gli(num, epsilon);; 2786 gli.SetFunction(wf1);; 2787 return gli.Integral(a, b);; 2788 ; 2789}; 2790 ; 2791 ; 2792////////////////////////////////////////////////////////////////////////////////; 2793/// See more general prototype below.; 2794/// This interface kept for back compatibility; 2795/// It is recommended to use the other interface where one can specify also epsabs and the maximum number of; 2796/// points; 2797 ; 2798Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Double_t epsrel, Double_t &relerr); 2799{; 2800 Int_t nfnevl, ifail;; 2801 UInt_t maxpts = TMath::Max(UInt_t(20 * TMath::Power(fNpx, GetNdim())), ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls());; 2802 Double_t result = IntegralMultiple(n, a, b, maxpts, epsrel, epsrel, relerr, nfnevl, ifail);; 2803 if (ifail > 0) {; 2804 Warning(""IntegralMultiple"", ""failed code=%d, "", ifail);; 2805 }; 2806 return result;; 2807}; 2808 ; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 28",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:106018,Integrability,interface,interface,106018,"* /* w */, Double_t a, Double_t b, Double_t *params, Double_t epsilon); 2779{; 2780 // Now x and w are not used!; 2781 ; 2782 ROOT::Math::WrappedTF1 wf1(*this);; 2783 if (params); 2784 wf1.SetParameters(params);; 2785 ROOT::Math::GaussLegendreIntegrator gli(num, epsilon);; 2786 gli.SetFunction(wf1);; 2787 return gli.Integral(a, b);; 2788 ; 2789}; 2790 ; 2791 ; 2792////////////////////////////////////////////////////////////////////////////////; 2793/// See more general prototype below.; 2794/// This interface kept for back compatibility; 2795/// It is recommended to use the other interface where one can specify also epsabs and the maximum number of; 2796/// points; 2797 ; 2798Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Double_t epsrel, Double_t &relerr); 2799{; 2800 Int_t nfnevl, ifail;; 2801 UInt_t maxpts = TMath::Max(UInt_t(20 * TMath::Power(fNpx, GetNdim())), ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls());; 2802 Double_t result = IntegralMultiple(n, a, b, maxpts, epsrel, epsrel, relerr, nfnevl, ifail);; 2803 if (ifail > 0) {; 2804 Warning(""IntegralMultiple"", ""failed code=%d, "", ifail);; 2805 }; 2806 return result;; 2807}; 2808 ; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 28",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:107015,Integrability,integrat,integration,107015,"commended to use the other interface where one can specify also epsabs and the maximum number of; 2796/// points; 2797 ; 2798Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Double_t epsrel, Double_t &relerr); 2799{; 2800 Int_t nfnevl, ifail;; 2801 UInt_t maxpts = TMath::Max(UInt_t(20 * TMath::Power(fNpx, GetNdim())), ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls());; 2802 Double_t result = IntegralMultiple(n, a, b, maxpts, epsrel, epsrel, relerr, nfnevl, ifail);; 2803 if (ifail > 0) {; 2804 Warning(""IntegralMultiple"", ""failed code=%d, "", ifail);; 2805 }; 2806 return result;; 2807}; 2808 ; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr conta",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:107339,Integrability,integrat,integration,107339,"s::DefaultNCalls());; 2802 Double_t result = IntegralMultiple(n, a, b, maxpts, epsrel, epsrel, relerr, nfnevl, ifail);; 2803 if (ifail > 0) {; 2804 Warning(""IntegralMultiple"", ""failed code=%d, "", ifail);; 2805 }; 2806 return result;; 2807}; 2808 ; 2809 ; 2810////////////////////////////////////////////////////////////////////////////////; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other meth",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108488,Integrability,integrat,integrators,108488,"param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions:",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108525,Integrability,integrat,integrators,108525,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108544,Integrability,integrat,integrators,108544,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108680,Integrability,integrat,integration,108680,"ainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerance();; 2858 if (ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {; 2859 ROOT::Math::AdaptiveIntegratorMultiDim aimd(wf1, epsabs, epsrel, maxpts);; 2860 //aimd.SetMinPts(minpts); // use default minpts ( n^2 + 2 * n * (n+1) +1 ); 2861 result = aimd.Integral(a, b);; 2862 relerr = aimd.RelError();; 2863 nfnevl = aimd.NEval();; 2864 ifail = aimd.Status();; 2865 } else {; 2866 // use default abs tolerance = relative tolerance; 2867 ROOT::Math::IntegratorMultiDim imd(wf1, ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType(), epsabs, epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:141113,Integrability,wrap,wrapped,141113,"sition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; 3683void TF1::RejectPoint(Bool_t reject); 3684{; 3685 fgRejectPoint = reject;; 3686}; 3687 ; 3688 ; 3689////////////////////////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3703{; 3704 // wrapped function in interface for integral calculation; 3705 // using abs value of integral; 3706 ; 3707 TF1_EvalWrapper func(this, params, kTRUE, n);; 3708 ; 3709 ROOT::Math::GaussIntegrator giod;; 3710 ; 3711 giod.SetFunction(func);; 3712 giod.SetRelTolerance(epsilon);; 3713 ; 3714 Double_t norm = giod.Integral(a, b);; 3715 if (norm == 0) {; 3716 Error(""Moment"", ""Integral zero over range"");; 3717 return 0;; 3718 }; 3719 ; 3720 // calculate now integral of x^n f(x); 3721 // wrapped the member function EvalNum in interface required by integrator using the functor class; 3722 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:141133,Integrability,interface,interface,141133,"sition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; 3683void TF1::RejectPoint(Bool_t reject); 3684{; 3685 fgRejectPoint = reject;; 3686}; 3687 ; 3688 ; 3689////////////////////////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3703{; 3704 // wrapped function in interface for integral calculation; 3705 // using abs value of integral; 3706 ; 3707 TF1_EvalWrapper func(this, params, kTRUE, n);; 3708 ; 3709 ROOT::Math::GaussIntegrator giod;; 3710 ; 3711 giod.SetFunction(func);; 3712 giod.SetRelTolerance(epsilon);; 3713 ; 3714 Double_t norm = giod.Integral(a, b);; 3715 if (norm == 0) {; 3716 Error(""Moment"", ""Integral zero over range"");; 3717 return 0;; 3718 }; 3719 ; 3720 // calculate now integral of x^n f(x); 3721 // wrapped the member function EvalNum in interface required by integrator using the functor class; 3722 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:141593,Integrability,wrap,wrapped,141593,"////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3703{; 3704 // wrapped function in interface for integral calculation; 3705 // using abs value of integral; 3706 ; 3707 TF1_EvalWrapper func(this, params, kTRUE, n);; 3708 ; 3709 ROOT::Math::GaussIntegrator giod;; 3710 ; 3711 giod.SetFunction(func);; 3712 giod.SetRelTolerance(epsilon);; 3713 ; 3714 Double_t norm = giod.Integral(a, b);; 3715 if (norm == 0) {; 3716 Error(""Moment"", ""Integral zero over range"");; 3717 return 0;; 3718 }; 3719 ; 3720 // calculate now integral of x^n f(x); 3721 // wrapped the member function EvalNum in interface required by integrator using the functor class; 3722 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Er",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:141632,Integrability,interface,interface,141632,"////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3703{; 3704 // wrapped function in interface for integral calculation; 3705 // using abs value of integral; 3706 ; 3707 TF1_EvalWrapper func(this, params, kTRUE, n);; 3708 ; 3709 ROOT::Math::GaussIntegrator giod;; 3710 ; 3711 giod.SetFunction(func);; 3712 giod.SetRelTolerance(epsilon);; 3713 ; 3714 Double_t norm = giod.Integral(a, b);; 3715 if (norm == 0) {; 3716 Error(""Moment"", ""Integral zero over range"");; 3717 return 0;; 3718 }; 3719 ; 3720 // calculate now integral of x^n f(x); 3721 // wrapped the member function EvalNum in interface required by integrator using the functor class; 3722 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Er",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:141654,Integrability,integrat,integrator,141654,"////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3703{; 3704 // wrapped function in interface for integral calculation; 3705 // using abs value of integral; 3706 ; 3707 TF1_EvalWrapper func(this, params, kTRUE, n);; 3708 ; 3709 ROOT::Math::GaussIntegrator giod;; 3710 ; 3711 giod.SetFunction(func);; 3712 giod.SetRelTolerance(epsilon);; 3713 ; 3714 Double_t norm = giod.Integral(a, b);; 3715 if (norm == 0) {; 3716 Error(""Moment"", ""Integral zero over range"");; 3717 return 0;; 3718 }; 3719 ; 3720 // calculate now integral of x^n f(x); 3721 // wrapped the member function EvalNum in interface required by integrator using the functor class; 3722 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Er",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:142719,Integrability,wrap,wrapped,142719,"unc, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Error(""Moment"", ""Integral zero over range"");; 3751 return 0;; 3752 }; 3753 ; 3754 // calculate now integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegen",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:142763,Integrability,interface,interface,142763,"unc, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Error(""Moment"", ""Integral zero over range"");; 3751 return 0;; 3752 }; 3753 ; 3754 // calculate now integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegen",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:142785,Integrability,integrat,integrator,142785,"unc, &TF1_EvalWrapper::EvalNMom);; 3723 giod.SetFunction(xnfunc);; 3724 ; 3725 Double_t res = giod.Integral(a, b) / norm;; 3726 ; 3727 return res;; 3728}; 3729 ; 3730 ; 3731////////////////////////////////////////////////////////////////////////////////; 3732/// Return nth central moment of function between a and b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Error(""Moment"", ""Integral zero over range"");; 3751 return 0;; 3752 }; 3753 ; 3754 // calculate now integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegen",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:143067,Integrability,wrap,wrapper,143067,"nd b; 3733/// (i.e the n-th moment around the mean value); 3734///; 3735/// See TF1::Integral() for parameter definitions; 3736///; 3737/// \author Gene Van Buren <gene@bnl.gov>; 3738 ; 3739Double_t TF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t *params, Double_t epsilon); 3740{; 3741 TF1_EvalWrapper func(this, params, kTRUE, n);; 3742 ; 3743 ROOT::Math::GaussIntegrator giod;; 3744 ; 3745 giod.SetFunction(func);; 3746 giod.SetRelTolerance(epsilon);; 3747 ; 3748 Double_t norm = giod.Integral(a, b);; 3749 if (norm == 0) {; 3750 Error(""Moment"", ""Integral zero over range"");; 3751 return 0;; 3752 }; 3753 ; 3754 // calculate now integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:143576,Integrability,interface,interface,143576," integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface fill",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:144002,Integrability,interface,interface,144002," integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface fill",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:144677,Integrability,interface,interface,144677,"nterface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface filling the arrays x and w (static method); 3807///; 3808/// Given the number of sampling points this routine fills the arrays x and w; 3809/// of length num, containing the abscissa and weight of the Gauss-Legendre; 3810/// n-point quadrature formula.; 3811///; 3812/// Gauss-Legendre:; 3813/** \f[; 3814 W(x)=1 -1<x<1 \\; 3815 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; 3816 \f]; 3817**/; 3818/// num is the number of sampling points (>0); 3819/// x and w are arrays of size num; 3820/// eps is the relative precision; 3821///; 3822/// If num<=0 or eps<=0 no action is done.; 3823///; 3824/// Reference: Numerical Recipes in C, Second Edition; 3825 ; 3826void TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps); 3827{; 3828 // This function is just kept like this for backward compatibility!; 3829 ; 3830 ROOT::Math::GaussLegendreIntegrator gli(num, eps);; 38",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:144789,Integrability,rout,routine,144789,"nterface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface filling the arrays x and w (static method); 3807///; 3808/// Given the number of sampling points this routine fills the arrays x and w; 3809/// of length num, containing the abscissa and weight of the Gauss-Legendre; 3810/// n-point quadrature formula.; 3811///; 3812/// Gauss-Legendre:; 3813/** \f[; 3814 W(x)=1 -1<x<1 \\; 3815 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; 3816 \f]; 3817**/; 3818/// num is the number of sampling points (>0); 3819/// x and w are arrays of size num; 3820/// eps is the relative precision; 3821///; 3822/// If num<=0 or eps<=0 no action is done.; 3823///; 3824/// Reference: Numerical Recipes in C, Second Edition; 3825 ; 3826void TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps); 3827{; 3828 // This function is just kept like this for backward compatibility!; 3829 ; 3830 ROOT::Math::GaussLegendreIntegrator gli(num, eps);; 38",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154055,Integrability,integrat,integration,154055,"ouble operator()(double x) constDefinition TF1.cxx:156; GFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:152; GFunc::fY0const double fY0Definition TF1.cxx:153; GFunc::GFuncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::I",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154247,Integrability,integrat,integrationDefinition,154247,"uncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:157560,Integrability,integrat,integration,157560," the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFinder.cxx:66; ROOT::Math::BrentRootFinder::Rootdouble Root() const overrideReturns root value.Definition BrentRootFinder.h:98; ROOT::Math::BrentRootFinder::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentRootFinder.h:89; ROOT::Math::BrentRootFinder::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentRootFinder.h:95; ROOT::Math::ChebyshevPolDefinition ChebyshevPol.h:129; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) ove",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158354,Integrability,integrat,integration,158354,"ring Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Ma",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158727,Integrability,integrat,integration,158727,"or of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Defi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158867,Integrability,integrat,integration,158867,"lTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance(",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:159946,Integrability,integrat,integration,159946,"or.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:367; ROOT::Math::IntegratorMultiDimUser class for performing multidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDim",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:160421,Integrability,integrat,integration,160421,"nMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:367; ROOT::Math::IntegratorMultiDimUser class for performing multidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, d",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:160947,Integrability,integrat,integration,160947,"tidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::Errordouble Error() constreturn the estimate of the absolute Error of the last Integral calculationDefinition Integrator.h:416; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:162406,Integrability,interface,interface,162406,"nction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::Errordouble Error() constreturn the estimate of the absolute Error of the last Integral calculationDefinition Integrator.h:416; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT::Math::MinimizerOptions::DefaultMinimizerAlgostatic const std::string & DefaultMinimizerAlgo()Definition MinimizerOptions.cxx:85; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetLimitedVariablevirtual bool SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower, double upper)set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition Minimizer.cxx:34; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimiz",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:164715,Integrability,wrap,wrap,164715,"nctor.h:274; ROOT::Math::RichardsonDerivatorUser class for calculating the derivatives of a function.Definition RichardsonDerivator.h:55; ROOT::Math::RichardsonDerivator::Derivative2double Derivative2(double x)Returns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition RichardsonDerivator.h:172; ROOT::Math::RichardsonDerivator::Errordouble Error() constReturns the estimate of the absolute Error of the last derivative calculation.Definition RichardsonDerivator.h:83; ROOT::Math::RichardsonDerivator::Derivative3double Derivative3(double x)Returns the third derivative of the function at point x, computed by Richardson's extrapolation metho...Definition RichardsonDerivator.h:211; ROOT::Math::RichardsonDerivator::Derivative1double Derivative1(double x)Returns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition RichardsonDerivator.h:116; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be ...Definition WrappedTF1.h:39; ROOT::Math::WrappedTF1::SetParametersvoid SetParameters(const double *p) overrideset parameter values need to call also SetParameters in TF1 in ace some other operations (re-normaliz...Definition WrappedTF1.h:90; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetNdimvirtual Int_t GetNdim() constDefinition TFormula.h:237; ROOT::v5::TFormula::GetNparvirtual Int_t GetNpar() constDefinition TFormula.h:238; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the for",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:164856,Integrability,wrap,wrap,164856,"hardsonDerivator::Derivative2double Derivative2(double x)Returns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition RichardsonDerivator.h:172; ROOT::Math::RichardsonDerivator::Errordouble Error() constReturns the estimate of the absolute Error of the last derivative calculation.Definition RichardsonDerivator.h:83; ROOT::Math::RichardsonDerivator::Derivative3double Derivative3(double x)Returns the third derivative of the function at point x, computed by Richardson's extrapolation metho...Definition RichardsonDerivator.h:211; ROOT::Math::RichardsonDerivator::Derivative1double Derivative1(double x)Returns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition RichardsonDerivator.h:116; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be ...Definition WrappedTF1.h:39; ROOT::Math::WrappedTF1::SetParametersvoid SetParameters(const double *p) overrideset parameter values need to call also SetParameters in TF1 in ace some other operations (re-normaliz...Definition WrappedTF1.h:90; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetNdimvirtual Int_t GetNdim() constDefinition TFormula.h:237; ROOT::v5::TFormula::GetNparvirtual Int_t GetNpar() constDefinition TFormula.h:238; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; TArrayDArray of doubles (64 bits per element).Definition TAr",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:165065,Integrability,interface,interface,165065,"inition RichardsonDerivator.h:172; ROOT::Math::RichardsonDerivator::Errordouble Error() constReturns the estimate of the absolute Error of the last derivative calculation.Definition RichardsonDerivator.h:83; ROOT::Math::RichardsonDerivator::Derivative3double Derivative3(double x)Returns the third derivative of the function at point x, computed by Richardson's extrapolation metho...Definition RichardsonDerivator.h:211; ROOT::Math::RichardsonDerivator::Derivative1double Derivative1(double x)Returns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition RichardsonDerivator.h:116; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be ...Definition WrappedTF1.h:39; ROOT::Math::WrappedTF1::SetParametersvoid SetParameters(const double *p) overrideset parameter values need to call also SetParameters in TF1 in ace some other operations (re-normaliz...Definition WrappedTF1.h:90; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetNdimvirtual Int_t GetNdim() constDefinition TFormula.h:237; ROOT::v5::TFormula::GetNparvirtual Int_t GetNpar() constDefinition TFormula.h:238; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::GetArrayconst Double_t * GetArray() constDefinition TArrayD.h:43; TAttAxis::GetLabelColorvirtual Color_t GetLabelColor() constDefinition TAttAxis",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:171543,Integrability,wrap,wrapping,171543,"Attributesvoid SaveAttributes(std::ostream &out, const char *name, const char *subname) overrideSave axis attributes as C++ statement(s) on output stream out.Definition TAxis.cxx:710; TAxis::SetLimitsvirtual void SetLimits(Double_t xmin, Double_t xmax)Definition TAxis.h:164; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TF1AbsCompositionDefinition TF1AbsComposition.h:16; TF1AbsComposition::IsATClass * IsA() const overrideDefinition TF1AbsComposition.h:28; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1Convolution.h:71; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1NormSum::GetParametersstd::vector< double > GetParameters() constReturn array of parameters.Definition TF1NormSum.cxx:289; TF1NormSum::GetNparInt_t GetNpar() constReturn the number of (non constant) parameters including the coefficients: for 2 functions: c1,...Definition TF1NormSum.cxx:361; TF1ParametersTF1 Parameters class.Definition TF1.h:53; TF1Parameters::fParNamesstd::vector< std::string > fParNamesDefinition TF1.h:139; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:173696,Integrability,wrap,wrap,173696,"n TF1.cxx:232; TF1_EvalWrapper::CloneROOT::Math::IGenFunction * Clone() const overrideClone a function.Definition TF1.cxx:201; TF1_EvalWrapper::fX0Double_t fX0Definition TF1.cxx:235; TF1_EvalWrapper::fNDouble_t fNDefinition TF1.cxx:234; TF1_EvalWrapper::fXDouble_t fX[1]Definition TF1.cxx:231; TF1_EvalWrapper::EvalFirstMomDouble_t EvalFirstMom(Double_t x)Definition TF1.cxx:218; TF1_EvalWrapper::fFuncTF1 * fFuncDefinition TF1.cxx:230; TF1_EvalWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition TF1.cxx:209; TF1_EvalWrapper::EvalNMomDouble_t EvalNMom(Double_t x) constDefinition TF1.cxx:224; TF1_EvalWrapper::TF1_EvalWrapperTF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n=1, Double_t x0=0)Definition TF1.cxx:190; TF1_EvalWrapper::fAbsValBool_t fAbsValDefinition TF1.cxx:233; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:175726,Integrability,interface,interface,175726,".cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::GetParErrorvirtual Double_t GetParError(Int_t ipar) constReturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::Classstatic TClass *",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:194971,Integrability,rout,routine,194971,"168; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Printvoid Print(Option_t *option="""") const overridePrint some global quantities for this histogram.Definition TH1.cxx:7009; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::Copyvoid Copy(TObject &named) co",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:195639,Integrability,interface,interface,195639,"h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TH1.h:289; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:197188,Integrability,message,message,197188,"urns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:197870,Integrability,message,message,197870,"bject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind firs",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:198148,Integrability,message,message,198148,", const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:200137,Integrability,integrat,integration,200137,"hange string to upper case.Definition TString.cxx:1195; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::GetFuncWidthWidth_t GetFuncWidth() constDefinition TStyle.h:221; TStyle::GetFuncStyleStyle_t GetFuncStyle() constDefinition TStyle.h:220; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; ROOT::Math::IntegrationOneDim::kGAUSS@ kGAUSSsimple Gauss integration method with fixed ruleDefinition AllIntegrationTypes.h:34; ROOT::Math::IntegrationMultiDim::kADAPTIVE@ kADAPTIVEadaptive multi-dimensional integrationDefinition AllIntegrationTypes.h:49; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; Factory.h; MathNamespace for new Math classes and functions.; ROOT::TF1Helper::IntegralErrordouble IntegralError(TF1 *func, Int_t ndim, const double *a, const double *b, const double *params, const double *covmat, double epsilon)Definition TF1Helper.cxx:39; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(D",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:200288,Integrability,integrat,integrationDefinition,200288,"pend(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TStyle::GetFuncColorColor_t GetFuncColor() constDefinition TStyle.h:219; TStyle::GetFuncWidthWidth_t GetFuncWidth() constDefinition TStyle.h:221; TStyle::GetFuncStyleStyle_t GetFuncStyle() constDefinition TStyle.h:220; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; bool; double; int; unsigned int; ROOT::Math::IntegrationOneDim::kGAUSS@ kGAUSSsimple Gauss integration method with fixed ruleDefinition AllIntegrationTypes.h:34; ROOT::Math::IntegrationMultiDim::kADAPTIVE@ kADAPTIVEadaptive multi-dimensional integrationDefinition AllIntegrationTypes.h:49; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; Factory.h; MathNamespace for new Math classes and functions.; ROOT::TF1Helper::IntegralErrordouble IntegralError(TF1 *func, Int_t ndim, const double *a, const double *b, const double *params, const double *covmat, double epsilon)Definition TF1Helper.cxx:39; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:7772,Modifiability,variab,variable,7772,":Abs(fFunc->EvalPar(fX, nullptr));; 222 }; 223 // evaluate (x - x0) ^n * f(x); 224 Double_t EvalNMom(Double_t x) const; 225 {; 226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Dou",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:7836,Modifiability,variab,variable,7836," x0) ^n * f(x); 224 Double_t EvalNMom(Double_t x) const; 225 {; 226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Double_t myFunc(double x) { return x+sin(x); }; 288....; 289auto f",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:7904,Modifiability,variab,variable,7904,"226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Double_t myFunc(double x) { return x+sin(x); }; 288....; 289auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; 290fa3->Draw();; 291~~~~; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:8206,Modifiability,variab,variable,8206,"tions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Double_t myFunc(double x) { return x+sin(x); }; 288....; 289auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; 290fa3->Draw();; 291~~~~; 292 ; 293\anchor F2; 294### 2 - Expression using variable x with parameters; 295 ; 296#### Case 1: inline expression using standard C++ functions/operators; 297 ; 298* Example a:; 299 ; 300 ; 301~~~~{.cpp}; 302auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; 303~~~~; 304 ; 305This creates a function of variable x with 2 parameters. The parameters must be initialized via:; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:8962,Modifiability,variab,variable,8962,"arameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Double_t myFunc(double x) { return x+sin(x); }; 288....; 289auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; 290fa3->Draw();; 291~~~~; 292 ; 293\anchor F2; 294### 2 - Expression using variable x with parameters; 295 ; 296#### Case 1: inline expression using standard C++ functions/operators; 297 ; 298* Example a:; 299 ; 300 ; 301~~~~{.cpp}; 302auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; 303~~~~; 304 ; 305This creates a function of variable x with 2 parameters. The parameters must be initialized via:; 306 ; 307~~~~{.cpp}; 308 fa->SetParameter(0,value_first_parameter);; 309 fa->SetParameter(1,value_second_parameter);; 310~~~~; 311 ; 312 ; 313Parameters may be given a name:; 314 ; 315~~~~{.cpp}; 316 fa->SetParName(0,""Constant"");; 317~~~~; 318 ; 319* Example b:; 320 ; 321~~~~{.cpp}; 322 auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; 323~~~~; 324 ; 325 ; 326``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``.; 327 ; 328#### Case 2: inline expression using TMath functions with parameters; 329 ; 330Begin_Macro(source); 331{; 332 auto fb2 = new TF1(""fa3"",""TMath:",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:9218,Modifiability,variab,variable,9218,"3### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters; 275 ; 276 ; 277Begin_Macro(source); 278{; 279 auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; 280 fa2->Draw();; 281}; 282End_Macro; 283 ; 284#### Case 3: inline expression using a user defined CLING function by name; 285 ; 286~~~~{.cpp}; 287Double_t myFunc(double x) { return x+sin(x); }; 288....; 289auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; 290fa3->Draw();; 291~~~~; 292 ; 293\anchor F2; 294### 2 - Expression using variable x with parameters; 295 ; 296#### Case 1: inline expression using standard C++ functions/operators; 297 ; 298* Example a:; 299 ; 300 ; 301~~~~{.cpp}; 302auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; 303~~~~; 304 ; 305This creates a function of variable x with 2 parameters. The parameters must be initialized via:; 306 ; 307~~~~{.cpp}; 308 fa->SetParameter(0,value_first_parameter);; 309 fa->SetParameter(1,value_second_parameter);; 310~~~~; 311 ; 312 ; 313Parameters may be given a name:; 314 ; 315~~~~{.cpp}; 316 fa->SetParName(0,""Constant"");; 317~~~~; 318 ; 319* Example b:; 320 ; 321~~~~{.cpp}; 322 auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; 323~~~~; 324 ; 325 ; 326``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``.; 327 ; 328#### Case 2: inline expression using TMath functions with parameters; 329 ; 330Begin_Macro(source); 331{; 332 auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; 333 fb2->SetParameters(0.2,1.3);; 334 fb2->Draw();; 335}; 336End_Macro; 337 ; 338\anchor F3; 339### 3 - A lambda expression with variables and parameters; 340 ; 341\since **6",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:10136,Modifiability,variab,variables,10136,"~~~{.cpp}; 302auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; 303~~~~; 304 ; 305This creates a function of variable x with 2 parameters. The parameters must be initialized via:; 306 ; 307~~~~{.cpp}; 308 fa->SetParameter(0,value_first_parameter);; 309 fa->SetParameter(1,value_second_parameter);; 310~~~~; 311 ; 312 ; 313Parameters may be given a name:; 314 ; 315~~~~{.cpp}; 316 fa->SetParName(0,""Constant"");; 317~~~~; 318 ; 319* Example b:; 320 ; 321~~~~{.cpp}; 322 auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; 323~~~~; 324 ; 325 ; 326``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``.; 327 ; 328#### Case 2: inline expression using TMath functions with parameters; 329 ; 330Begin_Macro(source); 331{; 332 auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; 333 fb2->SetParameters(0.2,1.3);; 334 fb2->Draw();; 335}; 336End_Macro; 337 ; 338\anchor F3; 339### 3 - A lambda expression with variables and parameters; 340 ; 341\since **6.00/00:**; 342TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; 343functions and still maintain the capability of storing the function in a file which cannot be done with; 344function pointer or lambda written not as expression, but as code (see items below).; 345 ; 346Example on how using lambda to define a sum of two functions.; 347Note that is necessary to provide the number of parameters; 348 ; 349~~~~{.cpp}; 350TF1 f1(""f1"",""sin(x)"",0,10);; 351TF1 f2(""f2"",""cos(x)"",0,10);; 352TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; 353~~~~; 354 ; 355\anchor F4; 356### 4 - A general C function with parameters; 357 ; 358Consider the macro myfunc.C below:; 359 ; 360~~~~{.cpp}; 361 // Macro myfunc.C; 362 Double_t myfunction(Double_t *x, Double_t *par); 363 {; 364 Float_t xx =x[0];; 365 Double_t f = TMath::Abs(par[0]*s",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:17707,Modifiability,extend,extend,17707,,MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:20681,Modifiability,extend,extend,20681,"9 newFuncs.SetOwner(kTRUE);; 610 TObjArray coeffNames;; 611 coeffNames.SetOwner(kTRUE);; 612 TString fullFormula;; 613 for (int i = 0; i < formDense.Length(); ++i) {; 614 if (formDense[i] == '('); 615 parenCount++;; 616 else if (formDense[i] == ')'); 617 parenCount--;; 618 else if (formDense[i] == delimiter && parenCount == 0) {; 619 // term goes from termStart to i; 620 DefineNSUMTerm(&newFuncs, &coeffNames, fullFormula, formDense, termStart, i, xmin, xmax);; 621 termStart = i + 1;; 622 }; 623 }; 624 DefineNSUMTerm(&newFuncs, &coeffNames, fullFormula, formDense, termStart, formDense.Length(), xmin, xmax);; 625 ; 626 TF1NormSum *normSum = new TF1NormSum(fullFormula, xmin, xmax);; 627 ; 628 if (xmin == 0 && xmax == 1.) Info(""TF1"",""Created TF1NormSum object using the default [0,1] range"");; 629 ; 630 fNpar = normSum->GetNpar();; 631 fNdim = 1; // (note: may want to extend functionality in the future); 632 ; 633 fType = EFType::kCompositionFcn;; 634 fComposition = std::unique_ptr<TF1AbsComposition>(normSum);; 635 ; 636 fParams = std::make_unique<TF1Parameters>(fNpar);; 637 fParams->SetParameters(&(normSum->GetParameters())[0]); // inherit default parameters from normSum; 638 ; 639 // Parameter names; 640 for (int i = 0; i < fNpar; i++) {; 641 if (coeffNames.At(i)) {; 642 this->SetParName(i, coeffNames.At(i)->GetName());; 643 } else {; 644 this->SetParName(i, normSum->GetParName(i));; 645 }; 646 }; 647 ; 648 } else { // regular TFormula; 649 fFormula = std::make_unique<TFormula>(name, formula, false, vectorize);; 650 fNpar = fFormula->GetNpar();; 651 // TFormula can have dimension zero, but since this is a TF1 minimal dim is 1; 652 fNdim = fFormula->GetNdim() == 0 ? 1 : fFormula->GetNdim();; 653 }; 654 if (fNpar) {; 655 fParErrors.resize(fNpar);; 656 fParMin.resize(fNpar);; 657 fParMax.resize(fNpar);; 658 }; 659 // do we want really to have this un-documented feature where we accept cases where dim > 1; 660 // by setting xmin >= xmax ??; 661 if (fNdim > 1 && xmin < xmax)",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:20951,Modifiability,inherit,inherit,20951,"9 newFuncs.SetOwner(kTRUE);; 610 TObjArray coeffNames;; 611 coeffNames.SetOwner(kTRUE);; 612 TString fullFormula;; 613 for (int i = 0; i < formDense.Length(); ++i) {; 614 if (formDense[i] == '('); 615 parenCount++;; 616 else if (formDense[i] == ')'); 617 parenCount--;; 618 else if (formDense[i] == delimiter && parenCount == 0) {; 619 // term goes from termStart to i; 620 DefineNSUMTerm(&newFuncs, &coeffNames, fullFormula, formDense, termStart, i, xmin, xmax);; 621 termStart = i + 1;; 622 }; 623 }; 624 DefineNSUMTerm(&newFuncs, &coeffNames, fullFormula, formDense, termStart, formDense.Length(), xmin, xmax);; 625 ; 626 TF1NormSum *normSum = new TF1NormSum(fullFormula, xmin, xmax);; 627 ; 628 if (xmin == 0 && xmax == 1.) Info(""TF1"",""Created TF1NormSum object using the default [0,1] range"");; 629 ; 630 fNpar = normSum->GetNpar();; 631 fNdim = 1; // (note: may want to extend functionality in the future); 632 ; 633 fType = EFType::kCompositionFcn;; 634 fComposition = std::unique_ptr<TF1AbsComposition>(normSum);; 635 ; 636 fParams = std::make_unique<TF1Parameters>(fNpar);; 637 fParams->SetParameters(&(normSum->GetParameters())[0]); // inherit default parameters from normSum; 638 ; 639 // Parameter names; 640 for (int i = 0; i < fNpar; i++) {; 641 if (coeffNames.At(i)) {; 642 this->SetParName(i, coeffNames.At(i)->GetName());; 643 } else {; 644 this->SetParName(i, normSum->GetParName(i));; 645 }; 646 }; 647 ; 648 } else { // regular TFormula; 649 fFormula = std::make_unique<TFormula>(name, formula, false, vectorize);; 650 fNpar = fFormula->GetNpar();; 651 // TFormula can have dimension zero, but since this is a TF1 minimal dim is 1; 652 fNdim = fFormula->GetNdim() == 0 ? 1 : fFormula->GetNdim();; 653 }; 654 if (fNpar) {; 655 fParErrors.resize(fNpar);; 656 fParMin.resize(fNpar);; 657 fParMax.resize(fNpar);; 658 }; 659 // do we want really to have this un-documented feature where we accept cases where dim > 1; 660 // by setting xmin >= xmax ??; 661 if (fNdim > 1 && xmin < xmax)",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:27315,Modifiability,parameteriz,parameterized,27315,"the normal C++ compiler.; 769///; 770/// see test program test/stress.cxx (function stress1) for an example.; 771/// note the interface with an intermediate pointer.; 772///; 773/// \warning A function created with this constructor cannot be Cloned.; 774 ; 775TF1::TF1(const char *name, Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 776 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 777{}; 778 ; 779////////////////////////////////////////////////////////////////////////////////; 780/// Constructor using the Functor class.; 781///; 782/// \param[in] name object name; 783/// \param f parameterized functor; 784/// \param xmin and; 785/// \param xmax define the plotting range of the function; 786/// \param[in] npar is the number of free parameters used by the function; 787/// \param[in] ndim number of dimensions; 788/// \param[in] addToGlobList boolean marking if it should be added to global list; 789///; 790/// This constructor can be used only in compiled code; 791///; 792/// WARNING! A function created with this constructor cannot be Cloned.; 793 ; 794TF1::TF1(const char *name, ROOT::Math::ParamFunctor f, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 795 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(f))); 796{}; 797 ; 798////////////////////////////////////////////////////////////////////////////////; 799/// Common initialization of the TF1. Add to the global list and; 800/// set the default style; 801 ; 802void TF1::DoInitialize(EAddToList addToGlobalList); 803{; 804 // add to global list of functions if default adding is on OR if bit is set; 805 bool doAdd = ((addToGlobalList == EAddToList::kDefault && fgAddToGlo",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:51591,Modifiability,variab,variables,51591,"/ If this function is used via the context menu, it recommended; 1405/// to create a new canvas/pad before invoking this function.; 1406 ; 1407TObject *TF1::DrawIntegral(Option_t *option); 1408{; 1409 TVirtualPad::TContext ctxt(gROOT->GetSelectedPad(), true, true);; 1410 ; 1411 TGraph *gr = new TGraph(this, ""i"");; 1412 gr->Draw(option);; 1413 return gr;; 1414}; 1415 ; 1416 ; 1417////////////////////////////////////////////////////////////////////////////////; 1418/// Draw function between xmin and xmax.; 1419 ; 1420void TF1::DrawF1(Double_t xmin, Double_t xmax, Option_t *option); 1421{; 1422// //if(Compile(formula)) return ;; 1423 SetRange(xmin, xmax);; 1424 ; 1425 Draw(option);; 1426}; 1427 ; 1428 ; 1429////////////////////////////////////////////////////////////////////////////////; 1430/// Evaluate this function.; 1431///; 1432/// Computes the value of this function (general case for a 3-d function); 1433/// at point x,y,z.; 1434/// For a 1-d function give y=0 and z=0; 1435/// The current value of variables x,y,z is passed through x, y and z.; 1436/// The parameters used will be the ones in the array params if params is given; 1437/// otherwise parameters will be taken from the stored data members fParams; 1438 ; 1439Double_t TF1::Eval(Double_t x, Double_t y, Double_t z, Double_t t) const; 1440{; 1441 if (fType == EFType::kFormula) return fFormula->Eval(x, y, z, t);; 1442 ; 1443 Double_t xx[4] = {x, y, z, t};; 1444 Double_t *pp = (Double_t *)fParams->GetParameters();; 1445 // if (fType == EFType::kInterpreted)((TF1 *)this)->InitArgs(xx, pp);; 1446 return ((TF1 *)this)->EvalPar(xx, pp);; 1447}; 1448 ; 1449 ; 1450////////////////////////////////////////////////////////////////////////////////; 1451/// Evaluate function with given coordinates and parameters.; 1452///; 1453/// Compute the value of this function at point defined by array x; 1454/// and current values of parameters in array params.; 1455/// If argument params is omitted or equal 0, the internal values; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:64870,Modifiability,variab,variable,64870,"in[0], &rmax[0]);; 1760 for (int i = 0; i < ndim; ++i) {; 1761 const char *xname = nullptr;; 1762 double stepSize = 0.1;; 1763 // use range for step size or give some value depending on x if range is not defined; 1764 if (rmax[i] > rmin[i]); 1765 stepSize = (rmax[i] - rmin[i]) / 100;; 1766 else if (std::abs(x[i]) > 1.); 1767 stepSize = 0.1 * x[i];; 1768 ; 1769 // set variable names; 1770 if (ndim <= 3) {; 1771 if (i == 0) {; 1772 xname = ""x"";; 1773 } else if (i == 1) {; 1774 xname = ""y"";; 1775 } else {; 1776 xname = ""z"";; 1777 }; 1778 } else {; 1779 xname = TString::Format(""x_%d"", i);; 1780 // arbitrary step sie (should be computed from range); 1781 }; 1782 ; 1783 if (rmin[i] < rmax[i]) {; 1784 //Info(""GetMinMax"",""setting limits on %s - [ %f , %f ]"",xname,rmin[i],rmax[i]);; 1785 min->SetLimitedVariable(i, xname, x[i], stepSize, rmin[i], rmax[i]);; 1786 } else {; 1787 min->SetVariable(i, xname, x[i], stepSize);; 1788 }; 1789 }; 1790 ; 1791 bool ret = min->Minimize();; 1792 if (!ret) {; 1793 Error(""GetMinimumNDim"", ""Error minimizing function %s"", GetName());; 1794 }; 1795 if (min->X()) std::copy(min->X(), min->X() + ndim, x);; 1796 double fmin = min->MinValue();; 1797 delete min;; 1798 // need to revert sign in case looking for maximum; 1799 return (findmax) ? -fmin : fmin;; 1800 ; 1801}; 1802 ; 1803 ; 1804////////////////////////////////////////////////////////////////////////////////; 1805/// Returns the X value corresponding to the minimum value of the function; 1806/// on the (xmin, xmax) interval; 1807///; 1808/// Method:; 1809/// First, the grid search is used to bracket the maximum; 1810/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1811/// can be controlled via the SetNpx() function. If the function is; 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:72290,Modifiability,variab,variable,72290,"etParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) const; 1941{; 1942 parmin = 0;; 1943 parmax = 0;; 1944 int n = fParMin.size();; 1945 assert(n == int(fParMax.size()) && n <= fNpar);; 1946 if (ipar < 0 || ipar > n - 1) return;; 1947 parmin = fParMin[ipar];; 1948 parmax = fParMax[ipar];; 1949}; 1950 ; 1951 ; 1952////////////////////////////////////////////////////////////////////////////////; 1953/// Return the fit probability; 1954 ; 1955Double_t TF1::GetProb() const; 1956{; 1957 if (fNDF <= 0) return 0;; 1958 return TMath::Prob(fChisquare, fNDF);; 1959}; 1960 ; 1961 ; 1962////////////////////////////////////////////////////////////////////////////////; 1963/// Compute Quantiles for density distribution of this function; 1964///; 1965/// Quantile x_p of a probability distribution Function F is defined as; 1966/// \f[; 1967/// F(x_{p}) = \int_{xmin}^{x_{p}} f dx = p with 0 <= p <= 1.; 1968/// \f]; 1969/// For instance the median \f$ x_{\frac{1}{2}} \f$ of a distribution is defined as that value; 1970/// of the random variable for which the distribution function equals 0.5:; 1971/// \f[; 1972/// F(x_{\frac{1}{2}}) = \prod(x < x_{\frac{1}{2}}) = \frac{1}{2}; 1973/// \f]; 1974///; 1975/// \param[in] n maximum size of array xp and size of array p; 1976/// \param[out] xp array filled with n quantiles evaluated at p. Memory has to be preallocated by caller.; 1977/// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; 1978/// It is assumed to contain at least n values.; 1979/// \return n, the number of quantiles computed (same as input argument n); 1980///; 1981/// Getting quantiles from two histograms and storing results in a TGraph,; 1982/// a so-called QQ-plot; 1983///; 1984/// TGraph *gr = new TGraph(nprob);; 1985/// f1->GetQuantiles(nprob,gr->GetX(),p);; 1986/// f2->GetQuantiles(nprob,gr->GetY(),p);; 1987/// gr->Draw(""alp"");; 1988///; 1989/// \author Eddy Offermann; 1990/// \warning Function leads to undefined behavior if xp or",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:93901,Modifiability,adapt,adaptive,93901,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94481,Modifiability,adapt,adaptive,94481,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94563,Modifiability,adapt,adaptive,94563,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:94654,Modifiability,adapt,adaptive,94654,"l not available for %s - with number %d compute numerical integral"", GetName(), GetNumber());; 2544 }; 2545 return IntegralOneDim(a, b, epsrel, epsrel, error);; 2546}; 2547 ; 2548////////////////////////////////////////////////////////////////////////////////; 2549/// Return Integral of function between a and b using the given parameter values and; 2550/// relative and absolute tolerance.; 2551///; 2552/// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; 2553/// If ROOT contains the MathMore library the default integrator is set to be; 2554/// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; 2555/// ROOT::Math::GaussIntegrator is used; 2556/// See the reference documentation of these classes for more information about the; 2557/// integration algorithms; 2558/// To change integration algorithm just do :; 2559/// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; 2560/// Valid integrator names are:; 2561/// - Gauss : for ROOT::Math::GaussIntegrator; 2562/// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; 2563/// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); 2564/// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); 2565/// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); 2566///; 2567/// In order to use the GSL integrators one needs to have the MathMore library installed; 2568///; 2569/// Note 1:; 2570///; 2571/// Values of the function f(x) at the interval end-points A and B are not; 2572/// required. The subprogram may therefore be used when these values are; 2573/// undefined.; 2574///; 2575/// Note 2:; 2576///; 2577/// Instead of TF1::Integral, you may want to use the combination of; 2578/// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; 2579/// See an example with the following script:; 2580///; 2581/// ~~~ {.cpp}; 2582/// void gint() {; 2583/// TF1 *g = new TF1(""g"",",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:108202,Modifiability,adapt,adaptive,108202,"param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1::IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t maxpts, Double_t epsrel, Double_t epsabs, Double_t &relerr, Int_t &nfnevl, Int_t &ifail); 2852{; 2853 ROOT::Math::WrappedMultiFunction<TF1 &> wf1(*this, n);; 2854 ; 2855 double result = 0;; 2856 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance();; 2857 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorMultiDimOptions:",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154035,Modifiability,adapt,adaptive,154035,"ouble operator()(double x) constDefinition TF1.cxx:156; GFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:152; GFunc::fY0const double fY0Definition TF1.cxx:153; GFunc::GFuncGFunc(const TF1 *function, double y)Definition TF1.cxx:155; GInverseFuncNdimDefinition TF1.cxx:174; GInverseFuncNdim::GInverseFuncNdimGInverseFuncNdim(TF1 *function)Definition TF1.cxx:177; GInverseFuncNdim::fFunctionTF1 * fFunctionDefinition TF1.cxx:175; GInverseFuncNdim::operator()double operator()(const double *x) constDefinition TF1.cxx:179; GInverseFuncDefinition TF1.cxx:163; GInverseFunc::operator()double operator()(double x) constDefinition TF1.cxx:168; GInverseFunc::fFunctionconst TF1 * fFunctionDefinition TF1.cxx:164; GInverseFunc::GInverseFuncGInverseFunc(const TF1 *function)Definition TF1.cxx:166; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::I",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:162686,Modifiability,variab,variable,162686,"the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::Errordouble Error() constreturn the estimate of the absolute Error of the last Integral calculationDefinition Integrator.h:416; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT::Math::MinimizerOptions::DefaultMinimizerAlgostatic const std::string & DefaultMinimizerAlgo()Definition MinimizerOptions.cxx:85; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetLimitedVariablevirtual bool SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower, double upper)set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition Minimizer.cxx:34; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::MinValuevirtual double MinValue() const =0return minimum function value; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:163369,Modifiability,variab,variable,163369,"MinimizerOptions.cxx:85; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetLimitedVariablevirtual bool SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower, double upper)set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition Minimizer.cxx:34; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::MinValuevirtual double MinValue() const =0return minimum function value; ROOT::Math::ParamFunctorTemplParam Functor class for Multidimensional functions.Definition ParamFunctor.h:274; ROOT::Math::RichardsonDerivatorUser class for calculating the derivatives of a function.Definition RichardsonDerivator.h:55; ROOT::Math::RichardsonDerivator::Derivative2double Derivative2(double x)Returns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition RichardsonDerivator.h:172; ROOT::Math::RichardsonDerivator::Errordouble Error() constReturns the estimate of the absolute Error of the last derivative calculation.Definition RichardsonDerivator.h:83; ROOT::Math::RichardsonDerivator::Derivative3double Derivative3(double x)Returns",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:165767,Modifiability,variab,variables,165767,"FunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedTF1Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be ...Definition WrappedTF1.h:39; ROOT::Math::WrappedTF1::SetParametersvoid SetParameters(const double *p) overrideset parameter values need to call also SetParameters in TF1 in ace some other operations (re-normaliz...Definition WrappedTF1.h:90; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetNdimvirtual Int_t GetNdim() constDefinition TFormula.h:237; ROOT::v5::TFormula::GetNparvirtual Int_t GetNpar() constDefinition TFormula.h:238; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::GetArrayconst Double_t * GetArray() constDefinition TArrayD.h:43; TAttAxis::GetLabelColorvirtual Color_t GetLabelColor() constDefinition TAttAxis.h:38; TAttAxis::GetNdivisionsvirtual Int_t GetNdivisions() constDefinition TAttAxis.h:36; TAttAxis::GetLabelOffsetvirtual Float_t GetLabelOffset() constDefinition TAttAxis.h:40; TAttAxis::SetLabelSizevirtual void SetLabelSize(Float_t size=0.04)Set size of axis labels.Definition TAttAxis.cxx:203; TAttAxis::GetLabelFontvirtual Style_t GetLabelFont() constDefinition TAttAxis.h:39; TAttAxis::SetLabelOffsetvirtual void SetLabelOffset(Float_t offset=0.005)Set distance between the axis and the labels.Definition TAttAxis.cxx:191; TAttAxis::SetLabelFontvirtual void SetLabelFont(Style_t font=62)Set labels' font.Definition TAttAxis.cxx:180; TAttAxis::GetLab",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:197716,Modifiability,inherit,inherits,197716,"ition TObjString.h:28; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:35431,Performance,cache,cached,35431,"), fXmax(0), fNpar(0), fNdim(0), fType(EFType::kFormula); 973{; 974 f1.TF1::Copy(*this);; 975}; 976 ; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Static function: set the fgAbsValue flag.; 980/// By default TF1::Integral uses the original function value to compute the integral; 981/// However, TF1::Moment, CentralMoment require to compute the integral; 982/// using the absolute value of the function.; 983 ; 984void TF1::AbsValue(Bool_t flag); 985{; 986 fgAbsValue = flag;; 987}; 988 ; 989 ; 990////////////////////////////////////////////////////////////////////////////////; 991/// Browse.; 992 ; 993void TF1::Browse(TBrowser *b); 994{; 995 Draw(b ? b->GetDrawOption() : """");; 996 gPad->Update();; 997}; 998 ; 999 ; 1000////////////////////////////////////////////////////////////////////////////////; 1001/// Copy this F1 to a new F1.; 1002/// Note that the cached integral with its related arrays are not copied; 1003/// (they are also set as transient data members); 1004 ; 1005void TF1::Copy(TObject &obj) const; 1006{; 1007 delete((TF1 &)obj).fHistogram;; 1008 ; 1009 TNamed::Copy((TF1 &)obj);; 1010 TAttLine::Copy((TF1 &)obj);; 1011 TAttFill::Copy((TF1 &)obj);; 1012 TAttMarker::Copy((TF1 &)obj);; 1013 ((TF1 &)obj).fXmin = fXmin;; 1014 ((TF1 &)obj).fXmax = fXmax;; 1015 ((TF1 &)obj).fNpx = fNpx;; 1016 ((TF1 &)obj).fNpar = fNpar;; 1017 ((TF1 &)obj).fNdim = fNdim;; 1018 ((TF1 &)obj).fType = fType;; 1019 ((TF1 &)obj).fChisquare = fChisquare;; 1020 ((TF1 &)obj).fNpfits = fNpfits;; 1021 ((TF1 &)obj).fNDF = fNDF;; 1022 ((TF1 &)obj).fMinimum = fMinimum;; 1023 ((TF1 &)obj).fMaximum = fMaximum;; 1024 ; 1025 ((TF1 &)obj).fParErrors = fParErrors;; 1026 ((TF1 &)obj).fParMin = fParMin;; 1027 ((TF1 &)obj).fParMax = fParMax;; 1028 ((TF1 &)obj).fParent = fParent;; 1029 ((TF1 &)obj).fSave = fSave;; 1030 ((TF1 &)obj).fHistogram = nullptr;; 1031 ((TF1 &)obj).fMethodCall = nullptr;; 1032 ((TF1 &)obj).fNormalized = fNormalized;; 1033 ((TF1 &)o",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:76932,Performance,perform,perform,76932,"eta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRand",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:99649,Performance,perform,performed,99649,"neDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TString msg(""\t\tFunction Parameters = {"");; 2659 for (int ipar = 0; ipar < GetNpar(); ++ipar) {; 2660 msg += TString::Format("" %s = %f "", GetParName(ipar), GetParameter(ipar));; 2661 if (ipar < GetNpar() - 1) msg += TString("","");; 2662 else msg += TString(""}"");; 2663 }; 2664 Info(""IntegralOneDim"", ""%s"", msg.Data());; 2665 }; 2666 return result;; 2667}; 2668 ; 2669////////////////////////////////////////////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:100560,Performance,multi-thread,multi-threading,100560,"er the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 2702///; 2703/// The user must pass a pointer to the elements of the full covariance matrix; 2704/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2705/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2706/// shown ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:102554,Performance,perform,performed,102554,"hown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2707 ; 2708Double_t TF1::IntegralError(Double_t a, Double_t b, const Double_t *params, const Double_t *covmat, Double_t epsilon); 2709{; 2710 Double_t x1[1];; 2711 Double_t x2[1];; 2712 x1[0] = a, x2[0] = b;; 2713 return ROOT::TF1Helper::IntegralError(this, 1, x1, x2, params, covmat, epsilon);; 2714}; 2715 ; 2716////////////////////////////////////////////////////////////////////////////////; 2717/// Return Error on Integral of a parametric function with dimension larger than one; 2718/// between a[] and b[] due to the parameters uncertainties.; 2719/// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); 2720/// TF1::IntegralMultiple is used for the integral calculation; 2721///; 2722/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2723/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2724/// previously performed fit using the TFitResult class.; 2725/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// Whe",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:103467,Performance,multi-thread,multi-threading,103467," the covariance matrix from the fit. These pointers should be retrieved from the; 2724/// previously performed fit using the TFitResult class.; 2725/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:107739,Performance,perform,performed,107739,"/; 2811/// This function computes, to an attempted specified accuracy, the value of; 2812/// the integral; 2813///; 2814/// \param[in] n Number of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:107882,Performance,perform,performed,107882,"er of dimensions [2,15]; 2815/// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; 2816/// contain the lower and upper limits of integration, respectively.; 2817/// \param[in] maxpts Maximum number of function evaluations to be allowed.; 2818/// maxpts >= 2^n +2*n*(n+1) +1; 2819/// if maxpts<minpts, maxpts is set to 10*minpts; 2820/// \param[in] epsrel Specified relative accuracy.; 2821/// \param[in] epsabs Specified absolute accuracy.; 2822/// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; 2823/// In case the maximum function called is reached the algorithm will stop earlier without having reached; 2824/// the desired accuracy; 2825///; 2826/// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; 2827/// \param[out] nfnevl number of function evaluations performed.; 2828/// \param[out] ifail; 2829/// \parblock; 2830/// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 2831///; 2832/// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; 2833/// specified value of maxpts.; 2834///; 2835/// 3 n<2 or n>15; 2836/// \endparblock; 2837///; 2838/// Method:; 2839///; 2840/// The default method used is the Genz-Mallik adaptive multidimensional algorithm; 2841/// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); 2842///; 2843/// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); 2844/// to different integrators.; 2845/// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; 2846/// Possible methods are : Vegas, Miser or Plain; 2847/// IN case of MC integration the accuracy is determined by the number of function calls, one should be; 2848/// careful not to use a too large value of maxpts; 2849///; 2850 ; 2851Double_t TF1:",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:129247,Performance,cache,cached,129247,,MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:154903,Performance,perform,performing,154903,"e fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Math::AdaptiveIntegratorMultiDimClass for adaptive quadrature integration in multi-dimensions using rectangular regions.Definition AdaptiveIntegratorMultiDim.h:84; ROOT::Math::AdaptiveIntegratorMultiDim::Statusint Status() const overridereturn status of integrationDefinition AdaptiveIntegratorMultiDim.h:149; ROOT::Math::AdaptiveIntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax) overrideevaluate the integral with the previously given function between xmin[] and xmax[]Definition AdaptiveIntegratorMultiDim.h:119; ROOT::Math::AdaptiveIntegratorMultiDim::NEvalint NEval() const overridereturn number of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentMinimizer1D.h:122; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; RO",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:157540,Performance,perform,performing,157540," the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFinder.cxx:66; ROOT::Math::BrentRootFinder::Rootdouble Root() const overrideReturns root value.Definition BrentRootFinder.h:98; ROOT::Math::BrentRootFinder::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentRootFinder.h:89; ROOT::Math::BrentRootFinder::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentRootFinder.h:95; ROOT::Math::ChebyshevPolDefinition ChebyshevPol.h:129; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) ove",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:158847,Performance,perform,performing,158847,"lTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integraldouble Integral(double a, double b) overrideReturns Integral of function between a and b.Definition GaussIntegrator.cxx:52; ROOT::Math::GaussIntegrator::IntegralUpdouble IntegralUp(double a) overrideReturns Integral of function on an upper semi-infinite interval.Definition GaussIntegrator.cxx:61; ROOT::Math::GaussIntegrator::SetFunctionvoid SetFunction(const IGenFunction &) overrideSet integration function (flag control if function must be copied inside).Definition GaussIntegrator.cxx:182; ROOT::Math::GaussIntegrator::IntegralLowdouble IntegralLow(double b) overrideReturns Integral of function on a lower semi-infinite interval.Definition GaussIntegrator.cxx:66; ROOT::Math::GaussIntegrator::Statusint Status() const overridereturn the status of the last integration - 0 in case of successDefinition GaussIntegrator.cxx:179; ROOT::Math::GaussLegendreIntegratorUser class for performing function integration.Definition GaussLegendreIntegrator.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance(",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:159918,Performance,perform,performing,159918,"or.h:37; ROOT::Math::GaussLegendreIntegrator::GetWeightVectorsvoid GetWeightVectors(double *x, double *w) constReturns the arrays x and w containing the abscissa and weight of the Gauss-Legendre n-point quadratur...Definition GaussLegendreIntegrator.cxx:51; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorTypestatic IntegrationMultiDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:341; ROOT::Math::IntegratorMultiDimOptions::DefaultNCallsstatic unsigned int DefaultNCalls()Definition IntegratorOptions.cxx:370; ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:368; ROOT::Math::IntegratorMultiDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:367; ROOT::Math::IntegratorMultiDimUser class for performing multidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDim",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:160926,Performance,perform,performing,160926,"tidimensional integration.Definition IntegratorMultiDim.h:47; ROOT::Math::IntegratorMultiDim::Integraldouble Integral(const double *xmin, const double *xmax)evaluate the integral with the previously given function between xmin[] and xmax[]Definition IntegratorMultiDim.h:122; ROOT::Math::IntegratorMultiDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition IntegratorMultiDim.h:162; ROOT::Math::IntegratorMultiDim::Errordouble Error() constreturn integration errorDefinition IntegratorMultiDim.h:159; ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerancestatic double DefaultAbsTolerance()Definition IntegratorOptions.cxx:265; ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerancestatic double DefaultRelTolerance()Definition IntegratorOptions.cxx:266; ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorTypestatic IntegrationOneDim::Type DefaultIntegratorType()Definition IntegratorOptions.cxx:240; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::GetNamestatic std::string GetName(IntegrationOneDim::Type)static function to get a string from the enumerationDefinition Integrator.cxx:66; ROOT::Math::IntegratorOneDim::Statusint Status() constreturn the Error Status of the last Integral calculationDefinition Integrator.h:421; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::Errordouble Error() constreturn the estimate of the absolute Error of the last Integral calculationDefinition Integrator.h:416; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:163199,Performance,perform,perform,163199,"MinimizerOptions.cxx:85; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetLimitedVariablevirtual bool SetLimitedVariable(unsigned int ivar, const std::string &name, double val, double step, double lower, double upper)set a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition Minimizer.cxx:34; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::MinValuevirtual double MinValue() const =0return minimum function value; ROOT::Math::ParamFunctorTemplParam Functor class for Multidimensional functions.Definition ParamFunctor.h:274; ROOT::Math::RichardsonDerivatorUser class for calculating the derivatives of a function.Definition RichardsonDerivator.h:55; ROOT::Math::RichardsonDerivator::Derivative2double Derivative2(double x)Returns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition RichardsonDerivator.h:172; ROOT::Math::RichardsonDerivator::Errordouble Error() constReturns the estimate of the absolute Error of the last derivative calculation.Definition RichardsonDerivator.h:83; ROOT::Math::RichardsonDerivator::Derivative3double Derivative3(double x)Returns",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:2570,Safety,avoid,avoid,2570,"or.h""; 45#include ""Math/AdaptiveIntegratorMultiDim.h""; 46#include ""Math/RichardsonDerivator.h""; 47#include ""Math/Functor.h""; 48#include ""Math/Minimizer.h""; 49#include ""Math/MinimizerOptions.h""; 50#include ""Math/Factory.h""; 51#include ""Math/ChebyshevPol.h""; 52#include ""Fit/FitResult.h""; 53// for I/O backward compatibility; 54#include ""v5/TF1Data.h""; 55 ; 56#include ""AnalyticalIntegrals.h""; 57 ; 58std::atomic<Bool_t> TF1::fgAbsValue(kFALSE);; 59Bool_t TF1::fgRejectPoint = kFALSE;; 60std::atomic<Bool_t> TF1::fgAddToGlobList(kTRUE);; 61static Double_t gErrorTF1 = 0;; 62 ; 63using TF1Updater_t = void (*)(Int_t nobjects, TObject **from, TObject **to);; 64bool R__SetClonesArrayTF1Updater(TF1Updater_t func);; 65 ; 66 ; 67namespace {; 68struct TF1v5Convert : public TF1 {; 69public:; 70 void Convert(ROOT::v5::TF1Data &from); 71 {; 72 // convert old TF1 to new one; 73 fNpar = from.GetNpar();; 74 fNdim = from.GetNdim();; 75 if (from.fType == 0) {; 76 // formula functions; 77 // if ndim is not 1 set xmin max to zero to avoid error in ctor; 78 double xmin = from.fXmin;; 79 double xmax = from.fXmax;; 80 if (fNdim > 1) {; 81 xmin = 0;; 82 xmax = 0;; 83 }; 84 TF1 fnew(from.GetName(), from.GetExpFormula(), xmin, xmax);; 85 if (fNdim > 1) {; 86 fnew.SetRange(from.fXmin, from.fXmax);; 87 }; 88 fnew.Copy(*this);; 89 // need to set parameter values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXm",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:29442,Safety,avoid,avoid,29442,"ize(EAddToList addToGlobalList); 803{; 804 // add to global list of functions if default adding is on OR if bit is set; 805 bool doAdd = ((addToGlobalList == EAddToList::kDefault && fgAddToGlobList); 806 || addToGlobalList == EAddToList::kAdd);; 807 if (doAdd && gROOT) {; 808 SetBit(kNotGlobal, kFALSE);; 809 R__LOCKGUARD(gROOTMutex);; 810 // Store formula in linked list of formula in ROOT; 811 TF1 *f1old = (TF1 *)gROOT->GetListOfFunctions()->FindObject(fName);; 812 if (f1old) {; 813 gROOT->GetListOfFunctions()->Remove(f1old);; 814 // We removed f1old from the list, it is not longer global.; 815 // (See TF1::AddToGlobalList which requires this flag to be correct).; 816 f1old->SetBit(kNotGlobal, kTRUE);; 817 }; 818 gROOT->GetListOfFunctions()->Add(this);; 819 } else; 820 SetBit(kNotGlobal, kTRUE);; 821 ; 822 if (gStyle) {; 823 SetLineColor(gStyle->GetFuncColor());; 824 SetLineWidth(gStyle->GetFuncWidth());; 825 SetLineStyle(gStyle->GetFuncStyle());; 826 }; 827 SetFillStyle(0);; 828}; 829 ; 830////////////////////////////////////////////////////////////////////////////////; 831/// Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ); 832/// After having called this static method, all the functions created afterwards will follow the; 833/// desired behaviour.; 834///; 835/// By default the functions are added automatically; 836/// It returns the previous status (true if the functions are added automatically); 837 ; 838Bool_t TF1::DefaultAddToGlobalList(Bool_t on); 839{; 840 return fgAddToGlobList.exchange(on);; 841}; 842 ; 843////////////////////////////////////////////////////////////////////////////////; 844/// Add to global list of functions (gROOT->GetListOfFunctions() ); 845/// return previous status (true if the function was already in the list false if not); 846 ; 847Bool_t TF1::AddToGlobalList(Bool_t on); 848{; 849 if (!gROOT) return false;; 850 ; 851 bool prevStatus = !TestBit(kNotGlobal);; 852 if (on) {; 85",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:40356,Safety,avoid,avoid,40356," x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1106/// \f]; 1107/// where k is the double precision, ai are coefficients used in; 1108/// central difference formulas; 1109/// interpolation error is decreased by making the step size h smaller.; 1110///; 1111/// \author Anna Kreshuk; 1112 ; 1113Double_t TF1::Derivative(Double_t x, Double_t *params, Double_t eps) const; 1114{; 1115 if (GetNdim() > 1) {; 1116 Warning(""Derivative"", ""Function dimension is larger than one"");; 1117 }; 1118 ; 1119 ROOT::Math::RichardsonDerivator rd;; 1120 double xmin, xmax;; 1121 GetRange(xmin, xmax);; 1122 // this is not optimal (should be used the average x instead of the range); 1123 double h = eps * std::abs(xmax - xmin);; 1124 if (h <= 0) h = 0.001;; 1125 double der = 0;; 1126 if (params) {; 1127 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1128 wtf.SetParameters(params);; 1129 der = rd.Derivative1(wtf, x, h);; 1130 } else {; 1131 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1132 // an array with parameter values; 1133 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1134 der = rd.Derivative1(wf, x, h);; 1135 }; 1136 ; 1137 gErrorTF1 = rd.Error();; 1138 return der;; 1139 ; 1140}; 1141 ; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Returns the second derivative of the function at point x,; 1145/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1146/// to compute a third, more accurate estimation); 1147/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1148/// \f[; 1149/// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; 1150/// \f]; 1151/// the final estimate; 1152/// \f[; 1153/// D = \frac{4D(h/2) - D(h)}{3}; 1154/// \f]; 1155/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1156///; 1157/// if the argument params is null, the current function parameters are used,; 1158/// otherwise the parameters in",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:42966,Safety,avoid,avoid,42966,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1171/// \f]; 1172/// where k is the double precision, ai are coefficients used in; 1173/// central difference formulas; 1174/// interpolation error is decreased by making the step size h smaller.; 1175///; 1176/// \author Anna Kreshuk; 1177 ; 1178Double_t TF1::Derivative2(Double_t x, Double_t *params, Double_t eps) const; 1179{; 1180 if (GetNdim() > 1) {; 1181 Warning(""Derivative2"", ""Function dimension is larger than one"");; 1182 }; 1183 ; 1184 ROOT::Math::RichardsonDerivator rd;; 1185 double xmin, xmax;; 1186 GetRange(xmin, xmax);; 1187 // this is not optimal (should be used the average x instead of the range); 1188 double h = eps * std::abs(xmax - xmin);; 1189 if (h <= 0) h = 0.001;; 1190 double der = 0;; 1191 if (params) {; 1192 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1193 wtf.SetParameters(params);; 1194 der = rd.Derivative2(wtf, x, h);; 1195 } else {; 1196 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1197 // an array with parameter values; 1198 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1199 der = rd.Derivative2(wf, x, h);; 1200 }; 1201 ; 1202 gErrorTF1 = rd.Error();; 1203 ; 1204 return der;; 1205}; 1206 ; 1207 ; 1208////////////////////////////////////////////////////////////////////////////////; 1209/// Returns the third derivative of the function at point x,; 1210/// computed by Richardson's extrapolation method (use 2 derivative estimates; 1211/// to compute a third, more accurate estimation); 1212/// first, derivatives with steps h and h/2 are computed by central difference formulas; 1213/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:45590,Safety,avoid,avoid,45590,"^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid allocating; 1262 // an array with parameter values; 1263 ROOT::Math::WrappedFunction<const TF1 & > wf(*this);; 1264 der = rd.Derivative3(wf, x, h);; 1265 }; 1266 ; 1267 gErrorTF1 = rd.Error();; 1268 return der;; 1269 ; 1270}; 1271 ; 1272 ; 1273////////////////////////////////////////////////////////////////////////////////; 1274/// Static function returning the error of the last call to the of Derivative's; 1275/// functions; 1276 ; 1277Double_t TF1::DerivativeError(); 1278{; 1279 return gErrorTF1;; 1280}; 1281 ; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Compute distance from point px,py to a function.; 1285///; 1286/// Compute the closest distance of approach from point px,py to this; 1287/// function. The distance is computed in pixels units.; 1288///; 1289/// Note that px is called with a negative value when the TF1 is in; 1290/// TGraph or TH1 list of functions. In this case there is no point; 1291/// looking at the histogram axi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:140015,Safety,safe,safe,140015,"fset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; 3683void TF1::RejectPoint(Bool_t reject); 3684{; 3685 fgRejectPoint = reject;; 3686}; 3687 ; 3688 ; 3689////////////////////////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:143571,Safety,safe,safe,143571," integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface fill",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:143997,Safety,safe,safe,143997," integral of xf(x); 3755 // wrapped the member function EvalFirstMom in interface required by integrator using the functor class; 3756 ROOT::Math::Functor1D xfunc(&func, &TF1_EvalWrapper::EvalFirstMom);; 3757 giod.SetFunction(xfunc);; 3758 ; 3759 // estimate of mean value; 3760 Double_t xbar = giod.Integral(a, b) / norm;; 3761 ; 3762 // use different mean value in function wrapper; 3763 func.fX0 = xbar;; 3764 ROOT::Math::Functor1D xnfunc(&func, &TF1_EvalWrapper::EvalNMom);; 3765 giod.SetFunction(xnfunc);; 3766 ; 3767 Double_t res = giod.Integral(a, b) / norm;; 3768 return res;; 3769}; 3770 ; 3771 ; 3772//______________________________________________________________________________; 3773// some useful static utility functions to compute sampling points for IntegralFast; 3774////////////////////////////////////////////////////////////////////////////////; 3775/// Type safe interface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface fill",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:144661,Safety,unsafe,unsafe,144661,"nterface (static method); 3776/// The number of sampling points are taken from the TGraph; 3777 ; 3778#ifdef INTHEFUTURE; 3779void TF1::CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); 3780{; 3781 if (!g) return;; 3782 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3783}; 3784 ; 3785 ; 3786////////////////////////////////////////////////////////////////////////////////; 3787/// Type safe interface (static method); 3788/// A TGraph is created with new with num points and the pointer to the; 3789/// graph is returned by the function. It is the responsibility of the; 3790/// user to delete the object.; 3791/// if num is invalid (<=0) NULL is returned; 3792 ; 3793TGraph *TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t eps); 3794{; 3795 if (num <= 0); 3796 return 0;; 3797 ; 3798 TGraph *g = new TGraph(num);; 3799 CalcGaussLegendreSamplingPoints(g->GetN(), g->GetX(), g->GetY(), eps);; 3800 return g;; 3801}; 3802#endif; 3803 ; 3804 ; 3805////////////////////////////////////////////////////////////////////////////////; 3806/// Type: unsafe but fast interface filling the arrays x and w (static method); 3807///; 3808/// Given the number of sampling points this routine fills the arrays x and w; 3809/// of length num, containing the abscissa and weight of the Gauss-Legendre; 3810/// n-point quadrature formula.; 3811///; 3812/// Gauss-Legendre:; 3813/** \f[; 3814 W(x)=1 -1<x<1 \\; 3815 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; 3816 \f]; 3817**/; 3818/// num is the number of sampling points (>0); 3819/// x and w are arrays of size num; 3820/// eps is the relative precision; 3821///; 3822/// If num<=0 or eps<=0 no action is done.; 3823///; 3824/// Reference: Numerical Recipes in C, Second Edition; 3825 ; 3826void TF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps); 3827{; 3828 // This function is just kept like this for backward compatibility!; 3829 ; 3830 ROOT::Math::GaussLegendreIntegrator gli(num, eps);; 38",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:175721,Safety,safe,safe,175721,".cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::GetParErrorvirtual Double_t GetParError(Int_t ipar) constReturn value of parameter number ipar.Definition TF1.cxx:1930; TF1::Classstatic TClass *",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:187461,Safety,avoid,avoid,187461,"eEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TF1.cxx:1536; TF1::GetSavevirtual Double_t GetSave(const Double_t *x)Get value corresponding to X in array of fSave values.Definition TF1.cxx:2344; TF1::fgAbsValuestatic std::atomic< Bool_t > fgAbsValueDefinition TF1.h:324; TF1::TF1TF1()TF1 default constructor.Definition TF1.cxx:489; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::fParMaxstd::vector< Double_t > fParMaxArray of upper limits of the fNpar parameters.Definition TF1.h:276; TF1::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TF1.cxx:3218; TF1::IsValidvirtual Bool_t IsValid() constReturn kTRUE if the function is valid.Definition TF1.cxx:2882; TF1::DefaultAddToGlobalListstatic Bool_t DefaultAddToGlobalList(Bool_t on=kTRUE)Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctio...Definition TF1.cxx:838; TF1::fSavestd::vector< Double_t > fSaveArray of fNsave function values.Definition TF1.h:277; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::DefineNSUMTermvoid DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula, int termStart, int termEnd, Double_t xmin, Double_t xmax)Helper functions for NSUM parsing.Definition TF1.cxx:883; TF1::fGammastd::vector< Double_t > fGamma! Array gamma.Definition TF1.h:281; TF1::fParentTObject * fParent! Parent object hooking this function (if one)Definition TF1.h:282; TF1::GetMinMaxNDimvirtual Double_t GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constFind the minimum of a function of whatever dimension.Definition TF1.cxx:1723; TF1::DrawF1virtual void DrawF1(Double_t xmin, Double_t xmax, Option_t *optio",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:31575,Security,sanitiz,sanitized,31575,"!TestBit(kNotGlobal);; 852 if (on) {; 853 if (prevStatus) {; 854 R__LOCKGUARD(gROOTMutex);; 855 assert(gROOT->GetListOfFunctions()->FindObject(this) != nullptr);; 856 return on; // do nothing; 857 }; 858 // do I need to delete previous one with the same name ???; 859 //TF1 * old = dynamic_cast<TF1*>( gROOT->GetListOfFunctions()->FindObject(GetName()) );; 860 //if (old) { gROOT->GetListOfFunctions()->Remove(old); old->SetBit(kNotGlobal, kTRUE); }; 861 R__LOCKGUARD(gROOTMutex);; 862 gROOT->GetListOfFunctions()->Add(this);; 863 SetBit(kNotGlobal, kFALSE);; 864 } else if (prevStatus) {; 865 // if previous status was on and now is off we need to remove the function; 866 SetBit(kNotGlobal, kTRUE);; 867 R__LOCKGUARD(gROOTMutex);; 868 TF1 *old = dynamic_cast<TF1 *>(gROOT->GetListOfFunctions()->FindObject(GetName()));; 869 if (!old) {; 870 Warning(""AddToGlobalList"", ""Function is supposed to be in the global list but it is not present"");; 871 return kFALSE;; 872 }; 873 gROOT->GetListOfFunctions()->Remove(this);; 874 }; 875 return prevStatus;; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Helper functions for NSUM parsing; 880 ; 881// Defines the formula that a given term uses, if not already defined,; 882// and appends ""sanitized"" formula to `fullFormula` string; 883void TF1::DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula,; 884 int termStart, int termEnd, Double_t xmin, Double_t xmax); 885{; 886 TString originalTerm = formula(termStart, termEnd-termStart);; 887 int coeffLength = TermCoeffLength(originalTerm);; 888 if (coeffLength != -1); 889 termStart += coeffLength + 1;; 890 ; 891 // `originalFunc` is the real formula and `cleanedFunc` is the; 892 // sanitized version that will not confuse the TF1NormSum; 893 // constructor; 894 TString originalFunc = formula(termStart, termEnd-termStart);; 895 TString cleanedFunc = TString(formula(termStart, termEnd-termStart)); 896 .",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:32066,Security,sanitiz,sanitized,32066,"!TestBit(kNotGlobal);; 852 if (on) {; 853 if (prevStatus) {; 854 R__LOCKGUARD(gROOTMutex);; 855 assert(gROOT->GetListOfFunctions()->FindObject(this) != nullptr);; 856 return on; // do nothing; 857 }; 858 // do I need to delete previous one with the same name ???; 859 //TF1 * old = dynamic_cast<TF1*>( gROOT->GetListOfFunctions()->FindObject(GetName()) );; 860 //if (old) { gROOT->GetListOfFunctions()->Remove(old); old->SetBit(kNotGlobal, kTRUE); }; 861 R__LOCKGUARD(gROOTMutex);; 862 gROOT->GetListOfFunctions()->Add(this);; 863 SetBit(kNotGlobal, kFALSE);; 864 } else if (prevStatus) {; 865 // if previous status was on and now is off we need to remove the function; 866 SetBit(kNotGlobal, kTRUE);; 867 R__LOCKGUARD(gROOTMutex);; 868 TF1 *old = dynamic_cast<TF1 *>(gROOT->GetListOfFunctions()->FindObject(GetName()));; 869 if (!old) {; 870 Warning(""AddToGlobalList"", ""Function is supposed to be in the global list but it is not present"");; 871 return kFALSE;; 872 }; 873 gROOT->GetListOfFunctions()->Remove(this);; 874 }; 875 return prevStatus;; 876}; 877 ; 878////////////////////////////////////////////////////////////////////////////////; 879/// Helper functions for NSUM parsing; 880 ; 881// Defines the formula that a given term uses, if not already defined,; 882// and appends ""sanitized"" formula to `fullFormula` string; 883void TF1::DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula,; 884 int termStart, int termEnd, Double_t xmin, Double_t xmax); 885{; 886 TString originalTerm = formula(termStart, termEnd-termStart);; 887 int coeffLength = TermCoeffLength(originalTerm);; 888 if (coeffLength != -1); 889 termStart += coeffLength + 1;; 890 ; 891 // `originalFunc` is the real formula and `cleanedFunc` is the; 892 // sanitized version that will not confuse the TF1NormSum; 893 // constructor; 894 TString originalFunc = formula(termStart, termEnd-termStart);; 895 TString cleanedFunc = TString(formula(termStart, termEnd-termStart)); 896 .",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:32545,Security,sanitiz,sanitized,32545,"r NSUM parsing; 880 ; 881// Defines the formula that a given term uses, if not already defined,; 882// and appends ""sanitized"" formula to `fullFormula` string; 883void TF1::DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula,; 884 int termStart, int termEnd, Double_t xmin, Double_t xmax); 885{; 886 TString originalTerm = formula(termStart, termEnd-termStart);; 887 int coeffLength = TermCoeffLength(originalTerm);; 888 if (coeffLength != -1); 889 termStart += coeffLength + 1;; 890 ; 891 // `originalFunc` is the real formula and `cleanedFunc` is the; 892 // sanitized version that will not confuse the TF1NormSum; 893 // constructor; 894 TString originalFunc = formula(termStart, termEnd-termStart);; 895 TString cleanedFunc = TString(formula(termStart, termEnd-termStart)); 896 .ReplaceAll('+', ""<plus>""); 897 .ReplaceAll('*',""<times>"");; 898 ; 899 // define function (if necessary); 900 if (!gROOT->GetListOfFunctions()->FindObject(cleanedFunc)); 901 newFuncs->Add(new TF1(cleanedFunc, originalFunc, xmin, xmax));; 902 ; 903 // append sanitized term to `fullFormula`; 904 if (fullFormula.Length() != 0); 905 fullFormula.Append('+');; 906 ; 907 // include numerical coefficient; 908 if (coeffLength != -1 && originalTerm[0] != '['); 909 fullFormula.Append(originalTerm(0, coeffLength+1));; 910 ; 911 // add coefficient name; 912 if (coeffLength != -1 && originalTerm[0] == '['); 913 coeffNames->Add(new TObjString(TString(originalTerm(1,coeffLength-2))));; 914 else; 915 coeffNames->Add(nullptr);; 916 ; 917 fullFormula.Append(cleanedFunc);; 918}; 919 ; 920 ; 921// Returns length of coeff at beginning of a given term, not counting the '*'; 922// Returns -1 if no coeff found; 923// Coeff can be either a number or parameter name; 924int TF1::TermCoeffLength(TString &term) {; 925 int firstAsterisk = term.First('*');; 926 if (firstAsterisk == -1) // no asterisk found; 927 return -1;; 928 ; 929 if (TString(term(0,firstAsterisk)).IsFloat()); 930 re",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:127532,Security,access,accessed,127532,"0 ; 3321 if (GetXaxis()) GetXaxis()->SaveAttributes(out, f1Name.Data(), ""->GetXaxis()"");; 3322 if (GetYaxis()) GetYaxis()->SaveAttributes(out, f1Name.Data(), ""->GetYaxis()"");; 3323 ; 3324 Double_t parmin, parmax;; 3325 for (i = 0; i < GetNpar(); i++) {; 3326 out << "" "" << f1Name.Data() << ""->SetParameter("" << i << "","" << GetParameter(i) << "");"" << std::endl;; 3327 out << "" "" << f1Name.Data() << ""->SetParError("" << i << "","" << GetParError(i) << "");"" << std::endl;; 3328 GetParLimits(i, parmin, parmax);; 3329 out << "" "" << f1Name.Data() << ""->SetParLimits("" << i << "","" << parmin << "","" << parmax << "");"" << std::endl;; 3330 }; 3331 if (!strstr(option, ""nodraw"")) {; 3332 out << "" "" << f1Name.Data() << ""->Draw(""; 3333 << quote << option << quote << "");"" << std::endl;; 3334 }; 3335}; 3336 ; 3337 ; 3338////////////////////////////////////////////////////////////////////////////////; 3339/// Static function setting the current function.; 3340/// the current function may be accessed in static C-like functions; 3341/// when fitting or painting a function.; 3342 ; 3343void TF1::SetCurrent(TF1 *f1); 3344{; 3345 fgCurrent = f1;; 3346}; 3347 ; 3348////////////////////////////////////////////////////////////////////////////////; 3349/// Set the result from the fit; 3350/// parameter values, errors, chi2, etc...; 3351/// Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; 3352/// This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; 3353/// By default it is assume that indpar = {0,1,2,....,fNpar-1}.; 3354 ; 3355void TF1::SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar); 3356{; 3357 Int_t npar = GetNpar();; 3358 if (result.IsEmpty()) {; 3359 Warning(""SetFitResult"", ""Empty Fit result - nothing is set in TF1"");; 3360 return;; 3361 }; 3362 if (indpar == nullptr && npar != (int) result.NPar()) {; 3363 Error(""SetFitResult"", ""Invalid Fit result passed -",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:3894,Testability,assert,assert,3894,"values; 90 if (from.GetParameters()); 91 fFormula->SetParameters(from.GetParameters());; 92 } else {; 93 // case of a function pointers; 94 fParams = std::make_unique<TF1Parameters>(fNpar);; 95 fName = from.GetName();; 96 fTitle = from.GetTitle();; 97 // need to set parameter values; 98 if (from.GetParameters()); 99 fParams->SetParameters(from.GetParameters());; 100 }; 101 // copy the other data members; 102 fNpx = from.fNpx;; 103 fType = (EFType)from.fType;; 104 fNpfits = from.fNpfits;; 105 fNDF = from.fNDF;; 106 fChisquare = from.fChisquare;; 107 fMaximum = from.fMaximum;; 108 fMinimum = from.fMinimum;; 109 fXmin = from.fXmin;; 110 fXmax = from.fXmax;; 111 ; 112 if (from.fParErrors); 113 fParErrors = std::vector<Double_t>(from.fParErrors, from.fParErrors + fNpar);; 114 if (from.fParMin); 115 fParMin = std::vector<Double_t>(from.fParMin, from.fParMin + fNpar);; 116 if (from.fParMax); 117 fParMax = std::vector<Double_t>(from.fParMax, from.fParMax + fNpar);; 118 if (from.fNsave > 0) {; 119 assert(from.fSave);; 120 fSave = std::vector<Double_t>(from.fSave, from.fSave + from.fNsave);; 121 }; 122 // set the bits; 123 for (int ibit = 0; ibit < 24; ++ibit); 124 if (from.TestBit(BIT(ibit))); 125 SetBit(BIT(ibit));; 126 ; 127 // copy the graph attributes; 128 from.TAttLine::Copy(*this);; 129 from.TAttFill::Copy(*this);; 130 from.TAttMarker::Copy(*this);; 131 }; 132};; 133} // unnamed namespace; 134 ; 135static void R__v5TF1Updater(Int_t nobjects, TObject **from, TObject **to); 136{; 137 auto **fromv5 = (ROOT::v5::TF1Data **)from;; 138 auto **target = (TF1v5Convert **)to;; 139 ; 140 for (int i = 0; i < nobjects; ++i) {; 141 if (fromv5[i] && target[i]); 142 target[i]->Convert(*fromv5[i]);; 143 }; 144}; 145 ; 146int R__RegisterTF1UpdaterTrigger = R__SetClonesArrayTF1Updater(R__v5TF1Updater);; 147 ; 148ClassImp(TF1);; 149 ; 150// class wrapping evaluation of TF1(x) - y0; 151class GFunc {; 152 const TF1 *fFunction;; 153 const double fY0;; 154public:; 155 GFunc(const TF1 *function",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:11384,Testability,test,test,11384,"functions and still maintain the capability of storing the function in a file which cannot be done with; 344function pointer or lambda written not as expression, but as code (see items below).; 345 ; 346Example on how using lambda to define a sum of two functions.; 347Note that is necessary to provide the number of parameters; 348 ; 349~~~~{.cpp}; 350TF1 f1(""f1"",""sin(x)"",0,10);; 351TF1 f2(""f2"",""cos(x)"",0,10);; 352TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; 353~~~~; 354 ; 355\anchor F4; 356### 4 - A general C function with parameters; 357 ; 358Consider the macro myfunc.C below:; 359 ; 360~~~~{.cpp}; 361 // Macro myfunc.C; 362 Double_t myfunction(Double_t *x, Double_t *par); 363 {; 364 Float_t xx =x[0];; 365 Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; 366 return f;; 367 }; 368 void myfunc(); 369 {; 370 auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; 371 f1->SetParameters(2,1);; 372 f1->SetParNames(""constant"",""coefficient"");; 373 f1->Draw();; 374 }; 375 void myfit(); 376 {; 377 auto h1 = new TH1F(""h1"",""test"",100,0,10);; 378 h1->FillRandom(""myfunc"",20000);; 379 TF1 *f1 = (TF1 *)gROOT->GetFunction(""myfunc"");; 380 f1->SetParameters(800,1);; 381 h1->Fit(""myfunc"");; 382 }; 383~~~~; 384 ; 385 ; 386 ; 387In an interactive session you can do:; 388 ; 389~~~~; 390 Root > .L myfunc.C; 391 Root > myfunc();; 392 Root > myfit();; 393~~~~; 394 ; 395 ; 396 ; 397TF1 objects can reference other TF1 objects of type A or B defined above. This excludes CLing or compiled functions. However, there is a restriction. A function cannot reference a basic function if the basic function is a polynomial polN.; 398 ; 399Example:; 400 ; 401~~~~{.cpp}; 402{; 403 auto fcos = new TF1 (""fcos"", ""[0]*cos(x)"", 0., 10.);; 404 fcos->SetParNames( ""cos"");; 405 fcos->SetParameter( 0, 1.1);; 406 ; 407 auto fsin = new TF1 (""fsin"", ""[0]*sin(x)"", 0., 10.);; 408 fsin->SetParNames( ""sin"");; 409 fsin->SetParameter( 0, 2.1);; 410 ; 411 auto fsincos = new TF1 (""fsc"", ""fc",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:25393,Testability,test,test,25393,"me.IsNull()) {; 721 Error(""TF1"", ""requires a proper function name!"");; 722 return;; 723 }; 724 ; 725 fMethodCall = std::make_unique<TMethodCall>();; 726 fMethodCall->InitWithPrototype(fName, ""Double_t*,Double_t*"");; 727 ; 728 if (! fMethodCall->IsValid()) {; 729 Error(""TF1"", ""No function found with the signature %s(Double_t*,Double_t*)"", name);; 730 return;; 731 }; 732}; 733 ; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Constructor using a pointer to a real function.; 737///; 738/// \param[in] name object name; 739/// \param[in] fcn pointer to function; 740/// \param[in] xmin,xmax x axis limits; 741/// \param[in] npar is the number of free parameters used by the function; 742/// \param[in] ndim number of dimensions; 743/// \param[in] addToGlobList boolean marking if it should be added to global list; 744///; 745/// This constructor creates a function of type C when invoked; 746/// with the normal C++ compiler.; 747///; 748/// see test program test/stress.cxx (function stress1) for an example.; 749/// note the interface with an intermediate pointer.; 750///; 751/// \warning A function created with this constructor cannot be Cloned.; 752 ; 753TF1::TF1(const char *name, Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:25406,Testability,test,test,25406,"me.IsNull()) {; 721 Error(""TF1"", ""requires a proper function name!"");; 722 return;; 723 }; 724 ; 725 fMethodCall = std::make_unique<TMethodCall>();; 726 fMethodCall->InitWithPrototype(fName, ""Double_t*,Double_t*"");; 727 ; 728 if (! fMethodCall->IsValid()) {; 729 Error(""TF1"", ""No function found with the signature %s(Double_t*,Double_t*)"", name);; 730 return;; 731 }; 732}; 733 ; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Constructor using a pointer to a real function.; 737///; 738/// \param[in] name object name; 739/// \param[in] fcn pointer to function; 740/// \param[in] xmin,xmax x axis limits; 741/// \param[in] npar is the number of free parameters used by the function; 742/// \param[in] ndim number of dimensions; 743/// \param[in] addToGlobList boolean marking if it should be added to global list; 744///; 745/// This constructor creates a function of type C when invoked; 746/// with the normal C++ compiler.; 747///; 748/// see test program test/stress.cxx (function stress1) for an example.; 749/// note the interface with an intermediate pointer.; 750///; 751/// \warning A function created with this constructor cannot be Cloned.; 752 ; 753TF1::TF1(const char *name, Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:26562,Testability,test,test,26562,"his constructor cannot be Cloned.; 752 ; 753TF1::TF1(const char *name, Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if it should be added to global list; 766///; 767/// This constructor creates a function of type C when invoked; 768/// with the normal C++ compiler.; 769///; 770/// see test program test/stress.cxx (function stress1) for an example.; 771/// note the interface with an intermediate pointer.; 772///; 773/// \warning A function created with this constructor cannot be Cloned.; 774 ; 775TF1::TF1(const char *name, Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 776 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 777{}; 778 ; 779////////////////////////////////////////////////////////////////////////////////; 780/// Constructor using the Functor class.; 781///; 782/// \param[in] name object name; 783/// \param f parameterized functor; 784/// \param xmin and; 785/// \param xmax define the plotting range of the function; 786/// \param[in] npar is the number of free parameters used by the function; 787/// \param[in] ndim number of dimensions; 788/// \param[in]",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:26575,Testability,test,test,26575,"his constructor cannot be Cloned.; 752 ; 753TF1::TF1(const char *name, Double_t (*fcn)(Double_t *, Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 754 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 755{}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Constructor using a pointer to (const) real function.; 759///; 760/// \param[in] name object name; 761/// \param[in] fcn pointer to function; 762/// \param[in] xmin,xmax x axis limits; 763/// \param[in] npar is the number of free parameters used by the function; 764/// \param[in] ndim number of dimensions; 765/// \param[in] addToGlobList boolean marking if it should be added to global list; 766///; 767/// This constructor creates a function of type C when invoked; 768/// with the normal C++ compiler.; 769///; 770/// see test program test/stress.cxx (function stress1) for an example.; 771/// note the interface with an intermediate pointer.; 772///; 773/// \warning A function created with this constructor cannot be Cloned.; 774 ; 775TF1::TF1(const char *name, Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList) :; 776 TF1(EFType::kPtrScalarFreeFcn, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(fcn))); 777{}; 778 ; 779////////////////////////////////////////////////////////////////////////////////; 780/// Constructor using the Functor class.; 781///; 782/// \param[in] name object name; 783/// \param f parameterized functor; 784/// \param xmin and; 785/// \param xmax define the plotting range of the function; 786/// \param[in] npar is the number of free parameters used by the function; 787/// \param[in] ndim number of dimensions; 788/// \param[in]",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:30383,Testability,assert,assert,30383,,MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:36615,Testability,assert,assert,36615,":Copy((TF1 &)obj);; 1011 TAttFill::Copy((TF1 &)obj);; 1012 TAttMarker::Copy((TF1 &)obj);; 1013 ((TF1 &)obj).fXmin = fXmin;; 1014 ((TF1 &)obj).fXmax = fXmax;; 1015 ((TF1 &)obj).fNpx = fNpx;; 1016 ((TF1 &)obj).fNpar = fNpar;; 1017 ((TF1 &)obj).fNdim = fNdim;; 1018 ((TF1 &)obj).fType = fType;; 1019 ((TF1 &)obj).fChisquare = fChisquare;; 1020 ((TF1 &)obj).fNpfits = fNpfits;; 1021 ((TF1 &)obj).fNDF = fNDF;; 1022 ((TF1 &)obj).fMinimum = fMinimum;; 1023 ((TF1 &)obj).fMaximum = fMaximum;; 1024 ; 1025 ((TF1 &)obj).fParErrors = fParErrors;; 1026 ((TF1 &)obj).fParMin = fParMin;; 1027 ((TF1 &)obj).fParMax = fParMax;; 1028 ((TF1 &)obj).fParent = fParent;; 1029 ((TF1 &)obj).fSave = fSave;; 1030 ((TF1 &)obj).fHistogram = nullptr;; 1031 ((TF1 &)obj).fMethodCall = nullptr;; 1032 ((TF1 &)obj).fNormalized = fNormalized;; 1033 ((TF1 &)obj).fNormIntegral = fNormIntegral;; 1034 ((TF1 &)obj).fFormula = nullptr;; 1035 ; 1036 if (fFormula) assert(fFormula->GetNpar() == fNpar);; 1037 ; 1038 // use copy-constructor of TMethodCall; 1039 TMethodCall *m = (fMethodCall) ? new TMethodCall(*fMethodCall) : nullptr;; 1040 ((TF1 &)obj).fMethodCall.reset(m);; 1041 ; 1042 TFormula *formulaToCopy = (fFormula) ? new TFormula(*fFormula) : nullptr;; 1043 ((TF1 &)obj).fFormula.reset(formulaToCopy);; 1044 ; 1045 TF1Parameters *paramsToCopy = (fParams) ? new TF1Parameters(*fParams) : nullptr;; 1046 ((TF1 &)obj).fParams.reset(paramsToCopy);; 1047 ; 1048 TF1FunctorPointer *functorToCopy = (fFunctor) ? fFunctor->Clone() : nullptr;; 1049 ((TF1 &)obj).fFunctor.reset(functorToCopy);; 1050 ; 1051 TF1AbsComposition *comp = nullptr;; 1052 if (fComposition) {; 1053 comp = (TF1AbsComposition *)fComposition->IsA()->New();; 1054 fComposition->Copy(*comp);; 1055 }; 1056 ((TF1 &)obj).fComposition.reset(comp);; 1057}; 1058 ; 1059 ; 1060////////////////////////////////////////////////////////////////////////////////; 1061/// Make a complete copy of the underlying object. If 'newname' is set,; 1062/// the copy's name will be se",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:53362,Testability,assert,assert,53362,"n array params.; 1455/// If argument params is omitted or equal 0, the internal values; 1456/// of parameters (array fParams) will be used instead.; 1457/// For a 1-D function only x[0] must be given.; 1458/// In case of a multi-dimensional function, the arrays x must be; 1459/// filled with the corresponding number of dimensions.; 1460///; 1461/// WARNING. In case of an interpreted function (fType=2), it is the; 1462/// user's responsibility to initialize the parameters via InitArgs; 1463/// before calling this function.; 1464/// InitArgs should be called at least once to specify the addresses; 1465/// of the arguments x and params.; 1466/// InitArgs should be called every time these addresses change.; 1467 ; 1468Double_t TF1::EvalPar(const Double_t *x, const Double_t *params); 1469{; 1470 //fgCurrent = this;; 1471 ; 1472 if (fType == EFType::kFormula) {; 1473 assert(fFormula);; 1474 ; 1475 if (fNormalized && fNormIntegral != 0); 1476 return fFormula->EvalPar(x, params) / fNormIntegral;; 1477 else; 1478 return fFormula->EvalPar(x, params);; 1479 }; 1480 Double_t result = 0;; 1481 if (fType == EFType::kPtrScalarFreeFcn || fType == EFType::kTemplScalar) {; 1482 if (fFunctor) {; 1483 assert(fParams);; 1484 if (params) result = ((TF1FunctorPointerImpl<Double_t> *)fFunctor.get())->fImpl((Double_t *)x, (Double_t *)params);; 1485 else result = ((TF1FunctorPointerImpl<Double_t> *)fFunctor.get())->fImpl((Double_t *)x, (Double_t *)fParams->GetParameters());; 1486 ; 1487 } else result = GetSave(x);; 1488 ; 1489 if (fNormalized && fNormIntegral != 0); 1490 result = result / fNormIntegral;; 1491 ; 1492 return result;; 1493 }; 1494 if (fType == EFType::kInterpreted) {; 1495 if (fMethodCall) fMethodCall->Execute(result);; 1496 else result = GetSave(x);; 1497 ; 1498 if (fNormalized && fNormIntegral != 0); 1499 result = result / fNormIntegral;; 1500 ; 1501 return result;; 1502 }; 1503 ; 1504#ifdef R__HAS_VECCORE; 1505 if (fType == EFType::kTemplVec) {; 1506 if (fFunctor) {; 1507 if ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:53689,Testability,assert,assert,53689,"n array params.; 1455/// If argument params is omitted or equal 0, the internal values; 1456/// of parameters (array fParams) will be used instead.; 1457/// For a 1-D function only x[0] must be given.; 1458/// In case of a multi-dimensional function, the arrays x must be; 1459/// filled with the corresponding number of dimensions.; 1460///; 1461/// WARNING. In case of an interpreted function (fType=2), it is the; 1462/// user's responsibility to initialize the parameters via InitArgs; 1463/// before calling this function.; 1464/// InitArgs should be called at least once to specify the addresses; 1465/// of the arguments x and params.; 1466/// InitArgs should be called every time these addresses change.; 1467 ; 1468Double_t TF1::EvalPar(const Double_t *x, const Double_t *params); 1469{; 1470 //fgCurrent = this;; 1471 ; 1472 if (fType == EFType::kFormula) {; 1473 assert(fFormula);; 1474 ; 1475 if (fNormalized && fNormIntegral != 0); 1476 return fFormula->EvalPar(x, params) / fNormIntegral;; 1477 else; 1478 return fFormula->EvalPar(x, params);; 1479 }; 1480 Double_t result = 0;; 1481 if (fType == EFType::kPtrScalarFreeFcn || fType == EFType::kTemplScalar) {; 1482 if (fFunctor) {; 1483 assert(fParams);; 1484 if (params) result = ((TF1FunctorPointerImpl<Double_t> *)fFunctor.get())->fImpl((Double_t *)x, (Double_t *)params);; 1485 else result = ((TF1FunctorPointerImpl<Double_t> *)fFunctor.get())->fImpl((Double_t *)x, (Double_t *)fParams->GetParameters());; 1486 ; 1487 } else result = GetSave(x);; 1488 ; 1489 if (fNormalized && fNormIntegral != 0); 1490 result = result / fNormIntegral;; 1491 ; 1492 return result;; 1493 }; 1494 if (fType == EFType::kInterpreted) {; 1495 if (fMethodCall) fMethodCall->Execute(result);; 1496 else result = GetSave(x);; 1497 ; 1498 if (fNormalized && fNormIntegral != 0); 1499 result = result / fNormIntegral;; 1500 ; 1501 return result;; 1502 }; 1503 ; 1504#ifdef R__HAS_VECCORE; 1505 if (fType == EFType::kTemplVec) {; 1506 if (fFunctor) {; 1507 if ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:58534,Testability,log,logx,58534,"96////////////////////////////////////////////////////////////////////////////////; 1597/// Returns the maximum value of the function; 1598///; 1599/// Method:; 1600/// First, the grid search is used to bracket the maximum; 1601/// with the step size = (xmax-xmin)/fNpx.; 1602/// This way, the step size can be controlled via the SetNpx() function.; 1603/// If the function is unimodal or if its extrema are far apart, setting; 1604/// the fNpx to a small value speeds the algorithm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() functi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:58573,Testability,log,log,58573,"96////////////////////////////////////////////////////////////////////////////////; 1597/// Returns the maximum value of the function; 1598///; 1599/// Method:; 1600/// First, the grid search is used to bracket the maximum; 1601/// with the step size = (xmax-xmin)/fNpx.; 1602/// This way, the step size can be controlled via the SetNpx() function.; 1603/// If the function is unimodal or if its extrema are far apart, setting; 1604/// the fNpx to a small value speeds the algorithm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() functi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:58630,Testability,log,log,58630,"96////////////////////////////////////////////////////////////////////////////////; 1597/// Returns the maximum value of the function; 1598///; 1599/// Method:; 1600/// First, the grid search is used to bracket the maximum; 1601/// with the step size = (xmax-xmin)/fNpx.; 1602/// This way, the step size can be controlled via the SetNpx() function.; 1603/// If the function is unimodal or if its extrema are far apart, setting; 1604/// the fNpx to a small value speeds the algorithm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() functi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:58837,Testability,log,logx,58837,"96////////////////////////////////////////////////////////////////////////////////; 1597/// Returns the maximum value of the function; 1598///; 1599/// Method:; 1600/// First, the grid search is used to bracket the maximum; 1601/// with the step size = (xmax-xmin)/fNpx.; 1602/// This way, the step size can be controlled via the SetNpx() function.; 1603/// If the function is unimodal or if its extrema are far apart, setting; 1604/// the fNpx to a small value speeds the algorithm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() functi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:58948,Testability,log,logx,58948,"96////////////////////////////////////////////////////////////////////////////////; 1597/// Returns the maximum value of the function; 1598///; 1599/// Method:; 1600/// First, the grid search is used to bracket the maximum; 1601/// with the step size = (xmax-xmin)/fNpx.; 1602/// This way, the step size can be controlled via the SetNpx() function.; 1603/// If the function is unimodal or if its extrema are far apart, setting; 1604/// the fNpx to a small value speeds the algorithm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() functi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:58973,Testability,log,logx,58973,"96////////////////////////////////////////////////////////////////////////////////; 1597/// Returns the maximum value of the function; 1598///; 1599/// Method:; 1600/// First, the grid search is used to bracket the maximum; 1601/// with the step size = (xmax-xmin)/fNpx.; 1602/// This way, the step size can be controlled via the SetNpx() function.; 1603/// If the function is unimodal or if its extrema are far apart, setting; 1604/// the fNpx to a small value speeds the algorithm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() functi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:59209,Testability,log,logx,59209,"hm up many times.; 1605/// Then, Brent's method is applied on the bracketed interval; 1606/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1607/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1608/// of iteration of the Brent algorithm; 1609/// If the flag logx is set the grid search is done in log step size; 1610/// This is done automatically if the log scale is set in the current Pad; 1611///; 1612/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1613 ; 1614Double_t TF1::GetMaximum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1615{; 1616 if (xmin >= xmax) {; 1617 xmin = fXmin;; 1618 xmax = fXmax;; 1619 }; 1620 ; 1621 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1622 ; 1623 ROOT::Math::BrentMinimizer1D bm;; 1624 GInverseFunc g(this);; 1625 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1626 bm.SetFunction(wf1, xmin, xmax);; 1627 bm.SetNpx(fNpx);; 1628 bm.SetLogScan(logx);; 1629 bm.Minimize(maxiter, epsilon, epsilon);; 1630 Double_t x;; 1631 x = - bm.FValMinimum();; 1632 ; 1633 return x;; 1634}; 1635 ; 1636 ; 1637////////////////////////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid se",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60189,Testability,log,logx,60189,"///////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the func",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60228,Testability,log,log,60228,"///////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the func",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60285,Testability,log,log,60285,"///////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the func",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60472,Testability,log,logx,60472,"///////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the func",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60583,Testability,log,logx,60583,"///////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the func",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60608,Testability,log,logx,60608,"///////////////////////////////////////////////////////////////; 1638/// Returns the X value corresponding to the maximum value of the function; 1639///; 1640/// Method:; 1641/// First, the grid search is used to bracket the maximum; 1642/// with the step size = (xmax-xmin)/fNpx.; 1643/// This way, the step size can be controlled via the SetNpx() function.; 1644/// If the function is unimodal or if its extrema are far apart, setting; 1645/// the fNpx to a small value speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the func",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:60844,Testability,log,logx,60844,"e speeds the algorithm up many times.; 1646/// Then, Brent's method is applied on the bracketed interval; 1647/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1648/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1649/// of iteration of the Brent algorithm; 1650/// If the flag logx is set the grid search is done in log step size; 1651/// This is done automatically if the log scale is set in the current Pad; 1652///; 1653/// NOTE: see also TF1::GetX; 1654 ; 1655Double_t TF1::GetMaximumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1656{; 1657 if (xmin >= xmax) {; 1658 xmin = fXmin;; 1659 xmax = fXmax;; 1660 }; 1661 ; 1662 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1663 ; 1664 ROOT::Math::BrentMinimizer1D bm;; 1665 GInverseFunc g(this);; 1666 ROOT::Math::WrappedFunction<GInverseFunc> wf1(g);; 1667 bm.SetFunction(wf1, xmin, xmax);; 1668 bm.SetNpx(fNpx);; 1669 bm.SetLogScan(logx);; 1670 bm.Minimize(maxiter, epsilon, epsilon);; 1671 Double_t x;; 1672 x = bm.XMinimum();; 1673 ; 1674 return x;; 1675}; 1676 ; 1677 ; 1678////////////////////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:61819,Testability,log,logx,61819,"//////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 172",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:61858,Testability,log,log,61858,"//////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 172",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:61915,Testability,log,log,61915,"//////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 172",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:62122,Testability,log,logx,62122,"//////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 172",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:62233,Testability,log,logx,62233,"//////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 172",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:62258,Testability,log,logx,62258,"//////////////////////////////////////////////////////////////////; 1679/// Returns the minimum value of the function on the (xmin, xmax) interval; 1680///; 1681/// Method:; 1682/// First, the grid search is used to bracket the maximum; 1683/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1684/// can be controlled via the SetNpx() function. If the function is; 1685/// unimodal or if its extrema are far apart, setting the fNpx to; 1686/// a small value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 172",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:62469,Testability,log,logx,62469," value speeds the algorithm up many times.; 1687/// Then, Brent's method is applied on the bracketed interval; 1688/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1689/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1690/// of iteration of the Brent algorithm; 1691/// If the flag logx is set the grid search is done in log step size; 1692/// This is done automatically if the log scale is set in the current Pad; 1693///; 1694/// NOTE: see also TF1::GetMaximumX and TF1::GetX; 1695 ; 1696Double_t TF1::GetMinimum(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 1723Double_t TF1::GetMinMaxNDim(Double_t *x , bool findmax, Double_t epsilon, Int_t maxiter) const; 1724{; 1725 R__ASSERT(x != nullptr);; 1726 ; 1727 int ndim = GetNdim();; 1728 if (ndim == 0) {; 1729 Error(""GetMinimumNDim"", ""Function of dimension 0 - return Eval(x)"");; 1730 return (const_cast<TF1 &>(*this))(x);; 1731 }; 1732 ; 1733 // create minimizer class; 1734 const char *minimName = ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str();; 1735 const char *",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:66694,Testability,log,logx,66694,"///////////////////////////////////////////////////////////////////////; 1805/// Returns the X value corresponding to the minimum value of the function; 1806/// on the (xmin, xmax) interval; 1807///; 1808/// Method:; 1809/// First, the grid search is used to bracket the maximum; 1810/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1811/// can be controlled via the SetNpx() function. If the function is; 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1816/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1817/// of iteration of the Brent algorithm; 1818/// If the flag logx is set the grid search is done in log step size; 1819/// This is done automatically if the log scale is set in the current Pad; 1820///; 1821/// NOTE: see also TF1::GetX; 1822 ; 1823Double_t TF1::GetMinimumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1824{; 1825 if (xmin >= xmax) {; 1826 xmin = fXmin;; 1827 xmax = fXmax;; 1828 }; 1829 ; 1830 ROOT::Math::BrentMinimizer1D bm;; 1831 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1832 bm.SetFunction(wf1, xmin, xmax);; 1833 bm.SetNpx(fNpx);; 1834 bm.SetLogScan(logx);; 1835 bm.Minimize(maxiter, epsilon, epsilon);; 1836 Double_t x;; 1837 x = bm.XMinimum();; 1838 ; 1839 return x;; 1840}; 1841 ; 1842 ; 1843////////////////////////////////////////////////////////////////////////////////; 1844/// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; 1845/// in other words it can find the roots of the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maxi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:66733,Testability,log,log,66733,"///////////////////////////////////////////////////////////////////////; 1805/// Returns the X value corresponding to the minimum value of the function; 1806/// on the (xmin, xmax) interval; 1807///; 1808/// Method:; 1809/// First, the grid search is used to bracket the maximum; 1810/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1811/// can be controlled via the SetNpx() function. If the function is; 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1816/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1817/// of iteration of the Brent algorithm; 1818/// If the flag logx is set the grid search is done in log step size; 1819/// This is done automatically if the log scale is set in the current Pad; 1820///; 1821/// NOTE: see also TF1::GetX; 1822 ; 1823Double_t TF1::GetMinimumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1824{; 1825 if (xmin >= xmax) {; 1826 xmin = fXmin;; 1827 xmax = fXmax;; 1828 }; 1829 ; 1830 ROOT::Math::BrentMinimizer1D bm;; 1831 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1832 bm.SetFunction(wf1, xmin, xmax);; 1833 bm.SetNpx(fNpx);; 1834 bm.SetLogScan(logx);; 1835 bm.Minimize(maxiter, epsilon, epsilon);; 1836 Double_t x;; 1837 x = bm.XMinimum();; 1838 ; 1839 return x;; 1840}; 1841 ; 1842 ; 1843////////////////////////////////////////////////////////////////////////////////; 1844/// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; 1845/// in other words it can find the roots of the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maxi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:66790,Testability,log,log,66790,"///////////////////////////////////////////////////////////////////////; 1805/// Returns the X value corresponding to the minimum value of the function; 1806/// on the (xmin, xmax) interval; 1807///; 1808/// Method:; 1809/// First, the grid search is used to bracket the maximum; 1810/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1811/// can be controlled via the SetNpx() function. If the function is; 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1816/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1817/// of iteration of the Brent algorithm; 1818/// If the flag logx is set the grid search is done in log step size; 1819/// This is done automatically if the log scale is set in the current Pad; 1820///; 1821/// NOTE: see also TF1::GetX; 1822 ; 1823Double_t TF1::GetMinimumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1824{; 1825 if (xmin >= xmax) {; 1826 xmin = fXmin;; 1827 xmax = fXmax;; 1828 }; 1829 ; 1830 ROOT::Math::BrentMinimizer1D bm;; 1831 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1832 bm.SetFunction(wf1, xmin, xmax);; 1833 bm.SetNpx(fNpx);; 1834 bm.SetLogScan(logx);; 1835 bm.Minimize(maxiter, epsilon, epsilon);; 1836 Double_t x;; 1837 x = bm.XMinimum();; 1838 ; 1839 return x;; 1840}; 1841 ; 1842 ; 1843////////////////////////////////////////////////////////////////////////////////; 1844/// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; 1845/// in other words it can find the roots of the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maxi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:66977,Testability,log,logx,66977,"///////////////////////////////////////////////////////////////////////; 1805/// Returns the X value corresponding to the minimum value of the function; 1806/// on the (xmin, xmax) interval; 1807///; 1808/// Method:; 1809/// First, the grid search is used to bracket the maximum; 1810/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1811/// can be controlled via the SetNpx() function. If the function is; 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1816/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1817/// of iteration of the Brent algorithm; 1818/// If the flag logx is set the grid search is done in log step size; 1819/// This is done automatically if the log scale is set in the current Pad; 1820///; 1821/// NOTE: see also TF1::GetX; 1822 ; 1823Double_t TF1::GetMinimumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1824{; 1825 if (xmin >= xmax) {; 1826 xmin = fXmin;; 1827 xmax = fXmax;; 1828 }; 1829 ; 1830 ROOT::Math::BrentMinimizer1D bm;; 1831 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1832 bm.SetFunction(wf1, xmin, xmax);; 1833 bm.SetNpx(fNpx);; 1834 bm.SetLogScan(logx);; 1835 bm.Minimize(maxiter, epsilon, epsilon);; 1836 Double_t x;; 1837 x = bm.XMinimum();; 1838 ; 1839 return x;; 1840}; 1841 ; 1842 ; 1843////////////////////////////////////////////////////////////////////////////////; 1844/// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; 1845/// in other words it can find the roots of the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maxi",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:67257,Testability,log,logx,67257," 1812/// unimodal or if its extrema are far apart, setting the fNpx to; 1813/// a small value speeds the algorithm up many times.; 1814/// Then, Brent's method is applied on the bracketed interval; 1815/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1816/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1817/// of iteration of the Brent algorithm; 1818/// If the flag logx is set the grid search is done in log step size; 1819/// This is done automatically if the log scale is set in the current Pad; 1820///; 1821/// NOTE: see also TF1::GetX; 1822 ; 1823Double_t TF1::GetMinimumX(Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1824{; 1825 if (xmin >= xmax) {; 1826 xmin = fXmin;; 1827 xmax = fXmax;; 1828 }; 1829 ; 1830 ROOT::Math::BrentMinimizer1D bm;; 1831 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1832 bm.SetFunction(wf1, xmin, xmax);; 1833 bm.SetNpx(fNpx);; 1834 bm.SetLogScan(logx);; 1835 bm.Minimize(maxiter, epsilon, epsilon);; 1836 Double_t x;; 1837 x = bm.XMinimum();; 1838 ; 1839 return x;; 1840}; 1841 ; 1842 ; 1843////////////////////////////////////////////////////////////////////////////////; 1844/// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; 1845/// in other words it can find the roots of the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:68419,Testability,log,logx,68419,"f the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:68458,Testability,log,log,68458,"f the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:68515,Testability,log,log,68515,"f the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:68733,Testability,log,logx,68733,"f the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:68844,Testability,log,logx,68844,"f the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:68869,Testability,log,logx,68869,"f the function when fy=0 and successive calls; 1846/// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; 1847///; 1848/// Method:; 1849/// First, the grid search is used to bracket the maximum; 1850/// with the step size = (xmax-xmin)/fNpx. This way, the step size; 1851/// can be controlled via the SetNpx() function. If the function is; 1852/// unimodal or if its extrema are far apart, setting the fNpx to; 1853/// a small value speeds the algorithm up many times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:69098,Testability,log,logx,69098," times.; 1854/// Then, Brent's method is applied on the bracketed interval; 1855/// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); 1856/// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; 1857/// of iteration of the Brent algorithm; 1858/// If the flag logx is set the grid search is done in log step size; 1859/// This is done automatically if the log scale is set in the current Pad; 1860///; 1861/// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX; 1862 ; 1863Double_t TF1::GetX(Double_t fy, Double_t xmin, Double_t xmax, Double_t epsilon, Int_t maxiter, Bool_t logx) const; 1864{; 1865 if (xmin >= xmax) {; 1866 xmin = fXmin;; 1867 xmax = fXmax;; 1868 }; 1869 ; 1870 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1871 ; 1872 GFunc g(this, fy);; 1873 ROOT::Math::WrappedFunction<GFunc> wf1(g);; 1874 ROOT::Math::BrentRootFinder brf;; 1875 brf.SetFunction(wf1, xmin, xmax);; 1876 brf.SetNpx(fNpx);; 1877 brf.SetLogScan(logx);; 1878 bool ret = brf.Solve(maxiter, epsilon, epsilon);; 1879 if (!ret) Error(""GetX"",""[%f,%f] is not a valid interval"",xmin,xmax);; 1880 return (ret) ? brf.Root() : TMath::QuietNaN();; 1881}; 1882 ; 1883////////////////////////////////////////////////////////////////////////////////; 1884/// Return the number of degrees of freedom in the fit; 1885/// the fNDF parameter has been previously computed during a fit.; 1886/// The number of degrees of freedom corresponds to the number of points; 1887/// used in the fit minus the number of free parameters.; 1888 ; 1889Int_t TF1::GetNDF() const; 1890{; 1891 Int_t npar = GetNpar();; 1892 if (fNDF == 0 && (fNpfits > npar)) return fNpfits - npar;; 1893 return fNDF;; 1894}; 1895 ; 1896 ; 1897////////////////////////////////////////////////////////////////////////////////; 1898/// Return the number of free parameters; 1899 ; 1900Int_t TF1::GetNumberFreeParameters() const; 1901{; 1902 Int_t ntot = GetNpar();; 1903 Int_t nfree = ntot;; 1904 Double_t al, ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:71393,Testability,assert,assert,71393,"Object::GetObjectInfo.; 1915/// Displays the function info (x, function value); 1916/// corresponding to cursor position px,py; 1917 ; 1918char *TF1::GetObjectInfo(Int_t px, Int_t /* py */) const; 1919{; 1920 static char info[64];; 1921 Double_t x = gPad->PadtoX(gPad->AbsPixeltoX(px));; 1922 snprintf(info, 64, ""(x=%g, f=%g)"", x, ((TF1 *)this)->Eval(x));; 1923 return info;; 1924}; 1925 ; 1926 ; 1927////////////////////////////////////////////////////////////////////////////////; 1928/// Return value of parameter number ipar; 1929 ; 1930Double_t TF1::GetParError(Int_t ipar) const; 1931{; 1932 if (ipar < 0 || ipar > GetNpar() - 1) return 0;; 1933 return fParErrors[ipar];; 1934}; 1935 ; 1936 ; 1937////////////////////////////////////////////////////////////////////////////////; 1938/// Return limits for parameter ipar.; 1939 ; 1940void TF1::GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) const; 1941{; 1942 parmin = 0;; 1943 parmax = 0;; 1944 int n = fParMin.size();; 1945 assert(n == int(fParMax.size()) && n <= fNpar);; 1946 if (ipar < 0 || ipar > n - 1) return;; 1947 parmin = fParMin[ipar];; 1948 parmax = fParMax[ipar];; 1949}; 1950 ; 1951 ; 1952////////////////////////////////////////////////////////////////////////////////; 1953/// Return the fit probability; 1954 ; 1955Double_t TF1::GetProb() const; 1956{; 1957 if (fNDF <= 0) return 0;; 1958 return TMath::Prob(fChisquare, fNDF);; 1959}; 1960 ; 1961 ; 1962////////////////////////////////////////////////////////////////////////////////; 1963/// Compute Quantiles for density distribution of this function; 1964///; 1965/// Quantile x_p of a probability distribution Function F is defined as; 1966/// \f[; 1967/// F(x_{p}) = \int_{xmin}^{x_{p}} f dx = p with 0 <= p <= 1.; 1968/// \f]; 1969/// For instance the median \f$ x_{\frac{1}{2}} \f$ of a distribution is defined as that value; 1970/// of the random variable for which the distribution function equals 0.5:; 1971/// \f[; 1972/// F(x_{\frac{1}{2}}) = \prod(x ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:76400,Testability,log,log,76400,"inue;; 2053 }; 2054 // LM use a tolerance 1.E-12 (integral precision); 2055 while (bin < npx - 1 && TMath::AreEqualRel(integral[bin + 1], r, 1E-12)) {; 2056 if (TMath::AreEqualRel(integral[bin + 2], r, 1E-12)) bin++;; 2057 else break;; 2058 }; 2059 ; 2060 const Double_t rr = r - integral[bin];; 2061 if (rr != 0.0) {; 2062 Double_t xx = 0.0;; 2063 const Double_t fac = -2.*gamma[bin] * rr / beta[bin] / beta[bin];; 2064 if (fac != 0 && fac <= 1); 2065 xx = (-beta[bin] + TMath::Sqrt(beta[bin] * beta[bin] + 2 * gamma[bin] * rr)) / gamma[bin];; 2066 else if (beta[bin] != 0.); 2067 xx = rr / beta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", f",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:76421,Testability,log,log,76421,"inue;; 2053 }; 2054 // LM use a tolerance 1.E-12 (integral precision); 2055 while (bin < npx - 1 && TMath::AreEqualRel(integral[bin + 1], r, 1E-12)) {; 2056 if (TMath::AreEqualRel(integral[bin + 2], r, 1E-12)) bin++;; 2057 else break;; 2058 }; 2059 ; 2060 const Double_t rr = r - integral[bin];; 2061 if (rr != 0.0) {; 2062 Double_t xx = 0.0;; 2063 const Double_t fac = -2.*gamma[bin] * rr / beta[bin] / beta[bin];; 2064 if (fac != 0 && fac <= 1); 2065 xx = (-beta[bin] + TMath::Sqrt(beta[bin] * beta[bin] + 2 * gamma[bin] * rr)) / gamma[bin];; 2066 else if (beta[bin] != 0.); 2067 xx = rr / beta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", f",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:76781,Testability,log,logbin,76781,"le_t fac = -2.*gamma[bin] * rr / beta[bin] / beta[bin];; 2064 if (fac != 0 && fac <= 1); 2065 xx = (-beta[bin] + TMath::Sqrt(beta[bin] * beta[bin] + 2 * gamma[bin] * rr)) / gamma[bin];; 2066 else if (beta[bin] != 0.); 2067 xx = rr / beta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:76942,Testability,log,log,76942,"eta[bin];; 2068 xp[i] = alpha[bin] + xx;; 2069 } else {; 2070 xp[i] = alpha[bin];; 2071 if (integral[bin + 1] == r) xp[i] += dx;; 2072 }; 2073 }; 2074 ; 2075 return n;; 2076}; 2077////////////////////////////////////////////////////////////////////////////////; 2078///; 2079/// Compute the cumulative function at fNpx points between fXmin and fXmax.; 2080/// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRand",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:77195,Testability,log,logbin,77195,"ic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRandom"", ""function:%s has %d negative values: abs assumed"", GetName(), intNegative);; 2129 }; 2130 if (fIntegral[fNpx] == 0) {; 2131 Error(""GetRandom"", ""Integral of function is zero"");; 2132 return kFALSE;; 2133 }; 2134 Double_t total = fIntegral[fNpx];; 2135 for (i = 1; i <= fNpx; i++) { // normalize integral to 1; 2136 fIntegral[i] /= total;; 2137 }; 2138 // the integral r for each bin is approximated by a parabola; 2139 // x = alpha + beta*r +gamma*r",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:77350,Testability,log,log,77350,"ic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRandom"", ""function:%s has %d negative values: abs assumed"", GetName(), intNegative);; 2129 }; 2130 if (fIntegral[fNpx] == 0) {; 2131 Error(""GetRandom"", ""Integral of function is zero"");; 2132 return kFALSE;; 2133 }; 2134 Double_t total = fIntegral[fNpx];; 2135 for (i = 1; i <= fNpx; i++) { // normalize integral to 1; 2136 fIntegral[i] /= total;; 2137 }; 2138 // the integral r for each bin is approximated by a parabola; 2139 // x = alpha + beta*r +gamma*r",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:77667,Testability,log,logbin,77667,"ic if empty.; 2081Bool_t TF1::ComputeCdfTable(Option_t * option) {; 2082 ; 2083 fIntegral.resize(fNpx + 1);; 2084 fAlpha.resize(fNpx + 1);; 2085 fBeta.resize(fNpx);; 2086 fGamma.resize(fNpx);; 2087 fIntegral[0] = 0;; 2088 fAlpha[fNpx] = 0;; 2089 Double_t integ;; 2090 Int_t intNegative = 0;; 2091 Int_t i;; 2092 Bool_t logbin = kFALSE;; 2093 Double_t dx;; 2094 Double_t xmin = fXmin;; 2095 Double_t xmax = fXmax;; 2096 TString opt(option);; 2097 opt.ToUpper();; 2098 // perform a log binning if specified by user (option=""Log"") or if some conditions are met; 2099 // and the user explicitly does not specify a Linear binning option; 2100 if (opt.Contains(""LOG"") || ((xmin > 0 && xmax / xmin > fNpx) && !opt.Contains(""LIN""))) {; 2101 logbin = kTRUE;; 2102 fAlpha[fNpx] = 1;; 2103 xmin = TMath::Log10(fXmin);; 2104 xmax = TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRandom"", ""function:%s has %d negative values: abs assumed"", GetName(), intNegative);; 2129 }; 2130 if (fIntegral[fNpx] == 0) {; 2131 Error(""GetRandom"", ""Integral of function is zero"");; 2132 return kFALSE;; 2133 }; 2134 Double_t total = fIntegral[fNpx];; 2135 for (i = 1; i <= fNpx; i++) { // normalize integral to 1; 2136 fIntegral[i] /= total;; 2137 }; 2138 // the integral r for each bin is approximated by a parabola; 2139 // x = alpha + beta*r +gamma*r",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:78671,Testability,log,logbin,78671," TMath::Log10(fXmax);; 2105 if (gDebug); 2106 Info(""GetRandom"", ""Use log scale for tabulating the integral in [%f,%f] with %d points"", fXmin, fXmax, fNpx);; 2107 }; 2108 dx = (xmax - xmin) / fNpx;; 2109 ; 2110 std::vector<Double_t> xx(fNpx + 1);; 2111 for (i = 0; i < fNpx; i++) {; 2112 xx[i] = xmin + i * dx;; 2113 }; 2114 xx[fNpx] = xmax;; 2115 for (i = 0; i < fNpx; i++) {; 2116 if (logbin) {; 2117 integ = Integral(TMath::Power(10, xx[i]), TMath::Power(10, xx[i + 1]), 0.0);; 2118 } else {; 2119 integ = Integral(xx[i], xx[i + 1], 0.0);; 2120 }; 2121 if (integ < 0) {; 2122 intNegative++;; 2123 integ = -integ;; 2124 }; 2125 fIntegral[i + 1] = fIntegral[i] + integ;; 2126 }; 2127 if (intNegative > 0) {; 2128 Warning(""GetRandom"", ""function:%s has %d negative values: abs assumed"", GetName(), intNegative);; 2129 }; 2130 if (fIntegral[fNpx] == 0) {; 2131 Error(""GetRandom"", ""Integral of function is zero"");; 2132 return kFALSE;; 2133 }; 2134 Double_t total = fIntegral[fNpx];; 2135 for (i = 1; i <= fNpx; i++) { // normalize integral to 1; 2136 fIntegral[i] /= total;; 2137 }; 2138 // the integral r for each bin is approximated by a parabola; 2139 // x = alpha + beta*r +gamma*r**2; 2140 // compute the coefficients alpha, beta, gamma for each bin; 2141 Double_t x0, r1, r2, r3;; 2142 for (i = 0; i < fNpx; i++) {; 2143 x0 = xx[i];; 2144 r2 = fIntegral[i + 1] - fIntegral[i];; 2145 if (logbin); 2146 r1 = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number ge",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:79602,Testability,log,log,79602," = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; 2165/// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; 2166/// xmax, xmin and Npx (function points).; 2167/// Possible values are:; 2168/// - ""LOG"" to force usage of log scale for tabulating the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never d",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:80494,Testability,log,log,80494,"ting the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; 2187/// whatever the fXmax/fXmin ratio is; 2188///; 2189/// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.; 2190 ; 2191 ; 2192Double_t TF1::GetRandom(TRandom * rng, Option_t * option); 2193{; 2194 // Check if integral array must be built; 2195 if (fIntegral.empty()) {; 2196 Bool_t ret = ComputeCdfTable(option);; 2197 if (!ret) return TMath::QuietNaN();; 2198 }; 2199 ; 2200 ; 2201 // return random number; 2202 Double_t r = (rng) ? rng->Rndm() : gRandom->Rndm();; 2203 Int_t bin = TMath::BinarySearch(fNpx, fIntegral.data(), r);; 2204 Double_t rr = r - fIntegral[bin];; 2205 ; 2206 Double_t yy;; 2207 if (fGamma[bin] != 0); 2208 yy = (-fBeta[bin] + TMath::Sqrt(fBeta[bin] * fBeta[bin] + 2 * fGamma[bin] * rr)) / fGamma[bin];; 2209 else; 2210 yy = rr / fBeta[bin];; 2211 Double_t x = fAlpha[bin] + yy;; 2212 if (fAlpha[fNpx] > 0) return TMath::Power(10, x);; 22",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:80520,Testability,log,log,80520,"ting the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; 2187/// whatever the fXmax/fXmin ratio is; 2188///; 2189/// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.; 2190 ; 2191 ; 2192Double_t TF1::GetRandom(TRandom * rng, Option_t * option); 2193{; 2194 // Check if integral array must be built; 2195 if (fIntegral.empty()) {; 2196 Bool_t ret = ComputeCdfTable(option);; 2197 if (!ret) return TMath::QuietNaN();; 2198 }; 2199 ; 2200 ; 2201 // return random number; 2202 Double_t r = (rng) ? rng->Rndm() : gRandom->Rndm();; 2203 Int_t bin = TMath::BinarySearch(fNpx, fIntegral.data(), r);; 2204 Double_t rr = r - fIntegral[bin];; 2205 ; 2206 Double_t yy;; 2207 if (fGamma[bin] != 0); 2208 yy = (-fBeta[bin] + TMath::Sqrt(fBeta[bin] * fBeta[bin] + 2 * fGamma[bin] * rr)) / fGamma[bin];; 2209 else; 2210 yy = rr / fBeta[bin];; 2211 Double_t x = fAlpha[bin] + yy;; 2212 if (fAlpha[fNpx] > 0) return TMath::Power(10, x);; 22",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:80695,Testability,log,log,80695,"ting the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; 2187/// whatever the fXmax/fXmin ratio is; 2188///; 2189/// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.; 2190 ; 2191 ; 2192Double_t TF1::GetRandom(TRandom * rng, Option_t * option); 2193{; 2194 // Check if integral array must be built; 2195 if (fIntegral.empty()) {; 2196 Bool_t ret = ComputeCdfTable(option);; 2197 if (!ret) return TMath::QuietNaN();; 2198 }; 2199 ; 2200 ; 2201 // return random number; 2202 Double_t r = (rng) ? rng->Rndm() : gRandom->Rndm();; 2203 Int_t bin = TMath::BinarySearch(fNpx, fIntegral.data(), r);; 2204 Double_t rr = r - fIntegral[bin];; 2205 ; 2206 Double_t yy;; 2207 if (fGamma[bin] != 0); 2208 yy = (-fBeta[bin] + TMath::Sqrt(fBeta[bin] * fBeta[bin] + 2 * fGamma[bin] * rr)) / fGamma[bin];; 2209 else; 2210 yy = rr / fBeta[bin];; 2211 Double_t x = fAlpha[bin] + yy;; 2212 if (fAlpha[fNpx] > 0) return TMath::Power(10, x);; 22",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:82795,Testability,log,log,82795," 2218/// Return a random number following this function shape in [xmin,xmax]; 2219///; 2220/// The distribution contained in the function fname (TF1) is integrated; 2221/// over the channel contents.; 2222/// It is normalized to 1.; 2223/// For each bin the integral is approximated by a parabola.; 2224/// The parabola coefficients are stored as non persistent data members; 2225/// Getting one random number implies:; 2226/// - Generating a random number between 0 and 1 (say r1); 2227/// - Look in which bin in the normalized integral r1 corresponds to; 2228/// - Evaluate the parabolic curve in the selected bin to find; 2229/// the corresponding X value.; 2230///; 2231/// The parabolic approximation is very good as soon as the number; 2232/// of bins is greater than 50.; 2233///; 2234/// @param xmin minimum value for generated random numbers; 2235/// @param xmax maximum value for generated random numbers; 2236/// @param rng (optional) random number generator pointer; 2237/// @param option (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table; 2238///; 2239/// IMPORTANT NOTE; 2240///; 2241/// The integral of the function is computed at fNpx points. If the function; 2242/// has sharp peaks, you should increase the number of points (SetNpx); 2243/// such that the peak is correctly tabulated at several points.; 2244 ; 2245Double_t TF1::GetRandom(Double_t xmin, Double_t xmax, TRandom * rng, Option_t * option); 2246{; 2247 // Check if integral array must be built; 2248 if (fIntegral.empty()) {; 2249 Bool_t ret = ComputeCdfTable(option);; 2250 if (!ret) return TMath::QuietNaN();; 2251 }; 2252 ; 2253 // return random number; 2254 Double_t dx = (fXmax - fXmin) / fNpx;; 2255 Int_t nbinmin = (Int_t)((xmin - fXmin) / dx);; 2256 Int_t nbinmax = (Int_t)((xmax - fXmin) / dx) + 2;; 2257 if (nbinmax > fNpx) nbinmax = fNpx;; 2258 ; 2259 Double_t pmin = fIntegral[nbinmin];; 2260 Double_t pmax = fIntegral[nbinmax];; 2261 ; 2262 ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:110967,Testability,assert,assert,110967,", epsrel, maxpts);; 2868 result = imd.Integral(a, b);; 2869 relerr = (result != 0) ? imd.Error() / std::abs(result) : imd.Error();; 2870 nfnevl = 0;; 2871 ifail = imd.Status();; 2872 }; 2873 ; 2874 ; 2875 return result;; 2876}; 2877 ; 2878 ; 2879////////////////////////////////////////////////////////////////////////////////; 2880/// Return kTRUE if the function is valid; 2881 ; 2882Bool_t TF1::IsValid() const; 2883{; 2884 if (fFormula) return fFormula->IsValid();; 2885 if (fMethodCall) return fMethodCall->IsValid();; 2886 // function built on compiled functors are always valid by definition; 2887 // (checked at compiled time); 2888 // invalid is a TF1 where the functor is null pointer and has not been saved; 2889 if (!fFunctor && fSave.empty()) return kFALSE;; 2890 return kTRUE;; 2891}; 2892 ; 2893 ; 2894//______________________________________________________________________________; 2895 ; 2896 ; 2897void TF1::Print(Option_t *option) const; 2898{; 2899 if (fType == EFType::kFormula) {; 2900 printf(""Formula based function: %s \n"", GetName());; 2901 assert(fFormula);; 2902 fFormula->Print(option);; 2903 } else if (fType > 0) {; 2904 if (fType == EFType::kInterpreted); 2905 printf(""Interpreted based function: %s(double *x, double *p). Ndim = %d, Npar = %d \n"", GetName(), GetNdim(),; 2906 GetNpar());; 2907 else if (fType == EFType::kCompositionFcn) {; 2908 printf(""Composition based function: %s. Ndim = %d, Npar = %d \n"", GetName(), GetNdim(), GetNpar());; 2909 if (!fComposition); 2910 printf(""fComposition not found!\n""); // this would be bad; 2911 } else {; 2912 if (fFunctor); 2913 printf(""Compiled based function: %s based on a functor object. Ndim = %d, Npar = %d\n"", GetName(),; 2914 GetNdim(), GetNpar());; 2915 else {; 2916 printf(""Function based on a list of points from a compiled based function: %s. Ndim = %d, Npar = %d, Npx ""; 2917 ""= %zu\n"",; 2918 GetName(), GetNdim(), GetNpar(), fSave.size());; 2919 if (fSave.empty()); 2920 Warning(""Print"", ""Function %s is base",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:114687,Testability,log,log,114687,"etUxmax());; 2972 }; 2973 if (optSAME.Length()) {; 2974 // Completely outside; 2975 if (xmax < pmin) return;; 2976 if (xmin > pmax) return;; 2977 }; 2978 ; 2979 // create an histogram using the function content (re-use it if already existing); 2980 fHistogram = DoCreateHistogram(xmin, xmax, kFALSE);; 2981 ; 2982 auto is_pfc = opt0.Index(""PFC""); // Automatic Fill Color; 2983 auto is_plc = opt0.Index(""PLC""); // Automatic Line Color; 2984 auto is_pmc = opt0.Index(""PMC""); // Automatic Marker Color; 2985 if (is_pfc != kNPOS || is_plc != kNPOS || is_pmc != kNPOS) {; 2986 Int_t i = gPad->NextPaletteColor();; 2987 if (is_pfc != kNPOS) { opt0.Replace(is_pfc, 3, "" ""); fHistogram->SetFillColor(i); }; 2988 if (is_plc != kNPOS) { opt0.Replace(is_plc, 3, "" ""); fHistogram->SetLineColor(i); }; 2989 if (is_pmc != kNPOS) { opt0.Replace(is_pmc, 3, "" ""); fHistogram->SetMarkerColor(i); }; 2990 }; 2991 ; 2992 // set the optimal minimum and maximum; 2993 Double_t minimum = fHistogram->GetMinimumStored();; 2994 Double_t maximum = fHistogram->GetMaximumStored();; 2995 if (minimum <= 0 && gPad && gPad->GetLogy()) minimum = -1111; // This can happen when switching from lin to log scale.; 2996 if (gPad && gPad->GetUymin() < fHistogram->GetMinimum() &&; 2997 !fHistogram->TestBit(TH1::kIsZoomed)) minimum = -1111; // This can happen after unzooming a fit.; 2998 if (minimum == -1111) { // This can happen after unzooming.; 2999 if (fHistogram->TestBit(TH1::kIsZoomed)) {; 3000 minimum = fHistogram->GetYaxis()->GetXmin();; 3001 } else {; 3002 minimum = fMinimum;; 3003 // Optimize the computation of the scale in Y in case the min/max of the; 3004 // function oscillate around a constant value; 3005 if (minimum == -1111) {; 3006 Double_t hmin;; 3007 if (optSAME.Length() && gPad) hmin = gPad->GetUymin();; 3008 else hmin = fHistogram->GetMinimum();; 3009 if (hmin > 0) {; 3010 Double_t hmax;; 3011 Double_t hminpos = hmin;; 3012 if (optSAME.Length() && gPad) hmax = gPad->GetUymax();; 3013 else hmax = fHisto",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:117940,Testability,log,logx,117940,"gram->Paint(optSAME.Data());; 3037 } else {; 3038 fHistogram->Paint(opt0.Data());; 3039 }; 3040}; 3041 ; 3042////////////////////////////////////////////////////////////////////////////////; 3043/// Create histogram with bin content equal to function value; 3044/// computed at the bin center; 3045/// This histogram will be used to paint the function; 3046/// A re-creation is forced and a new histogram is done if recreate=true; 3047 ; 3048TH1 *TF1::DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate); 3049{; 3050 Int_t i;; 3051 Double_t xv[1];; 3052 ; 3053 TH1 *histogram = nullptr;; 3054 ; 3055 ; 3056 // Create a temporary histogram and fill each channel with the function value; 3057 // Preserve axis titles; 3058 TString xtitle = """";; 3059 TString ytitle = """";; 3060 char *semicol = (char *)strstr(GetTitle(), "";"");; 3061 if (semicol) {; 3062 Int_t nxt = strlen(semicol);; 3063 char *ctemp = new char[nxt];; 3064 strlcpy(ctemp, semicol + 1, nxt);; 3065 semicol = (char *)strstr(ctemp, "";"");; 3066 if (semicol) {; 3067 *semicol = 0;; 3068 ytitle = semicol + 1;; 3069 }; 3070 xtitle = ctemp;; 3071 delete [] ctemp;; 3072 }; 3073 if (fHistogram) {; 3074 // delete previous histograms if were done if done in different mode; 3075 xtitle = fHistogram->GetXaxis()->GetTitle();; 3076 ytitle = fHistogram->GetYaxis()->GetTitle();; 3077 Bool_t test_logx = fHistogram->TestBit(TH1::kLogX);; 3078 if (!gPad->GetLogx() && test_logx) {; 3079 delete fHistogram;; 3080 fHistogram = nullptr;; 3081 recreate = kTRUE;; 3082 }; 3083 if (gPad->GetLogx() && !test_logx) {; 3084 delete fHistogram;; 3085 fHistogram = nullptr;; 3086 recreate = kTRUE;; 3087 }; 3088 }; 3089 ; 3090 if (fHistogram && !recreate) {; 3091 histogram = fHistogram;; 3092 fHistogram->GetXaxis()->SetLimits(xmin, xmax);; 3093 } else {; 3094 // If logx, we must bin in logx and not in x; 3095 // otherwise in case of several decades, one gets wrong results.; 3096 if (xmin > 0 && gPad && gPad->GetLogx()) {; 3097 Double_t *xbins =",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:117961,Testability,log,logx,117961,"gram->Paint(optSAME.Data());; 3037 } else {; 3038 fHistogram->Paint(opt0.Data());; 3039 }; 3040}; 3041 ; 3042////////////////////////////////////////////////////////////////////////////////; 3043/// Create histogram with bin content equal to function value; 3044/// computed at the bin center; 3045/// This histogram will be used to paint the function; 3046/// A re-creation is forced and a new histogram is done if recreate=true; 3047 ; 3048TH1 *TF1::DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate); 3049{; 3050 Int_t i;; 3051 Double_t xv[1];; 3052 ; 3053 TH1 *histogram = nullptr;; 3054 ; 3055 ; 3056 // Create a temporary histogram and fill each channel with the function value; 3057 // Preserve axis titles; 3058 TString xtitle = """";; 3059 TString ytitle = """";; 3060 char *semicol = (char *)strstr(GetTitle(), "";"");; 3061 if (semicol) {; 3062 Int_t nxt = strlen(semicol);; 3063 char *ctemp = new char[nxt];; 3064 strlcpy(ctemp, semicol + 1, nxt);; 3065 semicol = (char *)strstr(ctemp, "";"");; 3066 if (semicol) {; 3067 *semicol = 0;; 3068 ytitle = semicol + 1;; 3069 }; 3070 xtitle = ctemp;; 3071 delete [] ctemp;; 3072 }; 3073 if (fHistogram) {; 3074 // delete previous histograms if were done if done in different mode; 3075 xtitle = fHistogram->GetXaxis()->GetTitle();; 3076 ytitle = fHistogram->GetYaxis()->GetTitle();; 3077 Bool_t test_logx = fHistogram->TestBit(TH1::kLogX);; 3078 if (!gPad->GetLogx() && test_logx) {; 3079 delete fHistogram;; 3080 fHistogram = nullptr;; 3081 recreate = kTRUE;; 3082 }; 3083 if (gPad->GetLogx() && !test_logx) {; 3084 delete fHistogram;; 3085 fHistogram = nullptr;; 3086 recreate = kTRUE;; 3087 }; 3088 }; 3089 ; 3090 if (fHistogram && !recreate) {; 3091 histogram = fHistogram;; 3092 fHistogram->GetXaxis()->SetLimits(xmin, xmax);; 3093 } else {; 3094 // If logx, we must bin in logx and not in x; 3095 // otherwise in case of several decades, one gets wrong results.; 3096 if (xmin > 0 && gPad && gPad->GetLogx()) {; 3097 Double_t *xbins =",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:140235,Testability,test,tested,140235,"fset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; 3683void TF1::RejectPoint(Bool_t reject); 3684{; 3685 fgRejectPoint = reject;; 3686}; 3687 ; 3688 ; 3689////////////////////////////////////////////////////////////////////////////////; 3690/// See TF1::RejectPoint above; 3691 ; 3692Bool_t TF1::RejectedPoint(); 3693{; 3694 return fgRejectPoint;; 3695}; 3696 ; 3697////////////////////////////////////////////////////////////////////////////////; 3698/// Return nth moment of function between a and b; 3699///; 3700/// See TF1::Integral() for parameter definitions; 3701 ; 3702Double_t TF1::Moment(Double_t ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:155628,Testability,log,log,155628,"r of function evaluations in calculating the integralDefinition AdaptiveIntegratorMultiDim.h:152; ROOT::Math::AdaptiveIntegratorMultiDim::RelErrordouble RelError() constreturn relative errorDefinition AdaptiveIntegratorMultiDim.h:137; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentMinimizer1D.h:122; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; ROOT::Math::BrentMinimizer1D::FValMinimumdouble FValMinimum() const overrideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Math::BrentRootFinderClass for finding the root of a one dimensional function using the Brent algorithm.Definition BrentRootFinder.h:51; ROOT::Math::BrentRootFinder::SetFunctionbool SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup) overrideSets the function for the rest of the algorithms.Definition BrentRootFinder.cxx:42; ROOT::Math::BrentRootFinder::Solvebool Solve(int maxIter=100, double absTol=1E-8, double relTol=1E-10) overrideReturns the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFin",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:156965,Testability,log,log,156965,"errideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Math::BrentRootFinderClass for finding the root of a one dimensional function using the Brent algorithm.Definition BrentRootFinder.h:51; ROOT::Math::BrentRootFinder::SetFunctionbool SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup) overrideSets the function for the rest of the algorithms.Definition BrentRootFinder.cxx:42; ROOT::Math::BrentRootFinder::Solvebool Solve(int maxIter=100, double absTol=1E-8, double relTol=1E-10) overrideReturns the X value corresponding to the function value fy for (xmin<x<xmax).Definition BrentRootFinder.cxx:66; ROOT::Math::BrentRootFinder::Rootdouble Root() const overrideReturns root value.Definition BrentRootFinder.h:98; ROOT::Math::BrentRootFinder::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentRootFinder.h:89; ROOT::Math::BrentRootFinder::SetLogScanvoid SetLogScan(bool on)Set a log grid scan (default is equidistant bins) will work only if xlow > 0.Definition BrentRootFinder.h:95; ROOT::Math::ChebyshevPolDefinition ChebyshevPol.h:129; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::Functor1DFunctor1D class for one-dimensional functions.Definition Functor.h:95; ROOT::Math::GaussIntegratorUser class for performing function integration.Definition GaussIntegrator.h:40; ROOT::Math::GaussIntegrator::Errordouble Error() const overrideReturn the estimate of the absolute Error of the last Integral calculation.Definition GaussIntegrator.cxx:176; ROOT::Math::GaussIntegrator::SetRelTolerancevoid SetRelTolerance(double eps) overrideSet the desired relative Error.Definition GaussIntegrator.h:65; ROOT::Math::GaussIntegrator::Integr",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:173876,Testability,log,logx,173876," TF1_EvalWrapper::fXDouble_t fX[1]Definition TF1.cxx:231; TF1_EvalWrapper::EvalFirstMomDouble_t EvalFirstMom(Double_t x)Definition TF1.cxx:218; TF1_EvalWrapper::fFuncTF1 * fFuncDefinition TF1.cxx:230; TF1_EvalWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition TF1.cxx:209; TF1_EvalWrapper::EvalNMomDouble_t EvalNMom(Double_t x) constDefinition TF1.cxx:224; TF1_EvalWrapper::TF1_EvalWrapperTF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n=1, Double_t x0=0)Definition TF1.cxx:190; TF1_EvalWrapper::fAbsValBool_t fAbsValDefinition TF1.cxx:233; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAdd",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:174133,Testability,log,logx,174133,") const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition TF1.cxx:209; TF1_EvalWrapper::EvalNMomDouble_t EvalNMom(Double_t x) constDefinition TF1.cxx:224; TF1_EvalWrapper::TF1_EvalWrapperTF1_EvalWrapper(TF1 *f, const Double_t *par, bool useAbsVal, Double_t n=1, Double_t x0=0)Definition TF1.cxx:190; TF1_EvalWrapper::fAbsValBool_t fAbsValDefinition TF1.cxx:233; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.c",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:174730,Testability,test,tested,174730,"rPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:185913,Testability,log,logx,185913,".cxx:2281; TF1::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TF1.cxx:993; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::~TF1~TF1() overrideTF1 default destructor.Definition TF1.cxx:953; TF1::fgCurrentstatic TF1 * fgCurrentDefinition TF1.h:327; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::DoInitializevoid DoInitialize(EAddToList addToGlobList)Common initialization of the TF1.Definition TF1.cxx:802; TF1::GetXvirtual Double_t GetX(Double_t y, Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the function value fy for (xmin<x<xmax).Definition TF1.cxx:1863; TF1::GetCurrentstatic TF1 * GetCurrent()Static function returning the current function being processed.Definition TF1.cxx:1569; TF1::SetParNamevirtual void SetParName(Int_t ipar, const char *name)Set name of parameter number ipar.Definition TF1.cxx:3450; TF1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TF1.cxx:1918; TF1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TF1.cxx:1536; TF1::GetSavevirtual Double_t GetSave(const Double_t *x)Get value corresponding to X in array of fSave values.Definition TF1.cxx:2344; TF1::fgAbsValuestatic std::atomic< Bool_t > fgAbsValueDefinition TF1.h:324; TF1::TF1TF1()TF1 default constructor.Definition TF1.cxx:489; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attr",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:189390,Testability,log,logx,189390,"uble_t xmin, Double_t xmax, Option_t *option="""")Draw function between xmin and xmax.Definition TF1.cxx:1420; TF1::ComputeCdfTableBool_t ComputeCdfTable(Option_t *opt)Compute the cumulative function at fNpx points between fXmin and fXmax.Definition TF1.cxx:2081; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::DrawIntegralvirtual TObject * DrawIntegral(Option_t *option=""al"")Draw integral of this function.Definition TF1.cxx:1407; TF1::fIntegralstd::vector< Double_t > fIntegral! Integral of function binned on fNpx binsDefinition TF1.h:278; TF1::DrawDerivativevirtual TObject * DrawDerivative(Option_t *option=""al"")Draw derivative of this function.Definition TF1.cxx:1385; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF1::fParamsstd::unique_ptr< TF1Parameters > fParamsPointer to Function parameters object (exists only for not-formula functions)Definition TF1.h:289; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF1::Derivative3virtual Double_t Derivative3(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the third derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1243; TF1::Savevirtual void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax)Save values of function in array fSave.Definition TF1.cxx:3161; TF1::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a complete copy of the underlying object.Definition TF1.cxx:1064; TF1::EFTypeEFTypeDefinition TF1.h:254; TF1::kCompositionFcn@ kCompositionFcnDefinition TF1.h:260; TF1::kFormula@ kFormulaForm",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:191436,Testability,log,logx,191436,"::kPtrScalarFreeFcn@ kPtrScalarFreeFcnPointer to scalar free function,.Definition TF1.h:256; TF1::kTemplScalar@ kTemplScalarTemplScalar functors evaluating on scalar parameters.Definition TF1.h:259; TF1::kTemplVec@ kTemplVecVectorized free functions or TemplScalar functors evaluating on vectorized parameters,...Definition TF1.h:258; TF1::kInterpreted@ kInterpretedInterpreted functions constructed by name,.Definition TF1.h:257; TF1::SetSavedPointvirtual void SetSavedPoint(Int_t point, Double_t value)Restore value of function saved at point.Definition TF1.cxx:3542; TF1::FixParametervirtual void FixParameter(Int_t ipar, Double_t value)Fix the value of a parameter for a fit operation The specified value will be used in the fit and the ...Definition TF1.cxx:1557; TF1::fXmaxDouble_t fXmaxUpper bounds for the range.Definition TF1.h:264; TF1::GetMaximumXvirtual Double_t GetMaximumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the maximum value of the function.Definition TF1.cxx:1655; TF1::IsATClass * IsA() const overrideDefinition TF1.h:755; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TF1::GetXminvirtual Double_t GetXmin() constDefinition TF1.h:580; TF1::AddToGlobalListvirtual Bool_t AddToGlobalList(Bool_t on=kTRUE)Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the fu...Definition TF1.cxx:847; TF1::IntegralOneDimvirtual Double_t IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)Return Integral of function between a and b using the given parameter values and relative and absolut...Definition TF1.cxx:2621; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF1::GetParNumbervirtual Int_t GetParNumber(const char *name) constDefinition TF1.h:561; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullpt",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:193930,Testability,log,log,193930,"npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetMinimumStoredvirtual Double_t GetMinimumStored() constDefinition TH1.h:293; TH1::Classstatic TClass * Class(); TH1::kLogX@ kLogXX-axis in log scale.Definition TH1.h:168; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::kIsZoomed@ kIsZoomedBit set when zooming on Y axis.Definition TH1.h:169; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Printvoid Print(Option_t *option="""") const overridePrint some global quantities for this histogram.Definition TH1.cxx:7009; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:202042,Testability,log,logarithm,202042,"ax(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec)Comparing floating points.Definition TMath.h:426; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; formula1Definition formula1.py:1; v@ vDefinition rootcling_impl.cxx:3699; ROOT::v5::TF1DataDefinition TF1Data.h:37; ROOT::v5::TF1Data::fParMinDouble_t * fParMinDefinition TF1Data.h:48; ROOT::v5::TF1Data::fNsaveInt_t fNsaveDefinition TF1Data.h:45; ROOT::v5::TF1Data::fSaveDouble_t * fSaveDefinition TF1Data.h:50; ROOT::v5::TF1Data::Streamervoid Streamer(TBuffer &b, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class=nullptr)specialized streamer function being able to read old TF1 versions as TF1Data in memoryDefinition TF1Data_v5.cxx:81; ROOT::v5::TF1Data::fNpxInt_t fNpxDefinition TF1Data.h:41; ROOT::v5::TF1Data::fXminDouble_t fXminDefinition TF1Data.h:39; ROOT::v5::TF1Data::fNpfitsInt_t ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:7483,Usability,simpl,simple,7483,"rameters (i.e. pass zero); 212 fX[0] = x;; 213 Double_t fval = fFunc->EvalPar(fX, nullptr);; 214 if (fAbsVal && fval < 0) return -fval;; 215 return fval;; 216 }; 217 // evaluate x * |f(x)|; 218 Double_t EvalFirstMom(Double_t x); 219 {; 220 fX[0] = x;; 221 return fX[0] * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 222 }; 223 // evaluate (x - x0) ^n * f(x); 224 Double_t EvalNMom(Double_t x) const; 225 {; 226 fX[0] = x;; 227 return TMath::Power(fX[0] - fX0, fN) * TMath::Abs(fFunc->EvalPar(fX, nullptr));; 228 }; 229 ; 230 TF1 *fFunc;; 231 mutable Double_t fX[1];; 232 const double *fPar;; 233 Bool_t fAbsVal;; 234 Double_t fN;; 235 Double_t fX0;; 236};; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/** \class TF1; 240 \ingroup Functions; 241 \brief 1-Dim function class; 242 ; 243 ; 244## TF1: 1-Dim function class; 245 ; 246A TF1 object is a 1-Dim function defined between a lower and upper limit.; 247The function may be a simple function based on a TFormula expression or a precompiled user function.; 248The function may have associated parameters.; 249TF1 graphics function is via the TH1 and TGraph drawing functions.; 250 ; 251The following types of functions can be created:; 252 ; 2531. [Expression using variable x and no parameters](\ref F1); 2542. [Expression using variable x with parameters](\ref F2); 2553. [Lambda Expression with variable x and parameters](\ref F3); 2564. [A general C function with parameters](\ref F4); 2575. [A general C++ function object (functor) with parameters](\ref F5); 2586. [A member function with parameters of a general C++ class](\ref F6); 259 ; 260 ; 261 ; 262\anchor F1; 263### 1 - Expression using variable x and no parameters; 264 ; 265#### Case 1: inline expression using standard C++ functions/operators; 266 ; 267Begin_Macro(source); 268{; 269 auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; 270 fa1->Draw();; 271}; 272End_Macro; 273 ; 274#### Case 2: inline expression using a ROOT function (e.g. fro",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:19029,Usability,simpl,simply,19029,"v = new TF1Convolution(function1, function2, xmin, xmax);; 558 ; 559 // (note: currently ignoring `useFFT` option); 560 fNpar = conv->GetNpar();; 561 fNdim = 1; // (note: may want to extend this in the future?); 562 ; 563 fType = EFType::kCompositionFcn;; 564 fComposition = std::unique_ptr<TF1AbsComposition>(conv);; 565 ; 566 fParams = std::make_unique<TF1Parameters>(fNpar); // default to zeros (TF1Convolution has no GetParameters()); 567 // set parameter names; 568 for (int i = 0; i < fNpar; i++); 569 this->SetParName(i, conv->GetParName(i));; 570 // set parameters to default values; 571 int f1Npar = function1->GetNpar();; 572 int f2Npar = function2->GetNpar();; 573 // first, copy parameters from function1; 574 for (int i = 0; i < f1Npar; i++); 575 this->SetParameter(i, function1->GetParameter(i));; 576 // then, check if the ""Constant"" parameters were combined; 577 // (this code assumes function2 has at most one parameter named ""Constant""); 578 if (conv->GetNpar() == f1Npar + f2Npar - 1) {; 579 int cst1 = function1->GetParNumber(""Constant"");; 580 int cst2 = function2->GetParNumber(""Constant"");; 581 this->SetParameter(cst1, function1->GetParameter(cst1) * function2->GetParameter(cst2));; 582 // and copy parameters from function2; 583 for (int i = 0; i < f2Npar; i++); 584 if (i < cst2); 585 this->SetParameter(f1Npar + i, function2->GetParameter(i));; 586 else if (i > cst2); 587 this->SetParameter(f1Npar + i - 1, function2->GetParameter(i));; 588 } else {; 589 // or if no constant, simply copy parameters from function2; 590 for (int i = 0; i < f2Npar; i++); 591 this->SetParameter(i + f1Npar, function2->GetParameter(i));; 592 }; 593 ; 594 // Then check if we need NSUM syntax:; 595 } else if (formulaLength > 5 && strncmp(formula, ""NSUM("", 5) == 0 && formula[formulaLength - 1] == ')') {; 596 // using comma as delimiter; 597 char delimiter = ',';; 598 // first, remove ""NSUM("" and "")"" and spaces; 599 TString formDense = TString(formula)(5,formulaLength-5-1);; 600 formDense.",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:120648,Usability,clear,clear,120648,";; 3142 ; 3143}; 3144 ; 3145 ; 3146////////////////////////////////////////////////////////////////////////////////; 3147/// Release parameter number ipar during a fit operation.; 3148/// After releasing it, the parameter; 3149/// can vary freely in the fit. The parameter limits are reset to 0,0.; 3150 ; 3151void TF1::ReleaseParameter(Int_t ipar); 3152{; 3153 if (ipar < 0 || ipar > GetNpar() - 1) return;; 3154 SetParLimits(ipar, 0, 0);; 3155}; 3156 ; 3157 ; 3158////////////////////////////////////////////////////////////////////////////////; 3159/// Save values of function in array fSave; 3160 ; 3161void TF1::Save(Double_t xmin, Double_t xmax, Double_t, Double_t, Double_t, Double_t); 3162{; 3163 if (!fSave.empty()); 3164 fSave.clear();; 3165 ; 3166 Double_t *parameters = GetParameters();; 3167 //if (fSave != 0) {delete [] fSave; fSave = 0;}; 3168 if (fParent && fParent->InheritsFrom(TH1::Class())) {; 3169 //if parent is a histogram save the function at the center of the bins; 3170 if ((xmin > 0 && xmax > 0) && TMath::Abs(TMath::Log10(xmax / xmin) > TMath::Log10(fNpx))) {; 3171 TH1 *h = (TH1 *)fParent;; 3172 Int_t bin1 = h->GetXaxis()->FindBin(xmin);; 3173 Int_t bin2 = h->GetXaxis()->FindBin(xmax);; 3174 int nsave = bin2 - bin1 + 4;; 3175 fSave.resize(nsave);; 3176 Double_t xv[1];; 3177 ; 3178 InitArgs(xv, parameters);; 3179 for (Int_t i = bin1; i <= bin2; i++) {; 3180 xv[0] = h->GetXaxis()->GetBinCenter(i);; 3181 fSave[i - bin1] = EvalPar(xv, parameters);; 3182 }; 3183 fSave[nsave - 3] = xmin;; 3184 fSave[nsave - 2] = xmax;; 3185 fSave[nsave - 1] = xmax;; 3186 return;; 3187 }; 3188 }; 3189 ; 3190 Int_t npx = fNpx;; 3191 if (npx <= 0); 3192 return;; 3193 ; 3194 Double_t dx = (xmax - xmin) / fNpx;; 3195 if (dx <= 0) {; 3196 dx = (fXmax - fXmin) / fNpx;; 3197 npx--;; 3198 xmin = fXmin + 0.5 * dx;; 3199 xmax = fXmax - 0.5 * dx;; 3200 }; 3201 if (npx <= 0); 3202 return;; 3203 fSave.resize(npx + 3);; 3204 Double_t xv[1];; 3205 InitArgs(xv, parameters);; 3206 for (Int_t i =",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:137351,Usability,clear,clear,137351,"576 // process new version with new TFormula class which is contained in TF1; 3577 //printf(""reading TF1....- version %d..\n"",v);; 3578 ; 3579 if (v > 7) {; 3580 // new classes with new TFormula; 3581 // need to register the objects; 3582 b.ReadClassBuffer(TF1::Class(), this, v, R__s, R__c);; 3583 if (!TestBit(kNotGlobal)) {; 3584 R__LOCKGUARD(gROOTMutex);; 3585 gROOT->GetListOfFunctions()->Add(this);; 3586 }; 3587 return;; 3588 } else {; 3589 ROOT::v5::TF1Data fold;; 3590 //printf(""Reading TF1 as v5::TF1Data- version %d \n"",v);; 3591 fold.Streamer(b, v, R__s, R__c, TF1::Class());; 3592 // convert old TF1 to new one; 3593 ((TF1v5Convert *)this)->Convert(fold);; 3594 }; 3595 }; 3596 ; 3597 // Writing; 3598 else {; 3599 Int_t saved = 0;; 3600 // save not-formula functions as array of points; 3601 if (fType > 0 && fSave.empty() && fType != EFType::kCompositionFcn) {; 3602 saved = 1;; 3603 Save(fXmin, fXmax, 0, 0, 0, 0);; 3604 }; 3605 b.WriteClassBuffer(TF1::Class(), this);; 3606 ; 3607 // clear vector contents; 3608 if (saved) {; 3609 fSave.clear();; 3610 }; 3611 }; 3612}; 3613 ; 3614 ; 3615////////////////////////////////////////////////////////////////////////////////; 3616/// Called by functions such as SetRange, SetNpx, SetParameters; 3617/// to force the deletion of the associated histogram or Integral; 3618 ; 3619void TF1::Update(); 3620{; 3621 if (fHistogram) {; 3622 TString XAxisTitle = fHistogram->GetXaxis()->GetTitle();; 3623 TString YAxisTitle = fHistogram->GetYaxis()->GetTitle();; 3624 Int_t XLabCol = fHistogram->GetXaxis()->GetLabelColor();; 3625 Int_t YLabCol = fHistogram->GetYaxis()->GetLabelColor();; 3626 Int_t XLabFont = fHistogram->GetXaxis()->GetLabelFont();; 3627 Int_t YLabFont = fHistogram->GetYaxis()->GetLabelFont();; 3628 Float_t XLabOffset = fHistogram->GetXaxis()->GetLabelOffset();; 3629 Float_t YLabOffset = fHistogram->GetYaxis()->GetLabelOffset();; 3630 Float_t XLabSize = fHistogram->GetXaxis()->GetLabelSize();; 3631 Float_t YLabSize = fHistog",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:137404,Usability,clear,clear,137404," }; 3595 }; 3596 ; 3597 // Writing; 3598 else {; 3599 Int_t saved = 0;; 3600 // save not-formula functions as array of points; 3601 if (fType > 0 && fSave.empty() && fType != EFType::kCompositionFcn) {; 3602 saved = 1;; 3603 Save(fXmin, fXmax, 0, 0, 0, 0);; 3604 }; 3605 b.WriteClassBuffer(TF1::Class(), this);; 3606 ; 3607 // clear vector contents; 3608 if (saved) {; 3609 fSave.clear();; 3610 }; 3611 }; 3612}; 3613 ; 3614 ; 3615////////////////////////////////////////////////////////////////////////////////; 3616/// Called by functions such as SetRange, SetNpx, SetParameters; 3617/// to force the deletion of the associated histogram or Integral; 3618 ; 3619void TF1::Update(); 3620{; 3621 if (fHistogram) {; 3622 TString XAxisTitle = fHistogram->GetXaxis()->GetTitle();; 3623 TString YAxisTitle = fHistogram->GetYaxis()->GetTitle();; 3624 Int_t XLabCol = fHistogram->GetXaxis()->GetLabelColor();; 3625 Int_t YLabCol = fHistogram->GetYaxis()->GetLabelColor();; 3626 Int_t XLabFont = fHistogram->GetXaxis()->GetLabelFont();; 3627 Int_t YLabFont = fHistogram->GetYaxis()->GetLabelFont();; 3628 Float_t XLabOffset = fHistogram->GetXaxis()->GetLabelOffset();; 3629 Float_t YLabOffset = fHistogram->GetYaxis()->GetLabelOffset();; 3630 Float_t XLabSize = fHistogram->GetXaxis()->GetLabelSize();; 3631 Float_t YLabSize = fHistogram->GetYaxis()->GetLabelSize();; 3632 Int_t XNdiv = fHistogram->GetXaxis()->GetNdivisions();; 3633 Int_t YNdiv = fHistogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabel",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:139313,Usability,clear,clear,139313," Float_t YLabSize = fHistogram->GetYaxis()->GetLabelSize();; 3632 Int_t XNdiv = fHistogram->GetXaxis()->GetNdivisions();; 3633 Int_t YNdiv = fHistogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:139335,Usability,clear,clear,139335,"Histogram->GetYaxis()->GetLabelSize();; 3632 Int_t XNdiv = fHistogram->GetXaxis()->GetNdivisions();; 3633 Int_t YNdiv = fHistogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be se",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:139356,Usability,clear,clear,139356,">GetLabelSize();; 3632 Int_t XNdiv = fHistogram->GetXaxis()->GetNdivisions();; 3633 Int_t YNdiv = fHistogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitt",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8cxx_source.html:139378,Usability,clear,clear,139378,"ogram->GetYaxis()->GetNdivisions();; 3634 ; 3635 delete fHistogram;; 3636 fHistogram = nullptr;; 3637 GetHistogram();; 3638 ; 3639 fHistogram->GetXaxis()->SetTitle(XAxisTitle.Data());; 3640 fHistogram->GetYaxis()->SetTitle(YAxisTitle.Data());; 3641 fHistogram->GetXaxis()->SetLabelColor(XLabCol);; 3642 fHistogram->GetYaxis()->SetLabelColor(YLabCol);; 3643 fHistogram->GetXaxis()->SetLabelFont(XLabFont);; 3644 fHistogram->GetYaxis()->SetLabelFont(YLabFont);; 3645 fHistogram->GetXaxis()->SetLabelOffset(XLabOffset);; 3646 fHistogram->GetYaxis()->SetLabelOffset(YLabOffset);; 3647 fHistogram->GetXaxis()->SetLabelSize(XLabSize);; 3648 fHistogram->GetYaxis()->SetLabelSize(YLabSize);; 3649 fHistogram->GetXaxis()->SetNdivisions(XNdiv);; 3650 fHistogram->GetYaxis()->SetNdivisions(YNdiv);; 3651 }; 3652 if (!fIntegral.empty()) {; 3653 fIntegral.clear();; 3654 fAlpha.clear();; 3655 fBeta.clear();; 3656 fGamma.clear();; 3657 }; 3658 if (fNormalized) {; 3659 // need to compute the integral of the not-normalized function; 3660 fNormalized = false;; 3661 fNormIntegral = Integral(fXmin, fXmax, 0.0);; 3662 fNormalized = true;; 3663 } else; 3664 fNormIntegral = 0;; 3665 ; 3666 // std::vector<double>x(fNdim);; 3667 // if ((fType == 1) && !fFunctor->Empty()) (*fFunctor)x.data(), (Double_t*)fParams);; 3668 if (fType == EFType::kCompositionFcn && fComposition) {; 3669 // double-check that the parameters are correct; 3670 fComposition->SetParameters(GetParameters());; 3671 ; 3672 fComposition->Update(); // should not be necessary, but just to be safe; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Static function to set the global flag to reject points; 3678/// the fgRejectPoint global flag is tested by all fit functions; 3679/// if TRUE the point is not included in the fit.; 3680/// This flag can be set by a user in a fitting function.; 3681/// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.; 3682 ; ",MatchSource.WIKI,doc/master/TF1_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html
https://root.cern/doc/master/TF1_8h.html:546,Integrability,depend,dependency,546,". ROOT: hist/hist/inc/TF1.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; TF1.h File Reference. #include ""RConfigure.h""; #include <functional>; #include <cassert>; #include <memory>; #include <string>; #include <vector>; #include ""TFormula.h""; #include ""TMethodCall.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttMarker.h""; #include ""TF1AbsComposition.h""; #include ""TMath.h""; #include ""Math/Types.h""; #include ""Math/ParamFunctor.h"". Include dependency graph for TF1.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Internal::GetFunctorType< T >;  Internal class used by TF1 for obtaining the type from a functor out of the set of valid operator() signatures. More...;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(const T *, const double *) const >;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(const T *, const double *)>;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(T *, double *) const >;  ; struct  ROOT::Internal::GetFunctorType< T(F::*)(T *, double *)>;  ; class  TF1;  1-Dim function class More...;  ; struct  ROOT::Internal::TF1Builder< Func >;  Internal class used by TF1 for defining template specialization for different TF1 constructors More...;  ; struct  ROOT::Internal::TF1Builder< const char * >;  TF1 building from a string used to build a TFormula based on a lambda function. More...;  ; struct  ROOT::Internal::TF1Builder< Func * >;  ; struct  TF1::TF1FunctorPointer;  ; struct  TF1::TF1FunctorPointerImpl< T >;  ; class  TF1Parameters;  TF1 Parameters class. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declar",MatchSource.WIKI,doc/master/TF1_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h.html
https://root.cern/doc/master/TF1_8h_source.html:8175,Availability,error,errors,8175,"la = 0, ///< Formula functions which can be stored,; 256 kPtrScalarFreeFcn, ///< Pointer to scalar free function,; 257 kInterpreted, ///< Interpreted functions constructed by name,; 258 kTemplVec, ///< Vectorized free functions or TemplScalar functors evaluating on vectorized parameters,; 259 kTemplScalar, ///< TemplScalar functors evaluating on scalar parameters; 260 kCompositionFcn; 261 }; // formula based on composition class (e.g. NSUM, CONV); 262 ; 263 Double_t fXmin{-1111}; ///< Lower bounds for the range; 264 Double_t fXmax{-1111}; ///< Upper bounds for the range; 265 Int_t fNpar{}; ///< Number of parameters; 266 Int_t fNdim{}; ///< Function dimension; 267 Int_t fNpx{100}; ///< Number of points used for the graphical representation; 268 EFType fType{EFType::kTemplScalar};; 269 Int_t fNpfits{}; ///< Number of points used in the fit; 270 Int_t fNDF{}; ///< Number of degrees of freedom in the fit; 271 Double_t fChisquare{}; ///< Function fit chisquare; 272 Double_t fMinimum{-1111}; ///< Minimum value for plotting; 273 Double_t fMaximum{-1111}; ///< Maximum value for plotting; 274 std::vector<Double_t> fParErrors; ///< Array of errors of the fNpar parameters; 275 std::vector<Double_t> fParMin; ///< Array of lower limits of the fNpar parameters; 276 std::vector<Double_t> fParMax; ///< Array of upper limits of the fNpar parameters; 277 std::vector<Double_t> fSave; ///< Array of fNsave function values; 278 std::vector<Double_t> fIntegral; ///<! Integral of function binned on fNpx bins; 279 std::vector<Double_t> fAlpha; ///<! Array alpha. for each bin in x the deconvolution r of fIntegral; 280 std::vector<Double_t> fBeta; ///<! Array beta. is approximated by x = alpha +beta*r *gamma*r**2; 281 std::vector<Double_t> fGamma; ///<! Array gamma.; 282 TObject *fParent{nullptr}; ///<! Parent object hooking this function (if one); 283 TH1 *fHistogram{nullptr}; ///<! Pointer to histogram used for visualisation; 284 std::unique_ptr<TMethodCall> fMethodCall; ///<! Pointer to Met",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:30496,Availability,error,error,30496,"or, the SetParameter() method can be; 693 // overridden.; 694 if (fFormula) fFormula->SetParameters(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);; 695 else fParams->SetParameters(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);; 696 Update();; 697 } // *MENU*; 698 virtual void SetParName(Int_t ipar, const char *name);; 699 virtual void SetParNames(const char *name0 = """", const char *name1 = """", const char *name2 = """",; 700 const char *name3 = """", const char *name4 = """", const char *name5 = """",; 701 const char *name6 = """", const char *name7 = """", const char *name8 = """",; 702 const char *name9 = """", const char *name10 = """"); // *MENU*; 703 virtual void SetParError(Int_t ipar, Double_t error);; 704 virtual void SetParErrors(const Double_t *errors);; 705 virtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax);; 706 virtual void SetParent(TObject *p = nullptr); 707 {; 708 fParent = p;; 709 }; 710 virtual void SetRange(Double_t xmin, Double_t xmax); // *MENU*; 711 virtual void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax);; 712 virtual void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax);; 713 virtual void SetSavedPoint(Int_t point, Double_t value);; 714 void SetTitle(const char *title = """") override; // *MENU*; 715 virtual void SetVectorized(Bool_t vectorized); 716 {; 717 if (fType == EFType::kFormula && fFormula); 718 fFormula->SetVectorized(vectorized);; 719 else; 720 Warning(""SetVectorized"", ""Can only set vectorized flag on formula-based TF1"");; 721 }; 722 virtual void Update();; 723 ; 724 static TF1 *GetCurrent();; 725 static void AbsValue(Bool_t reject = kTRUE);; 726 static void RejectPoint(Bool_t reject = kTRUE);; 727 static Bool_t RejectedPoint();; 728 static void SetCurrent(TF1 *f1);; 729 ; 730 //Moments; 731 virtual Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t *params = nullptr, Double_t epsilon = 0.000001);; 732 virtual Double_t CentralMoment(Double_t n,",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:30551,Availability,error,errors,30551,"or, the SetParameter() method can be; 693 // overridden.; 694 if (fFormula) fFormula->SetParameters(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);; 695 else fParams->SetParameters(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);; 696 Update();; 697 } // *MENU*; 698 virtual void SetParName(Int_t ipar, const char *name);; 699 virtual void SetParNames(const char *name0 = """", const char *name1 = """", const char *name2 = """",; 700 const char *name3 = """", const char *name4 = """", const char *name5 = """",; 701 const char *name6 = """", const char *name7 = """", const char *name8 = """",; 702 const char *name9 = """", const char *name10 = """"); // *MENU*; 703 virtual void SetParError(Int_t ipar, Double_t error);; 704 virtual void SetParErrors(const Double_t *errors);; 705 virtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax);; 706 virtual void SetParent(TObject *p = nullptr); 707 {; 708 fParent = p;; 709 }; 710 virtual void SetRange(Double_t xmin, Double_t xmax); // *MENU*; 711 virtual void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax);; 712 virtual void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax);; 713 virtual void SetSavedPoint(Int_t point, Double_t value);; 714 void SetTitle(const char *title = """") override; // *MENU*; 715 virtual void SetVectorized(Bool_t vectorized); 716 {; 717 if (fType == EFType::kFormula && fFormula); 718 fFormula->SetVectorized(vectorized);; 719 else; 720 Warning(""SetVectorized"", ""Can only set vectorized flag on formula-based TF1"");; 721 }; 722 virtual void Update();; 723 ; 724 static TF1 *GetCurrent();; 725 static void AbsValue(Bool_t reject = kTRUE);; 726 static void RejectPoint(Bool_t reject = kTRUE);; 727 static Bool_t RejectedPoint();; 728 static void SetCurrent(TF1 *f1);; 729 ; 730 //Moments; 731 virtual Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t *params = nullptr, Double_t epsilon = 0.000001);; 732 virtual Double_t CentralMoment(Double_t n,",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:36475,Availability,error,error,36475,"alPar(x, params);; 825 } else; 826 return TF1::EvalPar((double *)x, params);; 827}; 828 ; 829////////////////////////////////////////////////////////////////////////////////; 830/// Eval for vectorized functions; 831// template <class T>; 832// T TF1::Eval(T x, T y, T z, T t) const; 833// {; 834// if (fType == EFType::kFormula); 835// return fFormula->Eval(x, y, z, t);; 836 ; 837// T xx[] = {x, y, z, t};; 838// Double_t *pp = (Double_t *)fParams->GetParameters();; 839// return ((TF1 *)this)->EvalPar(xx, pp);; 840// }; 841 ; 842// Internal to TF1. Evaluates Templated interfaces; 843template <class T>; 844inline T TF1::EvalParTempl(const T *data, const Double_t *params); 845{; 846 assert(fType == EFType::kTemplScalar || fType == EFType::kTemplVec);; 847 if (!params) params = (Double_t *)fParams->GetParameters();; 848 if (fFunctor); 849 return ((TF1FunctorPointerImpl<T> *)fFunctor.get())->fImpl(data, params);; 850 ; 851 // this should throw an error; 852 // we nned to implement a vectorized GetSave(x); 853 return TMath::SignalingNaN();; 854}; 855 ; 856#ifdef R__HAS_VECCORE; 857// Internal to TF1. Evaluates Vectorized TF1 on data of type Double_v; 858inline double TF1::EvalParVec(const Double_t *data, const Double_t *params); 859{; 860 assert(fType == EFType::kTemplVec);; 861 std::vector<ROOT::Double_v> d(fNdim);; 862 ROOT::Double_v res;; 863 ; 864 for(auto i=0; i<fNdim; i++) {; 865 d[i] = ROOT::Double_v(data[i]);; 866 }; 867 ; 868 if (fFunctor) {; 869 res = ((TF1FunctorPointerImpl<ROOT::Double_v> *) fFunctor.get())->fImpl(d.data(), params);; 870 } else {; 871 // res = GetSave(x);; 872 return TMath::SignalingNaN();; 873 }; 874 return vecCore::Get<ROOT::Double_v>(res, 0);; 875}; 876#endif; 877 ; 878inline void TF1::SetRange(Double_t xmin, Double_t, Double_t xmax, Double_t); 879{; 880 TF1::SetRange(xmin, xmax);; 881}; 882inline void TF1::SetRange(Double_t xmin, Double_t, Double_t, Double_t xmax, Double_t, Double_t); 883{; 884 TF1::SetRange(xmin, xmax);; 885}; 886 ; 887temp",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:39197,Availability,error,error,39197,"le_t *)x, eps);; 909}; 910 ; 911template <class T>; 912inline T TF1::GradientParTempl(Int_t ipar, const T *x, Double_t eps); 913{; 914 if (GetNpar() == 0); 915 return 0;; 916 ; 917 if (eps < 1e-10 || eps > 1) {; 918 Warning(""Derivative"", ""parameter esp=%g out of allowed range[1e-10,1], reset to 0.01"", eps);; 919 eps = 0.01;; 920 }; 921 Double_t h;; 922 TF1 *func = (TF1 *)this;; 923 Double_t *parameters = GetParameters();; 924 ; 925 // Copy parameters for thread safety; 926 std::vector<Double_t> parametersCopy(parameters, parameters + GetNpar());; 927 parameters = parametersCopy.data();; 928 ; 929 Double_t al, bl, h2;; 930 T f1, f2, g1, g2, d0, d2;; 931 ; 932 ((TF1 *)this)->GetParLimits(ipar, al, bl);; 933 if (al * bl != 0 && al >= bl) {; 934 // this parameter is fixed; 935 return 0;; 936 }; 937 ; 938 // check if error has been computer (is not zero); 939 if (func->GetParError(ipar) != 0); 940 h = eps * func->GetParError(ipar);; 941 else; 942 h = eps;; 943 ; 944 // save original parameters; 945 Double_t par0 = parameters[ipar];; 946 ; 947 parameters[ipar] = par0 + h;; 948 f1 = func->EvalPar(x, parameters);; 949 parameters[ipar] = par0 - h;; 950 f2 = func->EvalPar(x, parameters);; 951 parameters[ipar] = par0 + h / 2;; 952 g1 = func->EvalPar(x, parameters);; 953 parameters[ipar] = par0 - h / 2;; 954 g2 = func->EvalPar(x, parameters);; 955 ; 956 // compute the central differences; 957 h2 = 1 / (2. * h);; 958 d0 = f1 - f2;; 959 d2 = 2 * (g1 - g2);; 960 ; 961 T grad = h2 * (4 * d2 - d0) / 3.;; 962 ; 963 // restore original value; 964 parameters[ipar] = par0;; 965 ; 966 return grad;; 967}; 968 ; 969template <class T>; 970inline void TF1::GradientPar(const T *x, T *grad, Double_t eps); 971{; 972 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 973 GradientParTempl<T>(x, grad, eps);; 974 } else; 975 GradientParTempl<Double_t>((const Double_t *)x, (Double_t *)grad, eps);; 976}; 977 ; 978template <class T>; 979inline void TF1::GradientParTempl(const T *x, T *",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:47130,Availability,error,error,47130,"::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Meanvirtual Double_t Mean(Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constRetu",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:47140,Availability,error,error,47140,"::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Meanvirtual Double_t Mean(Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constRetu",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:48298,Availability,error,errors,48298," the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Meanvirtual Double_t Mean(Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetFormulavirtual const TFormula * GetFormula() constDefinition TF1.h:485; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetParamet",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:53911,Availability,error,errors,53911,"raw the function.Definition TF1.cxx:3528; TF1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TF1.h:501; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constDefinition TF1.h:489; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::IntegralMultiplevirtual Double_t IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t, Int_t maxpts, Double_t epsrel, Double_t &relerr, Int_t &nfnevl, Int_t &ifail)Definition TF1.h:616; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::GetParentTObject * GetParent() constDefinition TF1.h:536; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::SetFunctionvoid SetFunction(PtrObj &p, MemFn memFn)Definition TF1.h:895; TF1::SetParentvirtual void SetParent(TObject *p=nullptr)Definition TF1.h",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:53922,Availability,error,errors,53922,"raw the function.Definition TF1.cxx:3528; TF1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TF1.h:501; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constDefinition TF1.h:489; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::IntegralMultiplevirtual Double_t IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t, Int_t maxpts, Double_t epsrel, Double_t &relerr, Int_t &nfnevl, Int_t &ifail)Definition TF1.h:616; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::GetParentTObject * GetParent() constDefinition TF1.h:536; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::SetFunctionvoid SetFunction(PtrObj &p, MemFn memFn)Definition TF1.h:895; TF1::SetParentvirtual void SetParent(TObject *p=nullptr)Definition TF1.h",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:53993,Availability,error,errors,53993,"raw the function.Definition TF1.cxx:3528; TF1::GetMaximumStoredvirtual Double_t GetMaximumStored() constDefinition TF1.h:501; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constDefinition TF1.h:489; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::IntegralMultiplevirtual Double_t IntegralMultiple(Int_t n, const Double_t *a, const Double_t *b, Int_t, Int_t maxpts, Double_t epsrel, Double_t &relerr, Int_t &nfnevl, Int_t &ifail)Definition TF1.h:616; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::GetParentTObject * GetParent() constDefinition TF1.h:536; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::SetFunctionvoid SetFunction(PtrObj &p, MemFn memFn)Definition TF1.h:895; TF1::SetParentvirtual void SetParent(TObject *p=nullptr)Definition TF1.h",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:56229,Availability,error,error,56229,"dToGlobList=EAddToList::kDefault)Definition TF1.h:428; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetTitlevoid SetTitle(const char *title="""") overrideSet function title if title has the form ""fffffff;xxxx;yyyy"", it is assumed that the function title i...Definition TF1.cxx:3558; TF1::GetNumberFitPointsvirtual Int_t GetNumberFitPoints() constDefinition TF1.h:531; TF1::fFormulastd::unique_ptr< TFormula > fFormulaPointer to TFormula in case when user define formula.Definition TF1.h:288; TF1::SetParNamesvirtual void SetParNames(const char *name0="""", const char *name1="""", const char *name2="""", const char *name3="""", const char *name4="""", const char *name5="""", const char *name6="""", const char *name7="""", const char *name8="""", const char *name9="""", const char *name10="""")Set up to 10 parameter names.Definition TF1.cxx:3463; TF1::DerivativeErrorstatic Double_t DerivativeError()Static function returning the error of the last call to the of Derivative's functions.Definition TF1.cxx:1277; TF1::fParMinstd::vector< Double_t > fParMinArray of lower limits of the fNpar parameters.Definition TF1.h:275; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TF1.h:273; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TF1.h:272; TF1::TermCoeffLengthint TermCoeffLength(TString &term)Definition TF1.cxx:924; TF1::fgRejectPointstatic Bool_t fgRejectPointDefinition TF1.h:325; TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::SetNumberFitPointsvirtual void SetNumberFitPoints(Int_t npfits)De",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:69688,Availability,error,errors,69688,":493; TF1::SetVectorizedvirtual void SetVectorized(Bool_t vectorized)Definition TF1.h:715; TF1::IntegralOneDimvirtual Double_t IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)Return Integral of function between a and b using the given parameter values and relative and absolut...Definition TF1.cxx:2621; TF1::TF1TF1(const char *name, Func f, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault)Definition TF1.h:397; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF1::GetParNumbervirtual Int_t GetParNumber(const char *name) constDefinition TF1.h:561; TF1::TF1TF1(const char *name, T(*fcn)(const T *, const Double_t *), Double_t xmin=0, Double_t xmax=1, Int_t npar=0, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault)Constructor using a pointer to function.Definition TF1.h:381; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF1::GetXaxisTAxis * GetXaxis() constGet x axis of the function.Definition TF1.cxx:2400; TF1::HasSaveBool_t HasSave() constReturn true if function has data in fSave buffer.Definition TF1.h:466; TFormulaThe Formula class.Definition TFormula.h:89; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TString",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:45936,Energy Efficiency,efficient,efficient,45936,"r(Int_t iparam) constDefinition TF1.h:80; TF1Parameters::SetParNamevoid SetParName(Int_t iparam, const char *name)Definition TF1.h:122; TF1Parameters::operator=TF1Parameters & operator=(const TF1Parameters &rhs)Definition TF1.h:70; TF1Parameters::SetParametervoid SetParameter(Int_t iparam, Double_t value)Definition TF1.h:106; TF1Parameters::SetParametervoid SetParameter(const char *name, Double_t value)Definition TF1.h:118; TF1Parameters::TF1ParametersTF1Parameters(Int_t npar)Definition TF1.h:56; TF1Parameters::fParNamesstd::vector< std::string > fParNamesDefinition TF1.h:139; TF1Parameters::TF1ParametersTF1Parameters()Definition TF1.h:55; TF1Parameters::CheckIndexbool CheckIndex(Int_t i) constDefinition TF1.h:133; TF1Parameters::SetParNamesvoid SetParNames(Args &&... args)Set parameter names.Definition TF1.h:156; TF1Parameters::SetParametersvoid SetParameters(const Double_t *params)Definition TF1.h:111; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1Parameters::TF1ParametersTF1Parameters(const TF1Parameters &rhs)Definition TF1.h:65; TF1Parameters::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:9303,Integrability,wrap,wrap,9303,"Array of lower limits of the fNpar parameters; 276 std::vector<Double_t> fParMax; ///< Array of upper limits of the fNpar parameters; 277 std::vector<Double_t> fSave; ///< Array of fNsave function values; 278 std::vector<Double_t> fIntegral; ///<! Integral of function binned on fNpx bins; 279 std::vector<Double_t> fAlpha; ///<! Array alpha. for each bin in x the deconvolution r of fIntegral; 280 std::vector<Double_t> fBeta; ///<! Array beta. is approximated by x = alpha +beta*r *gamma*r**2; 281 std::vector<Double_t> fGamma; ///<! Array gamma.; 282 TObject *fParent{nullptr}; ///<! Parent object hooking this function (if one); 283 TH1 *fHistogram{nullptr}; ///<! Pointer to histogram used for visualisation; 284 std::unique_ptr<TMethodCall> fMethodCall; ///<! Pointer to MethodCall in case of interpreted function; 285 Bool_t fNormalized{false}; ///< Normalization option (false by default); 286 Double_t fNormIntegral{}; ///< Integral of the function before being normalized; 287 std::unique_ptr<TF1FunctorPointer> fFunctor; ///<! Functor object to wrap any C++ callable object; 288 std::unique_ptr<TFormula> fFormula; ///< Pointer to TFormula in case when user define formula; 289 std::unique_ptr<TF1Parameters> fParams; ///< Pointer to Function parameters object (exists only for not-formula functions); 290 std::unique_ptr<TF1AbsComposition> fComposition; ///< Pointer to composition (NSUM or CONV); 291 ; 292 /// General constructor for TF1. Most of the other constructors delegate on it; 293 TF1(EFType functionType, const char *name, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList, TF1Parameters *params = nullptr, TF1FunctorPointer * functor = nullptr):; 294 TNamed(name, name), TAttLine(), TAttFill(), TAttMarker(), fXmin(xmin), fXmax(xmax), fNpar(npar), fNdim(ndim),; 295 fType(functionType), fParErrors(npar), fParMin(npar), fParMax(npar); 296 {; 297 fParams.reset(params);; 298 fFunctor.reset(functor);; 299 DoInitialize(addToGlobList);; 300 }; 301 ;",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:15945,Integrability,interface,interface,15945,"ng a double.; 390 // The class name is not needed when using compile code, while it is required when using; 391 // interpreted code via the specialized constructor with void *.; 392 // An instance of the C++ function class or its pointer can both be used. The former is reccomended when using; 393 // C++ compiled code, but if CINT compatibility is needed, then a pointer to the function class must be used.; 394 // xmin and xmax specify the plotting range, npar is the number of parameters.; 395 // See the tutorial math/exampleFunctor.C for an example of using this constructor; 396 template <typename Func>; 397 TF1(const char *name, Func f, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim = 1, EAddToList addToGlobList = EAddToList::kDefault) :; 398 TF1(EFType::kTemplScalar, name, xmin, xmax, npar, ndim, addToGlobList); 399 {; 400 //actual fType set in TF1Builder; 401 ROOT::Internal::TF1Builder<Func>::Build(this, f);; 402 }; 403 ; 404 // backward compatible interface; 405 template <typename Func>; 406 TF1(const char *name, Func f, Double_t xmin, Double_t xmax, Int_t npar, const char *, EAddToList addToGlobList = EAddToList::kDefault) :; 407 TF1(EFType::kTemplScalar, name, xmin, xmax, npar, 1, addToGlobList, new TF1Parameters(npar)); 408 {; 409 ROOT::Internal::TF1Builder<Func>::Build(this, f);; 410 }; 411 ; 412 ; 413 // Template constructors from a pointer to any C++ class of type PtrObj with a specific member function of type; 414 // MemFn.; 415 // The member function must have the signature of (double * , double *) and returning a double.; 416 // The class name and the method name are not needed when using compile code; 417 // (the member function pointer is used in this case), while they are required when using interpreted; 418 // code via the specialized constructor with void *.; 419 // xmin and xmax specify the plotting range, npar is the number of parameters.; 420 // See the tutorial math/exampleFunctor.C for an example of using this constructor; 421 template <c",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:17383,Integrability,interface,interface,17383," npar is the number of parameters.; 420 // See the tutorial math/exampleFunctor.C for an example of using this constructor; 421 template <class PtrObj, typename MemFn>; 422 TF1(const char *name, const PtrObj &p, MemFn memFn, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim = 1, EAddToList addToGlobList = EAddToList::kDefault) :; 423 TF1(EFType::kTemplScalar, name, xmin, xmax, npar, ndim, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(p, memFn))); 424 {}; 425 ; 426 // backward compatible interface; 427 template <class PtrObj, typename MemFn>; 428 TF1(const char *name, const PtrObj &p, MemFn memFn, Double_t xmin, Double_t xmax, Int_t npar, const char *, const char *, EAddToList addToGlobList = EAddToList::kDefault) :; 429 TF1(EFType::kTemplScalar, name, xmin, xmax, npar, 1, addToGlobList, new TF1Parameters(npar), new TF1FunctorPointerImpl<double>(ROOT::Math::ParamFunctor(p, memFn))); 430 {}; 431 ; 432 TF1(const TF1 &f1);; 433 TF1 &operator=(const TF1 &rhs);; 434 ~TF1() override;; 435 virtual void AddParameter(const TString &name, Double_t value); 436 {; 437 if (fFormula) fFormula->AddParameter(name, value);; 438 }; 439 // virtual void AddParameters(const pair<TString,Double_t> *pairs, Int_t size) { fFormula->AddParameters(pairs,size); }; 440 // virtual void AddVariable(const TString &name, Double_t value = 0) { if (fFormula) fFormula->AddVariable(name,value); }; 441 // virtual void AddVariables(const TString *vars, Int_t size) { if (fFormula) fFormula->AddVariables(vars,size); }; 442 virtual Bool_t AddToGlobalList(Bool_t on = kTRUE);; 443 static Bool_t DefaultAddToGlobalList(Bool_t on = kTRUE);; 444 void Browse(TBrowser *b) override;; 445 void Copy(TObject &f1) const override;; 446 TObject *Clone(const char *newname = nullptr) const override;; 447 virtual Double_t Derivative(Double_t x, Double_t *params = nullptr, Double_t epsilon = 0.001) const;; 448 virtual Double_t Derivative2(Double_t x, Double_t *params = nul",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:36093,Integrability,interface,interfaces,36093,"r for vectorized; 818template <class T>; 819T TF1::EvalPar(const T *x, const Double_t *params); 820{; 821 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 822 return EvalParTempl(x, params);; 823 } else if (fType == EFType::kFormula) {; 824 return fFormula->EvalPar(x, params);; 825 } else; 826 return TF1::EvalPar((double *)x, params);; 827}; 828 ; 829////////////////////////////////////////////////////////////////////////////////; 830/// Eval for vectorized functions; 831// template <class T>; 832// T TF1::Eval(T x, T y, T z, T t) const; 833// {; 834// if (fType == EFType::kFormula); 835// return fFormula->Eval(x, y, z, t);; 836 ; 837// T xx[] = {x, y, z, t};; 838// Double_t *pp = (Double_t *)fParams->GetParameters();; 839// return ((TF1 *)this)->EvalPar(xx, pp);; 840// }; 841 ; 842// Internal to TF1. Evaluates Templated interfaces; 843template <class T>; 844inline T TF1::EvalParTempl(const T *data, const Double_t *params); 845{; 846 assert(fType == EFType::kTemplScalar || fType == EFType::kTemplVec);; 847 if (!params) params = (Double_t *)fParams->GetParameters();; 848 if (fFunctor); 849 return ((TF1FunctorPointerImpl<T> *)fFunctor.get())->fImpl(data, params);; 850 ; 851 // this should throw an error; 852 // we nned to implement a vectorized GetSave(x); 853 return TMath::SignalingNaN();; 854}; 855 ; 856#ifdef R__HAS_VECCORE; 857// Internal to TF1. Evaluates Vectorized TF1 on data of type Double_v; 858inline double TF1::EvalParVec(const Double_t *data, const Double_t *params); 859{; 860 assert(fType == EFType::kTemplVec);; 861 std::vector<ROOT::Double_v> d(fNdim);; 862 ROOT::Double_v res;; 863 ; 864 for(auto i=0; i<fNdim; i++) {; 865 d[i] = ROOT::Double_v(data[i]);; 866 }; 867 ; 868 if (fFunctor) {; 869 res = ((TF1FunctorPointerImpl<ROOT::Double_v> *) fFunctor.get())->fImpl(d.data(), params);; 870 } else {; 871 // res = GetSave(x);; 872 return TMath::SignalingNaN();; 873 }; 874 return vecCore::Get<ROOT::Double_v>(res, 0);; 875}; 876#endif; 877 ; 87",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:46312,Integrability,wrap,wrap,46312,"uble_t value)Definition TF1.h:118; TF1Parameters::TF1ParametersTF1Parameters(Int_t npar)Definition TF1.h:56; TF1Parameters::fParNamesstd::vector< std::string > fParNamesDefinition TF1.h:139; TF1Parameters::TF1ParametersTF1Parameters()Definition TF1.h:55; TF1Parameters::CheckIndexbool CheckIndex(Int_t i) constDefinition TF1.h:133; TF1Parameters::SetParNamesvoid SetParNames(Args &&... args)Set parameter names.Definition TF1.h:156; TF1Parameters::SetParametersvoid SetParameters(const Double_t *params)Definition TF1.h:111; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1Parameters::TF1ParametersTF1Parameters(const TF1Parameters &rhs)Definition TF1.h:65; TF1Parameters::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global ",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:48561,Integrability,interface,interface,48561,"le_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetFormulavirtual const TFormula * GetFormula() constDefinition TF1.h:485; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetParametervirtual Double_t GetParameter(const TString &name) constDefinition TF1.h:544; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::GetParametersvirtual void GetParameters(Double_t *params)Definition TF1.h:552; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of de",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:70134,Integrability,interface,interface,70134,"397; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF1::GetParNumbervirtual Int_t GetParNumber(const char *name) constDefinition TF1.h:561; TF1::TF1TF1(const char *name, T(*fcn)(const T *, const Double_t *), Double_t xmin=0, Double_t xmax=1, Int_t npar=0, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault)Constructor using a pointer to function.Definition TF1.h:381; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF1::GetXaxisTAxis * GetXaxis() constGet x axis of the function.Definition TF1.cxx:2400; TF1::HasSaveBool_t HasSave() constReturn true if function has data in fSave buffer.Definition TF1.h:466; TFormulaThe Formula class.Definition TFormula.h:89; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStringBasic string class.Definition TString.h:139; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; double; int; yDouble_t y[n]Definition legend1.C:17",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:70481,Integrability,message,message,70481,"onstructor using a pointer to function.Definition TF1.h:381; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF1::GetXaxisTAxis * GetXaxis() constGet x axis of the function.Definition TF1.cxx:2400; TF1::HasSaveBool_t HasSave() constReturn true if function has data in fSave buffer.Definition TF1.h:466; TFormulaThe Formula class.Definition TFormula.h:89; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TStringBasic string class.Definition TString.h:139; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; Types.h; F#define F(x, y, z); HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; MathNamespace for ne",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:38839,Safety,safe,safety,38839,"; 895void TF1::SetFunction(PtrObj &p, MemFn memFn); 896{; 897 // set from a pointer to a member function; 898 fType = EFType::kPtrScalarFreeFcn;; 899 fFunctor = std::make_unique<TF1::TF1FunctorPointerImpl<double>>(ROOT::Math::ParamFunctor(p, memFn));; 900}; 901 ; 902template <class T>; 903inline T TF1::GradientPar(Int_t ipar, const T *x, Double_t eps); 904{; 905 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 906 return GradientParTempl<T>(ipar, x, eps);; 907 } else; 908 return GradientParTempl<Double_t>(ipar, (const Double_t *)x, eps);; 909}; 910 ; 911template <class T>; 912inline T TF1::GradientParTempl(Int_t ipar, const T *x, Double_t eps); 913{; 914 if (GetNpar() == 0); 915 return 0;; 916 ; 917 if (eps < 1e-10 || eps > 1) {; 918 Warning(""Derivative"", ""parameter esp=%g out of allowed range[1e-10,1], reset to 0.01"", eps);; 919 eps = 0.01;; 920 }; 921 Double_t h;; 922 TF1 *func = (TF1 *)this;; 923 Double_t *parameters = GetParameters();; 924 ; 925 // Copy parameters for thread safety; 926 std::vector<Double_t> parametersCopy(parameters, parameters + GetNpar());; 927 parameters = parametersCopy.data();; 928 ; 929 Double_t al, bl, h2;; 930 T f1, f2, g1, g2, d0, d2;; 931 ; 932 ((TF1 *)this)->GetParLimits(ipar, al, bl);; 933 if (al * bl != 0 && al >= bl) {; 934 // this parameter is fixed; 935 return 0;; 936 }; 937 ; 938 // check if error has been computer (is not zero); 939 if (func->GetParError(ipar) != 0); 940 h = eps * func->GetParError(ipar);; 941 else; 942 h = eps;; 943 ; 944 // save original parameters; 945 Double_t par0 = parameters[ipar];; 946 ; 947 parameters[ipar] = par0 + h;; 948 f1 = func->EvalPar(x, parameters);; 949 parameters[ipar] = par0 - h;; 950 f2 = func->EvalPar(x, parameters);; 951 parameters[ipar] = par0 + h / 2;; 952 g1 = func->EvalPar(x, parameters);; 953 parameters[ipar] = par0 - h / 2;; 954 g2 = func->EvalPar(x, parameters);; 955 ; 956 // compute the central differences; 957 h2 = 1 / (2. * h);; 958 d0 = f1 - f2;; 959 d2 = 2 ",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:48556,Safety,safe,safe,48556,"le_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Double_t > fParErrorsArray of errors of the fNpar parameters.Definition TF1.h:274; TF1::fNdimInt_t fNdimFunction dimension.Definition TF1.h:266; TF1::CalcGaussLegendreSamplingPointsstatic void CalcGaussLegendreSamplingPoints(Int_t num, Double_t *x, Double_t *w, Double_t eps=3.0e-11)Type safe interface (static method) The number of sampling points are taken from the TGraph.Definition TF1.cxx:3826; TF1::AbsValuestatic void AbsValue(Bool_t reject=kTRUE)Static function: set the fgAbsValue flag.Definition TF1.cxx:984; TF1::GetHistogramvirtual TH1 * GetHistogram() constReturn a pointer to the histogram used to visualise the function Note that this histogram is managed ...Definition TF1.cxx:1584; TF1::GetFormulavirtual const TFormula * GetFormula() constDefinition TF1.h:485; TF1::GetParLimitsvirtual void GetParLimits(Int_t ipar, Double_t &parmin, Double_t &parmax) constReturn limits for parameter ipar.Definition TF1.cxx:1940; TF1::fNparInt_t fNparNumber of parameters.Definition TF1.h:265; TF1::GetParametervirtual Double_t GetParameter(const TString &name) constDefinition TF1.h:544; TF1::GetYaxisTAxis * GetYaxis() constGet y axis of the function.Definition TF1.cxx:2411; TF1::GetParametersvirtual void GetParameters(Double_t *params)Definition TF1.h:552; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of de",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:63690,Safety,avoid,avoid,63690,"3=TMath::QuietNaN(), double p4=TMath::QuietNaN(), double p5=TMath::QuietNaN(), double p6=TMath::QuietNaN(), double p7=TMath::QuietNaN(), double p8=TMath::QuietNaN(), double p9=TMath::QuietNaN(), double p10=TMath::QuietNaN())Set parameter values.Definition TF1.h:684; TF1::TF1TF1()TF1 default constructor.Definition TF1.cxx:489; TF1::DrawCopyvirtual TF1 * DrawCopy(Option_t *option="""") constDraw a copy of this function with its current attributes.Definition TF1.cxx:1363; TF1::fParMaxstd::vector< Double_t > fParMaxArray of upper limits of the fNpar parameters.Definition TF1.h:276; TF1::IsVectorizedbool IsVectorized()Definition TF1.h:467; TF1::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TF1.cxx:3218; TF1::IsValidvirtual Bool_t IsValid() constReturn kTRUE if the function is valid.Definition TF1.cxx:2882; TF1::DefaultAddToGlobalListstatic Bool_t DefaultAddToGlobalList(Bool_t on=kTRUE)Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctio...Definition TF1.cxx:838; TF1::fSavestd::vector< Double_t > fSaveArray of fNsave function values.Definition TF1.h:277; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::DefineNSUMTermvoid DefineNSUMTerm(TObjArray *newFuncs, TObjArray *coeffNames, TString &fullFormula, TString &formula, int termStart, int termEnd, Double_t xmin, Double_t xmax)Helper functions for NSUM parsing.Definition TF1.cxx:883; TF1::fGammastd::vector< Double_t > fGamma! Array gamma.Definition TF1.h:281; TF1::fParentTObject * fParent! Parent object hooking this function (if one)Definition TF1.h:282; TF1::GetMinMaxNDimvirtual Double_t GetMinMaxNDim(Double_t *x, Bool_t findmax, Double_t epsilon=0, Int_t maxiter=0) constFind the minimum of a function of whatever dimension.Definition TF1.cxx:1723; TF1::DrawF1virtual void DrawF1(Double_t xmin, Double_t xmax, Option_t *optio",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:21179,Testability,log,logx,21179," EFType::kTemplVec) || (fType == EFType::kFormula && fFormula && fFormula->IsVectorized());; 470 }; 471 /// Return the Chisquare after fitting. See ROOT::Fit::FitResult::Chi2(); 472 Double_t GetChisquare() const; 473 {; 474 return fChisquare;; 475 }; 476 virtual TH1 *GetHistogram() const;; 477 virtual TH1 *CreateHistogram(); 478 {; 479 return DoCreateHistogram(fXmin, fXmax);; 480 }; 481 virtual TFormula *GetFormula(); 482 {; 483 return fFormula.get();; 484 }; 485 virtual const TFormula *GetFormula() const; 486 {; 487 return fFormula.get();; 488 }; 489 virtual TString GetExpFormula(Option_t *option = """") const; 490 {; 491 return (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:21326,Testability,log,logx,21326,"ROOT::Fit::FitResult::Chi2(); 472 Double_t GetChisquare() const; 473 {; 474 return fChisquare;; 475 }; 476 virtual TH1 *GetHistogram() const;; 477 virtual TH1 *CreateHistogram(); 478 {; 479 return DoCreateHistogram(fXmin, fXmax);; 480 }; 481 virtual TFormula *GetFormula(); 482 {; 483 return fFormula.get();; 484 }; 485 virtual const TFormula *GetFormula() const; 486 {; 487 return fFormula.get();; 488 }; 489 virtual TString GetExpFormula(Option_t *option = """") const; 490 {; 491 return (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber() : 0;; 529 }; 530 virtual Int_t GetNumberFreeParameters() const;; 531 virtual Int_t GetNumberFitPoints() const; 532 {; 533 return fNpfits;; 534 }",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:21474,Testability,log,logx,21474,"irtual TH1 *CreateHistogram(); 478 {; 479 return DoCreateHistogram(fXmin, fXmax);; 480 }; 481 virtual TFormula *GetFormula(); 482 {; 483 return fFormula.get();; 484 }; 485 virtual const TFormula *GetFormula() const; 486 {; 487 return fFormula.get();; 488 }; 489 virtual TString GetExpFormula(Option_t *option = """") const; 490 {; 491 return (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber() : 0;; 529 }; 530 virtual Int_t GetNumberFreeParameters() const;; 531 virtual Int_t GetNumberFitPoints() const; 532 {; 533 return fNpfits;; 534 }; 535 char *GetObjectInfo(Int_t px, Int_t py) const override;; 536 TObject *GetParent() const; 537 {; 538 return fParent;; 539 }; 540 virtual Double",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:21622,Testability,log,logx,21622,"n (fFormula) ? fFormula->GetExpFormula(option) : TString();; 492 }; 493 virtual const TObject *GetLinearPart(Int_t i) const; 494 {; 495 return (fFormula) ? fFormula->GetLinearPart(i) : nullptr;; 496 }; 497 virtual Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 498 virtual Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 499 virtual Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 500 virtual Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 501 virtual Double_t GetMaximumStored() const; 502 {; 503 return fMaximum;; 504 }; 505 virtual Double_t GetMinimumStored() const; 506 {; 507 return fMinimum;; 508 }; 509 virtual Int_t GetNpar() const; 510 {; 511 return fNpar;; 512 }; 513 virtual Int_t GetNdim() const; 514 {; 515 return fNdim;; 516 }; 517 virtual Int_t GetNDF() const;; 518 virtual Int_t GetNpx() const; 519 {; 520 return fNpx;; 521 }; 522 TMethodCall *GetMethodCall() const; 523 {; 524 return fMethodCall.get();; 525 }; 526 virtual Int_t GetNumber() const; 527 {; 528 return (fFormula) ? fFormula->GetNumber() : 0;; 529 }; 530 virtual Int_t GetNumberFreeParameters() const;; 531 virtual Int_t GetNumberFitPoints() const; 532 {; 533 return fNpfits;; 534 }; 535 char *GetObjectInfo(Int_t px, Int_t py) const override;; 536 TObject *GetParent() const; 537 {; 538 return fParent;; 539 }; 540 virtual Double_t GetParameter(Int_t ipar) const; 541 {; 542 return (fFormula) ? fFormula->GetParameter(ipar) : fParams->GetParameter(ipar);; 543 }; 544 virtual Double_t GetParameter(const TString &name) const; 545 {; 546 return (fFormula) ? fFormula->GetParameter(name) : fParams->GetParameter(name);; 547 }; 548 virtual Double_t *GetParameters() const;",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:24499,Testability,log,logx,24499,"1 virtual Double_t GetProb() const;; 572 virtual Int_t GetQuantiles(Int_t n, Double_t *xp, const Double_t *p);; 573 virtual Double_t GetRandom(TRandom * rng = nullptr, Option_t * opt = nullptr);; 574 virtual Double_t GetRandom(Double_t xmin, Double_t xmax, TRandom * rng = nullptr, Option_t * opt = nullptr);; 575 virtual void GetRange(Double_t &xmin, Double_t &xmax) const;; 576 virtual void GetRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const;; 577 virtual void GetRange(Double_t &xmin, Double_t &ymin, Double_t &zmin, Double_t &xmax, Double_t &ymax, Double_t &zmax) const;; 578 virtual Double_t GetSave(const Double_t *x);; 579 virtual Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const;; 580 virtual Double_t GetXmin() const; 581 {; 582 return fXmin;; 583 }; 584 virtual Double_t GetXmax() const; 585 {; 586 return fXmax;; 587 }; 588 TAxis *GetXaxis() const ;; 589 TAxis *GetYaxis() const ;; 590 TAxis *GetZaxis() const ;; 591 virtual Double_t GetVariable(const TString &name); 592 {; 593 return (fFormula) ? fFormula->GetVariable(name) : 0;; 594 }; 595 virtual Double_t GradientPar(Int_t ipar, const Double_t *x, Double_t eps = 0.01);; 596 template <class T>; 597 T GradientPar(Int_t ipar, const T *x, Double_t eps = 0.01);; 598 template <class T>; 599 T GradientParTempl(Int_t ipar, const T *x, Double_t eps = 0.01);; 600 ; 601 virtual void GradientPar(const Double_t *x, Double_t *grad, Double_t eps = 0.01);; 602 template <class T>; 603 void GradientPar(const T *x, T *grad, Double_t eps = 0.01);; 604 template <class T>; 605 void GradientParTempl(const T *x, T *grad, Double_t eps = 0.01);; 606 ; 607 virtual void InitArgs(const Double_t *x, const Double_t *params);; 608 static void InitStandardFunctions();; 609 virtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel = 1.e-12);; 610 virtual Double_t IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:36208,Testability,assert,assert,36208,"r for vectorized; 818template <class T>; 819T TF1::EvalPar(const T *x, const Double_t *params); 820{; 821 if (fType == EFType::kTemplVec || fType == EFType::kTemplScalar) {; 822 return EvalParTempl(x, params);; 823 } else if (fType == EFType::kFormula) {; 824 return fFormula->EvalPar(x, params);; 825 } else; 826 return TF1::EvalPar((double *)x, params);; 827}; 828 ; 829////////////////////////////////////////////////////////////////////////////////; 830/// Eval for vectorized functions; 831// template <class T>; 832// T TF1::Eval(T x, T y, T z, T t) const; 833// {; 834// if (fType == EFType::kFormula); 835// return fFormula->Eval(x, y, z, t);; 836 ; 837// T xx[] = {x, y, z, t};; 838// Double_t *pp = (Double_t *)fParams->GetParameters();; 839// return ((TF1 *)this)->EvalPar(xx, pp);; 840// }; 841 ; 842// Internal to TF1. Evaluates Templated interfaces; 843template <class T>; 844inline T TF1::EvalParTempl(const T *data, const Double_t *params); 845{; 846 assert(fType == EFType::kTemplScalar || fType == EFType::kTemplVec);; 847 if (!params) params = (Double_t *)fParams->GetParameters();; 848 if (fFunctor); 849 return ((TF1FunctorPointerImpl<T> *)fFunctor.get())->fImpl(data, params);; 850 ; 851 // this should throw an error; 852 // we nned to implement a vectorized GetSave(x); 853 return TMath::SignalingNaN();; 854}; 855 ; 856#ifdef R__HAS_VECCORE; 857// Internal to TF1. Evaluates Vectorized TF1 on data of type Double_v; 858inline double TF1::EvalParVec(const Double_t *data, const Double_t *params); 859{; 860 assert(fType == EFType::kTemplVec);; 861 std::vector<ROOT::Double_v> d(fNdim);; 862 ROOT::Double_v res;; 863 ; 864 for(auto i=0; i<fNdim; i++) {; 865 d[i] = ROOT::Double_v(data[i]);; 866 }; 867 ; 868 if (fFunctor) {; 869 res = ((TF1FunctorPointerImpl<ROOT::Double_v> *) fFunctor.get())->fImpl(d.data(), params);; 870 } else {; 871 // res = GetSave(x);; 872 return TMath::SignalingNaN();; 873 }; 874 return vecCore::Get<ROOT::Double_v>(res, 0);; 875}; 876#endif; 877 ; 87",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:36772,Testability,assert,assert,36772,"kFormula); 835// return fFormula->Eval(x, y, z, t);; 836 ; 837// T xx[] = {x, y, z, t};; 838// Double_t *pp = (Double_t *)fParams->GetParameters();; 839// return ((TF1 *)this)->EvalPar(xx, pp);; 840// }; 841 ; 842// Internal to TF1. Evaluates Templated interfaces; 843template <class T>; 844inline T TF1::EvalParTempl(const T *data, const Double_t *params); 845{; 846 assert(fType == EFType::kTemplScalar || fType == EFType::kTemplVec);; 847 if (!params) params = (Double_t *)fParams->GetParameters();; 848 if (fFunctor); 849 return ((TF1FunctorPointerImpl<T> *)fFunctor.get())->fImpl(data, params);; 850 ; 851 // this should throw an error; 852 // we nned to implement a vectorized GetSave(x); 853 return TMath::SignalingNaN();; 854}; 855 ; 856#ifdef R__HAS_VECCORE; 857// Internal to TF1. Evaluates Vectorized TF1 on data of type Double_v; 858inline double TF1::EvalParVec(const Double_t *data, const Double_t *params); 859{; 860 assert(fType == EFType::kTemplVec);; 861 std::vector<ROOT::Double_v> d(fNdim);; 862 ROOT::Double_v res;; 863 ; 864 for(auto i=0; i<fNdim; i++) {; 865 d[i] = ROOT::Double_v(data[i]);; 866 }; 867 ; 868 if (fFunctor) {; 869 res = ((TF1FunctorPointerImpl<ROOT::Double_v> *) fFunctor.get())->fImpl(d.data(), params);; 870 } else {; 871 // res = GetSave(x);; 872 return TMath::SignalingNaN();; 873 }; 874 return vecCore::Get<ROOT::Double_v>(res, 0);; 875}; 876#endif; 877 ; 878inline void TF1::SetRange(Double_t xmin, Double_t, Double_t xmax, Double_t); 879{; 880 TF1::SetRange(xmin, xmax);; 881}; 882inline void TF1::SetRange(Double_t xmin, Double_t, Double_t, Double_t xmax, Double_t, Double_t); 883{; 884 TF1::SetRange(xmin, xmax);; 885}; 886 ; 887template <typename Func>; 888void TF1::SetFunction(Func f); 889{; 890 // set function from a generic C++ callable object; 891 fType = EFType::kPtrScalarFreeFcn;; 892 fFunctor = std::make_unique<TF1::TF1FunctorPointerImpl<double>>(ROOT::Math::ParamFunctor(f));; 893}; 894template <class PtrObj, typename MemFn>; 895void TF1::",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:46492,Testability,log,logx,46492,"finition TF1.h:55; TF1Parameters::CheckIndexbool CheckIndex(Int_t i) constDefinition TF1.h:133; TF1Parameters::SetParNamesvoid SetParNames(Args &&... args)Set parameter names.Definition TF1.h:156; TF1Parameters::SetParametersvoid SetParameters(const Double_t *params)Definition TF1.h:111; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1Parameters::TF1ParametersTF1Parameters(const TF1Parameters &rhs)Definition TF1.h:65; TF1Parameters::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAdd",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:46749,Testability,log,logx,46749,"Double_t *params)Definition TF1.h:111; TF1Parameters::GetParNumberInt_t GetParNumber(const char *name) constReturns the parameter number given a name not very efficient but list of parameters is typically smal...Definition TF1.cxx:3846; TF1Parameters::TF1ParametersTF1Parameters(const TF1Parameters &rhs)Definition TF1.h:65; TF1Parameters::GetParametersconst Double_t * GetParameters() constDefinition TF1.h:88; TF11-Dim function classDefinition TF1.h:233; TF1::fFunctorstd::unique_ptr< TF1FunctorPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Meanvirtual Double_t Mean(Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsil",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:47346,Testability,test,tested,47346,"rPointer > fFunctor! Functor object to wrap any C++ callable objectDefinition TF1.h:287; TF1::GetMinimumXvirtual Double_t GetMinimumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the minimum value of the function on the (xmin,...Definition TF1.cxx:1823; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::GetXmaxvirtual Double_t GetXmax() constDefinition TF1.h:584; TF1::ReleaseParametervirtual void ReleaseParameter(Int_t ipar)Release parameter number ipar during a fit operation.Definition TF1.cxx:3151; TF1::SetParErrorvirtual void SetParError(Int_t ipar, Double_t error)Set error for parameter number ipar.Definition TF1.cxx:3479; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::EAddToListEAddToListAdd to list behavior.Definition TF1.h:240; TF1::EAddToList::kDefault@ kDefault; TF1::EAddToList::kNo@ kNo; TF1::EAddToList::kAdd@ kAdd; TF1::Meanvirtual Double_t Mean(Double_t a, Double_t b, const Double_t *params=nullptr, Double_t epsilon=0.000001)Definition TF1.h:733; TF1::Derivativevirtual Double_t Derivative(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the first derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1113; TF1::GetParErrorsvirtual const Double_t * GetParErrors() constDefinition TF1.h:566; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::fParErrorsstd::vector< Doubl",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:61629,Testability,log,logx,61629,"h:327; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::TF1TF1(EFType functionType, const char *name, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim, EAddToList addToGlobList, TF1Parameters *params=nullptr, TF1FunctorPointer *functor=nullptr)General constructor for TF1. Most of the other constructors delegate on it.Definition TF1.h:293; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::DoInitializevoid DoInitialize(EAddToList addToGlobList)Common initialization of the TF1.Definition TF1.cxx:802; TF1::GetXvirtual Double_t GetX(Double_t y, Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the function value fy for (xmin<x<xmax).Definition TF1.cxx:1863; TF1::GetCurrentstatic TF1 * GetCurrent()Static function returning the current function being processed.Definition TF1.cxx:1569; TF1::SetParNamevirtual void SetParName(Int_t ipar, const char *name)Set name of parameter number ipar.Definition TF1.cxx:3450; TF1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TF1.cxx:1918; TF1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TF1.cxx:1536; TF1::GetSavevirtual Double_t GetSave(const Double_t *x)Get value corresponding to X in array of fSave values.Definition TF1.cxx:2344; TF1::fgAbsValuestatic std::atomic< Bool_t > fgAbsValueDefinition TF1.h:324; TF1::IsLinearvirtual Bool_t IsLinear() constDefinition TF1.h:630; TF1::SetParametersvirtual void SetParameters(double p0, double p1=TMath::QuietNaN(), double p2=TMath::Quiet",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:65749,Testability,log,logx,65749,"ool_t ComputeCdfTable(Option_t *opt)Compute the cumulative function at fNpx points between fXmin and fXmax.Definition TF1.cxx:2081; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::EvalParTemplT EvalParTempl(const T *data, const Double_t *params=nullptr)Eval for vectorized functions.Definition TF1.h:844; TF1::DrawIntegralvirtual TObject * DrawIntegral(Option_t *option=""al"")Draw integral of this function.Definition TF1.cxx:1407; TF1::fIntegralstd::vector< Double_t > fIntegral! Integral of function binned on fNpx binsDefinition TF1.h:278; TF1::DrawDerivativevirtual TObject * DrawDerivative(Option_t *option=""al"")Draw derivative of this function.Definition TF1.cxx:1385; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF1::fParamsstd::unique_ptr< TF1Parameters > fParamsPointer to Function parameters object (exists only for not-formula functions)Definition TF1.h:289; TF1::SetParametervirtual void SetParameter(const TString &name, Double_t value)Definition TF1.h:672; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF1::Derivative3virtual Double_t Derivative3(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the third derivative of the function at point x, computed by Richardson's extrapolation metho...Definition TF1.cxx:1243; TF1::Savevirtual void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax)Save values of function in array fSave.Definition TF1.cxx:3161; TF1::CloneTObject * Clone(const char *newname=nullptr) const overrideMake a complete copy of the underlying object.Definition TF1.cxx:1064; TF1::EFTypeEFTypeDefinit",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF1_8h_source.html:68094,Testability,log,logx,68094," TF1::kTemplVec@ kTemplVecVectorized free functions or TemplScalar functors evaluating on vectorized parameters,...Definition TF1.h:258; TF1::kInterpreted@ kInterpretedInterpreted functions constructed by name,.Definition TF1.h:257; TF1::SetSavedPointvirtual void SetSavedPoint(Int_t point, Double_t value)Restore value of function saved at point.Definition TF1.cxx:3542; TF1::FixParametervirtual void FixParameter(Int_t ipar, Double_t value)Fix the value of a parameter for a fit operation The specified value will be used in the fit and the ...Definition TF1.cxx:1557; TF1::IsInsidevirtual Bool_t IsInside(const Double_t *x) constreturn kTRUE if the point is inside the function rangeDefinition TF1.h:626; TF1::GetNpxvirtual Int_t GetNpx() constDefinition TF1.h:518; TF1::fXmaxDouble_t fXmaxUpper bounds for the range.Definition TF1.h:264; TF1::GetMaximumXvirtual Double_t GetMaximumX(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the X value corresponding to the maximum value of the function.Definition TF1.cxx:1655; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TF1::GetXminvirtual Double_t GetXmin() constDefinition TF1.h:580; TF1::AddToGlobalListvirtual Bool_t AddToGlobalList(Bool_t on=kTRUE)Add to global list of functions (gROOT->GetListOfFunctions() ) return previous status (true if the fu...Definition TF1.cxx:847; TF1::GetLinearPartvirtual const TObject * GetLinearPart(Int_t i) constDefinition TF1.h:493; TF1::SetVectorizedvirtual void SetVectorized(Bool_t vectorized)Definition TF1.h:715; TF1::IntegralOneDimvirtual Double_t IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &err)Return Integral of function between a and b using the given parameter values and relative and absolut...Definition TF1.cxx:2621; TF1::TF1TF1(const char *name, Func f, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault)Definition TF1.h:397; ",MatchSource.WIKI,doc/master/TF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:54592,Availability,error,error,54592,"efinition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:1",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:55904,Availability,mask,mask,55904,"nition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917. histhistsrcTF2.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:18641,Deployability,integrat,integrated,18641,"py));; 493 const char *drawOption = GetDrawOption();; 494 Double_t uxmin,uxmax;; 495 Double_t uymin,uymax;; 496 if (gPad->GetView() || strncmp(drawOption,""cont"",4) == 0; 497 || strncmp(drawOption,""CONT"",4) == 0) {; 498 uxmin=gPad->GetUxmin();; 499 uxmax=gPad->GetUxmax();; 500 x = fXmin +(fXmax-fXmin)*(x-uxmin)/(uxmax-uxmin);; 501 uymin=gPad->GetUymin();; 502 uymax=gPad->GetUymax();; 503 y = fYmin +(fYmax-fYmin)*(y-uymin)/(uymax-uymin);; 504 }; 505 snprintf(info,64,""(x=%g, y=%g, f=%.18g)"",x,y,((TF2*)this)->Eval(x,y));; 506 return info;; 507}; 508 ; 509////////////////////////////////////////////////////////////////////////////////; 510/// Return a random number following this function shape; 511 ; 512Double_t TF2::GetRandom(TRandom *, Option_t *); 513{; 514 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 515 return 0; // not yet implemented; 516}; 517 ; 518////////////////////////////////////////////////////////////////////////////////; 519/// Return a random number following this function shape; 520 ; 521 ; 522Double_t TF2::GetRandom(Double_t, Double_t, TRandom *, Option_t *); 523{; 524 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 525 return 0; // not yet implemented; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Return 2 random numbers following this function shape; 530///; 531/// The distribution contained in this TF2 function is integrated; 532/// over the cell contents.; 533/// It is normalized to 1.; 534/// Getting the two random numbers implies:; 535/// - Generating a random number between 0 and 1 (say r1); 536/// - Look in which cell in the normalized integral r1 corresponds to; 537/// - make a linear interpolation in the returned cell; 538///; 539///; 540/// IMPORTANT NOTE; 541///; 542/// The integral of the function is computed at fNpx * fNpy points.; 543/// If the function has sharp peaks, you should increase the number of; 544/// points (Se",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:18641,Integrability,integrat,integrated,18641,"py));; 493 const char *drawOption = GetDrawOption();; 494 Double_t uxmin,uxmax;; 495 Double_t uymin,uymax;; 496 if (gPad->GetView() || strncmp(drawOption,""cont"",4) == 0; 497 || strncmp(drawOption,""CONT"",4) == 0) {; 498 uxmin=gPad->GetUxmin();; 499 uxmax=gPad->GetUxmax();; 500 x = fXmin +(fXmax-fXmin)*(x-uxmin)/(uxmax-uxmin);; 501 uymin=gPad->GetUymin();; 502 uymax=gPad->GetUymax();; 503 y = fYmin +(fYmax-fYmin)*(y-uymin)/(uymax-uymin);; 504 }; 505 snprintf(info,64,""(x=%g, y=%g, f=%.18g)"",x,y,((TF2*)this)->Eval(x,y));; 506 return info;; 507}; 508 ; 509////////////////////////////////////////////////////////////////////////////////; 510/// Return a random number following this function shape; 511 ; 512Double_t TF2::GetRandom(TRandom *, Option_t *); 513{; 514 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 515 return 0; // not yet implemented; 516}; 517 ; 518////////////////////////////////////////////////////////////////////////////////; 519/// Return a random number following this function shape; 520 ; 521 ; 522Double_t TF2::GetRandom(Double_t, Double_t, TRandom *, Option_t *); 523{; 524 Error(""GetRandom"",""cannot be called for TF2/3, use GetRandom2/3 instead"");; 525 return 0; // not yet implemented; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Return 2 random numbers following this function shape; 530///; 531/// The distribution contained in this TF2 function is integrated; 532/// over the cell contents.; 533/// It is normalized to 1.; 534/// Getting the two random numbers implies:; 535/// - Generating a random number between 0 and 1 (say r1); 536/// - Look in which cell in the normalized integral r1 corresponds to; 537/// - make a linear interpolation in the returned cell; 538///; 539///; 540/// IMPORTANT NOTE; 541///; 542/// The integral of the function is computed at fNpx * fNpy points.; 543/// If the function has sharp peaks, you should increase the number of; 544/// points (Se",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:53156,Integrability,rout,routine,53156,"angevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TF2::Classstatic TClass * Class(); TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetContourLevelvirtual Double_t GetContourLevel(Int_t level) constReturn value of contour number level.Definition TH1.cxx:8430; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void ",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:54213,Integrability,message,message,54213," TH1.cxx:6206; TH1::GetContourLevelvirtual Double_t GetContourLevel(Int_t level) constReturn value of contour number level.Definition TH1.cxx:8430; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefin",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:54598,Integrability,message,message,54598,"efinition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:1",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:54876,Integrability,message,message,54876,"of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FiniteInt_t Finite(Double_",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:1108,Modifiability,variab,variables,1108,"atches. TF2.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Rene Brun 23/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TF2.h""; 14#include ""TMath.h""; 15#include ""TRandom.h""; 16#include ""TBuffer.h""; 17#include ""TH2.h""; 18#include ""TVirtualPad.h""; 19#include <iostream>; 20#include ""TColor.h""; 21#include ""TVirtualFitter.h""; 22#include ""Math/IntegratorOptions.h""; 23#include ""snprintf.h""; 24 ; 25ClassImp(TF2);; 26 ; 27/** \class TF2; 28 \ingroup Functions; 29 \brief A 2-Dim function with parameters.; 30 ; 31The following types of functions can be created:; 32 ; 331. [Expression using variables x and y](\ref TF2a); 342. [Expression using a user defined function](\ref TF2b); 353. [Lambda Expression with x and y variables and parameters](\ref TF2c); 36 ; 37\anchor TF2a; 38### Expression using variables x and y; 39 ; 40Begin_Macro (source); 41{; 42 auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; 43 f2->Draw();; 44}; 45End_Macro; 46 ; 47\anchor TF2b; 48### Expression using a user defined function; 49 ; 50~~~~{.cpp}; 51Double_t func(Double_t *val, Double_t *par); 52{; 53 Float_t x = val[0];; 54 Float_t y = val[1];; 55 Double_t f = x*x-y*y;; 56 return f;; 57}; 58 ; 59void fplot(); 60{; 61 auto f = new TF2(""f"",func,-1,1,-1,1);; 62 f->Draw(""surf1"");; 63}; 64~~~~; 65 ; 66\anchor TF2c; 67### Lambda Expression with x and y variables and parameters; 68 ; 69~~~~{.cpp}; 70root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); 71(TF2 &) Name: f2 Title: f2; 72root [1] f2.SetParameter(0, 1.); 73root [2] f2.Eval(1., 2.); 74(double) 3.0000000",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:1236,Modifiability,variab,variables,1236," All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TF2.h""; 14#include ""TMath.h""; 15#include ""TRandom.h""; 16#include ""TBuffer.h""; 17#include ""TH2.h""; 18#include ""TVirtualPad.h""; 19#include <iostream>; 20#include ""TColor.h""; 21#include ""TVirtualFitter.h""; 22#include ""Math/IntegratorOptions.h""; 23#include ""snprintf.h""; 24 ; 25ClassImp(TF2);; 26 ; 27/** \class TF2; 28 \ingroup Functions; 29 \brief A 2-Dim function with parameters.; 30 ; 31The following types of functions can be created:; 32 ; 331. [Expression using variables x and y](\ref TF2a); 342. [Expression using a user defined function](\ref TF2b); 353. [Lambda Expression with x and y variables and parameters](\ref TF2c); 36 ; 37\anchor TF2a; 38### Expression using variables x and y; 39 ; 40Begin_Macro (source); 41{; 42 auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; 43 f2->Draw();; 44}; 45End_Macro; 46 ; 47\anchor TF2b; 48### Expression using a user defined function; 49 ; 50~~~~{.cpp}; 51Double_t func(Double_t *val, Double_t *par); 52{; 53 Float_t x = val[0];; 54 Float_t y = val[1];; 55 Double_t f = x*x-y*y;; 56 return f;; 57}; 58 ; 59void fplot(); 60{; 61 auto f = new TF2(""f"",func,-1,1,-1,1);; 62 f->Draw(""surf1"");; 63}; 64~~~~; 65 ; 66\anchor TF2c; 67### Lambda Expression with x and y variables and parameters; 68 ; 69~~~~{.cpp}; 70root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); 71(TF2 &) Name: f2 Title: f2; 72root [1] f2.SetParameter(0, 1.); 73root [2] f2.Eval(1., 2.); 74(double) 3.0000000; 75~~~~; 76 ; 77See TF1 class for the list of functions formats; 78*/; 79 ; 80////////////////////////////////////////////////////////////////////////////////; 81/// TF2 default constructor; 82 ; 83TF2::TF2(): fYmin(0),fYmax(0),fNpy(100); 84{; 85}; 86 ; 87 ;",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:1318,Modifiability,variab,variables,1318," All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TF2.h""; 14#include ""TMath.h""; 15#include ""TRandom.h""; 16#include ""TBuffer.h""; 17#include ""TH2.h""; 18#include ""TVirtualPad.h""; 19#include <iostream>; 20#include ""TColor.h""; 21#include ""TVirtualFitter.h""; 22#include ""Math/IntegratorOptions.h""; 23#include ""snprintf.h""; 24 ; 25ClassImp(TF2);; 26 ; 27/** \class TF2; 28 \ingroup Functions; 29 \brief A 2-Dim function with parameters.; 30 ; 31The following types of functions can be created:; 32 ; 331. [Expression using variables x and y](\ref TF2a); 342. [Expression using a user defined function](\ref TF2b); 353. [Lambda Expression with x and y variables and parameters](\ref TF2c); 36 ; 37\anchor TF2a; 38### Expression using variables x and y; 39 ; 40Begin_Macro (source); 41{; 42 auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; 43 f2->Draw();; 44}; 45End_Macro; 46 ; 47\anchor TF2b; 48### Expression using a user defined function; 49 ; 50~~~~{.cpp}; 51Double_t func(Double_t *val, Double_t *par); 52{; 53 Float_t x = val[0];; 54 Float_t y = val[1];; 55 Double_t f = x*x-y*y;; 56 return f;; 57}; 58 ; 59void fplot(); 60{; 61 auto f = new TF2(""f"",func,-1,1,-1,1);; 62 f->Draw(""surf1"");; 63}; 64~~~~; 65 ; 66\anchor TF2c; 67### Lambda Expression with x and y variables and parameters; 68 ; 69~~~~{.cpp}; 70root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); 71(TF2 &) Name: f2 Title: f2; 72root [1] f2.SetParameter(0, 1.); 73root [2] f2.Eval(1., 2.); 74(double) 3.0000000; 75~~~~; 76 ; 77See TF1 class for the list of functions formats; 78*/; 79 ; 80////////////////////////////////////////////////////////////////////////////////; 81/// TF2 default constructor; 82 ; 83TF2::TF2(): fYmin(0),fYmax(0),fNpy(100); 84{; 85}; 86 ; 87 ;",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:1858,Modifiability,variab,variables,1858,"7#include ""TH2.h""; 18#include ""TVirtualPad.h""; 19#include <iostream>; 20#include ""TColor.h""; 21#include ""TVirtualFitter.h""; 22#include ""Math/IntegratorOptions.h""; 23#include ""snprintf.h""; 24 ; 25ClassImp(TF2);; 26 ; 27/** \class TF2; 28 \ingroup Functions; 29 \brief A 2-Dim function with parameters.; 30 ; 31The following types of functions can be created:; 32 ; 331. [Expression using variables x and y](\ref TF2a); 342. [Expression using a user defined function](\ref TF2b); 353. [Lambda Expression with x and y variables and parameters](\ref TF2c); 36 ; 37\anchor TF2a; 38### Expression using variables x and y; 39 ; 40Begin_Macro (source); 41{; 42 auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; 43 f2->Draw();; 44}; 45End_Macro; 46 ; 47\anchor TF2b; 48### Expression using a user defined function; 49 ; 50~~~~{.cpp}; 51Double_t func(Double_t *val, Double_t *par); 52{; 53 Float_t x = val[0];; 54 Float_t y = val[1];; 55 Double_t f = x*x-y*y;; 56 return f;; 57}; 58 ; 59void fplot(); 60{; 61 auto f = new TF2(""f"",func,-1,1,-1,1);; 62 f->Draw(""surf1"");; 63}; 64~~~~; 65 ; 66\anchor TF2c; 67### Lambda Expression with x and y variables and parameters; 68 ; 69~~~~{.cpp}; 70root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); 71(TF2 &) Name: f2 Title: f2; 72root [1] f2.SetParameter(0, 1.); 73root [2] f2.Eval(1., 2.); 74(double) 3.0000000; 75~~~~; 76 ; 77See TF1 class for the list of functions formats; 78*/; 79 ; 80////////////////////////////////////////////////////////////////////////////////; 81/// TF2 default constructor; 82 ; 83TF2::TF2(): fYmin(0),fYmax(0),fNpy(100); 84{; 85}; 86 ; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// F2 constructor using a formula definition; 90///; 91/// See TFormula constructor for explanation of the formula syntax.; 92///; 93/// If formula has the form ""fffffff;xxxx;yyyy"", it is assumed that; 94/// the formula string is ""fffffff"" and ""xxxx"" and ""yyy",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:11435,Performance,perform,performed,11435,"vels) {; 330 for (Int_t level=0; level<nlevels; level++) levels[level] = GetContourLevel(level);; 331 }; 332 return nlevels;; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// Return the number of contour levels; 337 ; 338Double_t TF2::GetContourLevel(Int_t level) const; 339{; 340 if (level <0 || level >= fContour.fN) return 0;; 341 if (fContour.fArray[0] != -9999) return fContour.fArray[level];; 342 if (fHistogram == nullptr) return 0;; 343 return fHistogram->GetContourLevel(level);; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// Return minimum/maximum value of the function; 348///; 349/// To find the minimum on a range, first set this range via the SetRange function.; 350/// If a vector x of coordinate is passed it will be used as starting point for the minimum.; 351/// In addition on exit x will contain the coordinate values at the minimuma; 352///; 353/// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; 354/// minimum location. The range of the function is divided into fNpx and fNpy; 355/// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; 356/// by SetNpx and SetNpy functions; 357///; 358/// Then, a minimization is used with starting values found by the grid search; 359/// The minimizer algorithm used (by default Minuit) can be changed by callinga; 360/// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); 361/// Other option for the minimizer can be set using the static method of the MinimizerOptions class; 362 ; 363Double_t TF2::FindMinMax(Double_t *x, Bool_t findmax) const; 364{; 365 //First do a grid search with step size fNpx and fNpy; 366 ; 367 Double_t xx[2];; 368 Double_t rsign = (findmax) ? -1. : 1.;; 369 TF2 & function = const_cast<TF2&>(*this); // needed since EvalPar is not const; 370 Double_t xxmin = 0, yymin = 0, zzmin = 0;; 371 if (x == nullptr || (",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:13732,Performance,perform,performed,13732,"his); // needed since EvalPar is not const; 370 Double_t xxmin = 0, yymin = 0, zzmin = 0;; 371 if (x == nullptr || ( (x!= nullptr) && ( !TMath::Finite(x[0]) || !TMath::Finite(x[1]) ) ) ){; 372 Double_t dx = (fXmax - fXmin)/fNpx;; 373 Double_t dy = (fYmax - fYmin)/fNpy;; 374 xxmin = fXmin;; 375 yymin = fYmin;; 376 zzmin = rsign * TMath::Infinity();; 377 for (Int_t i=0; i<fNpx; i++){; 378 xx[0]=fXmin + (i+0.5)*dx;; 379 for (Int_t j=0; j<fNpy; j++){; 380 xx[1]=fYmin+(j+0.5)*dy;; 381 Double_t zz = function(xx);; 382 if (rsign*zz < rsign*zzmin) {xxmin = xx[0], yymin = xx[1]; zzmin = zz;}; 383 }; 384 }; 385 ; 386 xxmin = TMath::Min(fXmax, xxmin);; 387 yymin = TMath::Min(fYmax, yymin);; 388 }; 389 else {; 390 xxmin = x[0];; 391 yymin = x[1];; 392 zzmin = function(x);; 393 }; 394 xx[0] = xxmin;; 395 xx[1] = yymin;; 396 ; 397 double fmin = GetMinMaxNDim(xx,findmax);; 398 if (rsign*fmin < rsign*zzmin) {; 399 if (x) {x[0] = xx[0]; x[1] = xx[1]; }; 400 return fmin;; 401 }; 402 // here if minimization failed; 403 if (x) { x[0] = xxmin; x[1] = yymin; }; 404 return zzmin;; 405}; 406 ; 407////////////////////////////////////////////////////////////////////////////////; 408/// Compute the X and Y values corresponding to the minimum value of the function; 409///; 410/// Return the minimum value of the function; 411/// To find the minimum on a range, first set this range via the SetRange function; 412///; 413/// Method:; 414/// First, a grid search is performed to find the initial estimate of the; 415/// minimum location. The range of the function is divided into fNpx and fNpy; 416/// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; 417/// by SetNpx and SetNpy functions; 418/// Then, a minimization is used with starting values found by the grid search; 419/// The minimizer algorithm used (by default Minuit) can be changed by callinga; 420/// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); 421/// Other option for the minimizer can be set using the sta",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:15728,Performance,perform,performed,15728,"; 432}; 433 ; 434////////////////////////////////////////////////////////////////////////////////; 435/// Compute the X and Y values corresponding to the maximum value of the function; 436///; 437/// Return the maximum value of the function; 438/// See TF2::GetMinimumXY; 439 ; 440Double_t TF2::GetMaximumXY(Double_t &x, Double_t &y) const; 441{; 442 double xx[2] = { 0,0 };; 443 xx[0] = TMath::QuietNaN(); // to force to do grid search in TF2::FindMinMax; 444 double fmax = FindMinMax(xx, true);; 445 x = xx[0]; y = xx[1];; 446 return fmax;; 447}; 448 ; 449 ; 450////////////////////////////////////////////////////////////////////////////////; 451/// Return minimum/maximum value of the function; 452///; 453/// To find the minimum on a range, first set this range via the SetRange function; 454/// If a vector x of coordinate is passed it will be used as starting point for the minimum.; 455/// In addition on exit x will contain the coordinate values at the minimuma; 456/// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; 457/// minimum location. The range of the function is divided into fNpx and fNpy; 458/// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; 459/// by SetNpx and SetNpy functions; 460/// Then, a minimization is used with starting values found by the grid search; 461/// The minimizer algorithm used (by default Minuit) can be changed by callinga; 462/// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); 463/// Other option for the minimizer can be set using the static method of the MinimizerOptions class; 464 ; 465Double_t TF2::GetMinimum(Double_t *x) const; 466{; 467 return FindMinMax(x, false);; 468}; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Return maximum value of the function; 472/// See TF2::GetMinimum; 473 ; 474Double_t TF2::GetMaximum(Double_t *x) const; 475{; 476 return FindMinMax(x, true);; 477}; 478 ; 479 ;",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:28009,Usability,clear,clear,28009,"; 777 fHistogram->SetLineStyle(GetLineStyle());; 778 fHistogram->SetLineWidth(GetLineWidth());; 779 fHistogram->SetFillColor(GetFillColor());; 780 fHistogram->SetFillStyle(GetFillStyle());; 781 fHistogram->SetMarkerColor(GetMarkerColor());; 782 fHistogram->SetMarkerStyle(GetMarkerStyle());; 783 fHistogram->SetMarkerSize(GetMarkerSize());; 784 fHistogram->SetStats(false);; 785 ; 786//- Draw the histogram; 787 if (!gPad) return;; 788 if (opt.Length() == 0) fHistogram->Paint(""cont3"");; 789 else if (opt == ""same"") fHistogram->Paint(""cont2same"");; 790 else fHistogram->Paint(option);; 791}; 792 ; 793////////////////////////////////////////////////////////////////////////////////; 794/// Save values of function in array fSave; 795 ; 796void TF2::Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t, Double_t); 797{; 798 if (!fSave.empty()); 799 fSave.clear();; 800 Int_t npx = fNpx, npy = fNpy;; 801 if ((npx < 2) || (npy < 2)); 802 return;; 803 Double_t dx = (xmax-xmin)/fNpx;; 804 Double_t dy = (ymax-ymin)/fNpy;; 805 if (dx <= 0) {; 806 dx = (fXmax-fXmin)/fNpx;; 807 npx--;; 808 xmin = fXmin + 0.5*dx;; 809 xmax = fXmax - 0.5*dx;; 810 }; 811 if (dy <= 0) {; 812 dy = (fYmax-fYmin)/fNpy;; 813 npy--;; 814 ymin = fYmin + 0.5*dy;; 815 ymax = fYmax - 0.5*dy;; 816 }; 817 ; 818 Int_t nsave = (npx + 1) * (npy + 1);; 819 fSave.resize(nsave + 6);; 820 Double_t xv[2];; 821 Double_t *parameters = GetParameters();; 822 InitArgs(xv, parameters);; 823 for (Int_t j = 0, k = 0; j <= npy; j++) {; 824 xv[1] = ymin + dy*j;; 825 for (Int_t i = 0; i <= npx; i++) {; 826 xv[0] = xmin + dx*i;; 827 fSave[k++] = EvalPar(xv, parameters);; 828 }; 829 }; 830 fSave[nsave+0] = xmin;; 831 fSave[nsave+1] = xmax;; 832 fSave[nsave+2] = ymin;; 833 fSave[nsave+3] = ymax;; 834 fSave[nsave+4] = npx;; 835 fSave[nsave+5] = npy;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// Save primitive as a C++ statement(s) on output stream out; 840 ; 841",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8cxx_source.html:34499,Usability,clear,clear,34499,"65 //====process old versions before automatic schema evolution; 966 Int_t nlevels;; 967 TF1::Streamer(R__b);; 968 if (R__v < 3) {; 969 Float_t ymin,ymax;; 970 R__b >> ymin; fYmin = ymin;; 971 R__b >> ymax; fYmax = ymax;; 972 } else {; 973 R__b >> fYmin;; 974 R__b >> fYmax;; 975 }; 976 R__b >> fNpy;; 977 R__b >> nlevels;; 978 if (R__v < 3) {; 979 Float_t *contour = nullptr;; 980 Int_t n = R__b.ReadArray(contour);; 981 fContour.Set(n);; 982 for (Int_t i=0;i<n;i++) fContour.fArray[i] = contour[i];; 983 delete [] contour;; 984 } else {; 985 fContour.Streamer(R__b);; 986 }; 987 R__b.CheckByteCount(R__s, R__c, TF2::IsA());; 988 //====end of old versions; 989 ; 990 } else {; 991 Int_t saved = 0;; 992 if (fType != EFType::kFormula && fSave.empty()) { saved = 1; Save(fXmin,fXmax,fYmin,fYmax,0,0);}; 993 ; 994 R__b.WriteClassBuffer(TF2::Class(),this);; 995 ; 996 if (saved) {fSave.clear(); }; 997 }; 998}; 999 ; 1000////////////////////////////////////////////////////////////////////////////////; 1001/// Return x^nx * y^ny moment of a 2d function in range [ax,bx],[ay,by]; 1002/// \author Gene Van Buren <gene@bnl.gov>; 1003 ; 1004Double_t TF2::Moment2(Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon); 1005{; 1006 Double_t norm = Integral(ax,bx,ay,by,epsilon);; 1007 if (norm == 0) {; 1008 Error(""Moment2"", ""Integral zero over range"");; 1009 return 0;; 1010 }; 1011 ; 1012 // define integrand function as a lambda : g(x,y)= x^(nx) * y^(ny) * f(x,y); 1013 auto integrand = [&](double *x, double *) {; 1014 return std::pow(x[0], nx) * std::pow(x[1], ny) * this->EvalPar(x, nullptr);; 1015 };; 1016 // compute integral of g(x,y); 1017 TF2 fnc(""TF2_ExpValHelper"",integrand,ax,bx,ay,by,0);; 1018 // set same points as current function to get correct max points when computing the integral; 1019 fnc.fNpx = fNpx;; 1020 fnc.fNpy = fNpy;; 1021 return fnc.Integral(ax,bx,ay,by,epsilon)/norm;; 1022}; 1023 ; 1024///////////////////////////////////////////////",MatchSource.WIKI,doc/master/TF2_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html
https://root.cern/doc/master/TF2_8h.html:205,Integrability,depend,dependency,205,". ROOT: hist/hist/inc/TF2.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TF2.h File Reference. #include ""TF1.h""; #include ""TArrayD.h"". Include dependency graph for TF2.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TF2;  A 2-Dim function with parameters. More...;  . histhistincTF2.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TF2_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8h.html
https://root.cern/doc/master/TF2_8h_source.html:9114,Testability,log,logx,9114,"n Rtypes.h:346; TArrayD.h; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; ROOT::Math::ParamFunctorTemplParam Functor class for Multidimensional functions.Definition ParamFunctor.h:274; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TF11-Dim function classDefinition TF1.h:233; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetRangevirtual void GetRange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetMaximumXYvirtual Double_t GetMaximumXY(Double_t &x, Double_t &y) constCompute the X and Y values correspondin",MatchSource.WIKI,doc/master/TF2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8h_source.html
https://root.cern/doc/master/TF2_8h_source.html:9884,Testability,log,logx,9884," bits per element).Definition TArrayD.h:27; TF11-Dim function classDefinition TF1.h:233; TF1::GetMinimumvirtual Double_t GetMinimum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the minimum value of the function on the (xmin, xmax) interval.Definition TF1.cxx:1696; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetRangevirtual void GetRange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::fNpxInt_t fNpxNumber of points used for the graphical representation.Definition TF1.h:267; TF1::GetMaximumvirtual Double_t GetMaximum(Double_t xmin=0, Double_t xmax=0, Double_t epsilon=1.E-10, Int_t maxiter=100, Bool_t logx=false) constReturns the maximum value of the function.Definition TF1.cxx:1614; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetMaximumXYvirtual Double_t GetMaximumXY(Double_t &x, Double_t &y) constCompute the X and Y values corresponding to the maximum value of the function.Definition TF2.cxx:440; TF2::FindMinMaxvirtual Double_t FindMinMax(Double_t *x, bool findmax) constReturn minimum/maximum value of the function.Definition TF2.cxx:363; TF2::~TF2~TF2() overrideF2 default destructor.Definition TF2.cxx:195; TF2::GetMinimumvirtual Double_t GetMinimum(Double_t *x) constReturn minimum/maximum value of the function.Definition TF2.cxx:465; TF2::Copyvoid Copy(TObject &f2) const overrideCopy this F2 to a new F2.Definition TF2.cxx:210; TF2::GetRandom2virtual void GetRandom2(Double_t &xrandom, Double_t &yrandom, TRandom *rng=nullptr)Return 2 random numbers following this function shape.Definition TF2.cxx:547; TF2::GetSaveDouble_t GetSave(const Double_t *x) overrideGet value correspondin",MatchSource.WIKI,doc/master/TF2_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TF2_8h_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:13339,Availability,recover,recovery,13339,"In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating temporary filenames) a value can be passed to the reproducible; 335/// option to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:14746,Availability,error,error,14746,"""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating temporary filenames) a value can be passed to the reproducible; 335/// option to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = TFile::Open(""tmpname.root?reproducible=fixedname"",""RECREATE"",""File title"");; 338/// ~~~; 339 ; 340TFile::TFile(const char *fname1, Option_t *option, const char *ftitle, Int_t compress); 341 : TDirectoryFile(), fCompress(compress), fUrl(fname1,kTRUE); 342{; 343 if (!gROOT); 344 ::Fatal(""TFile::TFile"", ""ROOT system not initialized"");; 345 ; 346 auto zombify = [this] {; 347 // error in file opening occurred, make this object a zombie; 348 if (fGlobalRegistration) {; 349 R__LOCKGUARD(gROOTMutex);; 350 gROOT->GetListOfClosedObjects()->Add(this);; 351 }; 352 MakeZombie();; 353 gDirectory = gROOT;; 354 };; 355 ; 356 fOption = option;; 357 if (strlen(fUrl.GetProtocol()) != 0 && strcmp(fUrl.GetProtocol(), ""file"") != 0 && !fOption.BeginsWith(""NET"") &&; 358 !fOption.BeginsWith(""WEB"")) {; 359 Error(""TFile"",; 360 ""please use TFile::Open to access remote files:\n\tauto f = std::unique_ptr<TFile>{TFile::Open(\""%s\"")};"",; 361 fname1);; 362 zombify();; 363 return;; 364 }; 365 ; 366 // store name without the options as name and title; 367 TString sfname1 = fname1;; 368 if (sfname1.Index(""?"") != kNPOS) {; 369 TString s = sfname1(0, sfname1.Index(""?""));; 370 SetName(s);; 371 fNoAnchorInName = kTRUE;; 372 } else; 373 SetName(fname1);; 374 ; 375 SetTitle(ftitle);; 376 ; 377 // accept also URL like ""file:..."" syntax; 378 fname1 = fUrl.GetFi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:18567,Availability,error,error,18567,"!recreate && !update && !read) {; 442 read = kTRUE;; 443 fOption = ""READ"";; 444 }; 445 ; 446 Bool_t devnull = kFALSE;; 447 ; 448 if (!fname1 || !fname1[0]) {; 449 Error(""TFile"", ""file name is not specified"");; 450 zombify();; 451 return;; 452 }; 453 ; 454 // support dumping to /dev/null on UNIX; 455 if (!strcmp(fname1, ""/dev/null"") &&; 456 !gSystem->AccessPathName(fname1, kWritePermission)) {; 457 devnull = kTRUE;; 458 create = kTRUE;; 459 recreate = kFALSE;; 460 update = kFALSE;; 461 read = kFALSE;; 462 fOption = ""CREATE"";; 463 SetBit(kDevNull);; 464 }; 465 ; 466 TString fname(fname1);; 467 if (!gSystem->ExpandPathName(fname)) {; 468 SetName(fname.Data());; 469 fRealName = GetName();; 470 if (!gSystem->IsAbsoluteFileName(fRealName)) {; 471 gSystem->PrependPathName(gSystem->WorkingDirectory(),fRealName);; 472 }; 473 fname = fRealName.Data();; 474 } else {; 475 Error(""TFile"", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option take it as the name to set for; 481 // the file instead of the actual filename; 482 if (TestBit(kReproducible)) {; 483 if(auto name=fUrl.GetValueFromOptions(""reproducible"")) {; 484 SetName(name);; 485 }; 486 }; 487 ; 488 if (recreate) {; 489 if (!gSystem->AccessPathName(fname.Data(), kFileExists)) {; 490 if (gSystem->Unlink(fname.Data()) != 0) {; 491 SysError(""TFile"", ""could not delete %s (errno: %d)"",; 492 fname.Data(), gSystem->GetErrno());; 493 zombify();; 494 return;; 495 }; 496 }; 497 recreate = kFALSE;; 498 create = kTRUE;; 499 fOption = ""CREATE"";; 500 }; 501 if (create && !devnull && !gSystem->AccessPathName(fname.Data(), kFileExists)) {; 502 Error(""TFile"", ""file %s already exists"", fname.Data());; 503 zombify();; 504 return;; 505 }; 506 if (update) {; 507 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 508 update = kFALSE;; 509 create = kTRUE;; 510 }; 511 if (update && gSystem->AccessPathName(fname.Data(), kWritePermission)) {; 512 Error(""TFile"", ""no",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:21357,Availability,down,down,21357," ""file %s can not be opened"", fname.Data());; 539 zombify();; 540 return;; 541 }; 542 fWritable = kTRUE;; 543 } else {; 544#ifndef WIN32; 545 fD = TFile::SysOpen(fname.Data(), O_RDONLY, 0644);; 546#else; 547 fD = TFile::SysOpen(fname.Data(), O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);; 548#endif; 549 if (fD == -1) {; 550 SysError(""TFile"", ""file %s can not be opened for reading"", fname.Data());; 551 zombify();; 552 return;; 553 }; 554 fWritable = kFALSE;; 555 }; 556 ; 557 // calling virtual methods from constructor not a good idea, but it is how code was developed; 558 TFile::Init(create); // NOLINT: silence clang-tidy warnings; 559}; 560 ; 561////////////////////////////////////////////////////////////////////////////////; 562/// File destructor.; 563 ; 564TFile::~TFile(); 565{; 566 Close(); // NOLINT: silence clang-tidy warnings; 567 ; 568 // In case where the TFile is still open at 'tear-down' time the order of operation will be; 569 // call Close(""nodelete""); 570 // then later call delete TFile; 571 // which means that at this point we might still have object held and those; 572 // might requires a 'valid' TFile object in their desctructor (for example,; 573 // TTree call's GetReadCache which expects a non-null fCacheReadMap).; 574 // So delete the objects (if any) now.; 575 ; 576 if (fList); 577 fList->Delete(""slow"");; 578 ; 579 SafeDelete(fAsyncHandle);; 580 SafeDelete(fCacheRead);; 581 SafeDelete(fCacheReadMap);; 582 SafeDelete(fCacheWrite);; 583 SafeDelete(fProcessIDs);; 584 SafeDelete(fFree);; 585 SafeDelete(fArchive);; 586 SafeDelete(fInfoCache);; 587 SafeDelete(fOpenPhases);; 588 ; 589 if (fGlobalRegistration) {; 590 R__LOCKGUARD(gROOTMutex);; 591 gROOT->GetListOfClosedObjects()->Remove(this);; 592 gROOT->GetUUIDs()->RemoveUUID(GetUniqueID());; 593 }; 594 ; 595 if (IsOnHeap()) {; 596 // Delete object from CINT symbol table so it can not be used anymore.; 597 // CINT object are always on the heap.; 598 gInterpreter->ResetGlobalVar(this);; 599 }; 600 ; 601 if (",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:25236,Availability,failure,failure,25236,"""Init"", ""archive %s can only be opened in read mode"", GetName());; 629 delete fArchive;; 630 fArchive = nullptr;; 631 fIsArchive = kFALSE;; 632 goto zombie;; 633 }; 634 ; 635 fArchive->OpenArchive();; 636 ; 637 if (fIsArchive) return;; 638 ; 639 // Make sure the anchor is in the name; 640 if (!fNoAnchorInName); 641 if (!strchr(GetName(),'#')); 642 SetName(TString::Format(""%s#%s"", GetName(), fArchive->GetMemberName()));; 643 ; 644 if (fArchive->SetCurrentMember() != -1); 645 fArchiveOffset = fArchive->GetMemberFilePosition();; 646 else {; 647 Error(""Init"", ""member %s not found in archive %s"",; 648 fArchive->GetMemberName(), fArchive->GetArchiveName());; 649 delete fArchive;; 650 fArchive = nullptr;; 651 fIsArchive = kFALSE;; 652 goto zombie;; 653 }; 654 }; 655 ; 656 Int_t nfree;; 657 fBEGIN = (Long64_t)kBEGIN; //First used word in file following the file header; 658 ; 659 // make newly opened file the current file and directory; 660 cd();; 661 ; 662 if (create) {; 663 //*-*---------------NEW file; 664 fFree = new TList;; 665 fEND = fBEGIN; //Pointer to end of file; 666 new TFree(fFree, fBEGIN, Long64_t(kStartBigFile)); //Create new free list; 667 ; 668 //*-* Write Directory info; 669 Int_t namelen= TNamed::Sizeof();; 670 Int_t nbytes = namelen + TDirectoryFile::Sizeof();; 671 TKey *key = new TKey(fName, fTitle, IsA(), nbytes, this);; 672 fNbytesName = key->GetKeylen() + namelen;; 673 fSeekDir = key->GetSeekKey();; 674 fSeekFree = 0;; 675 fNbytesFree = 0;; 676 WriteHeader();; 677 char *buffer = key->GetBuffer();; 678 TNamed::FillBuffer(buffer);; 679 TDirectoryFile::FillBuffer(buffer);; 680 key->WriteFile();; 681 delete key;; 682 } else {; 683 //*-*----------------UPDATE; 684 //char *header = new char[kBEGIN];; 685 char *header = new char[kBEGIN+200];; 686 Seek(0); // NOLINT: silence clang-tidy warnings; 687 //ReadBuffer(header, kBEGIN);; 688 if (ReadBuffer(header, kBEGIN+200)) { // NOLINT: silence clang-tidy warnings; 689 // ReadBuffer returns kTRUE in case of failure.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:27923,Availability,failure,failure,27923,"ader length (%lld) or incorrect end of file length (%lld)"",; 733 GetName(),fBEGIN,fEND);; 734 delete [] header;; 735 goto zombie;; 736 }; 737 fSeekDir = fBEGIN;; 738 //*-*-------------Read Free segments structure if file is writable; 739 if (fWritable) {; 740 fFree = new TList;; 741 if (fSeekFree > fBEGIN) {; 742 ReadFree(); // NOLINT: silence clang-tidy warnings; 743 } else {; 744 Warning(""Init"",""file %s probably not closed, cannot read free segments"",GetName());; 745 }; 746 }; 747 //*-*-------------Read directory info; 748 // buffer_keyloc is the start of the key record.; 749 char *buffer_keyloc = nullptr;; 750 ; 751 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 752 if ( (nbytes + fBEGIN) > fEND) {; 753 // humm fBEGIN is wrong ....; 754 Error(""Init"",""file %s has an incorrect header length (%lld) or incorrect end of file length (%lld)"",; 755 GetName(),fBEGIN+nbytes,fEND);; 756 delete [] header;; 757 goto zombie;; 758 }; 759 if (nbytes+fBEGIN > kBEGIN+200) {; 760 delete [] header;; 761 header = new char[nbytes];; 762 buffer = header;; 763 Seek(fBEGIN); // NOLINT: silence clang-tidy warnings; 764 if (ReadBuffer(buffer,nbytes)) { // NOLINT: silence clang-tidy warnings; 765 // ReadBuffer returns kTRUE in case of failure.; 766 Error(""Init"",""%s failed to read the file header information at %lld (size=%d)"",; 767 GetName(),fBEGIN,nbytes);; 768 delete [] header;; 769 goto zombie;; 770 }; 771 buffer = header+fNbytesName;; 772 buffer_keyloc = header;; 773 } else {; 774 buffer = header+fBEGIN+fNbytesName;; 775 buffer_keyloc = header+fBEGIN;; 776 }; 777 Version_t version,versiondir;; 778 frombuf(buffer,&version); versiondir = version%1000;; 779 fDatimeC.ReadBuffer(buffer);; 780 fDatimeM.ReadBuffer(buffer);; 781 frombuf(buffer, &fNbytesKeys);; 782 frombuf(buffer, &fNbytesName);; 783 if (version > 1000) {; 784 frombuf(buffer, &fSeekDir);; 785 frombuf(buffer, &fSeekParent);; 786 frombuf(buffer, &fSeekKeys);; 787 } else {; 788 Int_t sdir,sparent,skeys;; 789 frombuf(buffer",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:30079,Availability,recover,recovering,30079,"t)skeys;; 792 }; 793 if (versiondir > 1) fUUID.ReadBuffer(buffer);; 794 ; 795 //*-*---------read TKey::FillBuffer info; 796 buffer_keyloc += sizeof(Int_t); // Skip NBytes;; 797 Version_t keyversion;; 798 frombuf(buffer_keyloc, &keyversion);; 799 // Skip ObjLen, DateTime, KeyLen, Cycle, SeekKey, SeekPdir; 800 if (keyversion > 1000) {; 801 // Large files; 802 buffer_keyloc += 2*sizeof(Int_t)+2*sizeof(Short_t)+2*sizeof(Long64_t);; 803 } else {; 804 buffer_keyloc += 2*sizeof(Int_t)+2*sizeof(Short_t)+2*sizeof(Int_t);; 805 }; 806 TString cname;; 807 cname.ReadBuffer(buffer_keyloc);; 808 cname.ReadBuffer(buffer_keyloc); // fName.ReadBuffer(buffer); file may have been renamed; 809 fTitle.ReadBuffer(buffer_keyloc);; 810 delete [] header;; 811 if (fNbytesName < 10 || fNbytesName > 10000) {; 812 Error(""Init"",""cannot read directory info of file %s"", GetName());; 813 goto zombie;; 814 }; 815 ; 816 //*-* -------------Check if file is truncated; 817 Long64_t size;; 818 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 819 Error(""Init"", ""cannot stat the file %s"", GetName());; 820 goto zombie;; 821 }; 822 ; 823 //*-* -------------Check if, in case of inconsistencies, we are requested to; 824 //*-* -------------attempt recovering the file; 825 Bool_t tryrecover = (gEnv->GetValue(""TFile.Recover"", 1) == 1) ? kTRUE : kFALSE;; 826 ; 827 //*-* -------------Check if we need to enable forward compatible with version; 828 //*-* -------------prior to v6.30; 829 if (gEnv->GetValue(""TFile.v630forwardCompatibility"", 0) == 1); 830 SetBit(k630forwardCompatibility);; 831 ; 832 //*-* -------------Read keys of the top directory; 833 if (fSeekKeys > fBEGIN && fEND <= size) {; 834 //normal case. Recover only if file has no keys; 835 TDirectoryFile::ReadKeys(kFALSE);; 836 gDirectory = this;; 837 if (!GetNkeys()) {; 838 if (tryrecover) {; 839 Recover(); // NOLINT: silence clang-tidy warnings; 840 } else {; 841 Error(""Init"", ""file %s has no keys"", GetName());; 842 goto zombie;; 843 }",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31155,Availability,recover,recover,31155,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31299,Availability,recover,recover,31299,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31578,Availability,recover,recover,31578,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31833,Availability,recover,recovered,31833,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31906,Availability,recover,recovered,31906,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:33838,Availability,error,error,33838,"ersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = gROOT->GetVersionInt();; 904 const auto msg = ""no StreamerInfo found in %s therefore preventing schema evolution when reading this file. ""; 905 ""The file was produced with ROOT version %d.%02d%s%02d, ""; 906 ""while the current version is %d.%02d.%02d"";; 907 Warning(""Init"", msg,; 908 GetName(),; 909 fVersion / 10000, (fVersion / 100) % (100), separator, fVersion % 100,; 910 thisVersion / 10000, (thisVersion / 100) % (100), thisVersion % 100);; 911 }; 912 }; 913 }; 914 }; 915 ; 916 // Count number of TProcessIDs in this file; 917 {; 918 TIter next(fKeys);; 919 TKey *key;; 920 while ((key = (TKey*)next())) {; 921 if (!strcmp(key->GetClassName(),""TProcessID"")) fNProcessIDs++;; 922 }; 923 fProcessIDs = new TObjArray(fNProcessIDs+1);; 924 }; 925 ; 926 return;; 927 ; 928zombie:; 929 if (fGlobalRegistration) {; 930 R__LOCKGUARD(gROOTMutex);; 931 gROOT->GetListOfClosedObjects()->Add(this);; 932 }; 933 // error in file opening occurred, make this object a zombie; 934 fWritable = kFALSE;; 935 MakeZombie();; 936 gDirectory = gROOT;; 937}; 938 ; 939////////////////////////////////////////////////////////////////////////////////; 940/// Close a file.; 941///; 942/// \param[in] option If option == ""R"", all TProcessIDs referenced by this file are deleted.; 943///; 944/// Calling TFile::Close(""R"") might be necessary in case one reads a long list; 945/// of files having TRef, writing some of the referenced objects or TRef; 946/// to a new file. If the TRef or referenced objects of the file being closed; 947/// will not be referenced again, it is possible to minimize the size; 948/// of the TProcessID data structures in memory by forcing a delete of; 949/// the unused TProcessID.; 950 ; 951",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:41077,Availability,error,error,41077,"Once the map is drawn, turn on the TCanvas option ""View->Event Statusbar"". Then, when; 1120/// moving the mouse in the canvas, the ""Event Status"" panels shows the object corresponding; 1121/// to the mouse position.; 1122///; 1123/// Example:; 1124/// ~~~{.cpp}; 1125/// auto f = new TFile(""myfile.root"");; 1126/// f->DrawMap();; 1127/// ~~~; 1128 ; 1129void TFile::DrawMap(const char *keys, Option_t *option); 1130{; 1131 TPluginHandler *h;; 1132 if ((h = gROOT->GetPluginManager()->FindHandler(""TFileDrawMap""))) {; 1133 if (h->LoadPlugin() == -1); 1134 return;; 1135 h->ExecPlugin(3, this, keys, option);; 1136 }; 1137}; 1138 ; 1139////////////////////////////////////////////////////////////////////////////////; 1140/// Synchronize a file's in-memory and on-disk states.; 1141 ; 1142void TFile::Flush(); 1143{; 1144 if (IsOpen() && fWritable) {; 1145 FlushWriteCache();; 1146 if (SysSync(fD) < 0) {; 1147 // Write the system error only once for this file; 1148 SetBit(kWriteError); SetWritable(kFALSE);; 1149 SysError(""Flush"", ""error flushing file %s"", GetName());; 1150 }; 1151 }; 1152}; 1153 ; 1154////////////////////////////////////////////////////////////////////////////////; 1155/// Flush the write cache if active.; 1156///; 1157/// Return kTRUE in case of error; 1158 ; 1159Bool_t TFile::FlushWriteCache(); 1160{; 1161 if (fCacheWrite && IsOpen() && fWritable); 1162 return fCacheWrite->Flush();; 1163 return kFALSE;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Encode file output buffer.; 1168///; 1169/// The file output buffer contains only the FREE data record.; 1170 ; 1171void TFile::FillBuffer(char *&buffer); 1172{; 1173 Version_t version = TFile::Class_Version();; 1174 tobuf(buffer, version);; 1175}; 1176 ; 1177////////////////////////////////////////////////////////////////////////////////; 1178/// Return the best buffer size of objects on this file.; 1179///; 1180/// The best buffer size is estimated based ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:41180,Availability,error,error,41180,"Once the map is drawn, turn on the TCanvas option ""View->Event Statusbar"". Then, when; 1120/// moving the mouse in the canvas, the ""Event Status"" panels shows the object corresponding; 1121/// to the mouse position.; 1122///; 1123/// Example:; 1124/// ~~~{.cpp}; 1125/// auto f = new TFile(""myfile.root"");; 1126/// f->DrawMap();; 1127/// ~~~; 1128 ; 1129void TFile::DrawMap(const char *keys, Option_t *option); 1130{; 1131 TPluginHandler *h;; 1132 if ((h = gROOT->GetPluginManager()->FindHandler(""TFileDrawMap""))) {; 1133 if (h->LoadPlugin() == -1); 1134 return;; 1135 h->ExecPlugin(3, this, keys, option);; 1136 }; 1137}; 1138 ; 1139////////////////////////////////////////////////////////////////////////////////; 1140/// Synchronize a file's in-memory and on-disk states.; 1141 ; 1142void TFile::Flush(); 1143{; 1144 if (IsOpen() && fWritable) {; 1145 FlushWriteCache();; 1146 if (SysSync(fD) < 0) {; 1147 // Write the system error only once for this file; 1148 SetBit(kWriteError); SetWritable(kFALSE);; 1149 SysError(""Flush"", ""error flushing file %s"", GetName());; 1150 }; 1151 }; 1152}; 1153 ; 1154////////////////////////////////////////////////////////////////////////////////; 1155/// Flush the write cache if active.; 1156///; 1157/// Return kTRUE in case of error; 1158 ; 1159Bool_t TFile::FlushWriteCache(); 1160{; 1161 if (fCacheWrite && IsOpen() && fWritable); 1162 return fCacheWrite->Flush();; 1163 return kFALSE;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Encode file output buffer.; 1168///; 1169/// The file output buffer contains only the FREE data record.; 1170 ; 1171void TFile::FillBuffer(char *&buffer); 1172{; 1173 Version_t version = TFile::Class_Version();; 1174 tobuf(buffer, version);; 1175}; 1176 ; 1177////////////////////////////////////////////////////////////////////////////////; 1178/// Return the best buffer size of objects on this file.; 1179///; 1180/// The best buffer size is estimated based ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:41417,Availability,error,error,41417,"ion_t *option); 1130{; 1131 TPluginHandler *h;; 1132 if ((h = gROOT->GetPluginManager()->FindHandler(""TFileDrawMap""))) {; 1133 if (h->LoadPlugin() == -1); 1134 return;; 1135 h->ExecPlugin(3, this, keys, option);; 1136 }; 1137}; 1138 ; 1139////////////////////////////////////////////////////////////////////////////////; 1140/// Synchronize a file's in-memory and on-disk states.; 1141 ; 1142void TFile::Flush(); 1143{; 1144 if (IsOpen() && fWritable) {; 1145 FlushWriteCache();; 1146 if (SysSync(fD) < 0) {; 1147 // Write the system error only once for this file; 1148 SetBit(kWriteError); SetWritable(kFALSE);; 1149 SysError(""Flush"", ""error flushing file %s"", GetName());; 1150 }; 1151 }; 1152}; 1153 ; 1154////////////////////////////////////////////////////////////////////////////////; 1155/// Flush the write cache if active.; 1156///; 1157/// Return kTRUE in case of error; 1158 ; 1159Bool_t TFile::FlushWriteCache(); 1160{; 1161 if (fCacheWrite && IsOpen() && fWritable); 1162 return fCacheWrite->Flush();; 1163 return kFALSE;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Encode file output buffer.; 1168///; 1169/// The file output buffer contains only the FREE data record.; 1170 ; 1171void TFile::FillBuffer(char *&buffer); 1172{; 1173 Version_t version = TFile::Class_Version();; 1174 tobuf(buffer, version);; 1175}; 1176 ; 1177////////////////////////////////////////////////////////////////////////////////; 1178/// Return the best buffer size of objects on this file.; 1179///; 1180/// The best buffer size is estimated based on the current mean value; 1181/// and standard deviation of all objects written so far to this file.; 1182/// Returns mean value + one standard deviation.; 1183 ; 1184Int_t TFile::GetBestBuffer() const; 1185{; 1186 if (!fWritten) return TBuffer::kInitialSize;; 1187 Double_t mean = fSumBuffer/fWritten;; 1188 Double_t rms2 = TMath::Abs(fSum2Buffer/fSumBuffer -mean*mean);; 1189 Double_t result =",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:43423,Availability,failure,failure,43423,"objects written so far to this file.; 1182/// Returns mean value + one standard deviation.; 1183 ; 1184Int_t TFile::GetBestBuffer() const; 1185{; 1186 if (!fWritten) return TBuffer::kInitialSize;; 1187 Double_t mean = fSumBuffer/fWritten;; 1188 Double_t rms2 = TMath::Abs(fSum2Buffer/fSumBuffer -mean*mean);; 1189 Double_t result = mean + sqrt(rms2);; 1190 if (result >= (double)std::numeric_limits<Int_t>::max()) {; 1191 return std::numeric_limits<Int_t>::max() -1;; 1192 } else {; 1193 return (Int_t)result;; 1194 }; 1195}; 1196 ; 1197////////////////////////////////////////////////////////////////////////////////; 1198/// Return the file compression factor.; 1199///; 1200/// Add total number of compressed/uncompressed bytes for each key.; 1201/// Returns the ratio of the two.; 1202 ; 1203Float_t TFile::GetCompressionFactor(); 1204{; 1205 Short_t keylen;; 1206 UInt_t datime;; 1207 Int_t nbytes, objlen, nwh = 64;; 1208 char *header = new char[fBEGIN];; 1209 char *buffer;; 1210 Long64_t idcur = fBEGIN;; 1211 Float_t comp,uncomp;; 1212 comp = uncomp = fBEGIN;; 1213 ; 1214 while (idcur < fEND-100) {; 1215 Seek(idcur);; 1216 if (ReadBuffer(header, nwh)) {; 1217 // ReadBuffer returns kTRUE in case of failure.; 1218// Error(""GetCompressionFactor"",""%s failed to read the key header information at %lld (size=%d)."",; 1219// GetName(),idcur,nwh);; 1220 break;; 1221 }; 1222 buffer=header;; 1223 frombuf(buffer, &nbytes);; 1224 if (nbytes < 0) {; 1225 idcur -= nbytes;; 1226 Seek(idcur);; 1227 continue;; 1228 }; 1229 if (nbytes == 0) break; //this may happen when the file is corrupted; 1230 Version_t versionkey;; 1231 frombuf(buffer, &versionkey);; 1232 frombuf(buffer, &objlen);; 1233 frombuf(buffer, &datime);; 1234 frombuf(buffer, &keylen);; 1235 if (!objlen) objlen = nbytes-keylen;; 1236 comp += nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244///////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:46870,Availability,failure,failure,46870,"ical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The function reads nread bytes; 1297/// where nread is the minimum of maxbytes and the number of bytes; 1298/// before the end of file. The function returns nread.; 1299/// Note that the arguments objlen and keylen are returned only; 1300/// if maxbytes >=16; 1301 ; 1302Int_t TFile::GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen); 1303{; 1304 nbytes = 0;; 1305 objlen = 0;; 1306 keylen = 0;; 1307 if (first < fBEGIN) return 0;; 1308 if (first > fEND) return 0;; 1309 Seek(first);; 1310 Int_t nread = maxbytes;; 1311 if (first+maxbytes > fEND) nread = fEND-maxbytes;; 1312 if (nread < 4) {; 1313 Warning(""GetRecordHeader"",""%s: parameter maxbytes = %d must be >= 4"",; 1314 GetName(), nread);; 1315 return nread;; 1316 }; 1317 if (ReadBuffer(buf,nread)) {; 1318 // ReadBuffer return kTRUE in case of failure.; 1319 Warning(""GetRecordHeader"",""%s: failed to read header data (maxbytes = %d)"",; 1320 GetName(), nread);; 1321 return nread;; 1322 }; 1323 Version_t versionkey;; 1324 Short_t klen;; 1325 UInt_t datime;; 1326 Int_t nb,olen;; 1327 char *buffer = buf;; 1328 frombuf(buffer,&nb);; 1329 nbytes = nb;; 1330 if (nb < 0) return nread;; 1331 // const Int_t headerSize = Int_t(sizeof(nb) +sizeof(versionkey) +sizeof(olen) +sizeof(datime) +sizeof(klen));; 1332 const Int_t headerSize = 16;; 1333 if (nread < headerSize) return nread;; 1334 frombuf(buffer, &versionkey);; 1335 frombuf(buffer, &olen);; 1336 frombuf(buffer, &datime);; 1337 frombuf(buffer, &kle",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49612,Availability,failure,failure,49612,"(); 1368{; 1369 return fInfoCache ? fInfoCache : (fInfoCache=GetStreamerInfoList());; 1370}; 1371 ; 1372////////////////////////////////////////////////////////////////////////////////; 1373/// See documentation of GetStreamerInfoList for more details.; 1374/// This is an internal method which returns the list of streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:58360,Availability,failure,failure,58360,"OT file with histograms; 1560/// 20200820/155032 At:406225 N=8556 StreamerInfo CX = 3.42 name: StreamerInfo title: Doubly linked list; 1561/// 20200820/155708 At:414781 N=86 FreeSegments name: hsimple.root title: Demo ROOT file with histograms; 1562/// 20200820/155708 At:414867 N=1 END; 1563///; 1564/// Note: The combined size of the classname, name and title is truncated to 476 characters (a little more for regular keys of small files); 1565///; 1566 ; 1567 ; 1568void TFile::Map(Option_t *opt); 1569{; 1570 TString options(opt);; 1571 options.ToLower();; 1572 bool forComp = options.Contains(""forcomp"");; 1573 bool extended = options.Contains(""extended"");; 1574 ; 1575 Short_t keylen,cycle;; 1576 UInt_t datime;; 1577 Int_t nbytes,date,time,objlen;; 1578 date = 0;; 1579 time = 0;; 1580 Long64_t seekkey,seekpdir;; 1581 char *buffer;; 1582 char nwhc;; 1583 Long64_t idcur = fBEGIN;; 1584 ; 1585 constexpr Int_t nwheader = 512;; 1586 ; 1587 char header[nwheader];; 1588 char classname[512];; 1589 char keyname[512];; 1590 char keytitle[512];; 1591 TString extrainfo;; 1592 ; 1593 unsigned char nDigits = std::log10(fEND) + 1;; 1594 ; 1595 while (idcur < fEND) {; 1596 Seek(idcur);; 1597 Int_t nread = nwheader;; 1598 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 1599 if (ReadBuffer(header, nread)) {; 1600 // ReadBuffer returns kTRUE in case of failure.; 1601 Warning(""Map"",""%s: failed to read the key data from disk at %lld."",; 1602 GetName(),idcur);; 1603 break;; 1604 }; 1605 ; 1606 buffer=header;; 1607 frombuf(buffer, &nbytes);; 1608 if (!nbytes) {; 1609 Printf(""Address = %lld\tNbytes = %d\t=====E R R O R======="", idcur, nbytes);; 1610 date = 0; time = 0;; 1611 break;; 1612 }; 1613 if (nbytes < 0) {; 1614 Printf(""Address = %lld\tNbytes = %d\t=====G A P==========="", idcur, nbytes);; 1615 idcur -= nbytes;; 1616 Seek(idcur);; 1617 continue;; 1618 }; 1619 Version_t versionkey;; 1620 frombuf(buffer, &versionkey);; 1621 frombuf(buffer, &objlen);; 1622 frombuf(buffer, &datime);; 1623 fr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:62798,Availability,failure,failure,62798,"8 idcur += nbytes;; 1689 }; 1690 if (!forComp); 1691 Printf(""%d/%06d At:%-*lld N=%-8d %-14s"",date,time, nDigits+1, idcur,1,""END"");; 1692 else; 1693 Printf(""At:%-*lld N=%-8d K= O= %-14s"", nDigits+1, idcur,1,""END"");; 1694}; 1695 ; 1696////////////////////////////////////////////////////////////////////////////////; 1697/// Paint all objects in the file.; 1698 ; 1699void TFile::Paint(Option_t *option); 1700{; 1701 GetList()->R__FOR_EACH(TObject,Paint)(option);; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Print all objects in the file.; 1706 ; 1707void TFile::Print(Option_t *option) const; 1708{; 1709 Printf(""TFile: name=%s, title=%s, option=%s"", GetName(), GetTitle(), GetOption());; 1710 GetList()->R__FOR_EACH(TObject,Print)(option);; 1711}; 1712 ; 1713////////////////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:63540,Availability,error,error,63540,"/////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gMonitoringWriter); 1758 gMonitoringWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:63660,Availability,error,error,63660,"/////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gMonitoringWriter); 1758 gMonitoringWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:64317,Availability,failure,failure,64317,"n kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gMonitoringWriter); 1758 gMonitoringWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1785 if (gPerfStats) start = TTimeStamp();; 1786 ; 1787 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1788 ResetErrno();; 1789 ; 1790 if (siz < 0) {; 1791 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1792 return kTRUE;; 1793 }; 1794 if (siz != len) {; 1795 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1796 GetName(), (Long_t)siz, len);; 1797 return kTRUE;; 1798 }; 1799 fBytesRead += siz;; 1800 fgBytesRead += siz;; 1801 fReadCalls++;; 1802 fgReadCalls++;; 1803 ; 1804 if (gMonitoringWriter); 1805 gMonitoringWriter->SendFileReadProgress(this);; 1806 if (gPerfStats) {; 1807 gPerfStats->FileReadEvent(this, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:64813,Availability,error,error,64813,"ingWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1785 if (gPerfStats) start = TTimeStamp();; 1786 ; 1787 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1788 ResetErrno();; 1789 ; 1790 if (siz < 0) {; 1791 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1792 return kTRUE;; 1793 }; 1794 if (siz != len) {; 1795 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1796 GetName(), (Long_t)siz, len);; 1797 return kTRUE;; 1798 }; 1799 fBytesRead += siz;; 1800 fgBytesRead += siz;; 1801 fReadCalls++;; 1802 fgReadCalls++;; 1803 ; 1804 if (gMonitoringWriter); 1805 gMonitoringWriter->SendFileReadProgress(this);; 1806 if (gPerfStats) {; 1807 gPerfStats->FileReadEvent(this, len, start);; 1808 }; 1809 return kFALSE;; 1810 }; 1811 return kTRUE;; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Read the nbuf blocks described in arrays pos and len.; 1816///; 1817/// The value pos[i] is the seek position of block i of length len[i].; 1818/// Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; 1819/// This function is overloaded by TNetFile, TWebFile, etc.; 1820/// Returns kTRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, f",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:64933,Availability,error,error,64933,"ingWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1785 if (gPerfStats) start = TTimeStamp();; 1786 ; 1787 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1788 ResetErrno();; 1789 ; 1790 if (siz < 0) {; 1791 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1792 return kTRUE;; 1793 }; 1794 if (siz != len) {; 1795 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1796 GetName(), (Long_t)siz, len);; 1797 return kTRUE;; 1798 }; 1799 fBytesRead += siz;; 1800 fgBytesRead += siz;; 1801 fReadCalls++;; 1802 fgReadCalls++;; 1803 ; 1804 if (gMonitoringWriter); 1805 gMonitoringWriter->SendFileReadProgress(this);; 1806 if (gPerfStats) {; 1807 gPerfStats->FileReadEvent(this, len, start);; 1808 }; 1809 return kFALSE;; 1810 }; 1811 return kTRUE;; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Read the nbuf blocks described in arrays pos and len.; 1816///; 1817/// The value pos[i] is the seek position of block i of length len[i].; 1818/// Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; 1819/// This function is overloaded by TNetFile, TWebFile, etc.; 1820/// Returns kTRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, f",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:65798,Availability,failure,failure,65798,"1791 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1792 return kTRUE;; 1793 }; 1794 if (siz != len) {; 1795 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1796 GetName(), (Long_t)siz, len);; 1797 return kTRUE;; 1798 }; 1799 fBytesRead += siz;; 1800 fgBytesRead += siz;; 1801 fReadCalls++;; 1802 fgReadCalls++;; 1803 ; 1804 if (gMonitoringWriter); 1805 gMonitoringWriter->SendFileReadProgress(this);; 1806 if (gPerfStats) {; 1807 gPerfStats->FileReadEvent(this, len, start);; 1808 }; 1809 return kFALSE;; 1810 }; 1811 return kTRUE;; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Read the nbuf blocks described in arrays pos and len.; 1816///; 1817/// The value pos[i] is the seek position of block i of length len[i].; 1818/// Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; 1819/// This function is overloaded by TNetFile, TWebFile, etc.; 1820/// Returns kTRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, from TFileCacheRead to pass list of readahead buffers; 1825 if (!buf) {; 1826 for (Int_t j = 0; j < nbuf; j++) {; 1827 if (ReadBufferAsync(pos[j], len[j])) {; 1828 return kTRUE;; 1829 }; 1830 }; 1831 return kFALSE;; 1832 }; 1833 ; 1834 Int_t k = 0;; 1835 Bool_t result = kTRUE;; 1836 TFileCacheRead *old = fCacheRead;; 1837 fCacheRead = nullptr;; 1838 Long64_t curbegin = pos[0];; 1839 Long64_t cur;; 1840 char *buf2 = nullptr;; 1841 Int_t i = 0, n = 0;; 1842 while (i < nbuf) {; 1843 cur = pos[i]+len[i];; 1844 Bool_t bigRead = kTRUE;; 1845 if (cur -curbegin < fgReadaheadSize) {n++; i++; bigRead = kFALSE;}; 1846 if (bigRead || (i>=nbuf)) {; 1847 if (n == 0) {; 1848 //if the block to read is about the same size as the read-ahead buffer; 1849 //we read the block directly; 1850 Seek(pos[i]);; 1851 result = ReadBuffer(&buf[k], len[i]);; 1852 if (result",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:68142,Availability,failure,failure,68142,"2 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->Get",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:71659,Availability,recover,recover,71659," 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)pids->UncheckedAt(pidf);; 1957 if (pid) {; 1958 pid->CheckInit();; 1959 return pid;; 1960 }; 1961 ; 1962 //check if fProcessIDs[uid] is set in file; 1963 //if not set, read the process uid from file; 1964 char pidname[32];; 1965 snprintf(pidname,32,""ProcessID%d"",pidf);; 1966 pid = (TProcessID *)Get(pidname);; 1967 if (gDebug > 0) {; 1968 printf(""ReadProcessID, name=%s, file=%s, pid=%zx\n"",pidname,GetName(),(size_t)pid);; 1969 }; 1970 if (!pid) {; 1971 //file->Error(""ReadProcessID"",""Cannot find %s in file %s"",pidname,file->GetName());; 1972 return pid;; 1973 }; 1974 ; 1975 //check that a similar pid is not already registered in fgPIDs; 1976 TObjArray *pidslist = TProcessID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:71769,Availability,recover,recovered,71769," 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)pids->UncheckedAt(pidf);; 1957 if (pid) {; 1958 pid->CheckInit();; 1959 return pid;; 1960 }; 1961 ; 1962 //check if fProcessIDs[uid] is set in file; 1963 //if not set, read the process uid from file; 1964 char pidname[32];; 1965 snprintf(pidname,32,""ProcessID%d"",pidf);; 1966 pid = (TProcessID *)Get(pidname);; 1967 if (gDebug > 0) {; 1968 printf(""ReadProcessID, name=%s, file=%s, pid=%zx\n"",pidname,GetName(),(size_t)pid);; 1969 }; 1970 if (!pid) {; 1971 //file->Error(""ReadProcessID"",""Cannot find %s in file %s"",pidname,file->GetName());; 1972 return pid;; 1973 }; 1974 ; 1975 //check that a similar pid is not already registered in fgPIDs; 1976 TObjArray *pidslist = TProcessID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:71807,Availability,recover,recovered,71807,"ID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has be",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72095,Availability,recover,recover,72095,"; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72265,Availability,recover,recovered,72265,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72634,Availability,recover,recovered,72634,"///////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 20",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72745,Availability,recover,recovered,72745,"ber of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy war",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72835,Availability,recover,recovered,72835," automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:73028,Availability,recover,recovered,73028,"pen in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 207",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:73253,Availability,recover,recovery,73253,"been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 2075 while (idcur < fEND) {; 2076 Seek(idcur); // NOLINT: silence clang-tidy warnings; 2077 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 2078 if (ReadBuffer(header, nread)) { // NOLINT: silence clang-tidy warnings; 2079 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:74299,Availability,failure,failure,74299,"overed}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 2075 while (idcur < fEND) {; 2076 Seek(idcur); // NOLINT: silence clang-tidy warnings; 2077 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 2078 if (ReadBuffer(header, nread)) { // NOLINT: silence clang-tidy warnings; 2079 // ReadBuffer returns kTRUE in case of failure.; 2080 Error(""Recover"",""%s: failed to read the key data from disk at %lld."",; 2081 GetName(),idcur);; 2082 break;; 2083 }; 2084 buffer = header;; 2085 bufread = header;; 2086 frombuf(buffer, &nbytes);; 2087 if (!nbytes) {; 2088 Error(""Recover"",""Address = %lld\tNbytes = %d\t=====E R R O R======="", idcur, nbytes);; 2089 break;; 2090 }; 2091 if (nbytes < 0) {; 2092 idcur -= nbytes;; 2093 if (fWritable) new TFree(fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffe",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:76031,Availability,recover,recovered,76031,"fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffer, &versionkey);; 2099 frombuf(buffer, &objlen);; 2100 frombuf(buffer, &datime);; 2101 frombuf(buffer, &keylen);; 2102 frombuf(buffer, &cycle);; 2103 if (versionkey > 1000) {; 2104 frombuf(buffer, &seekkey);; 2105 frombuf(buffer, &seekpdir);; 2106 } else {; 2107 Int_t skey,sdir;; 2108 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 2109 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 2110 }; 2111 frombuf(buffer, &nwhc);; 2112 char *classname = nullptr;; 2113 if (nwhc <= 0 || nwhc > 100) break;; 2114 classname = new char[nwhc+1];; 2115 int i, nwhci = nwhc;; 2116 for (i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 2117 classname[nwhci] = '\0';; 2118 TDatime::GetDateTime(datime, date, time);; 2119 TClass *tclass = TClass::GetClass(classname);; 2120 if (seekpdir == fSeekDir && tclass && !tclass->InheritsFrom(TFile::Class()); 2121 && strcmp(classname,""TBasket"")) {; 2122 key = new TKey(this);; 2123 key->ReadKeyBuffer(bufread);; 2124 if (!strcmp(key->GetName(),""StreamerInfo"")) {; 2125 fSeekInfo = seekkey;; 2126 SafeDelete(fInfoCache);; 2127 fNbytesInfo = nbytes;; 2128 } else {; 2129 AppendKey(key);; 2130 nrecov++;; 2131 SetBit(kRecovered);; 2132 Info(""Recover"", ""%s, recovered key %s:%s at address %lld"",GetName(),key->GetClassName(),key->GetName(),idcur);; 2133 }; 2134 }; 2135 delete [] classname;; 2136 idcur += nbytes;; 2137 }; 2138 if (fWritable) {; 2139 Long64_t max_file_size = Long64_t(kStartBigFile);; 2140 if (max_file_size < fEND) max_file_size = fEND+1000000000;; 2141 TFree *last = (TFree*)fFree->Last();; 2142 if (last) {; 2143 last->AddFree(fFree,fEND,max_file_size);; 2144 } else {; 2145 new TFree(fFree,fEND,max_file_size);; 2146 }; 2147 if (nrecov) Write();; 2148 }; 2149 return nrecov;; 2150}; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Reopen a file with a different access mode.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:77116,Availability,failure,failure,77116,"s at address %lld"",GetName(),key->GetClassName(),key->GetName(),idcur);; 2133 }; 2134 }; 2135 delete [] classname;; 2136 idcur += nbytes;; 2137 }; 2138 if (fWritable) {; 2139 Long64_t max_file_size = Long64_t(kStartBigFile);; 2140 if (max_file_size < fEND) max_file_size = fEND+1000000000;; 2141 TFree *last = (TFree*)fFree->Last();; 2142 if (last) {; 2143 last->AddFree(fFree,fEND,max_file_size);; 2144 } else {; 2145 new TFree(fFree,fEND,max_file_size);; 2146 }; 2147 if (nrecov) Write();; 2148 }; 2149 return nrecov;; 2150}; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Reopen a file with a different access mode.; 2154///; 2155/// For example, it is possible to change from READ to; 2156/// UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; 2157/// mode argument can be either ""READ"" or ""UPDATE"". The method returns; 2158/// 0 in case the mode was successfully modified, 1 in case the mode; 2159/// did not change (was already as requested or wrong input arguments); 2160/// and -1 in case of failure, in which case the file cannot be used; 2161/// anymore. The current directory (gFile) is changed to this file.; 2162 ; 2163Int_t TFile::ReOpen(Option_t *mode); 2164{; 2165 cd();; 2166 ; 2167 TString opt = mode;; 2168 opt.ToUpper();; 2169 ; 2170 if (opt != ""READ"" && opt != ""UPDATE"") {; 2171 Error(""ReOpen"", ""mode must be either READ or UPDATE, not %s"", opt.Data());; 2172 return 1;; 2173 }; 2174 ; 2175 if (opt == fOption || (opt == ""UPDATE"" && fOption == ""CREATE"")); 2176 return 1;; 2177 ; 2178 if (opt == ""READ"") {; 2179 // switch to READ mode; 2180 ; 2181 // flush data still in the pipeline and close the file; 2182 if (IsOpen() && IsWritable()) {; 2183 WriteStreamerInfo();; 2184 ; 2185 // save directory key list and header; 2186 Save();; 2187 ; 2188 TFree *f1 = (TFree*)fFree->First();; 2189 if (f1) {; 2190 WriteFree(); // write free segments linked list; 2191 WriteHeader(); // now write file header; 2192 }; 2193 ; ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:87984,Availability,failure,failure,87984,"());; 2450 else; 2451 Info(""Write"", ""writing name = %s title = %s"", GetName(), GetTitle());; 2452 }; 2453 ; 2454 fMustFlush = kFALSE;; 2455 Int_t nbytes = TDirectoryFile::Write(0, opt, bufsiz); // Write directory tree; 2456 WriteStreamerInfo();; 2457 WriteFree(); // Write free segments linked list; 2458 WriteHeader(); // Now write file header; 2459 fMustFlush = kTRUE;; 2460 ; 2461 return nbytes;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// One can not save a const TDirectory object.; 2466 ; 2467Int_t TFile::Write(const char *n, Int_t opt, Int_t bufsize) const; 2468{; 2469 Error(""Write const"",""A const TFile object should not be saved. We try to proceed anyway."");; 2470 return const_cast<TFile*>(this)->Write(n, opt, bufsize);; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Write a buffer to the file. This is the basic low level write operation.; 2475/// Returns kTRUE in case of failure.; 2476 ; 2477Bool_t TFile::WriteBuffer(const char *buf, Int_t len); 2478{; 2479 if (IsOpen() && fWritable) {; 2480 ; 2481 Int_t st;; 2482 if ((st = WriteBufferViaCache(buf, len))) {; 2483 if (st == 2); 2484 return kTRUE;; 2485 return kFALSE;; 2486 }; 2487 ; 2488 ssize_t siz;; 2489 gSystem->IgnoreInterrupt();; 2490 while ((siz = SysWrite(fD, buf, len)) < 0 && GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fByt",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:88559,Availability,error,error,88559,"TFile object should not be saved. We try to proceed anyway."");; 2470 return const_cast<TFile*>(this)->Write(n, opt, bufsize);; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Write a buffer to the file. This is the basic low level write operation.; 2475/// Returns kTRUE in case of failure.; 2476 ; 2477Bool_t TFile::WriteBuffer(const char *buf, Int_t len); 2478{; 2479 if (IsOpen() && fWritable) {; 2480 ; 2481 Int_t st;; 2482 if ((st = WriteBufferViaCache(buf, len))) {; 2483 if (st == 2); 2484 return kTRUE;; 2485 return kFALSE;; 2486 }; 2487 ; 2488 ssize_t siz;; 2489 gSystem->IgnoreInterrupt();; 2490 while ((siz = SysWrite(fD, buf, len)) < 0 && GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len))",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:88668,Availability,error,error,88668,"TFile object should not be saved. We try to proceed anyway."");; 2470 return const_cast<TFile*>(this)->Write(n, opt, bufsize);; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Write a buffer to the file. This is the basic low level write operation.; 2475/// Returns kTRUE in case of failure.; 2476 ; 2477Bool_t TFile::WriteBuffer(const char *buf, Int_t len); 2478{; 2479 if (IsOpen() && fWritable) {; 2480 ; 2481 Int_t st;; 2482 if ((st = WriteBufferViaCache(buf, len))) {; 2483 if (st == 2); 2484 return kTRUE;; 2485 return kFALSE;; 2486 }; 2487 ; 2488 ssize_t siz;; 2489 gSystem->IgnoreInterrupt();; 2490 while ((siz = SysWrite(fD, buf, len)) < 0 && GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len))",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:88833,Availability,error,error,88833,"TFile object should not be saved. We try to proceed anyway."");; 2470 return const_cast<TFile*>(this)->Write(n, opt, bufsize);; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Write a buffer to the file. This is the basic low level write operation.; 2475/// Returns kTRUE in case of failure.; 2476 ; 2477Bool_t TFile::WriteBuffer(const char *buf, Int_t len); 2478{; 2479 if (IsOpen() && fWritable) {; 2480 ; 2481 Int_t st;; 2482 if ((st = WriteBufferViaCache(buf, len))) {; 2483 if (st == 2); 2484 return kTRUE;; 2485 return kFALSE;; 2486 }; 2487 ; 2488 ssize_t siz;; 2489 gSystem->IgnoreInterrupt();; 2490 while ((siz = SysWrite(fD, buf, len)) < 0 && GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len))",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:89705,Availability,error,error,89705,"kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 2551 Bool_t largeFile = (fEND > TFile::kStartBigFile);; 2552 ; 2553 auto createKey = [this]() {; 2554 Int_t nbytes = 0;; 2555 TFree *afree;; 2556 TIter next (fFree);; 2557 while ((afree = (TFree*) next())) {; 2558 nbytes += afree->Sizeof();; 2559 }; 2560 if (!nbytes) return (TKey*)nullptr;; 2561 ; 2562 TKey *key = new TKey(fName,fTitle,IsA(),nbytes,this);; 2563 ; 2564 if (key->GetSeekKey(",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:95570,Availability,avail,available,95570," generated includes:; 2672/// - <em>dirnameProjectHeaders.h</em>, which contains one `#include` statement per generated header file; 2673/// - <em>dirnameProjectSource.cxx</em>,which contains all the constructors and destructors implementation.; 2674/// and one header per class that is not nested inside another class.; 2675/// The header file name is the fully qualified name of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__Vertex_int_.h; 2678///; 2679/// In the generated classes, map, multimap when the first template parameter is a class; 2680/// are replaced by a vector of pair. set and multiset when the tempalte parameter; 2681/// is a class are replaced by a vector. This is required since we do not have the; 2682/// code needed to order and/or compare the object of the classes.; 2683/// This is a quick explanation of the options available:; 2684/// Option | Details; 2685/// -------|--------; 2686/// new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.; 2687/// recreate | If dirname does not exist, it is created (like in ""new""). If dirname already exist, all existing files in dirname are deleted before creating the new files.; 2688/// update | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as ""new"".; 2689/// genreflex | Use genreflex rather than rootcint to generate the dictionary.; 2690/// par | Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; 2691///; 2692/// If, in addition to one of the 3 above options, the option ""+"" is specified,; 2693/// the function will generate:;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:95723,Availability,error,error,95723,"ile; 2673/// - <em>dirnameProjectSource.cxx</em>,which contains all the constructors and destructors implementation.; 2674/// and one header per class that is not nested inside another class.; 2675/// The header file name is the fully qualified name of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__Vertex_int_.h; 2678///; 2679/// In the generated classes, map, multimap when the first template parameter is a class; 2680/// are replaced by a vector of pair. set and multiset when the tempalte parameter; 2681/// is a class are replaced by a vector. This is required since we do not have the; 2682/// code needed to order and/or compare the object of the classes.; 2683/// This is a quick explanation of the options available:; 2684/// Option | Details; 2685/// -------|--------; 2686/// new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.; 2687/// recreate | If dirname does not exist, it is created (like in ""new""). If dirname already exist, all existing files in dirname are deleted before creating the new files.; 2688/// update | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as ""new"".; 2689/// genreflex | Use genreflex rather than rootcint to generate the dictionary.; 2690/// par | Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; 2691///; 2692/// If, in addition to one of the 3 above options, the option ""+"" is specified,; 2693/// the function will generate:; 2694/// - a script called MAKEP to build the shared lib; 2695/// - a dirnameLinkDef.h file; 2696/// - rootcint will be run to g",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:101328,Availability,error,error,101328,"82 void *dir = gSystem->OpenDirectory(dirname);; 2783 TString dirpath;; 2784 ; 2785 if (opt.Contains(""update"")) {; 2786 // check that directory exist, if not create it; 2787 if (!dir) {; 2788 gSystem->mkdir(dirname);; 2789 }; 2790 ; 2791 } else if (opt.Contains(""recreate"")) {; 2792 // check that directory exist, if not create it; 2793 if (!dir) {; 2794 if (gSystem->mkdir(dirname) < 0) {; 2795 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2796 return;; 2797 }; 2798 }; 2799 // clear directory; 2800 while (dir) {; 2801 const char *afile = gSystem->GetDirEntry(dir);; 2802 if (!afile) break;; 2803 if (strcmp(afile,""."") == 0) continue;; 2804 if (strcmp(afile,"".."") == 0) continue;; 2805 dirpath.Form(""%s/%s"",dirname,afile);; 2806 gSystem->Unlink(dirpath);; 2807 }; 2808 ; 2809 } else {; 2810 // new is assumed; 2811 // if directory already exist, print error message and return; 2812 if (dir) {; 2813 Error(""MakeProject"",""cannot create directory %s, already existing"",dirname);; 2814 gSystem->FreeDirectory(dir);; 2815 return;; 2816 }; 2817 if (gSystem->mkdir(dirname) < 0) {; 2818 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2819 return;; 2820 }; 2821 }; 2822 if (dir) {; 2823 gSystem->FreeDirectory(dir);; 2824 }; 2825 }; 2826 Bool_t genreflex = opt.Contains(""genreflex"");; 2827 ; 2828 // we are now ready to generate the classes; 2829 // loop on all TStreamerInfo; 2830 TList *filelist = (TList*)GetStreamerInfoCache();; 2831 if (filelist) filelist = (TList*)filelist->Clone();; 2832 if (!filelist) {; 2833 Error(""MakeProject"",""file %s has no StreamerInfo"", GetName());; 2834 return;; 2835 }; 2836 ; 2837 TString clean_dirname(dirname);; 2838 if (makepar) clean_dirname.Form(""%s/%s"", pardir.Data(), parname.Data());; 2839 if (clean_dirname[clean_dirname.Length()-1]=='/') {; 2840 clean_dirname.Remove(clean_dirname.Length()-1);; 2841 } else if (clean_dirname[clean_dirname.Length()-1]=='\\') {; 2842 clean_dirname.Remove(clean_dirname.Length()-1);; 2843 if (clea",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:121283,Availability,error,error,121283,"36 gSystem->Exec(""chmod +x MAKEP"");; 3337 int res = !gSystem->Exec(""./MAKEP"");; 3338#else; 3339 // not really needed for Windows but it would work both both Unix and NT; 3340 chmod(""makep.cmd"",00700);; 3341 int res = !gSystem->Exec(""MAKEP"");; 3342#endif; 3343 gSystem->ChangeDirectory(path);; 3344 path.Form(""%s/%s.%s"",clean_dirname.Data(),subdirname.Data(),gSystem->GetSoExt());; 3345 if (res) printf(""Shared lib %s has been generated\n"",path.Data());; 3346 ; 3347 //dynamically link the generated shared lib; 3348 if (opt.Contains(""++"")) {; 3349 res = !gSystem->Load(path);; 3350 if (res) printf(""Shared lib %s has been dynamically linked\n"",path.Data());; 3351 }; 3352 }; 3353 ; 3354 delete list;; 3355 filelist->Delete();; 3356 delete filelist;; 3357}; 3358 ; 3359////////////////////////////////////////////////////////////////////////////////; 3360/// Create makefile at 'filemake' for PAR package 'pack'.; 3361///; 3362/// Called by MakeProject when option 'par' is given.; 3363/// Return 0 on success, -1 on error.; 3364 ; 3365Int_t TFile::MakeProjectParMake(const char *pack, const char *filemake); 3366{; 3367 // Output file path must be defined; 3368 if (!filemake || (filemake && strlen(filemake) <= 0)) {; 3369 Error(""MakeProjectParMake"", ""path for output file undefined!"");; 3370 return -1;; 3371 }; 3372 ; 3373 // Package name must be defined; 3374 if (!pack || (pack && strlen(pack) <= 0)) {; 3375 Error(""MakeProjectParMake"", ""package name undefined!"");; 3376 return -1;; 3377 }; 3378 ; 3379#ifdef R__WINGCC; 3380 FILE *fmk = fopen(filemake, ""wb"");; 3381#else; 3382 FILE *fmk = fopen(filemake, ""w"");; 3383#endif; 3384 if (!fmk) {; 3385 Error(""MakeProjectParMake"", ""cannot create file '%s' (errno: %d)"", filemake, TSystem::GetErrno());; 3386 return -1;; 3387 }; 3388 ; 3389 // Fill the file now; 3390 fprintf(fmk, ""# Makefile for the ROOT test programs.\n"");; 3391 fprintf(fmk, ""# This Makefile shows how to compile and link applications\n"");; 3392 fprintf(fmk, ""# using the ROOT librar",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:125349,Availability,echo,echo,125349,"34),1234)\n"");; 3433 fprintf(fmk, ""ifeq ($(MACOSX_MINOR),4)\n"");; 3434 fprintf(fmk, ""\t\tln -sf $@ $(subst .$(DllSuf),.so,$@)\n"");; 3435 fprintf(fmk, ""else\n"");; 3436 fprintf(fmk, ""\t\t$(LD) -bundle -undefined $(UNDEFOPT) $(LDFLAGS) $^ \\\n"");; 3437 fprintf(fmk, ""\t\t $(OutPutOpt) $(subst .$(DllSuf),.so,$@)\n"");; 3438 fprintf(fmk, ""endif\n"");; 3439 fprintf(fmk, ""endif\n"");; 3440 fprintf(fmk, ""else\n"");; 3441 fprintf(fmk, ""ifeq ($(PLATFORM),win32)\n"");; 3442 fprintf(fmk, ""\t\tbindexplib $* $^ > $*.def\n"");; 3443 fprintf(fmk, ""\t\tlib -nologo -MACHINE:IX86 $^ -def:$*.def \\\n"");; 3444 fprintf(fmk, ""\t\t $(OutPutOpt)$(PACKLIB)\n"");; 3445 fprintf(fmk, ""\t\t$(LD) $(SOFLAGS) $(LDFLAGS) $^ $*.exp $(LIBS) \\\n"");; 3446 fprintf(fmk, ""\t\t $(OutPutOpt)$@\n"");; 3447 fprintf(fmk, ""else\n"");; 3448 fprintf(fmk, ""\t\t$(LD) $(SOFLAGS) $(LDFLAGS) $^ $(OutPutOpt) $@ $(LIBS) $(EXPLLINKLIBS)\n"");; 3449 fprintf(fmk, ""endif\n"");; 3450 fprintf(fmk, ""endif\n"");; 3451 fprintf(fmk, ""endif\n"");; 3452 fprintf(fmk, ""endif\n"");; 3453 fprintf(fmk, ""\t\t@echo \""$@ done\""\n"");; 3454 fprintf(fmk, ""\n"");; 3455 fprintf(fmk, ""clean:\n"");; 3456 fprintf(fmk, ""\t\t@rm -f $(OBJS) core\n"");; 3457 fprintf(fmk, ""\n"");; 3458 fprintf(fmk, ""distclean: clean\n"");; 3459 fprintf(fmk, ""\t\t@rm -f $(PROGRAMS) $(PACKSO) $(PACKLIB) *Dict.* *.def *.exp \\\n"");; 3460 fprintf(fmk, ""\t\t *.so *.lib *.dll *.d *.log .def so_locations\n"");; 3461 fprintf(fmk, ""\t\t@rm -rf cxx_repository\n"");; 3462 fprintf(fmk, ""\n"");; 3463 fprintf(fmk, ""# Dependencies\n"");; 3464 fprintf(fmk, ""\n"");; 3465 fprintf(fmk, ""%sProjectSource.$(ObjSuf): %sProjectHeaders.h %sLinkDef.h %sProjectDict.$(SrcSuf)\n"", pack, pack, pack, pack);; 3466 fprintf(fmk, ""\n"");; 3467 fprintf(fmk, ""%sProjectDict.$(SrcSuf): %sProjectHeaders.h %sLinkDef.h\n"", pack, pack, pack);; 3468 fprintf(fmk, ""\t\t@echo \""Generating dictionary $@...\""\n"");; 3469 fprintf(fmk, ""\t\t@rootcint -f $@ $^\n"");; 3470 fprintf(fmk, ""\n"");; 3471 fprintf(fmk, "".$(SrcSuf).$(ObjSuf):\n"");; 3472 fpri",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:126138,Availability,echo,echo,126138," $(SOFLAGS) $(LDFLAGS) $^ $(OutPutOpt) $@ $(LIBS) $(EXPLLINKLIBS)\n"");; 3449 fprintf(fmk, ""endif\n"");; 3450 fprintf(fmk, ""endif\n"");; 3451 fprintf(fmk, ""endif\n"");; 3452 fprintf(fmk, ""endif\n"");; 3453 fprintf(fmk, ""\t\t@echo \""$@ done\""\n"");; 3454 fprintf(fmk, ""\n"");; 3455 fprintf(fmk, ""clean:\n"");; 3456 fprintf(fmk, ""\t\t@rm -f $(OBJS) core\n"");; 3457 fprintf(fmk, ""\n"");; 3458 fprintf(fmk, ""distclean: clean\n"");; 3459 fprintf(fmk, ""\t\t@rm -f $(PROGRAMS) $(PACKSO) $(PACKLIB) *Dict.* *.def *.exp \\\n"");; 3460 fprintf(fmk, ""\t\t *.so *.lib *.dll *.d *.log .def so_locations\n"");; 3461 fprintf(fmk, ""\t\t@rm -rf cxx_repository\n"");; 3462 fprintf(fmk, ""\n"");; 3463 fprintf(fmk, ""# Dependencies\n"");; 3464 fprintf(fmk, ""\n"");; 3465 fprintf(fmk, ""%sProjectSource.$(ObjSuf): %sProjectHeaders.h %sLinkDef.h %sProjectDict.$(SrcSuf)\n"", pack, pack, pack, pack);; 3466 fprintf(fmk, ""\n"");; 3467 fprintf(fmk, ""%sProjectDict.$(SrcSuf): %sProjectHeaders.h %sLinkDef.h\n"", pack, pack, pack);; 3468 fprintf(fmk, ""\t\t@echo \""Generating dictionary $@...\""\n"");; 3469 fprintf(fmk, ""\t\t@rootcint -f $@ $^\n"");; 3470 fprintf(fmk, ""\n"");; 3471 fprintf(fmk, "".$(SrcSuf).$(ObjSuf):\n"");; 3472 fprintf(fmk, ""\t\t$(CXX) $(CXXFLAGS) -c $<\n"");; 3473 fprintf(fmk, ""\n"");; 3474 ; 3475 // Close the file; 3476 fclose(fmk);; 3477 ; 3478 // Done; 3479 return 0;; 3480}; 3481 ; 3482////////////////////////////////////////////////////////////////////////////////; 3483/// Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; 3484/// Called by MakeProject when option 'par' is given.; 3485/// Return 0 on success, -1 on error.; 3486 ; 3487Int_t TFile::MakeProjectParProofInf(const char *pack, const char *proofinf); 3488{; 3489 // Output directory path must be defined ...; 3490 if (!proofinf || (proofinf && strlen(proofinf) <= 0)) {; 3491 Error(""MakeProjectParProofInf"", ""directory path undefined!"");; 3492 return -1;; 3493 }; 3494 ; 3495 // ... and exist and be a directory; 3496 Int_t rcst = 0;; 3497 Fil",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:126741,Availability,error,error,126741,"f(fmk, ""\t\t@rm -rf cxx_repository\n"");; 3462 fprintf(fmk, ""\n"");; 3463 fprintf(fmk, ""# Dependencies\n"");; 3464 fprintf(fmk, ""\n"");; 3465 fprintf(fmk, ""%sProjectSource.$(ObjSuf): %sProjectHeaders.h %sLinkDef.h %sProjectDict.$(SrcSuf)\n"", pack, pack, pack, pack);; 3466 fprintf(fmk, ""\n"");; 3467 fprintf(fmk, ""%sProjectDict.$(SrcSuf): %sProjectHeaders.h %sLinkDef.h\n"", pack, pack, pack);; 3468 fprintf(fmk, ""\t\t@echo \""Generating dictionary $@...\""\n"");; 3469 fprintf(fmk, ""\t\t@rootcint -f $@ $^\n"");; 3470 fprintf(fmk, ""\n"");; 3471 fprintf(fmk, "".$(SrcSuf).$(ObjSuf):\n"");; 3472 fprintf(fmk, ""\t\t$(CXX) $(CXXFLAGS) -c $<\n"");; 3473 fprintf(fmk, ""\n"");; 3474 ; 3475 // Close the file; 3476 fclose(fmk);; 3477 ; 3478 // Done; 3479 return 0;; 3480}; 3481 ; 3482////////////////////////////////////////////////////////////////////////////////; 3483/// Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; 3484/// Called by MakeProject when option 'par' is given.; 3485/// Return 0 on success, -1 on error.; 3486 ; 3487Int_t TFile::MakeProjectParProofInf(const char *pack, const char *proofinf); 3488{; 3489 // Output directory path must be defined ...; 3490 if (!proofinf || (proofinf && strlen(proofinf) <= 0)) {; 3491 Error(""MakeProjectParProofInf"", ""directory path undefined!"");; 3492 return -1;; 3493 }; 3494 ; 3495 // ... and exist and be a directory; 3496 Int_t rcst = 0;; 3497 FileStat_t st;; 3498 if ((rcst = gSystem->GetPathInfo(proofinf, st)) != 0 || !R_ISDIR(st.fMode)) {; 3499 Error(""MakeProjectParProofInf"", ""path '%s' %s"", proofinf,; 3500 ((rcst == 0) ? ""is not a directory"" : ""does not exist""));; 3501 return -1;; 3502 }; 3503 ; 3504 // Package name must be defined; 3505 if (!pack || (pack && strlen(pack) <= 0)) {; 3506 Error(""MakeProjectParProofInf"", ""package name undefined!"");; 3507 return -1;; 3508 }; 3509 ; 3510 TString path;; 3511 ; 3512 // The BUILD.sh first; 3513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), """,MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128377,Availability,echo,echo,128377,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128550,Availability,echo,echo,128550,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128640,Availability,echo,echo,128640,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128987,Availability,echo,echo,128987,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:140696,Availability,down,downloaded,140696,"sert(clinfo);; 3840 }; 3841 }; 3842 }; 3843 }; 3844 ; 3845 // Write the StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:140759,Availability,down,download,140759," StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:140829,Availability,down,downloaded,140829," //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 389",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:148597,Availability,error,error,148597,"'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the f",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:149094,Availability,down,downloaded,149094,"Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:149157,Availability,down,download,149157,"he URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UN",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:149227,Availability,down,downloaded,149227,"will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirecti",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:151116,Availability,avail,available,151116,"input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:153032,Availability,error,errors,153032,"(aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter(",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:153057,Availability,failure,failure,153057,"(aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter(",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:157564,Availability,error,error,157564,"280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::Open( newUrl, option, ftitle, compress );; 4300 else; 4301 f = nullptr;; 4302 }; 4303 }; 4304 ; 4305 if (rediroutput) {; 4306 // Restore output to stdout; 4307 gSystem->RedirectOutput(0, """", &rh);; 4308 // If we failed print error messages; 4309 if (!f); 4310 gSystem->ShowOutput(&rh);; 4311 // Remove the file; 4312 gSystem->Unlink(rh.fFile);; 4313 }; 4314 ; 4315 // if the file is writable, non local, and not opened in raw mode; 4316 // we create a default write cache of 512 KBytes; 4317 if (type != kLocal && type != kFile &&; 4318 f && f->IsWritable() && !f->IsRaw()) {; 4319 new TFileCacheWrite(f, 1);; 4320 }; 4321 ; 4322 return f;; 4323}; 4324 ; 4325////////////////////////////////////////////////////////////////////////////////; 4326/// Submit an asynchronous open request.; 4327 ; 4328/// See TFile::Open(const char *, ...) for an; 4329/// explanation of the arguments. A handler is returned which is to be passed; 4330/// to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; 4331/// the file is open.; 4332/// This call never blocks and it is provided to allow parallel submission; 4333/// of file opening operati",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:159805,Availability,error,errors,159805,"n(TFile::AsyncOpen(const char *, ...)); 4338///; 4339/// is equivalent to; 4340///; 4341/// TFile::Open(const char *, ...); 4342///; 4343/// To be effective, the underlying TFile implementation must be able to; 4344/// support asynchronous open functionality. Currently, only TNetXNGFile; 4345/// supports it. If the functionality is not implemented, this call acts; 4346/// transparently by returning an handle with the arguments for the; 4347/// standard synchronous open run by TFile::Open(TFileOpenHandle *).; 4348/// The retuned handle will be adopted by TFile after opening completion; 4349/// in TFile::Open(TFileOpenHandle *); if opening is not finalized the; 4350/// handle must be deleted by the caller.; 4351 ; 4352TFileOpenHandle *TFile::AsyncOpen(const char *url, Option_t *option,; 4353 const char *ftitle, Int_t compress,; 4354 Int_t netopt); 4355{; 4356 TFileOpenHandle *fh = nullptr;; 4357 TFile *f = nullptr;; 4358 Bool_t notfound = kTRUE;; 4359 ; 4360 // Check input; 4361 if (!url || strlen(url) <= 0) {; 4362 ::Error(""TFile::AsyncOpen"", ""no url specified"");; 4363 return fh;; 4364 }; 4365 ; 4366 // Many URLs? Redirect output and print errors in case of global failure; 4367 TString namelist(url);; 4368 gSystem->ExpandPathName(namelist);; 4369 Ssiz_t ip = namelist.Index(""|"");; 4370 Bool_t rediroutput = (ip != kNPOS &&; 4371 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4372 RedirectHandle_t rh;; 4373 if (rediroutput) {; 4374 TString outf = "".TFileAsyncOpen_"";; 4375 FILE *fout = gSystem->TempFileName(outf);; 4376 if (fout) {; 4377 fclose(fout);; 4378 gSystem->RedirectOutput(outf, ""w"", &rh);; 4379 }; 4380 }; 4381 ; 4382 // Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetU",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:159830,Availability,failure,failure,159830,"n(TFile::AsyncOpen(const char *, ...)); 4338///; 4339/// is equivalent to; 4340///; 4341/// TFile::Open(const char *, ...); 4342///; 4343/// To be effective, the underlying TFile implementation must be able to; 4344/// support asynchronous open functionality. Currently, only TNetXNGFile; 4345/// supports it. If the functionality is not implemented, this call acts; 4346/// transparently by returning an handle with the arguments for the; 4347/// standard synchronous open run by TFile::Open(TFileOpenHandle *).; 4348/// The retuned handle will be adopted by TFile after opening completion; 4349/// in TFile::Open(TFileOpenHandle *); if opening is not finalized the; 4350/// handle must be deleted by the caller.; 4351 ; 4352TFileOpenHandle *TFile::AsyncOpen(const char *url, Option_t *option,; 4353 const char *ftitle, Int_t compress,; 4354 Int_t netopt); 4355{; 4356 TFileOpenHandle *fh = nullptr;; 4357 TFile *f = nullptr;; 4358 Bool_t notfound = kTRUE;; 4359 ; 4360 // Check input; 4361 if (!url || strlen(url) <= 0) {; 4362 ::Error(""TFile::AsyncOpen"", ""no url specified"");; 4363 return fh;; 4364 }; 4365 ; 4366 // Many URLs? Redirect output and print errors in case of global failure; 4367 TString namelist(url);; 4368 gSystem->ExpandPathName(namelist);; 4369 Ssiz_t ip = namelist.Index(""|"");; 4370 Bool_t rediroutput = (ip != kNPOS &&; 4371 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4372 RedirectHandle_t rh;; 4373 if (rediroutput) {; 4374 TString outf = "".TFileAsyncOpen_"";; 4375 FILE *fout = gSystem->TempFileName(outf);; 4376 if (fout) {; 4377 fclose(fout);; 4378 gSystem->RedirectOutput(outf, ""w"", &rh);; 4379 }; 4380 }; 4381 ; 4382 // Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetU",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:161370,Availability,error,error,161370,"Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetUrl();; 4391 ; 4392 // Resolve the file type; this also adjusts names; 4393 EFileType type = GetType(name, option);; 4394 ; 4395 TPluginHandler *h = nullptr;; 4396 ; 4397 // Here we send the asynchronous request if the functionality is implemented; 4398 if (type == kNet) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 gSystem->Unlink(rh.fFile);; 4417 }; 4418 ; 4419 // Make sure that no error occurred; 4420 if (notfound) {; 4421 SafeDelete(f);; 4422 // Save the arguments in the handler, so that a standard open can be; 4423 // attempted later on; 4424 fh = new TFileOpenHandle(name, option, ftitle, compress, netopt);; 4425 } else if (f) {; 4426 // Fill the opaque handler to be use to attach the file later on; 4427 fh = new TFileOpenHandle(f);; 4428 }; 4429 ; 4430 // Record this request; 4431 if (fh) {; 4432 // Create the lst, if not done already; 4433 if (!fgAsyncOpenRequests); 4434 fgAsyncOpenRequests = new TList;; 4435 fgAsyncOpenRequests->Add(fh);; 4436 }; 4437 ; 4438 // We are done; 4439 return fh;; 4440}; 4441 ; 4442////////////////////////////////////////////////////////////////////////////////; 4443/// Waits for the completion of an asyn",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:161544,Availability,error,error,161544,"et) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 gSystem->Unlink(rh.fFile);; 4417 }; 4418 ; 4419 // Make sure that no error occurred; 4420 if (notfound) {; 4421 SafeDelete(f);; 4422 // Save the arguments in the handler, so that a standard open can be; 4423 // attempted later on; 4424 fh = new TFileOpenHandle(name, option, ftitle, compress, netopt);; 4425 } else if (f) {; 4426 // Fill the opaque handler to be use to attach the file later on; 4427 fh = new TFileOpenHandle(f);; 4428 }; 4429 ; 4430 // Record this request; 4431 if (fh) {; 4432 // Create the lst, if not done already; 4433 if (!fgAsyncOpenRequests); 4434 fgAsyncOpenRequests = new TList;; 4435 fgAsyncOpenRequests->Add(fh);; 4436 }; 4437 ; 4438 // We are done; 4439 return fh;; 4440}; 4441 ; 4442////////////////////////////////////////////////////////////////////////////////; 4443/// Waits for the completion of an asynchronous open request.; 4444///; 4445/// Returns the pointer to the associated TFile, transferring ownership of the; 4446/// handle to the TFile instance.; 4447 ; 4448TFile *TFile::Open(TFileOpenHandle *fh); 4449{; 4450 TFile *f = nullptr;; 4451 ; 4452 // Note that the request may have failed; 4453 if (fh && fgAsyncOpenRequests) {; 4454 // Remove it from the pending list: we need to do it at this level to avoid; 4455 // recursive calls in the standard TFile::Open; 4456 fgAsyncOpenRequests->Remove(fh);; 4457 // Was asynchronous open functionality implemented?; 4458 if ((f = fh->GetFile()) && !(f",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172013,Availability,echo,echo,172013,"81 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173368,Availability,error,error,173368,") = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:180901,Availability,avail,available,180901, = gROOT->GetListOfFiles();; 4914 if (of && (of->GetSize() > 0)) {; 4915 TIter nxf(of);; 4916 TFile *f = nullptr;; 4917 while ((f = (TFile *)nxf())); 4918 if (f->Matches(name)); 4919 return f->GetAsyncOpenStatus();; 4920 }; 4921 ; 4922 // Default is synchronous mode; 4923 return kAOSNotAsync;; 4924}; 4925 ; 4926////////////////////////////////////////////////////////////////////////////////; 4927/// Get status of the async open request related to 'handle'.; 4928 ; 4929TFile::EAsyncOpenStatus TFile::GetAsyncOpenStatus(TFileOpenHandle *handle); 4930{; 4931 if (handle && handle->fFile) {; 4932 if (!handle->fFile->IsZombie()); 4933 return handle->fFile->GetAsyncOpenStatus();; 4934 else; 4935 return TFile::kAOSFailure;; 4936 }; 4937 ; 4938 // Default is synchronous mode; 4939 return TFile::kAOSNotAsync;; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Get final URL for file being opened asynchronously.; 4944/// Returns 0 is the information is not yet available.; 4945 ; 4946const TUrl *TFile::GetEndpointUrl(const char* name); 4947{; 4948 // Check the list of pending async open requests; 4949 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4950 TIter nxr(fgAsyncOpenRequests);; 4951 TFileOpenHandle *fh = nullptr;; 4952 while ((fh = (TFileOpenHandle *)nxr())); 4953 if (fh->Matches(name)); 4954 if (fh->fFile); 4955 return fh->fFile->GetEndpointUrl();; 4956 }; 4957 ; 4958 // Check also the list of files open; 4959 R__LOCKGUARD(gROOTMutex);; 4960 TSeqCollection *of = gROOT->GetListOfFiles();; 4961 if (of && (of->GetSize() > 0)) {; 4962 TIter nxf(of);; 4963 TFile *f = nullptr;; 4964 while ((f = (TFile *)nxf())); 4965 if (f->Matches(name)); 4966 return f->GetEndpointUrl();; 4967 }; 4968 ; 4969 // Information not yet available; 4970 return (const TUrl *)nullptr;; 4971}; 4972 ; 4973////////////////////////////////////////////////////////////////////////////////; 4974/// Print file copy progress.; 4975 ;,MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:181693,Availability,avail,available,181693,"cOpenStatus(TFileOpenHandle *handle); 4930{; 4931 if (handle && handle->fFile) {; 4932 if (!handle->fFile->IsZombie()); 4933 return handle->fFile->GetAsyncOpenStatus();; 4934 else; 4935 return TFile::kAOSFailure;; 4936 }; 4937 ; 4938 // Default is synchronous mode; 4939 return TFile::kAOSNotAsync;; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Get final URL for file being opened asynchronously.; 4944/// Returns 0 is the information is not yet available.; 4945 ; 4946const TUrl *TFile::GetEndpointUrl(const char* name); 4947{; 4948 // Check the list of pending async open requests; 4949 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4950 TIter nxr(fgAsyncOpenRequests);; 4951 TFileOpenHandle *fh = nullptr;; 4952 while ((fh = (TFileOpenHandle *)nxr())); 4953 if (fh->Matches(name)); 4954 if (fh->fFile); 4955 return fh->fFile->GetEndpointUrl();; 4956 }; 4957 ; 4958 // Check also the list of files open; 4959 R__LOCKGUARD(gROOTMutex);; 4960 TSeqCollection *of = gROOT->GetListOfFiles();; 4961 if (of && (of->GetSize() > 0)) {; 4962 TIter nxf(of);; 4963 TFile *f = nullptr;; 4964 while ((f = (TFile *)nxf())); 4965 if (f->Matches(name)); 4966 return f->GetEndpointUrl();; 4967 }; 4968 ; 4969 // Information not yet available; 4970 return (const TUrl *)nullptr;; 4971}; 4972 ; 4973////////////////////////////////////////////////////////////////////////////////; 4974/// Print file copy progress.; 4975 ; 4976void TFile::CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch); 4977{; 4978 fprintf(stderr, ""[TFile::Cp] Total %.02f MB\t|"", (Double_t)size/1048576);; 4979 ; 4980 for (int l = 0; l < 20; l++) {; 4981 if (size > 0) {; 4982 if (l < 20*bytesread/size); 4983 fprintf(stderr, ""="");; 4984 else if (l == 20*bytesread/size); 4985 fprintf(stderr, "">"");; 4986 else if (l > 20*bytesread/size); 4987 fprintf(stderr, ""."");; 4988 } else; 4989 fprintf(stderr, ""="");; 4990 }; 4991 // Allow to update the GUI ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:184425,Availability,error,errors,184425,"""alien"")); 5025 opt += TString::Format(""&source=%s"", GetName());; 5026 ; 5027 dURL.SetOptions(opt);; 5028 ; 5029 char *copybuffer = nullptr;; 5030 ; 5031 TFile *sfile = this;; 5032 TFile *dfile = nullptr;; 5033 ; 5034 // ""RECREATE"" does not work always well with XROOTD; 5035 // namely when some pieces of the path are missing;; 5036 // we force ""NEW"" in such a case; 5037 if (TFile::GetType(ourl, """") == TFile::kNet) {; 5038 if (gSystem->AccessPathName(ourl)) {; 5039 oopt = ""NEW"";; 5040 // Force creation of the missing parts of the path; 5041 opt += ""&mkpath=1"";; 5042 dURL.SetOptions(opt);; 5043 }; 5044 }; 5045 ; 5046 // Open destination file; 5047 if (!(dfile = TFile::Open(dURL.GetUrl(), oopt))) {; 5048 ::Error(""TFile::Cp"", ""cannot open destination file %s"", dst);; 5049 goto copyout;; 5050 }; 5051 ; 5052 // Probably we created a new file; 5053 // We have to remove it in case of errors; 5054 rmdestiferror = kTRUE;; 5055 ; 5056 sfile->Seek(0);; 5057 dfile->Seek(0);; 5058 ; 5059 copybuffer = new char[buffersize];; 5060 if (!copybuffer) {; 5061 ::Error(""TFile::Cp"", ""cannot allocate the copy buffer"");; 5062 goto copyout;; 5063 }; 5064 ; 5065 Bool_t readop, writeop;; 5066 Long64_t read, written, totalread, filesize, b00;; 5067 ; 5068 totalread = 0;; 5069 filesize = sfile->GetSize();; 5070 ; 5071 watch.Start();; 5072 ; 5073 b00 = sfile->GetBytesRead();; 5074 ; 5075 do {; 5076 if (progressbar) CpProgress(totalread, filesize,watch);; 5077 ; 5078 Long64_t b1 = sfile->GetBytesRead() - b00;; 5079 ; 5080 Long64_t readsize;; 5081 if (filesize - b1 > (Long64_t)buffersize) {; 5082 readsize = buffersize;; 5083 } else {; 5084 readsize = filesize - b1;; 5085 }; 5086 ; 5087 if (readsize == 0) break;; 5088 ; 5089 Long64_t b0 = sfile->GetBytesRead();; 5090 sfile->Seek(totalread,TFile::kBeg);; 5091 readop = sfile->ReadBuffer(copybuffer, (Int_t)readsize);; 5092 read = sfile->GetBytesRead() - b0;; 5093 if ((read <= 0) || readop) {; 5094 ::Error(""TFile::Cp"", ""cannot read from source file %s. r",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:229202,Availability,recover,recover,229202,"mory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Drawvoid Draw(Option_t *option="""") overrideFill Graphics Structure and Paint.Definition TFile.cxx:1111; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::IsATClass * IsA() const overrideDefinition TFile.h:344; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:237836,Availability,error,error,237836,") const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:238531,Availability,error,error,238531,"444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::MatchInt_t Match(const TString &s, UInt_t start=0)Runs a match on s against the regex 'this' was created with.Definition TPRegexp.cxx:797; TPluginHandle",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:238667,Availability,error,error,238667,"niqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::MatchInt_t Match(const TString &s, UInt_t start=0)Runs a match on s against the regex 'this' was created with.Definition TPRegexp.cxx:797; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TProcessI",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:246812,Availability,error,error,246812,"seCompare cmp=kExact) constDefinition TString.h:651; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::GetIn",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:247087,Availability,error,error,247087,"ystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::ShowOutputvirtual void ShowOutput(RedirectHandle_t *h)Display the content associated with the redirection described by the opaque handle 'h'.Definition TSystem.cxx",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:247242,Availability,error,error,247242,"edirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::Chmodvirtual int Chmod(const char *file, UInt_t mode)Set the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TSystem.cxx:1508; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::CopyFilevirtual int CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE)Copy a file.Definition TSystem.cxx:1341; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::ShowOutputvirtual void ShowOutput(RedirectHandle_t *h)Display the content associated with the redirection described by the opaque handle 'h'.Definition TSystem.cxx:1725; TSystem::IsPathLocalvirtual Bool_t IsPathLocal(const char *path)Returns TRUE if the url in 'path' points to the local file system.Definition TSystem.cxx:1305; TSystem::mkdirvirtual ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:17552,Deployability,update,update,17552," this) : nullptr;; 408 if (fArchive) {; 409 fname1 = fArchive->GetArchiveName();; 410 // if no archive member is specified then this TFile is just used; 411 // to read the archive contents; 412 if (!strlen(fArchive->GetMemberName())); 413 fIsArchive = kTRUE;; 414 }; 415 }; 416 ; 417 if (fOption.Contains(""_WITHOUT_GLOBALREGISTRATION"")) {; 418 fOption = fOption.ReplaceAll(""_WITHOUT_GLOBALREGISTRATION"", """");; 419 fGlobalRegistration = false;; 420 if (fList) {; 421 fList->UseRWLock(false);; 422 }; 423 }; 424 ; 425 if (fOption == ""NET""); 426 return;; 427 ; 428 if (fOption == ""WEB"") {; 429 fOption = ""READ"";; 430 fWritable = kFALSE;; 431 return;; 432 }; 433 ; 434 if (fOption == ""NEW""); 435 fOption = ""CREATE"";; 436 ; 437 Bool_t create = (fOption == ""CREATE"") ? kTRUE : kFALSE;; 438 Bool_t recreate = (fOption == ""RECREATE"") ? kTRUE : kFALSE;; 439 Bool_t update = (fOption == ""UPDATE"") ? kTRUE : kFALSE;; 440 Bool_t read = (fOption == ""READ"") ? kTRUE : kFALSE;; 441 if (!create && !recreate && !update && !read) {; 442 read = kTRUE;; 443 fOption = ""READ"";; 444 }; 445 ; 446 Bool_t devnull = kFALSE;; 447 ; 448 if (!fname1 || !fname1[0]) {; 449 Error(""TFile"", ""file name is not specified"");; 450 zombify();; 451 return;; 452 }; 453 ; 454 // support dumping to /dev/null on UNIX; 455 if (!strcmp(fname1, ""/dev/null"") &&; 456 !gSystem->AccessPathName(fname1, kWritePermission)) {; 457 devnull = kTRUE;; 458 create = kTRUE;; 459 recreate = kFALSE;; 460 update = kFALSE;; 461 read = kFALSE;; 462 fOption = ""CREATE"";; 463 SetBit(kDevNull);; 464 }; 465 ; 466 TString fname(fname1);; 467 if (!gSystem->ExpandPathName(fname)) {; 468 SetName(fname.Data());; 469 fRealName = GetName();; 470 if (!gSystem->IsAbsoluteFileName(fRealName)) {; 471 gSystem->PrependPathName(gSystem->WorkingDirectory(),fRealName);; 472 }; 473 fname = fRealName.Data();; 474 } else {; 475 Error(""TFile"", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option ta",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:17692,Deployability,update,update,17692," this) : nullptr;; 408 if (fArchive) {; 409 fname1 = fArchive->GetArchiveName();; 410 // if no archive member is specified then this TFile is just used; 411 // to read the archive contents; 412 if (!strlen(fArchive->GetMemberName())); 413 fIsArchive = kTRUE;; 414 }; 415 }; 416 ; 417 if (fOption.Contains(""_WITHOUT_GLOBALREGISTRATION"")) {; 418 fOption = fOption.ReplaceAll(""_WITHOUT_GLOBALREGISTRATION"", """");; 419 fGlobalRegistration = false;; 420 if (fList) {; 421 fList->UseRWLock(false);; 422 }; 423 }; 424 ; 425 if (fOption == ""NET""); 426 return;; 427 ; 428 if (fOption == ""WEB"") {; 429 fOption = ""READ"";; 430 fWritable = kFALSE;; 431 return;; 432 }; 433 ; 434 if (fOption == ""NEW""); 435 fOption = ""CREATE"";; 436 ; 437 Bool_t create = (fOption == ""CREATE"") ? kTRUE : kFALSE;; 438 Bool_t recreate = (fOption == ""RECREATE"") ? kTRUE : kFALSE;; 439 Bool_t update = (fOption == ""UPDATE"") ? kTRUE : kFALSE;; 440 Bool_t read = (fOption == ""READ"") ? kTRUE : kFALSE;; 441 if (!create && !recreate && !update && !read) {; 442 read = kTRUE;; 443 fOption = ""READ"";; 444 }; 445 ; 446 Bool_t devnull = kFALSE;; 447 ; 448 if (!fname1 || !fname1[0]) {; 449 Error(""TFile"", ""file name is not specified"");; 450 zombify();; 451 return;; 452 }; 453 ; 454 // support dumping to /dev/null on UNIX; 455 if (!strcmp(fname1, ""/dev/null"") &&; 456 !gSystem->AccessPathName(fname1, kWritePermission)) {; 457 devnull = kTRUE;; 458 create = kTRUE;; 459 recreate = kFALSE;; 460 update = kFALSE;; 461 read = kFALSE;; 462 fOption = ""CREATE"";; 463 SetBit(kDevNull);; 464 }; 465 ; 466 TString fname(fname1);; 467 if (!gSystem->ExpandPathName(fname)) {; 468 SetName(fname.Data());; 469 fRealName = GetName();; 470 if (!gSystem->IsAbsoluteFileName(fRealName)) {; 471 gSystem->PrependPathName(gSystem->WorkingDirectory(),fRealName);; 472 }; 473 fname = fRealName.Data();; 474 } else {; 475 Error(""TFile"", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option ta",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:18146,Deployability,update,update,18146," this) : nullptr;; 408 if (fArchive) {; 409 fname1 = fArchive->GetArchiveName();; 410 // if no archive member is specified then this TFile is just used; 411 // to read the archive contents; 412 if (!strlen(fArchive->GetMemberName())); 413 fIsArchive = kTRUE;; 414 }; 415 }; 416 ; 417 if (fOption.Contains(""_WITHOUT_GLOBALREGISTRATION"")) {; 418 fOption = fOption.ReplaceAll(""_WITHOUT_GLOBALREGISTRATION"", """");; 419 fGlobalRegistration = false;; 420 if (fList) {; 421 fList->UseRWLock(false);; 422 }; 423 }; 424 ; 425 if (fOption == ""NET""); 426 return;; 427 ; 428 if (fOption == ""WEB"") {; 429 fOption = ""READ"";; 430 fWritable = kFALSE;; 431 return;; 432 }; 433 ; 434 if (fOption == ""NEW""); 435 fOption = ""CREATE"";; 436 ; 437 Bool_t create = (fOption == ""CREATE"") ? kTRUE : kFALSE;; 438 Bool_t recreate = (fOption == ""RECREATE"") ? kTRUE : kFALSE;; 439 Bool_t update = (fOption == ""UPDATE"") ? kTRUE : kFALSE;; 440 Bool_t read = (fOption == ""READ"") ? kTRUE : kFALSE;; 441 if (!create && !recreate && !update && !read) {; 442 read = kTRUE;; 443 fOption = ""READ"";; 444 }; 445 ; 446 Bool_t devnull = kFALSE;; 447 ; 448 if (!fname1 || !fname1[0]) {; 449 Error(""TFile"", ""file name is not specified"");; 450 zombify();; 451 return;; 452 }; 453 ; 454 // support dumping to /dev/null on UNIX; 455 if (!strcmp(fname1, ""/dev/null"") &&; 456 !gSystem->AccessPathName(fname1, kWritePermission)) {; 457 devnull = kTRUE;; 458 create = kTRUE;; 459 recreate = kFALSE;; 460 update = kFALSE;; 461 read = kFALSE;; 462 fOption = ""CREATE"";; 463 SetBit(kDevNull);; 464 }; 465 ; 466 TString fname(fname1);; 467 if (!gSystem->ExpandPathName(fname)) {; 468 SetName(fname.Data());; 469 fRealName = GetName();; 470 if (!gSystem->IsAbsoluteFileName(fRealName)) {; 471 gSystem->PrependPathName(gSystem->WorkingDirectory(),fRealName);; 472 }; 473 fname = fRealName.Data();; 474 } else {; 475 Error(""TFile"", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option ta",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:19454,Deployability,update,update,19454,"me(gSystem->WorkingDirectory(),fRealName);; 472 }; 473 fname = fRealName.Data();; 474 } else {; 475 Error(""TFile"", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option take it as the name to set for; 481 // the file instead of the actual filename; 482 if (TestBit(kReproducible)) {; 483 if(auto name=fUrl.GetValueFromOptions(""reproducible"")) {; 484 SetName(name);; 485 }; 486 }; 487 ; 488 if (recreate) {; 489 if (!gSystem->AccessPathName(fname.Data(), kFileExists)) {; 490 if (gSystem->Unlink(fname.Data()) != 0) {; 491 SysError(""TFile"", ""could not delete %s (errno: %d)"",; 492 fname.Data(), gSystem->GetErrno());; 493 zombify();; 494 return;; 495 }; 496 }; 497 recreate = kFALSE;; 498 create = kTRUE;; 499 fOption = ""CREATE"";; 500 }; 501 if (create && !devnull && !gSystem->AccessPathName(fname.Data(), kFileExists)) {; 502 Error(""TFile"", ""file %s already exists"", fname.Data());; 503 zombify();; 504 return;; 505 }; 506 if (update) {; 507 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 508 update = kFALSE;; 509 create = kTRUE;; 510 }; 511 if (update && gSystem->AccessPathName(fname.Data(), kWritePermission)) {; 512 Error(""TFile"", ""no write permission, could not open file %s"", fname.Data());; 513 zombify();; 514 return;; 515 }; 516 }; 517 if (read) {; 518 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 519 Error(""TFile"", ""file %s does not exist"", fname.Data());; 520 zombify();; 521 return;; 522 }; 523 if (gSystem->AccessPathName(fname.Data(), kReadPermission)) {; 524 Error(""TFile"", ""no read permission, could not open file %s"", fname.Data());; 525 zombify();; 526 return;; 527 }; 528 }; 529 ; 530 // Connect to file system stream; 531 if (create || update) {; 532#ifndef WIN32; 533 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT, 0644);; 534#else; 535 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 536#endif; 537 if (fD == -1) {; 538 SysError(""TFi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:19532,Deployability,update,update,19532,", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option take it as the name to set for; 481 // the file instead of the actual filename; 482 if (TestBit(kReproducible)) {; 483 if(auto name=fUrl.GetValueFromOptions(""reproducible"")) {; 484 SetName(name);; 485 }; 486 }; 487 ; 488 if (recreate) {; 489 if (!gSystem->AccessPathName(fname.Data(), kFileExists)) {; 490 if (gSystem->Unlink(fname.Data()) != 0) {; 491 SysError(""TFile"", ""could not delete %s (errno: %d)"",; 492 fname.Data(), gSystem->GetErrno());; 493 zombify();; 494 return;; 495 }; 496 }; 497 recreate = kFALSE;; 498 create = kTRUE;; 499 fOption = ""CREATE"";; 500 }; 501 if (create && !devnull && !gSystem->AccessPathName(fname.Data(), kFileExists)) {; 502 Error(""TFile"", ""file %s already exists"", fname.Data());; 503 zombify();; 504 return;; 505 }; 506 if (update) {; 507 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 508 update = kFALSE;; 509 create = kTRUE;; 510 }; 511 if (update && gSystem->AccessPathName(fname.Data(), kWritePermission)) {; 512 Error(""TFile"", ""no write permission, could not open file %s"", fname.Data());; 513 zombify();; 514 return;; 515 }; 516 }; 517 if (read) {; 518 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 519 Error(""TFile"", ""file %s does not exist"", fname.Data());; 520 zombify();; 521 return;; 522 }; 523 if (gSystem->AccessPathName(fname.Data(), kReadPermission)) {; 524 Error(""TFile"", ""no read permission, could not open file %s"", fname.Data());; 525 zombify();; 526 return;; 527 }; 528 }; 529 ; 530 // Connect to file system stream; 531 if (create || update) {; 532#ifndef WIN32; 533 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT, 0644);; 534#else; 535 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 536#endif; 537 if (fD == -1) {; 538 SysError(""TFile"", ""file %s can not be opened"", fname.Data());; 539 zombify();; 540 return;; 541 }; 542 fWritable = kTRUE;; 543",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:19586,Deployability,update,update,19586,", ""error expanding path %s"", fname1);; 476 zombify();; 477 return;; 478 }; 479 ; 480 // If the user supplied a value to the option take it as the name to set for; 481 // the file instead of the actual filename; 482 if (TestBit(kReproducible)) {; 483 if(auto name=fUrl.GetValueFromOptions(""reproducible"")) {; 484 SetName(name);; 485 }; 486 }; 487 ; 488 if (recreate) {; 489 if (!gSystem->AccessPathName(fname.Data(), kFileExists)) {; 490 if (gSystem->Unlink(fname.Data()) != 0) {; 491 SysError(""TFile"", ""could not delete %s (errno: %d)"",; 492 fname.Data(), gSystem->GetErrno());; 493 zombify();; 494 return;; 495 }; 496 }; 497 recreate = kFALSE;; 498 create = kTRUE;; 499 fOption = ""CREATE"";; 500 }; 501 if (create && !devnull && !gSystem->AccessPathName(fname.Data(), kFileExists)) {; 502 Error(""TFile"", ""file %s already exists"", fname.Data());; 503 zombify();; 504 return;; 505 }; 506 if (update) {; 507 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 508 update = kFALSE;; 509 create = kTRUE;; 510 }; 511 if (update && gSystem->AccessPathName(fname.Data(), kWritePermission)) {; 512 Error(""TFile"", ""no write permission, could not open file %s"", fname.Data());; 513 zombify();; 514 return;; 515 }; 516 }; 517 if (read) {; 518 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 519 Error(""TFile"", ""file %s does not exist"", fname.Data());; 520 zombify();; 521 return;; 522 }; 523 if (gSystem->AccessPathName(fname.Data(), kReadPermission)) {; 524 Error(""TFile"", ""no read permission, could not open file %s"", fname.Data());; 525 zombify();; 526 return;; 527 }; 528 }; 529 ; 530 // Connect to file system stream; 531 if (create || update) {; 532#ifndef WIN32; 533 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT, 0644);; 534#else; 535 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 536#endif; 537 if (fD == -1) {; 538 SysError(""TFile"", ""file %s can not be opened"", fname.Data());; 539 zombify();; 540 return;; 541 }; 542 fWritable = kTRUE;; 543",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:20211,Deployability,update,update,20211,"}; 497 recreate = kFALSE;; 498 create = kTRUE;; 499 fOption = ""CREATE"";; 500 }; 501 if (create && !devnull && !gSystem->AccessPathName(fname.Data(), kFileExists)) {; 502 Error(""TFile"", ""file %s already exists"", fname.Data());; 503 zombify();; 504 return;; 505 }; 506 if (update) {; 507 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 508 update = kFALSE;; 509 create = kTRUE;; 510 }; 511 if (update && gSystem->AccessPathName(fname.Data(), kWritePermission)) {; 512 Error(""TFile"", ""no write permission, could not open file %s"", fname.Data());; 513 zombify();; 514 return;; 515 }; 516 }; 517 if (read) {; 518 if (gSystem->AccessPathName(fname.Data(), kFileExists)) {; 519 Error(""TFile"", ""file %s does not exist"", fname.Data());; 520 zombify();; 521 return;; 522 }; 523 if (gSystem->AccessPathName(fname.Data(), kReadPermission)) {; 524 Error(""TFile"", ""no read permission, could not open file %s"", fname.Data());; 525 zombify();; 526 return;; 527 }; 528 }; 529 ; 530 // Connect to file system stream; 531 if (create || update) {; 532#ifndef WIN32; 533 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT, 0644);; 534#else; 535 fD = TFile::SysOpen(fname.Data(), O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 536#endif; 537 if (fD == -1) {; 538 SysError(""TFile"", ""file %s can not be opened"", fname.Data());; 539 zombify();; 540 return;; 541 }; 542 fWritable = kTRUE;; 543 } else {; 544#ifndef WIN32; 545 fD = TFile::SysOpen(fname.Data(), O_RDONLY, 0644);; 546#else; 547 fD = TFile::SysOpen(fname.Data(), O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);; 548#endif; 549 if (fD == -1) {; 550 SysError(""TFile"", ""file %s can not be opened for reading"", fname.Data());; 551 zombify();; 552 return;; 553 }; 554 fWritable = kFALSE;; 555 }; 556 ; 557 // calling virtual methods from constructor not a good idea, but it is how code was developed; 558 TFile::Init(create); // NOLINT: silence clang-tidy warnings; 559}; 560 ; 561//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:50569,Deployability,release,released,50569,"1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in addition to TStreamerInfo object, contains sometimes; 1433/// a TList named 'listOfRules' and containing the schema evolution rules; 1434/// related to the file's content.; 1435///; 1436/// Using the list, one can access additional information, e.g.:; 1437/// ~~~{.cpp}; 1438/// TFile f(""myfile.root"");; 1439/// auto list = f.GetStreamerInfoList();; 1440/// auto info = dynamic_cast<TStreamerInfo*>(list->FindObject(""MyClass""));; 1441/// if (info) auto classversionid = info->GetClassVersion();; 1442/// delete list;; 1443/// ~~~; 1444///; 1445 ; 1446TList *TFile::GetStreamerInfoList(); 1447{; 1448 return GetStreamerInfoListIm",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:53858,Deployability,update,update,53858,"::IsOpen() const; 1471{; 1472 return fD == -1 ? kFALSE : kTRUE;; 1473}; 1474 ; 1475////////////////////////////////////////////////////////////////////////////////; 1476/// Mark unused bytes on the file.; 1477///; 1478/// The list of free segments is in the fFree linked list.; 1479/// When an object is deleted from the file, the freed space is added; 1480/// into the FREE linked list (fFree). The FREE list consists of a chain; 1481/// of consecutive free segments on the file. At the same time, the first; 1482/// 4 bytes of the freed record on the file are overwritten by GAPSIZE; 1483/// where GAPSIZE = -(Number of bytes occupied by the record).; 1484 ; 1485void TFile::MakeFree(Long64_t first, Long64_t last); 1486{; 1487 TFree *f1 = (TFree*)fFree->First();; 1488 if (!f1) return;; 1489 TFree *newfree = f1->AddFree(fFree,first,last);; 1490 if(!newfree) return;; 1491 Long64_t nfirst = newfree->GetFirst();; 1492 Long64_t nlast = newfree->GetLast();; 1493 Long64_t nbytesl= nlast-nfirst+1;; 1494 if (nbytesl > 2000000000) nbytesl = 2000000000;; 1495 Int_t nbytes = -Int_t (nbytesl);; 1496 Int_t nb = sizeof(Int_t);; 1497 char * buffer = new char[nb];; 1498 char * psave = buffer;; 1499 tobuf(buffer, nbytes);; 1500 if (last == fEND-1) fEND = nfirst;; 1501 Seek(nfirst);; 1502 // We could not update the meta data for this block on the file.; 1503 // This is not fatal as this only means that we won't get it 'right'; 1504 // if we ever need to Recover the file before the block is actually; 1505 // (attempted to be reused.; 1506 // coverity[unchecked_value]; 1507 WriteBuffer(psave, nb);; 1508 if (fMustFlush) Flush();; 1509 delete [] psave;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// List the contents of a file sequentially.; 1514/// For each logical record found, it prints:; 1515///; 1516/// Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor; 1517///; 1518/// Example of output; 1519///; 1520/// 2",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72047,Deployability,update,update,72047,"; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:77711,Deployability,pipeline,pipeline,77711,,MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:79182,Deployability,update,update,79182," (opt == ""READ"") {; 2179 // switch to READ mode; 2180 ; 2181 // flush data still in the pipeline and close the file; 2182 if (IsOpen() && IsWritable()) {; 2183 WriteStreamerInfo();; 2184 ; 2185 // save directory key list and header; 2186 Save();; 2187 ; 2188 TFree *f1 = (TFree*)fFree->First();; 2189 if (f1) {; 2190 WriteFree(); // write free segments linked list; 2191 WriteHeader(); // now write file header; 2192 }; 2193 ; 2194 FlushWriteCache();; 2195 ; 2196 // delete free segments from free list; 2197 fFree->Delete();; 2198 SafeDelete(fFree);; 2199 ; 2200 SysClose(fD);; 2201 fD = -1;; 2202 ; 2203 SetWritable(kFALSE);; 2204 }; 2205 ; 2206 // open in READ mode; 2207 fOption = opt; // set fOption before SysOpen() for TNetFile; 2208#ifndef WIN32; 2209 fD = SysOpen(fRealName, O_RDONLY, 0644);; 2210#else; 2211 fD = SysOpen(fRealName, O_RDONLY | O_BINARY, S_IREAD | S_IWRITE);; 2212#endif; 2213 if (fD == -1) {; 2214 SysError(""ReOpen"", ""file %s can not be opened in read mode"", GetName());; 2215 return -1;; 2216 }; 2217 SetWritable(kFALSE);; 2218 ; 2219 } else {; 2220 // switch to UPDATE mode; 2221 ; 2222 // close readonly file; 2223 if (IsOpen()) {; 2224 SysClose(fD);; 2225 fD = -1;; 2226 }; 2227 ; 2228 // open in UPDATE mode; 2229 fOption = opt; // set fOption before SysOpen() for TNetFile; 2230#ifndef WIN32; 2231 fD = SysOpen(fRealName, O_RDWR | O_CREAT, 0644);; 2232#else; 2233 fD = SysOpen(fRealName, O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 2234#endif; 2235 if (fD == -1) {; 2236 SysError(""ReOpen"", ""file %s can not be opened in update mode"", GetName());; 2237 return -1;; 2238 }; 2239 SetWritable(kTRUE);; 2240 ; 2241 fFree = new TList;; 2242 if (fSeekFree > fBEGIN); 2243 ReadFree();; 2244 else; 2245 Warning(""ReOpen"",""file %s probably not closed, cannot read free segments"", GetName());; 2246 }; 2247 ; 2248 return 0;; 2249}; 2250 ; 2251////////////////////////////////////////////////////////////////////////////////; 2252/// Set position from where to start reading.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:95960,Deployability,update,update,95960,"of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__Vertex_int_.h; 2678///; 2679/// In the generated classes, map, multimap when the first template parameter is a class; 2680/// are replaced by a vector of pair. set and multiset when the tempalte parameter; 2681/// is a class are replaced by a vector. This is required since we do not have the; 2682/// code needed to order and/or compare the object of the classes.; 2683/// This is a quick explanation of the options available:; 2684/// Option | Details; 2685/// -------|--------; 2686/// new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.; 2687/// recreate | If dirname does not exist, it is created (like in ""new""). If dirname already exist, all existing files in dirname are deleted before creating the new files.; 2688/// update | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as ""new"".; 2689/// genreflex | Use genreflex rather than rootcint to generate the dictionary.; 2690/// par | Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; 2691///; 2692/// If, in addition to one of the 3 above options, the option ""+"" is specified,; 2693/// the function will generate:; 2694/// - a script called MAKEP to build the shared lib; 2695/// - a dirnameLinkDef.h file; 2696/// - rootcint will be run to generate a dirnameProjectDict.cxx file; 2697/// - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; 2698/// - a shared lib dirname.so will be created.; 2699/// If the option ""++"" is specified, the generated shared lib i",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:100559,Deployability,update,update,100559,"file = gSystem->GetDirEntry(dirp))) {; 2762 if (strcmp(afile,""."") == 0) continue;; 2763 if (strcmp(afile,"".."") == 0) continue;; 2764 filepath.Form(""%s/%s"", path.Data(), afile);; 2765 if (gSystem->Unlink(filepath)); 2766 Warning(""MakeProject"", ""2: problems unlinking '%s' ('%s', '%s')"", filepath.Data(), path.Data(), afile);; 2767 }; 2768 gSystem->FreeDirectory(dirp);; 2769 if (gSystem->Unlink(path)); 2770 Warning(""MakeProject"", ""problems unlinking '%s'"", path.Data());; 2771 }; 2772 }; 2773 // Make sure that the relevant dirs exists: this is mandatory, so we fail if unsuccessful; 2774 path.Form(""%s/%s/PROOF-INF"", pardir.Data(), parname.Data());; 2775 if (gSystem->mkdir(path, kTRUE)) {; 2776 Error(""MakeProject"", ""problems creating '%s'"", path.Data());; 2777 return;; 2778 }; 2779 makepar = kTRUE;; 2780 ; 2781 } else {; 2782 void *dir = gSystem->OpenDirectory(dirname);; 2783 TString dirpath;; 2784 ; 2785 if (opt.Contains(""update"")) {; 2786 // check that directory exist, if not create it; 2787 if (!dir) {; 2788 gSystem->mkdir(dirname);; 2789 }; 2790 ; 2791 } else if (opt.Contains(""recreate"")) {; 2792 // check that directory exist, if not create it; 2793 if (!dir) {; 2794 if (gSystem->mkdir(dirname) < 0) {; 2795 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2796 return;; 2797 }; 2798 }; 2799 // clear directory; 2800 while (dir) {; 2801 const char *afile = gSystem->GetDirEntry(dir);; 2802 if (!afile) break;; 2803 if (strcmp(afile,""."") == 0) continue;; 2804 if (strcmp(afile,"".."") == 0) continue;; 2805 dirpath.Form(""%s/%s"",dirname,afile);; 2806 gSystem->Unlink(dirpath);; 2807 }; 2808 ; 2809 } else {; 2810 // new is assumed; 2811 // if directory already exist, print error message and return; 2812 if (dir) {; 2813 Error(""MakeProject"",""cannot create directory %s, already existing"",dirname);; 2814 gSystem->FreeDirectory(dir);; 2815 return;; 2816 }; 2817 if (gSystem->mkdir(dirname) < 0) {; 2818 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2819 return",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:130933,Deployability,update,updated,130933,"\n"");; 3577 fprintf(f, ""// Printf(\""event-SETUP: PROOF-Lite node (session has %%s workers)\"",\n"");; 3578 fprintf(f, ""// gSystem->Getenv(\""ROOTPROOFLITE\""));\n"");; 3579 fprintf(f, ""// } else if (gSystem->Getenv(\""ROOTPROOFCLIENT\"")) {\n"");; 3580 fprintf(f, ""// Printf(\""event-SETUP: PROOF client\"");\n"");; 3581 fprintf(f, ""// } else {\n"");; 3582 fprintf(f, ""// Printf(\""event-SETUP: standard PROOF node\"");\n"");; 3583 fprintf(f, ""// }\n"");; 3584 fprintf(f, ""\n"");; 3585 fprintf(f, "" if (gSystem->Load(\""lib%s\"") == -1)\n"", pack);; 3586 fprintf(f, "" return -1;\n"");; 3587 fprintf(f, "" return 0;\n"");; 3588 fprintf(f, ""}\n"");; 3589 fprintf(f, ""\n"");; 3590 ; 3591 // Close the file; 3592 fclose(f);; 3593 ; 3594 // Done; 3595 return 0;; 3596}; 3597 ; 3598////////////////////////////////////////////////////////////////////////////////; 3599/// Read the list of StreamerInfo from this file.; 3600///; 3601/// The key with name holding the list of TStreamerInfo objects is read.; 3602/// The corresponding TClass objects are updated.; 3603/// Note that this function is not called if the static member fgReadInfo is false.; 3604/// (see TFile::SetReadStreamerInfo); 3605 ; 3606void TFile::ReadStreamerInfo(); 3607{; 3608 auto listRetcode = GetStreamerInfoListImpl(/*lookupSICache*/ true); // NOLINT: silence clang-tidy warnings; 3609 TList *list = listRetcode.fList;; 3610 auto retcode = listRetcode.fReturnCode;; 3611 if (!list) {; 3612 if (retcode) MakeZombie();; 3613 return;; 3614 }; 3615 ; 3616 list->SetOwner(kFALSE);; 3617 ; 3618 if (gDebug > 0) Info(""ReadStreamerInfo"", ""called for file %s"",GetName());; 3619 ; 3620 TStreamerInfo *info;; 3621 ; 3622 Int_t version = fVersion;; 3623 if (version > 1000000) version -= 1000000;; 3624 if (version < 53419 || (59900 < version && version < 59907)) {; 3625 // We need to update the fCheckSum field of the TStreamerBase.; 3626 ; 3627 // loop on all TStreamerInfo classes; 3628 TObjLink *lnk = list->FirstLink();; 3629 while (lnk) {; 3630 info = (TStreamerI",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:131730,Deployability,update,update,131730,"printf(f, ""\n"");; 3590 ; 3591 // Close the file; 3592 fclose(f);; 3593 ; 3594 // Done; 3595 return 0;; 3596}; 3597 ; 3598////////////////////////////////////////////////////////////////////////////////; 3599/// Read the list of StreamerInfo from this file.; 3600///; 3601/// The key with name holding the list of TStreamerInfo objects is read.; 3602/// The corresponding TClass objects are updated.; 3603/// Note that this function is not called if the static member fgReadInfo is false.; 3604/// (see TFile::SetReadStreamerInfo); 3605 ; 3606void TFile::ReadStreamerInfo(); 3607{; 3608 auto listRetcode = GetStreamerInfoListImpl(/*lookupSICache*/ true); // NOLINT: silence clang-tidy warnings; 3609 TList *list = listRetcode.fList;; 3610 auto retcode = listRetcode.fReturnCode;; 3611 if (!list) {; 3612 if (retcode) MakeZombie();; 3613 return;; 3614 }; 3615 ; 3616 list->SetOwner(kFALSE);; 3617 ; 3618 if (gDebug > 0) Info(""ReadStreamerInfo"", ""called for file %s"",GetName());; 3619 ; 3620 TStreamerInfo *info;; 3621 ; 3622 Int_t version = fVersion;; 3623 if (version > 1000000) version -= 1000000;; 3624 if (version < 53419 || (59900 < version && version < 59907)) {; 3625 // We need to update the fCheckSum field of the TStreamerBase.; 3626 ; 3627 // loop on all TStreamerInfo classes; 3628 TObjLink *lnk = list->FirstLink();; 3629 while (lnk) {; 3630 info = (TStreamerInfo*)lnk->GetObject();; 3631 if (!info || info->IsA() != TStreamerInfo::Class()) {; 3632 lnk = lnk->Next();; 3633 continue;; 3634 }; 3635 TIter next(info->GetElements());; 3636 TStreamerElement *element;; 3637 while ((element = (TStreamerElement*) next())) {; 3638 TStreamerBase *base = dynamic_cast<TStreamerBase*>(element);; 3639 if (!base) continue;; 3640 if (base->GetBaseCheckSum() != 0) continue;; 3641 TStreamerInfo *baseinfo = (TStreamerInfo*)list->FindObject(base->GetName());; 3642 if (baseinfo) {; 3643 base->SetBaseCheckSum(baseinfo->GetCheckSum());; 3644 }; 3645 }; 3646 lnk = lnk->Next();; 3647 }; 3648 }; 3649 ; 36",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:138178,Deployability,update,update,138178,"ile::kHasReferences);; 3775 pids->AddAtAndExpand(pid,npids);; 3776 pid->IncrementCount();; 3777 char name[32];; 3778 snprintf(name,32,""ProcessID%d"",npids);; 3779 this->WriteTObject(pid,name);; 3780 this->IncrementProcessIDs();; 3781 if (gDebug > 0) {; 3782 Info(""WriteProcessID"", ""name=%s, file=%s"", name, GetName());; 3783 }; 3784 return (UShort_t)npids;; 3785}; 3786 ; 3787 ; 3788////////////////////////////////////////////////////////////////////////////////; 3789/// Write the list of TStreamerInfo as a single object in this file; 3790/// The class Streamer description for all classes written to this file; 3791/// is saved. See class TStreamerInfo.; 3792 ; 3793void TFile::WriteStreamerInfo(); 3794{; 3795 //if (!gFile) return;; 3796 if (!fWritable) return;; 3797 if (!fClassIndex) return;; 3798 if (fIsPcmFile) return; // No schema evolution for ROOT PCM files.; 3799 if (fClassIndex->fArray[0] == 0; 3800 && fSeekInfo != 0) {; 3801 // No need to update the index if no new classes added to the file; 3802 // but write once an empty StreamerInfo list to mark that there is no need; 3803 // for StreamerInfos in this file.; 3804 return;; 3805 }; 3806 if (gDebug > 0) Info(""WriteStreamerInfo"", ""called for file %s"",GetName());; 3807 ; 3808 SafeDelete(fInfoCache);; 3809 ; 3810 // build a temporary list with the marked files; 3811 TIter next(gROOT->GetListOfStreamerInfo());; 3812 TStreamerInfo *info;; 3813 TList list;; 3814 TList listOfRules;; 3815 listOfRules.SetOwner(kTRUE);; 3816 listOfRules.SetName(""listOfRules"");; 3817 std::set<TClass*> classSet;; 3818 ; 3819 while ((info = (TStreamerInfo*)next())) {; 3820 Int_t uid = info->GetNumber();; 3821 if (fClassIndex->fArray[uid]) {; 3822 list.Add(info);; 3823 if (gDebug > 0) printf("" -class: %s info number %d saved\n"",info->GetName(),uid);; 3824 ; 3825 // Add the IO customization rules to the list to be saved for the underlying; 3826 // class but make sure to add them only once.; 3827 TClass *clinfo = info->GetClass();; 3828 if (clin",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145284,Deployability,update,update,145284,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145465,Deployability,update,update,145465,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:182377,Deployability,update,update,182377," 4959 R__LOCKGUARD(gROOTMutex);; 4960 TSeqCollection *of = gROOT->GetListOfFiles();; 4961 if (of && (of->GetSize() > 0)) {; 4962 TIter nxf(of);; 4963 TFile *f = nullptr;; 4964 while ((f = (TFile *)nxf())); 4965 if (f->Matches(name)); 4966 return f->GetEndpointUrl();; 4967 }; 4968 ; 4969 // Information not yet available; 4970 return (const TUrl *)nullptr;; 4971}; 4972 ; 4973////////////////////////////////////////////////////////////////////////////////; 4974/// Print file copy progress.; 4975 ; 4976void TFile::CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch); 4977{; 4978 fprintf(stderr, ""[TFile::Cp] Total %.02f MB\t|"", (Double_t)size/1048576);; 4979 ; 4980 for (int l = 0; l < 20; l++) {; 4981 if (size > 0) {; 4982 if (l < 20*bytesread/size); 4983 fprintf(stderr, ""="");; 4984 else if (l == 20*bytesread/size); 4985 fprintf(stderr, "">"");; 4986 else if (l > 20*bytesread/size); 4987 fprintf(stderr, ""."");; 4988 } else; 4989 fprintf(stderr, ""="");; 4990 }; 4991 // Allow to update the GUI while uploading files; 4992 gSystem->ProcessEvents();; 4993 watch.Stop();; 4994 Double_t lCopy_time = watch.RealTime();; 4995 fprintf(stderr, ""| %.02f %% [%.01f MB/s]\r"",; 4996 100.0*(size?(bytesread/((float)size)):1), (lCopy_time>0.)?bytesread/lCopy_time/1048576.:0.);; 4997 watch.Continue();; 4998}; 4999 ; 5000////////////////////////////////////////////////////////////////////////////////; 5001/// Allows to copy this file to the dst URL. Returns kTRUE in case of success,; 5002/// kFALSE otherwise.; 5003 ; 5004Bool_t TFile::Cp(const char *dst, Bool_t progressbar, UInt_t buffersize); 5005{; 5006 Bool_t rmdestiferror = kFALSE;; 5007 TStopwatch watch;; 5008 Bool_t success = kFALSE;; 5009 ; 5010 TUrl dURL(dst, kTRUE);; 5011 ; 5012 TString oopt = ""RECREATE"";; 5013 TString ourl = dURL.GetUrl();; 5014 ; 5015 // Files will be open in RAW mode; 5016 TString raw = ""filetype=raw"";; 5017 ; 5018 // Set optimization options for the destination file; 5019 TString opt = dURL.GetOptions();; ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:190415,Deployability,update,updatestatic,190415," 5215#endif; 5216 ; 5217////////////////////////////////////////////////////////////////////////////////; 5218/// Max number of bytes to prefetch.; 5219///; 5220/// By default this is 75% of the; 5221/// read cache size. But specific TFile implementations may need to change it; 5222 ; 5223Int_t TFile::GetBytesToPrefetch() const; 5224{; 5225 TFileCacheRead *cr = nullptr;; 5226 if ((cr = GetCacheRead())) {; 5227 Int_t bytes = cr->GetBufferSize() / 4 * 3;; 5228 return ((bytes < 0) ? 0 : bytes);; 5229 }; 5230 return 0;; 5231}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; Compression.h; RConcurrentHashColl.hxx; RConfig.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TArchiveFile.h; TArrayC.h; TBuffer.h; TClassEdit.h; TClassTable.h; TCla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:190433,Deployability,update,update,190433," 5215#endif; 5216 ; 5217////////////////////////////////////////////////////////////////////////////////; 5218/// Max number of bytes to prefetch.; 5219///; 5220/// By default this is 75% of the; 5221/// read cache size. But specific TFile implementations may need to change it; 5222 ; 5223Int_t TFile::GetBytesToPrefetch() const; 5224{; 5225 TFileCacheRead *cr = nullptr;; 5226 if ((cr = GetCacheRead())) {; 5227 Int_t bytes = cr->GetBufferSize() / 4 * 3;; 5228 return ((bytes < 0) ? 0 : bytes);; 5229 }; 5230 return 0;; 5231}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; Compression.h; RConcurrentHashColl.hxx; RConfig.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TArchiveFile.h; TArrayC.h; TBuffer.h; TClassEdit.h; TClassTable.h; TCla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:241062,Deployability,install,installation,241062," TFile::Close(""R"")Definition TProcessID.cxx:218; TProcessID::CheckInitvoid CheckInit()Initialize fObjects.Definition TProcessID.cxx:192; TProcessID::GetPIDsstatic TObjArray * GetPIDs()static: returns array of TProcessIDsDefinition TProcessID.cxx:351; TProcessID::GetSessionProcessIDstatic TProcessID * GetSessionProcessID()static function returning the pointer to the session TProcessIDDefinition TProcessID.cxx:305; TProcessID::DecrementCountInt_t DecrementCount()The reference fCount is used to delete the TProcessID in the TFile destructor when fCount = 0.Definition TProcessID.cxx:238; TProcessID::GetPIDstatic TProcessID * GetPID()static: returns pointer to current TProcessIDDefinition TProcessID.cxx:343; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::RealTimeDouble_t RealTime()Stop the stopwatch (if it is running) and return the realtime (in seconds) passed between the start a...Definition TStopwatch.cxx:110; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Continuevoid Continue()Resume a stopped stopwatch.Definition TStopwatch.cxx:93; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Resetvoid Reset()Definition TStopwatch.h:52; TStreamerBaseDefinition TStreamerElement.h:150; TStreamerBase::GetBaseCheckSumUInt_t GetBaseCheckSum()Definition TStreamerElement.h:1",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128214,Energy Efficiency,adapt,adapt,128214,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:129777,Energy Efficiency,adapt,adapt,129777,");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");; 3572 fprintf(f, ""//\n"");; 3573 fprintf(f, ""// The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3574 fprintf(f, ""// adapt the macro to the calling environment\n"");; 3575 fprintf(f, ""//\n"");; 3576 fprintf(f, ""// if (gSystem->Getenv(\""ROOTPROOFLITE\"")) {\n"");; 3577 fprintf(f, ""// Printf(\""event-SETUP: PROOF-Lite node (session has %%s workers)\"",\n"");; 3578 fprintf(f, ""// gSystem->Getenv(\""ROOTPROOFLITE\""));\n"");; 3579 fprintf(f, ""// } else if (gSystem->Getenv(\""ROOTPROOFCLIENT\"")) {\n"");; 3580 fprintf(f, ""// Printf(\""event-SETUP: PROOF client\"");\n"");; 3581 fprintf(f, ""// } else {\n"");; 3582 fprintf(f, ""// Printf(\""event-SETUP: standard PROOF node\"");\n"");; 3583 fprintf(f, ""// }\n"");; 3584 fprintf(f, ""\n"");; 3585 fprintf(f, "" if (gSystem->Load(\""lib%s\"") == -1)\n"", pack);; 3586 fprintf(f, "" return -1;\n"");; 3587 fprintf(f, "" return 0;\n"");; 3588 fprintf(f, ""}\n"");; 3589 fprintf(f, ""\n"");; 3590 ; 3591 // Close the file; 3592 fclose(f);; 3593 ; 3594 // Done; 3595 return 0;; 3596}; 3597 ; 3598////////////////////////////////////////////////////////////////////////////////; 3599/// Read the list of StreamerInfo from this file.; 3600///; 3601/// The key with name holding the list of TStreamerInfo objects is read.; 3602/// The corresponding TClass objects are updated.; 3603/// Note that this function is not called if the static member fgReadInfo is false.; 3604/// (see TFile::SetReadStreamerInfo); 3605 ; 3606void TFile::ReadStreamerInfo(); 3607{; 3608 auto listRe",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:184620,Energy Efficiency,allocate,allocate,184620,"""alien"")); 5025 opt += TString::Format(""&source=%s"", GetName());; 5026 ; 5027 dURL.SetOptions(opt);; 5028 ; 5029 char *copybuffer = nullptr;; 5030 ; 5031 TFile *sfile = this;; 5032 TFile *dfile = nullptr;; 5033 ; 5034 // ""RECREATE"" does not work always well with XROOTD; 5035 // namely when some pieces of the path are missing;; 5036 // we force ""NEW"" in such a case; 5037 if (TFile::GetType(ourl, """") == TFile::kNet) {; 5038 if (gSystem->AccessPathName(ourl)) {; 5039 oopt = ""NEW"";; 5040 // Force creation of the missing parts of the path; 5041 opt += ""&mkpath=1"";; 5042 dURL.SetOptions(opt);; 5043 }; 5044 }; 5045 ; 5046 // Open destination file; 5047 if (!(dfile = TFile::Open(dURL.GetUrl(), oopt))) {; 5048 ::Error(""TFile::Cp"", ""cannot open destination file %s"", dst);; 5049 goto copyout;; 5050 }; 5051 ; 5052 // Probably we created a new file; 5053 // We have to remove it in case of errors; 5054 rmdestiferror = kTRUE;; 5055 ; 5056 sfile->Seek(0);; 5057 dfile->Seek(0);; 5058 ; 5059 copybuffer = new char[buffersize];; 5060 if (!copybuffer) {; 5061 ::Error(""TFile::Cp"", ""cannot allocate the copy buffer"");; 5062 goto copyout;; 5063 }; 5064 ; 5065 Bool_t readop, writeop;; 5066 Long64_t read, written, totalread, filesize, b00;; 5067 ; 5068 totalread = 0;; 5069 filesize = sfile->GetSize();; 5070 ; 5071 watch.Start();; 5072 ; 5073 b00 = sfile->GetBytesRead();; 5074 ; 5075 do {; 5076 if (progressbar) CpProgress(totalread, filesize,watch);; 5077 ; 5078 Long64_t b1 = sfile->GetBytesRead() - b00;; 5079 ; 5080 Long64_t readsize;; 5081 if (filesize - b1 > (Long64_t)buffersize) {; 5082 readsize = buffersize;; 5083 } else {; 5084 readsize = filesize - b1;; 5085 }; 5086 ; 5087 if (readsize == 0) break;; 5088 ; 5089 Long64_t b0 = sfile->GetBytesRead();; 5090 sfile->Seek(totalread,TFile::kBeg);; 5091 readop = sfile->ReadBuffer(copybuffer, (Int_t)readsize);; 5092 read = sfile->GetBytesRead() - b0;; 5093 if ((read <= 0) || readop) {; 5094 ::Error(""TFile::Cp"", ""cannot read from source file %s. r",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:235034,Energy Efficiency,efficient,efficient,235034,"ideReturn the last object in the list. Returns 0 when list is empty.Definition TList.cxx:691; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 when list is empty.Definition TList.cxx:657; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::RemoveLastvoid RemoveLast() overrideRemove the last object of the list.Definition TList.cxx:907; TMakeProject::GenerateMissingStreamerInfosstatic void GenerateMissingStreamerInfos(TList *extrainfos, TStreamerElement *element)Generate an empty StreamerInfo for types that are used in templates parameters but are not known in t...Definition TMakeProject.cxx:413; TMakeProject::UpdateAssociativeToVectorstatic TString UpdateAssociativeToVector(const char *name)Definition TMakeProject.cxx:659; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TMap::Addvoid Add(TObject *obj) overrideThis function may not be used (but we need to provide it since it is a pure virtual in TCollection).Definition TMap.cxx:54; TMap::RemoveTObject * Remove(TObject *key) overrideRemove the (key,value) pair with key from the map.Definition TMap.cxx:296; TMap::GetValueTObject * GetValue(const char *keyname) constReturns a pointer to the value associated with keyname as name of the key.Definition TMap.cxx:236; TNamed::FillBuffervirtual void FillBuffer(char *&buffer)Encode TNamed into output buffer.Definition TNamed.cxx:104; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:62859,Integrability,rout,routine,62859,"r,1,""END"");; 1692 else; 1693 Printf(""At:%-*lld N=%-8d K= O= %-14s"", nDigits+1, idcur,1,""END"");; 1694}; 1695 ; 1696////////////////////////////////////////////////////////////////////////////////; 1697/// Paint all objects in the file.; 1698 ; 1699void TFile::Paint(Option_t *option); 1700{; 1701 GetList()->R__FOR_EACH(TObject,Paint)(option);; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Print all objects in the file.; 1706 ; 1707void TFile::Print(Option_t *option) const; 1708{; 1709 Printf(""TFile: name=%s, title=%s, option=%s"", GetName(), GetTitle(), GetOption());; 1710 GetList()->R__FOR_EACH(TObject,Print)(option);; 1711}; 1712 ; 1713////////////////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gM",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72199,Integrability,message,message,72199,"nd(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84075,Integrability,interface,interface,84075,"r = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:95729,Integrability,message,message,95729,"ile; 2673/// - <em>dirnameProjectSource.cxx</em>,which contains all the constructors and destructors implementation.; 2674/// and one header per class that is not nested inside another class.; 2675/// The header file name is the fully qualified name of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__Vertex_int_.h; 2678///; 2679/// In the generated classes, map, multimap when the first template parameter is a class; 2680/// are replaced by a vector of pair. set and multiset when the tempalte parameter; 2681/// is a class are replaced by a vector. This is required since we do not have the; 2682/// code needed to order and/or compare the object of the classes.; 2683/// This is a quick explanation of the options available:; 2684/// Option | Details; 2685/// -------|--------; 2686/// new (default) | A new directory dirname is created. If dirname already exist, an error message is printed and the function returns.; 2687/// recreate | If dirname does not exist, it is created (like in ""new""). If dirname already exist, all existing files in dirname are deleted before creating the new files.; 2688/// update | New classes are added to the existing directory. Existing classes with the same name are replaced by the new definition. If the directory dirname doest not exist, same effect as ""new"".; 2689/// genreflex | Use genreflex rather than rootcint to generate the dictionary.; 2690/// par | Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; 2691///; 2692/// If, in addition to one of the 3 above options, the option ""+"" is specified,; 2693/// the function will generate:; 2694/// - a script called MAKEP to build the shared lib; 2695/// - a dirnameLinkDef.h file; 2696/// - rootcint will be run to g",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:101334,Integrability,message,message,101334,"82 void *dir = gSystem->OpenDirectory(dirname);; 2783 TString dirpath;; 2784 ; 2785 if (opt.Contains(""update"")) {; 2786 // check that directory exist, if not create it; 2787 if (!dir) {; 2788 gSystem->mkdir(dirname);; 2789 }; 2790 ; 2791 } else if (opt.Contains(""recreate"")) {; 2792 // check that directory exist, if not create it; 2793 if (!dir) {; 2794 if (gSystem->mkdir(dirname) < 0) {; 2795 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2796 return;; 2797 }; 2798 }; 2799 // clear directory; 2800 while (dir) {; 2801 const char *afile = gSystem->GetDirEntry(dir);; 2802 if (!afile) break;; 2803 if (strcmp(afile,""."") == 0) continue;; 2804 if (strcmp(afile,"".."") == 0) continue;; 2805 dirpath.Form(""%s/%s"",dirname,afile);; 2806 gSystem->Unlink(dirpath);; 2807 }; 2808 ; 2809 } else {; 2810 // new is assumed; 2811 // if directory already exist, print error message and return; 2812 if (dir) {; 2813 Error(""MakeProject"",""cannot create directory %s, already existing"",dirname);; 2814 gSystem->FreeDirectory(dir);; 2815 return;; 2816 }; 2817 if (gSystem->mkdir(dirname) < 0) {; 2818 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2819 return;; 2820 }; 2821 }; 2822 if (dir) {; 2823 gSystem->FreeDirectory(dir);; 2824 }; 2825 }; 2826 Bool_t genreflex = opt.Contains(""genreflex"");; 2827 ; 2828 // we are now ready to generate the classes; 2829 // loop on all TStreamerInfo; 2830 TList *filelist = (TList*)GetStreamerInfoCache();; 2831 if (filelist) filelist = (TList*)filelist->Clone();; 2832 if (!filelist) {; 2833 Error(""MakeProject"",""file %s has no StreamerInfo"", GetName());; 2834 return;; 2835 }; 2836 ; 2837 TString clean_dirname(dirname);; 2838 if (makepar) clean_dirname.Form(""%s/%s"", pardir.Data(), parname.Data());; 2839 if (clean_dirname[clean_dirname.Length()-1]=='/') {; 2840 clean_dirname.Remove(clean_dirname.Length()-1);; 2841 } else if (clean_dirname[clean_dirname.Length()-1]=='\\') {; 2842 clean_dirname.Remove(clean_dirname.Length()-1);; 2843 if (clea",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:147563,Integrability,depend,depends,147563,"ache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 407",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:150256,Integrability,protocol,protocol,150256,": <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:151143,Integrability,protocol,protocol,151143,"input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:154079,Integrability,protocol,protocol,154079,"xpandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter();; 4211 ; 4212 // change names to be recognized by the plugin manager; 4213 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4214 TUrl urlname(n, kTRUE);; 4215 name = urlname.GetUrl();; 4216 // Check first if a pending async open request matches this one; 4217 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4218 TIter nxr(fgAsyncOpenRequests);; 4219 TFileOpenHandle *fh = nullptr;; 4220 while ((fh = (TFileOpenHandle *)nxr())); 4221 if (fh->Matches(name)); 4222 return TFile::Open(fh);; 4223 }; 4224 ; 4225 TString urlOptions(urlname.GetOptions());; 4226 if (urlOptions.BeginsWith(""pmerge"") || urlOptions.Contains(""&pmerge"") || urlOptions.Contains("" pmerge"")) {; 4227 type = kMerge;; 4228 ; 4229 // Pass the full name including the url options:; 4230 f = (TFile*) gROOT->ProcessLineFast(TString::Format(""new TParallelMergingFile(\""%s\"",\""%s\"",\""%s\"",%d)"",n.Data(),option,ftitle,compress));; 4231 ; 4232 } else {; 4233 // Resolve the file type; this also adjusts names; 4234 TString lfname = gEnv->GetValue(""Path.Localroot"", """");; 4235 type = GetType(name",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:154109,Integrability,protocol,protocol,154109,"p = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter();; 4211 ; 4212 // change names to be recognized by the plugin manager; 4213 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4214 TUrl urlname(n, kTRUE);; 4215 name = urlname.GetUrl();; 4216 // Check first if a pending async open request matches this one; 4217 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4218 TIter nxr(fgAsyncOpenRequests);; 4219 TFileOpenHandle *fh = nullptr;; 4220 while ((fh = (TFileOpenHandle *)nxr())); 4221 if (fh->Matches(name)); 4222 return TFile::Open(fh);; 4223 }; 4224 ; 4225 TString urlOptions(urlname.GetOptions());; 4226 if (urlOptions.BeginsWith(""pmerge"") || urlOptions.Contains(""&pmerge"") || urlOptions.Contains("" pmerge"")) {; 4227 type = kMerge;; 4228 ; 4229 // Pass the full name including the url options:; 4230 f = (TFile*) gROOT->ProcessLineFast(TString::Format(""new TParallelMergingFile(\""%s\"",\""%s\"",\""%s\"",%d)"",n.Data(),option,ftitle,compress));; 4231 ; 4232 } else {; 4233 // Resolve the file type; this also adjusts names; 4234 TString lfname = gEnv->GetValue(""Path.Localroot"", """");; 4235 type = GetType(name, option, &lfname);; 4236 ; ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:155981,Integrability,protocol,protocol,155981,"names; 4234 TString lfname = gEnv->GetValue(""Path.Localroot"", """");; 4235 type = GetType(name, option, &lfname);; 4236 ; 4237 if (type == kLocal) {; 4238 ; 4239 // Local files; 4240 if (lfname.IsNull()) {; 4241 urlname.SetHost("""");; 4242 urlname.SetProtocol(""file"");; 4243 lfname = urlname.GetUrl();; 4244 }; 4245 f = new TFile(lfname.Data(), option, ftitle, compress);; 4246 ; 4247 } else if (type == kNet) {; 4248 ; 4249 // Network files; 4250 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name))) {; 4251 if (h->LoadPlugin() == -1); 4252 return nullptr;; 4253 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4254 }; 4255 ; 4256 } else if (type == kWeb) {; 4257 ; 4258 // Web files; 4259 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name))) {; 4260 if (h->LoadPlugin() == -1); 4261 return nullptr;; 4262 f = (TFile*) h->ExecPlugin(2, name.Data(), option);; 4263 }; 4264 ; 4265 } else if (type == kFile) {; 4266 ; 4267 // 'file:' protocol; 4268 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4269 h->LoadPlugin() == 0) {; 4270 name.ReplaceAll(""file:"", """");; 4271 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4272 } else; 4273 f = new TFile(name.Data(), option, ftitle, compress);; 4274 ; 4275 } else {; 4276 ; 4277 // no recognized specification: try the plugin manager; 4278 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name.Data()))) {; 4279 if (h->LoadPlugin() == -1); 4280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:157570,Integrability,message,messages,157570,"280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::Open( newUrl, option, ftitle, compress );; 4300 else; 4301 f = nullptr;; 4302 }; 4303 }; 4304 ; 4305 if (rediroutput) {; 4306 // Restore output to stdout; 4307 gSystem->RedirectOutput(0, """", &rh);; 4308 // If we failed print error messages; 4309 if (!f); 4310 gSystem->ShowOutput(&rh);; 4311 // Remove the file; 4312 gSystem->Unlink(rh.fFile);; 4313 }; 4314 ; 4315 // if the file is writable, non local, and not opened in raw mode; 4316 // we create a default write cache of 512 KBytes; 4317 if (type != kLocal && type != kFile &&; 4318 f && f->IsWritable() && !f->IsRaw()) {; 4319 new TFileCacheWrite(f, 1);; 4320 }; 4321 ; 4322 return f;; 4323}; 4324 ; 4325////////////////////////////////////////////////////////////////////////////////; 4326/// Submit an asynchronous open request.; 4327 ; 4328/// See TFile::Open(const char *, ...) for an; 4329/// explanation of the arguments. A handler is returned which is to be passed; 4330/// to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; 4331/// the file is open.; 4332/// This call never blocks and it is provided to allow parallel submission; 4333/// of file opening operati",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:160535,Integrability,protocol,protocol,160535,"tr;; 4357 TFile *f = nullptr;; 4358 Bool_t notfound = kTRUE;; 4359 ; 4360 // Check input; 4361 if (!url || strlen(url) <= 0) {; 4362 ::Error(""TFile::AsyncOpen"", ""no url specified"");; 4363 return fh;; 4364 }; 4365 ; 4366 // Many URLs? Redirect output and print errors in case of global failure; 4367 TString namelist(url);; 4368 gSystem->ExpandPathName(namelist);; 4369 Ssiz_t ip = namelist.Index(""|"");; 4370 Bool_t rediroutput = (ip != kNPOS &&; 4371 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4372 RedirectHandle_t rh;; 4373 if (rediroutput) {; 4374 TString outf = "".TFileAsyncOpen_"";; 4375 FILE *fout = gSystem->TempFileName(outf);; 4376 if (fout) {; 4377 fclose(fout);; 4378 gSystem->RedirectOutput(outf, ""w"", &rh);; 4379 }; 4380 }; 4381 ; 4382 // Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetUrl();; 4391 ; 4392 // Resolve the file type; this also adjusts names; 4393 EFileType type = GetType(name, option);; 4394 ; 4395 TPluginHandler *h = nullptr;; 4396 ; 4397 // Here we send the asynchronous request if the functionality is implemented; 4398 if (type == kNet) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 gSystem->Unlink(rh.fFile);; 4417 }; 4418 ; 4419 // Make sure that no e",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:160565,Integrability,protocol,protocol,160565,"r;; 4358 Bool_t notfound = kTRUE;; 4359 ; 4360 // Check input; 4361 if (!url || strlen(url) <= 0) {; 4362 ::Error(""TFile::AsyncOpen"", ""no url specified"");; 4363 return fh;; 4364 }; 4365 ; 4366 // Many URLs? Redirect output and print errors in case of global failure; 4367 TString namelist(url);; 4368 gSystem->ExpandPathName(namelist);; 4369 Ssiz_t ip = namelist.Index(""|"");; 4370 Bool_t rediroutput = (ip != kNPOS &&; 4371 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4372 RedirectHandle_t rh;; 4373 if (rediroutput) {; 4374 TString outf = "".TFileAsyncOpen_"";; 4375 FILE *fout = gSystem->TempFileName(outf);; 4376 if (fout) {; 4377 fclose(fout);; 4378 gSystem->RedirectOutput(outf, ""w"", &rh);; 4379 }; 4380 }; 4381 ; 4382 // Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetUrl();; 4391 ; 4392 // Resolve the file type; this also adjusts names; 4393 EFileType type = GetType(name, option);; 4394 ; 4395 TPluginHandler *h = nullptr;; 4396 ; 4397 // Here we send the asynchronous request if the functionality is implemented; 4398 if (type == kNet) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 gSystem->Unlink(rh.fFile);; 4417 }; 4418 ; 4419 // Make sure that no error occurred; 4420 if (notf",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:161376,Integrability,message,messages,161376,"Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetUrl();; 4391 ; 4392 // Resolve the file type; this also adjusts names; 4393 EFileType type = GetType(name, option);; 4394 ; 4395 TPluginHandler *h = nullptr;; 4396 ; 4397 // Here we send the asynchronous request if the functionality is implemented; 4398 if (type == kNet) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 gSystem->Unlink(rh.fFile);; 4417 }; 4418 ; 4419 // Make sure that no error occurred; 4420 if (notfound) {; 4421 SafeDelete(f);; 4422 // Save the arguments in the handler, so that a standard open can be; 4423 // attempted later on; 4424 fh = new TFileOpenHandle(name, option, ftitle, compress, netopt);; 4425 } else if (f) {; 4426 // Fill the opaque handler to be use to attach the file later on; 4427 fh = new TFileOpenHandle(f);; 4428 }; 4429 ; 4430 // Record this request; 4431 if (fh) {; 4432 // Create the lst, if not done already; 4433 if (!fgAsyncOpenRequests); 4434 fgAsyncOpenRequests = new TList;; 4435 fgAsyncOpenRequests->Add(fh);; 4436 }; 4437 ; 4438 // We are done; 4439 return fh;; 4440}; 4441 ; 4442////////////////////////////////////////////////////////////////////////////////; 4443/// Waits for the completion of an asyn",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:165772,Integrability,interface,interface,165772,"/////////////////////////////; 4513/// Interface to system write. All arguments like in POSIX write().; 4514 ; 4515Int_t TFile::SysWrite(Int_t fd, const void *buf, Int_t len); 4516{; 4517 return ::write(fd, buf, len);; 4518}; 4519////////////////////////////////////////////////////////////////////////////////; 4520/// Interface to system lseek.; 4521///; 4522/// All arguments like in POSIX lseek(); 4523/// except that the offset and return value are of a type which are; 4524/// able to handle 64 bit file systems.; 4525 ; 4526Long64_t TFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); 4527{; 4528#if defined (R__SEEK64); 4529 return ::lseek64(fd, offset, whence);; 4530#elif defined(WIN32); 4531 return ::_lseeki64(fd, offset, whence);; 4532#else; 4533 return ::lseek(fd, offset, whence);; 4534#endif; 4535}; 4536 ; 4537////////////////////////////////////////////////////////////////////////////////; 4538/// Return file stat information.; 4539///; 4540/// The interface and return value is; 4541/// identical to TSystem::GetPathInfo(). The function returns 0 in; 4542/// case of success and 1 if the file could not be stat'ed.; 4543 ; 4544Int_t TFile::SysStat(Int_t, Long_t *id, Long64_t *size, Long_t *flags,; 4545 Long_t *modtime); 4546{; 4547 return gSystem->GetPathInfo(fRealName, id, size, flags, modtime);; 4548}; 4549 ; 4550////////////////////////////////////////////////////////////////////////////////; 4551/// Interface to system fsync. All arguments like in POSIX fsync().; 4552 ; 4553Int_t TFile::SysSync(Int_t fd); 4554{; 4555 if (TestBit(kDevNull)) return 0;; 4556 ; 4557#ifndef WIN32; 4558 return ::fsync(fd);; 4559#else; 4560 return ::_commit(fd);; 4561#endif; 4562}; 4563 ; 4564////////////////////////////////////////////////////////////////////////////////; 4565/// Return the total number of bytes written so far to the file.; 4566 ; 4567Long64_t TFile::GetBytesWritten() const; 4568{; 4569 return fCacheWrite ? fCacheWrite->GetBytesInCache() + fBytesWrite : fBytes",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:174832,Integrability,depend,dependent,174832,"///////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged;; 4758}; 4759 ; 4760////////////////////////////////////////////////////////////////////////////////; 4761/// Return kTRUE if 'url' matches the coordinates of this file.; 4762///; 4763/// The check is implementation dependent and may need to be overload; 4764/// by each TFile implementation relying on this check.; 4765/// The default implementation checks the file name only.; 4766 ; 4767Bool_t TFile::Matches(const char *url); 4768{; 4769 // Check the full URL, including port and FQDN.; 4770 TUrl u(url);; 4771 ; 4772 // Check; 4773 if (!strcmp(u.GetFile(), fUrl.GetFile())) {; 4774 // Check ports; 4775 if (u.GetPort() == fUrl.GetPort()) {; 4776 if (!strcmp(u.GetHostFQDN(), fUrl.GetHostFQDN())) {; 4777 // Ok, coordinates match; 4778 return kTRUE;; 4779 }; 4780 }; 4781 }; 4782 ; 4783 // Default is not matching; 4784 return kFALSE;; 4785}; 4786 ; 4787////////////////////////////////////////////////////////////////////////////////; 4788/// Return kTRUE if this async request matches the open request; 4789/// specified by 'url'; 4790 ; 4791Bool_t TFileOpenHandle::Matches(const char *url); 4792{; 4793 if (fFile) {; 4794 return fFile->Matches(url);; 4795 } else if (fName.Length() > 0){; 4796 // Deep check of URLs; 4797 TUrl u(url);;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:176384,Integrability,protocol,protocol,176384,"FQDN())) {; 4777 // Ok, coordinates match; 4778 return kTRUE;; 4779 }; 4780 }; 4781 }; 4782 ; 4783 // Default is not matching; 4784 return kFALSE;; 4785}; 4786 ; 4787////////////////////////////////////////////////////////////////////////////////; 4788/// Return kTRUE if this async request matches the open request; 4789/// specified by 'url'; 4790 ; 4791Bool_t TFileOpenHandle::Matches(const char *url); 4792{; 4793 if (fFile) {; 4794 return fFile->Matches(url);; 4795 } else if (fName.Length() > 0){; 4796 // Deep check of URLs; 4797 TUrl u(url);; 4798 TUrl uref(fName);; 4799 if (!strcmp(u.GetFile(), uref.GetFile())) {; 4800 // Check ports; 4801 if (u.GetPort() == uref.GetPort()) {; 4802 // Check also the host name; 4803 if (!strcmp(u.GetHostFQDN(), uref.GetHostFQDN())) {; 4804 // Ok, coordinates match; 4805 return kTRUE;; 4806 }; 4807 }; 4808 }; 4809 }; 4810 ; 4811 // Default is not matching; 4812 return kFALSE;; 4813}; 4814 ; 4815////////////////////////////////////////////////////////////////////////////////; 4816/// Resolve the file type as a function of the protocol field in 'name'; 4817///; 4818/// If defined, the string 'prefix' is added when testing the locality of; 4819/// a 'name' with network-like structure (i.e. root://host//path); if the file; 4820/// is local, on return 'prefix' will contain the actual local path of the file.; 4821 ; 4822TFile::EFileType TFile::GetType(const char *name, Option_t *option, TString *prefix); 4823{; 4824 EFileType type = kDefault;; 4825 ; 4826 TPMERegexp re(""^(root|xroot).*"", ""i"");; 4827 if (re.Match(name)) {; 4828 //; 4829 // Should be a network file ...; 4830 type = kNet;; 4831 // ... but make sure that is not local or that a remote-like connection; 4832 // is forced. Treat it as local if:; 4833 // i) the url points to the localhost, the file will be opened in; 4834 // readonly mode and the current user has read access;; 4835 // ii) the specified user is equal to the current user then open local; 4836 // TFile.; 4837 Bool_t",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:179116,Integrability,protocol,protocol,179116," {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.IsNull() ||; 4868 !opt.CompareTo(""READ"", TString::kIgnoreCase)) ? kTRUE : kFALSE;; 4869 if (read) {; 4870 TString fn = TUrl(lfname).GetFile();; 4871 if (!gSystem->ExpandPathName(fn)) {; 4872 if (gSystem->AccessPathName(fn, kReadPermission)); 4873 localFile = kFALSE;; 4874 }; 4875 }; 4876 // Return full local path if requested (and if the case); 4877 if (localFile && prefix); 4878 *prefix = lfname;; 4879 }; 4880 }; 4881 //; 4882 // Adjust the type according to findings; 4883 type = (localFile) ? kLocal : type;; 4884 } else if (TPMERegexp(""^(http[s]?|s3http[s]?|[a]?s3|gs|gshttp[s]?){1}:"", ""i"").Match(name)) {; 4885 //; 4886 // Web file; 4887 type = kWeb;; 4888 } else if (!strncmp(name, ""file:"", 5)) {; 4889 //; 4890 // 'file' protocol; 4891 type = kFile;; 4892 }; 4893 // We are done; 4894 return type;; 4895}; 4896 ; 4897////////////////////////////////////////////////////////////////////////////////; 4898/// Get status of the async open request related to 'name'.; 4899 ; 4900TFile::EAsyncOpenStatus TFile::GetAsyncOpenStatus(const char* name); 4901{; 4902 // Check the list of pending async open requests; 4903 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4904 TIter nxr(fgAsyncOpenRequests);; 4905 TFileOpenHandle *fh = nullptr;; 4906 while ((fh = (TFileOpenHandle *)nxr())); 4907 if (fh->Matches(name)); 4908 return TFile::GetAsyncOpenStatus(fh);; 4909 }; 4910 ; 4911 // Check also the list of files open; 4912 R__LOCKGUARD(gROOTMutex);; 4913 TSeqCollection *of = gROOT->GetListOfFiles();; 4914 if (of && (of->GetSize() > 0)) {; 4915 TIter nxf(of);; 4916 TFile *f = nullptr;; 4917 while ((f = (TFile *)nxf())); 4918 if (f->Matches(name)); 4919 return f->GetAsyncOpenStatus();; 4920 }; 4921 ; 4922 // Default is synchronous mode; 4923 return kAOSNotAs",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:200609,Integrability,depend,depending,200609,"hColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFile::GetMemberTArchiveMember * GetMember() constDefinition TArchiveFile.h:51; TArchiveFile::Openstatic TArchiveFile * Open(const char *url, TFile *file)Return proper archive file handler depending on passed url.Definition TArchiveFile.cxx:121; TArchiveFile::GetMemberFilePositionLong64_t GetMemberFilePosition() constReturn position in archive of current member.Definition TArchiveFile.cxx:71; TArchiveFile::OpenArchivevirtual Int_t OpenArchive()=0; TArchiveMember::GetDecompressedSizeLong64_t GetDecompressedSize() constDefinition TArchiveFile.h:92; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TArrayC::fArrayChar_t * fArrayDefinition TArrayC.h:30; TArrayC::Setvoid Set(Int_t n) overrideSet size of this array to n chars.Definition TArrayC.cxx:105; TArray::GetSizeInt_t GetSize() constDefinition TArray.h:47; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::IsSyntheticPairBool_t IsSyntheticPair()",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:223698,Integrability,protocol,protocol,223698,"rrno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::EFileTypeEFileTypeFile type.Definition TFile.h:202; TFile::kWeb@ kWebDefinition TFile.h:202; TFile::kDefault@ kDefaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:237842,Integrability,message,message,237842,") const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:238196,Integrability,message,message,238196,"5; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *metho",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:238537,Integrability,message,message,238537,"444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::MatchInt_t Match(const TString &s, UInt_t start=0)Runs a match on s against the regex 'this' was created with.Definition TPRegexp.cxx:797; TPluginHandle",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:238673,Integrability,message,message,238673,"niqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::MatchInt_t Match(const TString &s, UInt_t start=0)Runs a match on s against the regex 'this' was created with.Definition TPRegexp.cxx:797; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TProcessI",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:239233,Integrability,message,message,239233,"79; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPMERegexpWrapper for PCRE library (Perl Compatible Regular Expressions).Definition TPRegexp.h:97; TPMERegexp::MatchInt_t Match(const TString &s, UInt_t start=0)Runs a match on s against the regex 'this' was created with.Definition TPRegexp.cxx:797; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TProcessID::IncrementCountInt_t IncrementCount()Increase the reference count to this object.Definition TProcessID.cxx:313; TProcessID::Clearvoid Clear(Option_t *option="""") overridedelete the TObjArray pointing to referenced objects this function is called by TFile::Close(""R"")Definition TProcessID.cxx:218; TProcessID::CheckInitvoid CheckInit()Initialize fObjects.Definition TProcessID.cxx:192; TProcessID::GetPIDsstatic TObjArray * GetPIDs()static: returns array o",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:252423,Integrability,protocol,protocol,252423,"bally Unique IDent...Definition TUUID.h:42; TUUID::ReadBuffervoid ReadBuffer(char *&buffer)Stream UUID from input buffer.Definition TUUID.cxx:291; TUUID::FillBuffervoid FillBuffer(char *&buffer)Stream UUID into output buffer.Definition TUUID.cxx:275; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetAnchorconst char * GetAnchor() constDefinition TUrl.h:70; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::SetAnchorvoid SetAnchor(const char *anchor)Definition TUrl.h:86; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char * GetFile() constDefinition TUrl.h:69; TUrl::GetValueFromOptionsconst char * GetValueFromOptions(const char *key) constReturn a value for a given key from the URL options.Definition TUrl.cxx:660; TUrl::SetProtocolvoid SetProtocol(const char *proto, Bool_t setDefaultPort=kFALSE)Set protocol and, optionally, change the port accordingly.Definition TUrl.cxx:523; TUrl::SetOptionsvoid SetOptions(const char *opt)Definition TUrl.h:87; TUrl::GetHostFQDNconst char * GetHostFQDN() constReturn fully qualified domain name of url host.Definition TUrl.cxx:472; TUrl::GetOptionsconst char * GetOptions() constDefinition TUrl.h:71; TUrl::SetHostvoid SetHost(const char *host)Definition TUrl.h:84; TUrl::GetProtocolconst char * GetProtocol() constDefinition TUrl.h:64; TUrl::SetFilevoid SetFile(const char *file)Definition TUrl.h:85; TUrl::GetPortInt_t GetPort() constDefinition TUrl.h:78; TUrl::HasOptionBool_t HasOption(const char *key) constReturns true if the given key appears in the URL options list.Definition TUrl.cxx:683; TVirtualMonitoringWriter::SendFileReadProgressvirtual Bool_t SendFileReadProgress(TFile *)Definition TVirtualMonitoring.h:57; TVirtualMonitoringWriter::SendFileCloseEventvirtual Bool_t SendFileCloseEvent(TFile *)Definition TVirtualMonitoring.h",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:8477,Modifiability,plugin,plugin,8477," : TDirectoryFile(), fCompress(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); 203{; 204 fCacheReadMap = new TMap();; 205 SetBit(kBinaryFile, kTRUE);; 206 ; 207 if (gDebug); 208 Info(""TFile"", ""default ctor"");; 209}; 210 ; 211////////////////////////////////////////////////////////////////////////////////; 212/// Opens or creates a local ROOT file.; 213///; 214/// \param[in] fname1 The name of the file; 215/// \param[in] option Specifies the mode in which the file is opened; 216/// \param[in] ftitle The title of the file; 217/// \param[in] compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:9741,Modifiability,plugin,plugins,9741,"written.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The title of the file (ftitle) will be shown by the ROOT browsers.; 258/// A ROOT file (like a Unix file system) may contain objects and; 259/// directories. There are no restrictions for the number of levels; 260/// of directories.; 261/// A ROOT file is designed such that one can write in the file in pure; 262/// sequential mode (case of BATCH jobs). In this case, the file may be; 263/// read sequentially again without using the file index written; 264/// at the end of the file. In case of a job crash, all the information; 265/// on the file is therefore protected.; 266/// A ROOT file can be used interactively. In this case, one has the; 267/// possibility to delete existing objects and add new ones.; 268/// When",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:9934,Modifiability,plugin,plugins,9934,"ed remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The title of the file (ftitle) will be shown by the ROOT browsers.; 258/// A ROOT file (like a Unix file system) may contain objects and; 259/// directories. There are no restrictions for the number of levels; 260/// of directories.; 261/// A ROOT file is designed such that one can write in the file in pure; 262/// sequential mode (case of BATCH jobs). In this case, the file may be; 263/// read sequentially again without using the file index written; 264/// at the end of the file. In case of a job crash, all the information; 265/// on the file is therefore protected.; 266/// A ROOT file can be used interactively. In this case, one has the; 267/// possibility to delete existing objects and add new ones.; 268/// When an object is deleted from the file, the freed space is added; 269/// into the FREE linked list (fFree). The FREE list consists of a chain; 270/// of consecutive free segments on the",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:13424,Modifiability,variab,variable,13424,"In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating temporary filenames) a value can be passed to the reproducible; 335/// option to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:16597,Modifiability,plugin,plugins,16597,");; 370 SetName(s);; 371 fNoAnchorInName = kTRUE;; 372 } else; 373 SetName(fname1);; 374 ; 375 SetTitle(ftitle);; 376 ; 377 // accept also URL like ""file:..."" syntax; 378 fname1 = fUrl.GetFile();; 379 ; 380 // if option contains filetype=raw then go into raw file mode; 381 if (strstr(fUrl.GetOptions(), ""filetype=raw"")); 382 fIsRootFile = kFALSE;; 383 ; 384 // if option contains filetype=pcm then go into ROOT PCM file mode; 385 if (strstr(fUrl.GetOptions(), ""filetype=pcm"")); 386 fIsPcmFile = kTRUE;; 387 ; 388 if (fUrl.HasOption(""reproducible"")); 389 SetBit(kReproducible);; 390 ; 391 // We are opening synchronously; 392 fAsyncOpenStatus = kAOSNotAsync;; 393 ; 394 BuildDirectoryFile(this, nullptr);; 395 ; 396 fVersion = gROOT->GetVersionInt(); //ROOT version in integer format; 397 fUnits = 4;; 398 fCacheReadMap = new TMap();; 399 SetBit(kBinaryFile, kTRUE);; 400 ; 401 fOption.ToUpper();; 402 ; 403 if (fIsRootFile && !fIsPcmFile && fOption != ""NEW"" && fOption != ""CREATE""; 404 && fOption != ""RECREATE"") {; 405 // If !gPluginMgr then we are at startup and cannot handle plugins; 406 // as TArchiveFile yet.; 407 fArchive = gPluginMgr ? TArchiveFile::Open(fUrl.GetUrl(), this) : nullptr;; 408 if (fArchive) {; 409 fname1 = fArchive->GetArchiveName();; 410 // if no archive member is specified then this TFile is just used; 411 // to read the archive contents; 412 if (!strlen(fArchive->GetMemberName())); 413 fIsArchive = kTRUE;; 414 }; 415 }; 416 ; 417 if (fOption.Contains(""_WITHOUT_GLOBALREGISTRATION"")) {; 418 fOption = fOption.ReplaceAll(""_WITHOUT_GLOBALREGISTRATION"", """");; 419 fGlobalRegistration = false;; 420 if (fList) {; 421 fList->UseRWLock(false);; 422 }; 423 }; 424 ; 425 if (fOption == ""NET""); 426 return;; 427 ; 428 if (fOption == ""WEB"") {; 429 fOption = ""READ"";; 430 fWritable = kFALSE;; 431 return;; 432 }; 433 ; 434 if (fOption == ""NEW""); 435 fOption = ""CREATE"";; 436 ; 437 Bool_t create = (fOption == ""CREATE"") ? kTRUE : kFALSE;; 438 Bool_t recreate = (fOption == ""RECREATE",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:56244,Modifiability,extend,extended,56244,"2 At:253232 N=28324 TBasket CX = 1.13; 1532/// 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 1533/// 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 1534/// 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 1535/// 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 1536/// 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 1537/// 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 1538/// 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 1539/// 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 1540/// 20010404/150442 At:402823 N=307 KeysList; 1541/// 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 1542/// 20010404/150443 At:407678 N=86 FreeSegments; 1543/// 20010404/150443 At:407764 N=1 END; 1544///; 1545/// If the parameter opt contains ""forComp"", the Date/Time is omitted; 1546/// and the decompressed size is also printed.; 1547///; 1548/// Record_Adress Logical_Record_Length Key_Length Object_Record_Length ClassName CompressionFactor; 1549///; 1550/// If the parameter opt contains ""extended"", the name and title of the keys are added:; 1551/// 20200820/155031 At:100 N=180 TFile name: hsimple.root title: Demo ROOT file with histograms; 1552/// 220200820/155032 At:280 N=28880 TBasket CX = 1.11 name: random title: ntuple; 1553/// 220200820/155032 At:29160 N=29761 TBasket CX = 1.08 name: px title: ntuple; 1554/// 220200820/155032 At:58921 N=29725 TBasket CX = 1.08 name: py title: ntuple; 1555/// 220200820/155032 At:88646 N=29209 TBasket CX = 1.10 name: pz title: ntuple; 1556/// 220200820/155032 At:117855 N=10197 TBasket CX = 3.14 name: i title: ntuple; 1557/// ...; 1558/// 20200820/155032 At:405110 N=808 TNtuple CX = 3.53 name: ntuple title: Demo ntuple; 1559/// 20200820/155706 At:405918 N=307 KeysList name: hsimple.root title: Demo ROOT file with histograms; 1560/// 20200820/155032 At:406225 N=8556 StreamerInfo CX = 3.42 name: StreamerInfo title: Doubly linked list; 1561/// 20200820/155708 At:414781 N=86 FreeSegments name: hsimple.root title",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:57628,Modifiability,extend,extended,57628," = 1.08 name: py title: ntuple; 1555/// 220200820/155032 At:88646 N=29209 TBasket CX = 1.10 name: pz title: ntuple; 1556/// 220200820/155032 At:117855 N=10197 TBasket CX = 3.14 name: i title: ntuple; 1557/// ...; 1558/// 20200820/155032 At:405110 N=808 TNtuple CX = 3.53 name: ntuple title: Demo ntuple; 1559/// 20200820/155706 At:405918 N=307 KeysList name: hsimple.root title: Demo ROOT file with histograms; 1560/// 20200820/155032 At:406225 N=8556 StreamerInfo CX = 3.42 name: StreamerInfo title: Doubly linked list; 1561/// 20200820/155708 At:414781 N=86 FreeSegments name: hsimple.root title: Demo ROOT file with histograms; 1562/// 20200820/155708 At:414867 N=1 END; 1563///; 1564/// Note: The combined size of the classname, name and title is truncated to 476 characters (a little more for regular keys of small files); 1565///; 1566 ; 1567 ; 1568void TFile::Map(Option_t *opt); 1569{; 1570 TString options(opt);; 1571 options.ToLower();; 1572 bool forComp = options.Contains(""forcomp"");; 1573 bool extended = options.Contains(""extended"");; 1574 ; 1575 Short_t keylen,cycle;; 1576 UInt_t datime;; 1577 Int_t nbytes,date,time,objlen;; 1578 date = 0;; 1579 time = 0;; 1580 Long64_t seekkey,seekpdir;; 1581 char *buffer;; 1582 char nwhc;; 1583 Long64_t idcur = fBEGIN;; 1584 ; 1585 constexpr Int_t nwheader = 512;; 1586 ; 1587 char header[nwheader];; 1588 char classname[512];; 1589 char keyname[512];; 1590 char keytitle[512];; 1591 TString extrainfo;; 1592 ; 1593 unsigned char nDigits = std::log10(fEND) + 1;; 1594 ; 1595 while (idcur < fEND) {; 1596 Seek(idcur);; 1597 Int_t nread = nwheader;; 1598 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 1599 if (ReadBuffer(header, nread)) {; 1600 // ReadBuffer returns kTRUE in case of failure.; 1601 Warning(""Map"",""%s: failed to read the key data from disk at %lld."",; 1602 GetName(),idcur);; 1603 break;; 1604 }; 1605 ; 1606 buffer=header;; 1607 frombuf(buffer, &nbytes);; 1608 if (!nbytes) {; 1609 Printf(""Address = %lld\tNbytes = %d\t=====E R R",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:57657,Modifiability,extend,extended,57657,"OT file with histograms; 1560/// 20200820/155032 At:406225 N=8556 StreamerInfo CX = 3.42 name: StreamerInfo title: Doubly linked list; 1561/// 20200820/155708 At:414781 N=86 FreeSegments name: hsimple.root title: Demo ROOT file with histograms; 1562/// 20200820/155708 At:414867 N=1 END; 1563///; 1564/// Note: The combined size of the classname, name and title is truncated to 476 characters (a little more for regular keys of small files); 1565///; 1566 ; 1567 ; 1568void TFile::Map(Option_t *opt); 1569{; 1570 TString options(opt);; 1571 options.ToLower();; 1572 bool forComp = options.Contains(""forcomp"");; 1573 bool extended = options.Contains(""extended"");; 1574 ; 1575 Short_t keylen,cycle;; 1576 UInt_t datime;; 1577 Int_t nbytes,date,time,objlen;; 1578 date = 0;; 1579 time = 0;; 1580 Long64_t seekkey,seekpdir;; 1581 char *buffer;; 1582 char nwhc;; 1583 Long64_t idcur = fBEGIN;; 1584 ; 1585 constexpr Int_t nwheader = 512;; 1586 ; 1587 char header[nwheader];; 1588 char classname[512];; 1589 char keyname[512];; 1590 char keytitle[512];; 1591 TString extrainfo;; 1592 ; 1593 unsigned char nDigits = std::log10(fEND) + 1;; 1594 ; 1595 while (idcur < fEND) {; 1596 Seek(idcur);; 1597 Int_t nread = nwheader;; 1598 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 1599 if (ReadBuffer(header, nread)) {; 1600 // ReadBuffer returns kTRUE in case of failure.; 1601 Warning(""Map"",""%s: failed to read the key data from disk at %lld."",; 1602 GetName(),idcur);; 1603 break;; 1604 }; 1605 ; 1606 buffer=header;; 1607 frombuf(buffer, &nbytes);; 1608 if (!nbytes) {; 1609 Printf(""Address = %lld\tNbytes = %d\t=====E R R O R======="", idcur, nbytes);; 1610 date = 0; time = 0;; 1611 break;; 1612 }; 1613 if (nbytes < 0) {; 1614 Printf(""Address = %lld\tNbytes = %d\t=====G A P==========="", idcur, nbytes);; 1615 idcur -= nbytes;; 1616 Seek(idcur);; 1617 continue;; 1618 }; 1619 Version_t versionkey;; 1620 frombuf(buffer, &versionkey);; 1621 frombuf(buffer, &objlen);; 1622 frombuf(buffer, &datime);; 1623 fr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:59863,Modifiability,extend,extended,59863,"n_t versionkey;; 1620 frombuf(buffer, &versionkey);; 1621 frombuf(buffer, &objlen);; 1622 frombuf(buffer, &datime);; 1623 frombuf(buffer, &keylen);; 1624 frombuf(buffer, &cycle);; 1625 if (versionkey > 1000) {; 1626 frombuf(buffer, &seekkey);; 1627 frombuf(buffer, &seekpdir);; 1628 } else {; 1629 Int_t skey,sdir;; 1630 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 1631 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 1632 }; 1633 frombuf(buffer, &nwhc);; 1634 if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1635 nwhc = nwheader - (buffer-header);; 1636 for (int i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 1637 classname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1638 if (idcur == fSeekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1662 nwhc = nwheader - (buffer-header);; 1663 }; 1664 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keytitle[i]);; 1665 keytitle[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1666 ; 1667 extrainfo.Form("" name: %-16s title: %s"", keyname, keytitle);; 1668 }; 1669 ; 1670 TDatime::GetDateTime(datime, d",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128130,Modifiability,variab,variables,128130,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128214,Modifiability,adapt,adapt,128214,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:129692,Modifiability,variab,variables,129692,");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");; 3572 fprintf(f, ""//\n"");; 3573 fprintf(f, ""// The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3574 fprintf(f, ""// adapt the macro to the calling environment\n"");; 3575 fprintf(f, ""//\n"");; 3576 fprintf(f, ""// if (gSystem->Getenv(\""ROOTPROOFLITE\"")) {\n"");; 3577 fprintf(f, ""// Printf(\""event-SETUP: PROOF-Lite node (session has %%s workers)\"",\n"");; 3578 fprintf(f, ""// gSystem->Getenv(\""ROOTPROOFLITE\""));\n"");; 3579 fprintf(f, ""// } else if (gSystem->Getenv(\""ROOTPROOFCLIENT\"")) {\n"");; 3580 fprintf(f, ""// Printf(\""event-SETUP: PROOF client\"");\n"");; 3581 fprintf(f, ""// } else {\n"");; 3582 fprintf(f, ""// Printf(\""event-SETUP: standard PROOF node\"");\n"");; 3583 fprintf(f, ""// }\n"");; 3584 fprintf(f, ""\n"");; 3585 fprintf(f, "" if (gSystem->Load(\""lib%s\"") == -1)\n"", pack);; 3586 fprintf(f, "" return -1;\n"");; 3587 fprintf(f, "" return 0;\n"");; 3588 fprintf(f, ""}\n"");; 3589 fprintf(f, ""\n"");; 3590 ; 3591 // Close the file; 3592 fclose(f);; 3593 ; 3594 // Done; 3595 return 0;; 3596}; 3597 ; 3598////////////////////////////////////////////////////////////////////////////////; 3599/// Read the list of StreamerInfo from this file.; 3600///; 3601/// The key with name holding the list of TStreamerInfo objects is read.; 3602/// The corresponding TClass objects are updated.; 3603/// Note that this function is not called if the static member fgReadInfo is false.; 3604/// (see TFile::SetReadStreamerInfo); 3605 ; 3606void TFile::ReadStreamerInfo(); 3607{; 3608 auto listRe",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:129777,Modifiability,adapt,adapt,129777,");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");; 3572 fprintf(f, ""//\n"");; 3573 fprintf(f, ""// The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3574 fprintf(f, ""// adapt the macro to the calling environment\n"");; 3575 fprintf(f, ""//\n"");; 3576 fprintf(f, ""// if (gSystem->Getenv(\""ROOTPROOFLITE\"")) {\n"");; 3577 fprintf(f, ""// Printf(\""event-SETUP: PROOF-Lite node (session has %%s workers)\"",\n"");; 3578 fprintf(f, ""// gSystem->Getenv(\""ROOTPROOFLITE\""));\n"");; 3579 fprintf(f, ""// } else if (gSystem->Getenv(\""ROOTPROOFCLIENT\"")) {\n"");; 3580 fprintf(f, ""// Printf(\""event-SETUP: PROOF client\"");\n"");; 3581 fprintf(f, ""// } else {\n"");; 3582 fprintf(f, ""// Printf(\""event-SETUP: standard PROOF node\"");\n"");; 3583 fprintf(f, ""// }\n"");; 3584 fprintf(f, ""\n"");; 3585 fprintf(f, "" if (gSystem->Load(\""lib%s\"") == -1)\n"", pack);; 3586 fprintf(f, "" return -1;\n"");; 3587 fprintf(f, "" return 0;\n"");; 3588 fprintf(f, ""}\n"");; 3589 fprintf(f, ""\n"");; 3590 ; 3591 // Close the file; 3592 fclose(f);; 3593 ; 3594 // Done; 3595 return 0;; 3596}; 3597 ; 3598////////////////////////////////////////////////////////////////////////////////; 3599/// Read the list of StreamerInfo from this file.; 3600///; 3601/// The key with name holding the list of TStreamerInfo objects is read.; 3602/// The corresponding TClass objects are updated.; 3603/// Note that this function is not called if the static member fgReadInfo is false.; 3604/// (see TFile::SetReadStreamerInfo); 3605 ; 3606void TFile::ReadStreamerInfo(); 3607{; 3608 auto listRe",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:147396,Modifiability,plugin,plugin,147396,"ird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:147448,Modifiability,plugin,plugin,147448,"ird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:147481,Modifiability,plugin,plugin,147481,"ird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:147953,Modifiability,plugin,plugin,147953,"cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For rem",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:154049,Modifiability,plugin,plugin,154049,""");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter();; 4211 ; 4212 // change names to be recognized by the plugin manager; 4213 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4214 TUrl urlname(n, kTRUE);; 4215 name = urlname.GetUrl();; 4216 // Check first if a pending async open request matches this one; 4217 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4218 TIter nxr(fgAsyncOpenRequests);; 4219 TFileOpenHandle *fh = nullptr;; 4220 while ((fh = (TFileOpenHandle *)nxr())); 4221 if (fh->Matches(name)); 4222 return TFile::Open(fh);; 4223 }; 4224 ; 4225 TString urlOptions(urlname.GetOptions());; 4226 if (urlOptions.BeginsWith(""pmerge"") || urlOptions.Contains(""&pmerge"") || urlOptions.Contains("" pmerge"")) {; 4227 type = kMerge;; 4228 ; 4229 // Pass the full name including the url options:; 4230 f = (TFile*) gROOT->ProcessLineFast(TString::Format(""new",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:156353,Modifiability,plugin,plugin,156353,"option, ftitle, compress);; 4246 ; 4247 } else if (type == kNet) {; 4248 ; 4249 // Network files; 4250 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name))) {; 4251 if (h->LoadPlugin() == -1); 4252 return nullptr;; 4253 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4254 }; 4255 ; 4256 } else if (type == kWeb) {; 4257 ; 4258 // Web files; 4259 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name))) {; 4260 if (h->LoadPlugin() == -1); 4261 return nullptr;; 4262 f = (TFile*) h->ExecPlugin(2, name.Data(), option);; 4263 }; 4264 ; 4265 } else if (type == kFile) {; 4266 ; 4267 // 'file:' protocol; 4268 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4269 h->LoadPlugin() == 0) {; 4270 name.ReplaceAll(""file:"", """");; 4271 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4272 } else; 4273 f = new TFile(name.Data(), option, ftitle, compress);; 4274 ; 4275 } else {; 4276 ; 4277 // no recognized specification: try the plugin manager; 4278 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name.Data()))) {; 4279 if (h->LoadPlugin() == -1); 4280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::O",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:156885,Modifiability,plug-in,plug-in,156885," 4262 f = (TFile*) h->ExecPlugin(2, name.Data(), option);; 4263 }; 4264 ; 4265 } else if (type == kFile) {; 4266 ; 4267 // 'file:' protocol; 4268 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4269 h->LoadPlugin() == 0) {; 4270 name.ReplaceAll(""file:"", """");; 4271 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4272 } else; 4273 f = new TFile(name.Data(), option, ftitle, compress);; 4274 ; 4275 } else {; 4276 ; 4277 // no recognized specification: try the plugin manager; 4278 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name.Data()))) {; 4279 if (h->LoadPlugin() == -1); 4280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::Open( newUrl, option, ftitle, compress );; 4300 else; 4301 f = nullptr;; 4302 }; 4303 }; 4304 ; 4305 if (rediroutput) {; 4306 // Restore output to stdout; 4307 gSystem->RedirectOutput(0, """", &rh);; 4308 // If we failed print error messages; 4309 if (!f); 4310 gSystem->ShowOutput(&rh);; 4311 // Remove the file; 4312 gSystem->Unlink(rh.fFile);; 4313 }; 4314 ; 4315 // if the file is writable, non local, and not opened in raw mode; 4316 // we create a default write cache of 512 KBytes; 4317 if (type != kLocal ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:160505,Modifiability,plugin,plugin,160505,"compress,; 4354 Int_t netopt); 4355{; 4356 TFileOpenHandle *fh = nullptr;; 4357 TFile *f = nullptr;; 4358 Bool_t notfound = kTRUE;; 4359 ; 4360 // Check input; 4361 if (!url || strlen(url) <= 0) {; 4362 ::Error(""TFile::AsyncOpen"", ""no url specified"");; 4363 return fh;; 4364 }; 4365 ; 4366 // Many URLs? Redirect output and print errors in case of global failure; 4367 TString namelist(url);; 4368 gSystem->ExpandPathName(namelist);; 4369 Ssiz_t ip = namelist.Index(""|"");; 4370 Bool_t rediroutput = (ip != kNPOS &&; 4371 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4372 RedirectHandle_t rh;; 4373 if (rediroutput) {; 4374 TString outf = "".TFileAsyncOpen_"";; 4375 FILE *fout = gSystem->TempFileName(outf);; 4376 if (fout) {; 4377 fclose(fout);; 4378 gSystem->RedirectOutput(outf, ""w"", &rh);; 4379 }; 4380 }; 4381 ; 4382 // Try sequentially all names in 'names'; 4383 TString name, n;; 4384 Ssiz_t from = 0;; 4385 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4386 ; 4387 // change names to be recognized by the plugin manager; 4388 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4389 TUrl urlname(n, kTRUE);; 4390 name = urlname.GetUrl();; 4391 ; 4392 // Resolve the file type; this also adjusts names; 4393 EFileType type = GetType(name, option);; 4394 ; 4395 TPluginHandler *h = nullptr;; 4396 ; 4397 // Here we send the asynchronous request if the functionality is implemented; 4398 if (type == kNet) {; 4399 // Network files; 4400 if ((h = gROOT->GetPluginManager()->FindHandler(""TFile"", name)) &&; 4401 !strcmp(h->GetClass(),""TNetXNGFile""); 4402 && h->LoadPlugin() == 0) {; 4403 f = (TFile*) h->ExecPlugin(6, name.Data(), option, ftitle, compress, netopt, kTRUE);; 4404 notfound = kFALSE;; 4405 }; 4406 }; 4407 }; 4408 ; 4409 if (rediroutput) {; 4410 // Restore output to stdout; 4411 gSystem->RedirectOutput(0, """", &rh);; 4412 // If we failed print error messages; 4413 if (!notfound && !f); 4414 gSystem->ShowOutput(&rh);; 4415 // Remove the file; 4416 g",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188599,Modifiability,plugin,plugins,188599,"n source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217//////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188638,Modifiability,plugin,plugins,188638,"or(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217////////////////////////////////////////////////////////////////////////////////; 5218/// Max numb",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:202354,Modifiability,inherit,inherits,202354,"inition TBuffer.h:43; TBuffer::kInitialSize@ kInitialSizeDefinition TBuffer.h:78; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:17",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:13132,Performance,perform,performed,13132,"; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read co",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:35059,Performance,concurren,concurrent,35059,"ALSE;; 935 MakeZombie();; 936 gDirectory = gROOT;; 937}; 938 ; 939////////////////////////////////////////////////////////////////////////////////; 940/// Close a file.; 941///; 942/// \param[in] option If option == ""R"", all TProcessIDs referenced by this file are deleted.; 943///; 944/// Calling TFile::Close(""R"") might be necessary in case one reads a long list; 945/// of files having TRef, writing some of the referenced objects or TRef; 946/// to a new file. If the TRef or referenced objects of the file being closed; 947/// will not be referenced again, it is possible to minimize the size; 948/// of the TProcessID data structures in memory by forcing a delete of; 949/// the unused TProcessID.; 950 ; 951void TFile::Close(Option_t *option); 952{; 953 TString opt = option;; 954 ; 955 opt.ToLower();; 956 ; 957 if (!IsOpen()) return;; 958 ; 959 if (fIsArchive || !fIsRootFile) {; 960 FlushWriteCache();; 961 SysClose(fD);; 962 fD = -1;; 963 ; 964 if (gMonitoringWriter); 965 gMonitoringWriter->SendFileCloseEvent(this);; 966 ; 967 return;; 968 }; 969 ; 970 if (IsWritable()) {; 971 WriteStreamerInfo();; 972 }; 973 ; 974 // Finish any concurrent I/O operations before we close the file handles.; 975 if (fCacheRead) fCacheRead->Close();; 976 {; 977 TIter iter(fCacheReadMap);; 978 TObject *key = nullptr;; 979 while ((key = iter()) != nullptr) {; 980 TFileCacheRead *cache = dynamic_cast<TFileCacheRead *>(fCacheReadMap->GetValue(key));; 981 cache->Close();; 982 }; 983 }; 984 ; 985 // Delete all supported directories structures from memory; 986 // If gDirectory points to this object or any of the nested; 987 // TDirectoryFile, TDirectoryFile::Close will induce the proper cd.; 988 fMustFlush = kFALSE; // Make sure there is only one Flush.; 989 TDirectoryFile::Close(option);; 990 ; 991 if (IsWritable()) {; 992 TFree *f1 = (TFree*)fFree->First();; 993 if (f1) {; 994 WriteFree(); //*-*- Write free segments linked list; 995 WriteHeader(); //*-*- Now write file header ; this forces a Flu",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:35291,Performance,cache,cache,35291,"6/// to a new file. If the TRef or referenced objects of the file being closed; 947/// will not be referenced again, it is possible to minimize the size; 948/// of the TProcessID data structures in memory by forcing a delete of; 949/// the unused TProcessID.; 950 ; 951void TFile::Close(Option_t *option); 952{; 953 TString opt = option;; 954 ; 955 opt.ToLower();; 956 ; 957 if (!IsOpen()) return;; 958 ; 959 if (fIsArchive || !fIsRootFile) {; 960 FlushWriteCache();; 961 SysClose(fD);; 962 fD = -1;; 963 ; 964 if (gMonitoringWriter); 965 gMonitoringWriter->SendFileCloseEvent(this);; 966 ; 967 return;; 968 }; 969 ; 970 if (IsWritable()) {; 971 WriteStreamerInfo();; 972 }; 973 ; 974 // Finish any concurrent I/O operations before we close the file handles.; 975 if (fCacheRead) fCacheRead->Close();; 976 {; 977 TIter iter(fCacheReadMap);; 978 TObject *key = nullptr;; 979 while ((key = iter()) != nullptr) {; 980 TFileCacheRead *cache = dynamic_cast<TFileCacheRead *>(fCacheReadMap->GetValue(key));; 981 cache->Close();; 982 }; 983 }; 984 ; 985 // Delete all supported directories structures from memory; 986 // If gDirectory points to this object or any of the nested; 987 // TDirectoryFile, TDirectoryFile::Close will induce the proper cd.; 988 fMustFlush = kFALSE; // Make sure there is only one Flush.; 989 TDirectoryFile::Close(option);; 990 ; 991 if (IsWritable()) {; 992 TFree *f1 = (TFree*)fFree->First();; 993 if (f1) {; 994 WriteFree(); //*-*- Write free segments linked list; 995 WriteHeader(); //*-*- Now write file header ; this forces a Flush/fsync; 996 } else {; 997 Flush();; 998 }; 999 }; 1000 fMustFlush = kTRUE;; 1001 ; 1002 FlushWriteCache();; 1003 ; 1004 if (gMonitoringWriter); 1005 gMonitoringWriter->SendFileCloseEvent(this);; 1006 ; 1007 delete fClassIndex;; 1008 fClassIndex = nullptr;; 1009 ; 1010 // Delete free segments from free list (but don't delete list header); 1011 if (fFree) {; 1012 fFree->Delete();; 1013 }; 1014 ; 1015 if (IsOpen()) {; 1016 SysClose(fD);; 1017",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:35366,Performance,cache,cache,35366,"6/// to a new file. If the TRef or referenced objects of the file being closed; 947/// will not be referenced again, it is possible to minimize the size; 948/// of the TProcessID data structures in memory by forcing a delete of; 949/// the unused TProcessID.; 950 ; 951void TFile::Close(Option_t *option); 952{; 953 TString opt = option;; 954 ; 955 opt.ToLower();; 956 ; 957 if (!IsOpen()) return;; 958 ; 959 if (fIsArchive || !fIsRootFile) {; 960 FlushWriteCache();; 961 SysClose(fD);; 962 fD = -1;; 963 ; 964 if (gMonitoringWriter); 965 gMonitoringWriter->SendFileCloseEvent(this);; 966 ; 967 return;; 968 }; 969 ; 970 if (IsWritable()) {; 971 WriteStreamerInfo();; 972 }; 973 ; 974 // Finish any concurrent I/O operations before we close the file handles.; 975 if (fCacheRead) fCacheRead->Close();; 976 {; 977 TIter iter(fCacheReadMap);; 978 TObject *key = nullptr;; 979 while ((key = iter()) != nullptr) {; 980 TFileCacheRead *cache = dynamic_cast<TFileCacheRead *>(fCacheReadMap->GetValue(key));; 981 cache->Close();; 982 }; 983 }; 984 ; 985 // Delete all supported directories structures from memory; 986 // If gDirectory points to this object or any of the nested; 987 // TDirectoryFile, TDirectoryFile::Close will induce the proper cd.; 988 fMustFlush = kFALSE; // Make sure there is only one Flush.; 989 TDirectoryFile::Close(option);; 990 ; 991 if (IsWritable()) {; 992 TFree *f1 = (TFree*)fFree->First();; 993 if (f1) {; 994 WriteFree(); //*-*- Write free segments linked list; 995 WriteHeader(); //*-*- Now write file header ; this forces a Flush/fsync; 996 } else {; 997 Flush();; 998 }; 999 }; 1000 fMustFlush = kTRUE;; 1001 ; 1002 FlushWriteCache();; 1003 ; 1004 if (gMonitoringWriter); 1005 gMonitoringWriter->SendFileCloseEvent(this);; 1006 ; 1007 delete fClassIndex;; 1008 fClassIndex = nullptr;; 1009 ; 1010 // Delete free segments from free list (but don't delete list header); 1011 if (fFree) {; 1012 fFree->Delete();; 1013 }; 1014 ; 1015 if (IsOpen()) {; 1016 SysClose(fD);; 1017",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:41358,Performance,cache,cache,41358,"Once the map is drawn, turn on the TCanvas option ""View->Event Statusbar"". Then, when; 1120/// moving the mouse in the canvas, the ""Event Status"" panels shows the object corresponding; 1121/// to the mouse position.; 1122///; 1123/// Example:; 1124/// ~~~{.cpp}; 1125/// auto f = new TFile(""myfile.root"");; 1126/// f->DrawMap();; 1127/// ~~~; 1128 ; 1129void TFile::DrawMap(const char *keys, Option_t *option); 1130{; 1131 TPluginHandler *h;; 1132 if ((h = gROOT->GetPluginManager()->FindHandler(""TFileDrawMap""))) {; 1133 if (h->LoadPlugin() == -1); 1134 return;; 1135 h->ExecPlugin(3, this, keys, option);; 1136 }; 1137}; 1138 ; 1139////////////////////////////////////////////////////////////////////////////////; 1140/// Synchronize a file's in-memory and on-disk states.; 1141 ; 1142void TFile::Flush(); 1143{; 1144 if (IsOpen() && fWritable) {; 1145 FlushWriteCache();; 1146 if (SysSync(fD) < 0) {; 1147 // Write the system error only once for this file; 1148 SetBit(kWriteError); SetWritable(kFALSE);; 1149 SysError(""Flush"", ""error flushing file %s"", GetName());; 1150 }; 1151 }; 1152}; 1153 ; 1154////////////////////////////////////////////////////////////////////////////////; 1155/// Flush the write cache if active.; 1156///; 1157/// Return kTRUE in case of error; 1158 ; 1159Bool_t TFile::FlushWriteCache(); 1160{; 1161 if (fCacheWrite && IsOpen() && fWritable); 1162 return fCacheWrite->Flush();; 1163 return kFALSE;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167/// Encode file output buffer.; 1168///; 1169/// The file output buffer contains only the FREE data record.; 1170 ; 1171void TFile::FillBuffer(char *&buffer); 1172{; 1173 Version_t version = TFile::Class_Version();; 1174 tobuf(buffer, version);; 1175}; 1176 ; 1177////////////////////////////////////////////////////////////////////////////////; 1178/// Return the best buffer size of objects on this file.; 1179///; 1180/// The best buffer size is estimated based ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:44722,Performance,cache,cache,44722,"3 frombuf(buffer, &nbytes);; 1224 if (nbytes < 0) {; 1225 idcur -= nbytes;; 1226 Seek(idcur);; 1227 continue;; 1228 }; 1229 if (nbytes == 0) break; //this may happen when the file is corrupted; 1230 Version_t versionkey;; 1231 frombuf(buffer, &versionkey);; 1232 frombuf(buffer, &objlen);; 1233 frombuf(buffer, &datime);; 1234 frombuf(buffer, &keylen);; 1235 if (!objlen) objlen = nbytes-keylen;; 1236 comp += nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf p",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:45048,Performance,cache,cache,45048," nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The fun",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:45116,Performance,cache,cache,45116," nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The fun",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:45155,Performance,cache,cache,45155," nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The fun",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:45309,Performance,cache,cache,45309," nbytes;; 1237 uncomp += keylen + objlen;; 1238 idcur += nbytes;; 1239 }; 1240 delete [] header;; 1241 return uncomp/comp;; 1242}; 1243 ; 1244////////////////////////////////////////////////////////////////////////////////; 1245/// Method returning errno.; 1246 ; 1247Int_t TFile::GetErrno() const; 1248{; 1249 return TSystem::GetErrno();; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The fun",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:48418,Performance,cache,cached,48418,"fer,&nb);; 1329 nbytes = nb;; 1330 if (nb < 0) return nread;; 1331 // const Int_t headerSize = Int_t(sizeof(nb) +sizeof(versionkey) +sizeof(olen) +sizeof(datime) +sizeof(klen));; 1332 const Int_t headerSize = 16;; 1333 if (nread < headerSize) return nread;; 1334 frombuf(buffer, &versionkey);; 1335 frombuf(buffer, &olen);; 1336 frombuf(buffer, &datime);; 1337 frombuf(buffer, &klen);; 1338 if (!olen) olen = nbytes-klen;; 1339 objlen = olen;; 1340 keylen = klen;; 1341 return nread;; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Returns the current file size. Returns -1 in case the file could not; 1346/// be stat'ed.; 1347 ; 1348Long64_t TFile::GetSize() const; 1349{; 1350 Long64_t size;; 1351 ; 1352 if (fArchive && fArchive->GetMember()) {; 1353 size = fArchive->GetMember()->GetDecompressedSize();; 1354 } else {; 1355 Long_t id, flags, modtime;; 1356 if (const_cast<TFile*>(this)->SysStat(fD, &id, &size, &flags, &modtime)) { // NOLINT: silence clang-tidy warnings; 1357 Error(""GetSize"", ""cannot stat the file %s"", GetName());; 1358 return -1;; 1359 }; 1360 }; 1361 return size;; 1362}; 1363 ; 1364////////////////////////////////////////////////////////////////////////////////; 1365/// Returns the cached list of StreamerInfos used in this file.; 1366 ; 1367const TList *TFile::GetStreamerInfoCache(); 1368{; 1369 return fInfoCache ? fInfoCache : (fInfoCache=GetStreamerInfoList());; 1370}; 1371 ; 1372////////////////////////////////////////////////////////////////////////////////; 1373/// See documentation of GetStreamerInfoList for more details.; 1374/// This is an internal method which returns the list of streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for RO",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:62986,Performance,cache,cache,62986,"r,1,""END"");; 1692 else; 1693 Printf(""At:%-*lld N=%-8d K= O= %-14s"", nDigits+1, idcur,1,""END"");; 1694}; 1695 ; 1696////////////////////////////////////////////////////////////////////////////////; 1697/// Paint all objects in the file.; 1698 ; 1699void TFile::Paint(Option_t *option); 1700{; 1701 GetList()->R__FOR_EACH(TObject,Paint)(option);; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Print all objects in the file.; 1706 ; 1707void TFile::Print(Option_t *option) const; 1708{; 1709 Printf(""TFile: name=%s, title=%s, option=%s"", GetName(), GetTitle(), GetOption());; 1710 GetList()->R__FOR_EACH(TObject,Print)(option);; 1711}; 1712 ; 1713////////////////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gM",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:67174,Performance,cache,cache,67174,"TRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, from TFileCacheRead to pass list of readahead buffers; 1825 if (!buf) {; 1826 for (Int_t j = 0; j < nbuf; j++) {; 1827 if (ReadBufferAsync(pos[j], len[j])) {; 1828 return kTRUE;; 1829 }; 1830 }; 1831 return kFALSE;; 1832 }; 1833 ; 1834 Int_t k = 0;; 1835 Bool_t result = kTRUE;; 1836 TFileCacheRead *old = fCacheRead;; 1837 fCacheRead = nullptr;; 1838 Long64_t curbegin = pos[0];; 1839 Long64_t cur;; 1840 char *buf2 = nullptr;; 1841 Int_t i = 0, n = 0;; 1842 while (i < nbuf) {; 1843 cur = pos[i]+len[i];; 1844 Bool_t bigRead = kTRUE;; 1845 if (cur -curbegin < fgReadaheadSize) {n++; i++; bigRead = kFALSE;}; 1846 if (bigRead || (i>=nbuf)) {; 1847 if (n == 0) {; 1848 //if the block to read is about the same size as the read-ahead buffer; 1849 //we read the block directly; 1850 Seek(pos[i]);; 1851 result = ReadBuffer(&buf[k], len[i]);; 1852 if (result) break;; 1853 k += len[i];; 1854 i++;; 1855 } else {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Retur",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:67753,Performance,cache,cache,67753,"TRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, from TFileCacheRead to pass list of readahead buffers; 1825 if (!buf) {; 1826 for (Int_t j = 0; j < nbuf; j++) {; 1827 if (ReadBufferAsync(pos[j], len[j])) {; 1828 return kTRUE;; 1829 }; 1830 }; 1831 return kFALSE;; 1832 }; 1833 ; 1834 Int_t k = 0;; 1835 Bool_t result = kTRUE;; 1836 TFileCacheRead *old = fCacheRead;; 1837 fCacheRead = nullptr;; 1838 Long64_t curbegin = pos[0];; 1839 Long64_t cur;; 1840 char *buf2 = nullptr;; 1841 Int_t i = 0, n = 0;; 1842 while (i < nbuf) {; 1843 cur = pos[i]+len[i];; 1844 Bool_t bigRead = kTRUE;; 1845 if (cur -curbegin < fgReadaheadSize) {n++; i++; bigRead = kFALSE;}; 1846 if (bigRead || (i>=nbuf)) {; 1847 if (n == 0) {; 1848 //if the block to read is about the same size as the read-ahead buffer; 1849 //we read the block directly; 1850 Seek(pos[i]);; 1851 result = ReadBuffer(&buf[k], len[i]);; 1852 if (result) break;; 1853 k += len[i];; 1854 i++;; 1855 } else {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Retur",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:67825,Performance,cache,cache,67825," {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:67860,Performance,cache,cache,67860," {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:67901,Performance,cache,cache,67901," {; 1856 //otherwise we read all blocks that fit in the read-ahead buffer; 1857 Seek(curbegin);; 1858 if (!buf2) buf2 = new char[fgReadaheadSize];; 1859 //we read ahead; 1860 Long64_t nahead = pos[i-1]+len[i-1]-curbegin;; 1861 result = ReadBuffer(buf2, nahead);; 1862 if (result) break;; 1863 //now copy from the read-ahead buffer to the cache; 1864 Int_t kold = k;; 1865 for (Int_t j=0;j<n;j++) {; 1866 memcpy(&buf[k],&buf2[pos[i-n+j]-curbegin],len[i-n+j]);; 1867 k += len[i-n+j];; 1868 }; 1869 Int_t nok = k-kold;; 1870 Long64_t extra = nahead-nok;; 1871 fBytesReadExtra += extra;; 1872 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:68454,Performance,cache,cache,68454,"2 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->Get",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:68499,Performance,cache,cache,68499,"2 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->Get",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:82696,Performance,cache,cache,82696,"s % 100;; 2313 fCompress = 100 * algorithm + level;; 2314 }; 2315}; 2316 ; 2317////////////////////////////////////////////////////////////////////////////////; 2318/// See comments for function SetCompressionSettings; 2319 ; 2320void TFile::SetCompressionLevel(Int_t level); 2321{; 2322 if (level < 0) level = 0;; 2323 if (level > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:82772,Performance,cache,cache,82772,"l > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:82844,Performance,cache,cache,82844,"l > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:82885,Performance,cache,cache,82885,"l > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83084,Performance,cache,cache,83084,"l > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83172,Performance,cache,cache,83172,"0 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->Ge",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83273,Performance,cache,cache,83273,"0 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->Ge",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83384,Performance,cache,cache,83384," the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83625,Performance,cache,cache,83625," ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache se",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83808,Performance,cache,cache,83808,"so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 238",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83890,Performance,cache,cache,83890,"r = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:83968,Performance,cache,cache,83968,"r = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84000,Performance,cache,cache,84000,"r = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84384,Performance,cache,cache,84384,"sconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TB",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84391,Performance,cache,cache,84391,"sconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TB",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84591,Performance,cache,cache,84591,"sconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TB",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84617,Performance,cache,cache,84617,"kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of ob",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84760,Performance,cache,cache,84760,"kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of ob",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84820,Performance,cache,cache,84820,"te the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84893,Performance,cache,cache,84893,"->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double(bufsize);; 2422 fSum2Buffer += double(bufsize) * double(bufsize); // avoid reaching MAXINT for temporary; 2423}; 2424 ; 2425//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84918,Performance,cache,cache,84918,"->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double(bufsize);; 2422 fSum2Buffer += double(bufsize) * double(bufsize); // avoid reaching MAXINT for temporary; 2423}; 2424 ; 2425//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84980,Performance,cache,cache,84980,"->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double(bufsize);; 2422 fSum2Buffer += double(bufsize) * double(bufsize); // avoid reaching MAXINT for temporary; 2423}; 2424 ; 2425//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:89286,Performance,cache,cache,89286,"TFile object should not be saved. We try to proceed anyway."");; 2470 return const_cast<TFile*>(this)->Write(n, opt, bufsize);; 2471}; 2472 ; 2473////////////////////////////////////////////////////////////////////////////////; 2474/// Write a buffer to the file. This is the basic low level write operation.; 2475/// Returns kTRUE in case of failure.; 2476 ; 2477Bool_t TFile::WriteBuffer(const char *buf, Int_t len); 2478{; 2479 if (IsOpen() && fWritable) {; 2480 ; 2481 Int_t st;; 2482 if ((st = WriteBufferViaCache(buf, len))) {; 2483 if (st == 2); 2484 return kTRUE;; 2485 return kFALSE;; 2486 }; 2487 ; 2488 ssize_t siz;; 2489 gSystem->IgnoreInterrupt();; 2490 while ((siz = SysWrite(fD, buf, len)) < 0 && GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len))",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:89306,Performance,cache,cache,89306,"& GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 255",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:89356,Performance,cache,cache,89356,"& GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 255",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:89398,Performance,cache,cache,89398,"& GetErrno() == EINTR) // NOLINT: silence clang-tidy warnings; 2491 ResetErrno(); // NOLINT: silence clang-tidy warnings; 2492 gSystem->IgnoreInterrupt(kFALSE);; 2493 if (siz < 0) {; 2494 // Write the system error only once for this file; 2495 SetBit(kWriteError); SetWritable(kFALSE);; 2496 SysError(""WriteBuffer"", ""error writing to file %s (%ld)"", GetName(), (Long_t)siz);; 2497 return kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 255",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:89722,Performance,cache,cache,89722,"kTRUE;; 2498 }; 2499 if (siz != len) {; 2500 SetBit(kWriteError);; 2501 Error(""WriteBuffer"", ""error writing all requested bytes to file %s, wrote %ld of %d"",; 2502 GetName(), (Long_t)siz, len);; 2503 return kTRUE;; 2504 }; 2505 fBytesWrite += siz;; 2506 fgBytesWrite += siz;; 2507 ; 2508 if (gMonitoringWriter); 2509 gMonitoringWriter->SendFileWriteProgress(this);; 2510 ; 2511 return kFALSE;; 2512 }; 2513 return kTRUE;; 2514}; 2515 ; 2516////////////////////////////////////////////////////////////////////////////////; 2517/// Write buffer via cache. Returns 0 if cache is not active, 1 in case; 2518/// write via cache was successful, 2 in case write via cache failed.; 2519 ; 2520Int_t TFile::WriteBufferViaCache(const char *buf, Int_t len); 2521{; 2522 if (!fCacheWrite) return 0;; 2523 ; 2524 Int_t st;; 2525 Long64_t off = GetRelOffset();; 2526 if ((st = fCacheWrite->WriteBuffer(buf, off, len)) < 0) {; 2527 SetBit(kWriteError);; 2528 Error(""WriteBuffer"", ""error writing to cache"");; 2529 return 2;; 2530 }; 2531 if (st > 0) {; 2532 // fOffset might have been changed via TFileCacheWrite::WriteBuffer(), reset it; 2533 Seek(off + len);; 2534 return 1;; 2535 }; 2536 return 0;; 2537}; 2538 ; 2539////////////////////////////////////////////////////////////////////////////////; 2540/// Write FREE linked list on the file.; 2541/// The linked list of FREE segments (fFree) is written as a single data; 2542/// record.; 2543 ; 2544void TFile::WriteFree(); 2545{; 2546 //*-* Delete old record if it exists; 2547 if (fSeekFree != 0) {; 2548 MakeFree(fSeekFree, fSeekFree + fNbytesFree -1);; 2549 }; 2550 ; 2551 Bool_t largeFile = (fEND > TFile::kStartBigFile);; 2552 ; 2553 auto createKey = [this]() {; 2554 Int_t nbytes = 0;; 2555 TFree *afree;; 2556 TIter next (fFree);; 2557 while ((afree = (TFree*) next())) {; 2558 nbytes += afree->Sizeof();; 2559 }; 2560 if (!nbytes) return (TKey*)nullptr;; 2561 ; 2562 TKey *key = new TKey(fName,fTitle,IsA(),nbytes,this);; 2563 ; 2564 if (key->GetSeekKey(",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:97975,Performance,load,load,97975,"ame.so will be created.; 2699/// If the option ""++"" is specified, the generated shared lib is dynamically; 2700/// linked with the current executable module.; 2701/// If the option ""+"" and ""nocompile"" are specified, the utility files are generated; 2702/// as in the option ""+"" but they are not executed.; 2703/// Example:; 2704/// file.MakeProject(""demo"",""*"",""recreate++"");; 2705/// - creates a new directory demo unless it already exist; 2706/// - clear the previous directory content; 2707/// - generate the xxx.h files for all classes xxx found in this file; 2708/// and not yet known to the CINT dictionary.; 2709/// - creates the build script MAKEP; 2710/// - creates a LinkDef.h file; 2711/// - runs rootcint generating demoProjectDict.cxx; 2712/// - compiles demoProjectDict.cxx into demoProjectDict.o; 2713/// - generates a shared lib demo.so; 2714/// - dynamically links the shared lib demo.so to the executable; 2715/// If only the option ""+"" had been specified, one can still link the; 2716/// shared lib to the current executable module with:; 2717///; 2718/// gSystem->load(""demo/demo.so"");; 2719///; 2720/// The following feature is not yet enabled:; 2721/// One can restrict the list of classes to be generated by using expressions like:; 2722///; 2723/// classes = ""Ali*"" generate code only for classes starting with Ali; 2724/// classes = ""myClass"" generate code for class MyClass only.; 2725///; 2726 ; 2727void TFile::MakeProject(const char *dirname, const char * /*classes*/,; 2728 Option_t *option); 2729{; 2730 TString opt = option;; 2731 opt.ToLower();; 2732 Bool_t makepar = kFALSE;; 2733 TString parname, pardir;; 2734 if (opt.Contains(""par"")) {; 2735 // Create a PAR file; 2736 parname = gSystem->BaseName(dirname);; 2737 if (parname.EndsWith("".par"")) parname.ReplaceAll("".par"","""");; 2738 pardir = gSystem->GetDirName(dirname);; 2739 // Cleanup or prepare the dirs; 2740 TString path, filepath;; 2741 void *dir = gSystem->OpenDirectory(pardir);; 2742 if (dir) {; 2743 path.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:135776,Performance,load,loaded,135776,"ss()->IsSyntheticPair()) {; 3706 printf(""ReadStreamerInfo, class:%s, illegal uid=%d\n"",info->GetName(),uid);; 3707 }; 3708 if (gDebug > 0) printf("" -class: %s version: %d info read at slot %d\n"",info->GetName(), info->GetClassVersion(),uid);; 3709 }; 3710 lnk = lnk->Next();; 3711 }; 3712 }; 3713 fClassIndex->fArray[0] = 0;; 3714 list->Clear(); //this will delete all TStreamerInfo objects with kCanDelete bit set; 3715 delete list;; 3716 ; 3717 // We are done processing the record, let future calls and other threads that it; 3718 // has been done.; 3719 fgTsSIHashes.Insert(listRetcode.fHash, std::move(si_uids));; 3720}; 3721 ; 3722////////////////////////////////////////////////////////////////////////////////; 3723/// Specify if the streamerinfos must be read at file opening.; 3724///; 3725/// If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; 3726/// when opening the file.; 3727/// It may be interesting to set fgReadInfo to false to speedup the file; 3728/// opening time or in case libraries containing classes referenced; 3729/// by the file have not yet been loaded.; 3730/// if fgReadInfo is false, one can still read the StreamerInfo with; 3731/// myfile.ReadStreamerInfo();; 3732 ; 3733void TFile::SetReadStreamerInfo(Bool_t readinfo); 3734{; 3735 fgReadInfo = readinfo;; 3736}; 3737 ; 3738////////////////////////////////////////////////////////////////////////////////; 3739/// If the streamerinfos are to be read at file opening.; 3740///; 3741/// See TFile::SetReadStreamerInfo for more documentation.; 3742 ; 3743Bool_t TFile::GetReadStreamerInfo(); 3744{; 3745 return fgReadInfo;; 3746}; 3747 ; 3748////////////////////////////////////////////////////////////////////////////////; 3749/// Show the StreamerInfo of all classes written to this file.; 3750 ; 3751void TFile::ShowStreamerInfo(); 3752{; 3753 TList *list = GetStreamerInfoList();; 3754 if (!list) return;; 3755 ; 3756 list->ls();; 3757 delete list;; 3758}; 3759 ; 3760/////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:140654,Performance,cache,cache,140654,"ring *obj = new TObjString();; 3836 rule->AsString(obj->String());; 3837 listOfRules.Add(obj);; 3838 }; 3839 classSet.insert(clinfo);; 3840 }; 3841 }; 3842 }; 3843 }; 3844 ; 3845 // Write the StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""y",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:140714,Performance,cache,cache,140714,"sert(clinfo);; 3840 }; 3841 }; 3842 }; 3843 }; 3844 ; 3845 // Write the StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141163,Performance,cache,cache,141163,"bytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141192,Performance,cache,cache,141192,"bytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141285,Performance,cache,cache,141285,"bytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141499,Performance,cache,cache,141499," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141608,Performance,cache,cache,141608," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141766,Performance,cache,cache,141766," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141792,Performance,cache,cachepath,141792," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141826,Performance,cache,cachefilepath,141826," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141855,Performance,cache,cachefilepathbasedir,141855," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141883,Performance,cache,cachefilepath,141883," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141921,Performance,cache,cachefilepath,141921," The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:141963,Performance,cache,cachefilepathbasedir,141963,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142006,Performance,cache,cachefilepath,142006,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142048,Performance,cache,cachefilepathbasedir,142048,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142116,Performance,cache,cachefilepathbasedir,142116,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142222,Performance,cache,cache,142222,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142304,Performance,cache,cachefilepathbasedir,142304,"""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)obj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142494,Performance,cache,cachefilepath,142494," through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142523,Performance,cache,cachefilepath,142523," through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:142685,Performance,cache,cache,142685,"es - CACHEREAD disabled"");; 3894 } else {; 3895 // this is a remote file and worthwhile to be put into the local cache; 3896 // now create cachepath to put it; 3897 TString cachefilepath;; 3898 TString cachefilepathbasedir;; 3899 cachefilepath = fgCacheFileDir;; 3900 cachefilepath += fileurl.GetFile();; 3901 cachefilepathbasedir = gSystem->GetDirName(cachefilepath);; 3902 if ((gSystem->mkdir(cachefilepathbasedir, kTRUE) < 0) &&; 3903 (gSystem->AccessPathName(cachefilepathbasedir, kFileExists))) {; 3904 ::Warning(""TFile::OpenFromCache"",""you want to read through a cache, but I ""; 3905 ""cannot create the directory %s - CACHEREAD disabled"",; 3906 cachefilepathbasedir.Data());; 3907 } else {; 3908 // check if this should be a zip file; 3909 if (strlen(fileurl.GetAnchor())) {; 3910 // remove the anchor and change the target name; 3911 cachefilepath += ""__"";; 3912 cachefilepath += fileurl.GetAnchor();; 3913 fileurl.SetAnchor("""");; 3914 }; 3915 if (strstr(name,""zip="")) {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:143600,Performance,cache,cachefilepath,143600,") {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 397",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:143629,Performance,cache,cachefilepath,143629,") {; 3916 // filter out this option and change the target cache name; 3917 TString urloptions = fileurl.GetOptions();; 3918 TString newoptions;; 3919 TObjArray *objOptions = urloptions.Tokenize(""&"");; 3920 Int_t optioncount = 0;; 3921 TString zipname;; 3922 for (Int_t n = 0; n < objOptions->GetEntries(); n++) {; 3923 TString loption = ((TObjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 397",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:143772,Performance,cache,cache,143772,"bjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:143890,Performance,cache,cachefilepath,143890,"bjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:143962,Performance,cache,cache,143962,"bjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144017,Performance,cache,cacheblock,144017,"bjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144171,Performance,cache,cachefilepath,144171,"bjString*)objOptions->At(n))->GetName();; 3924 TObjArray *objTags = loption.Tokenize(""="");; 3925 if (objTags->GetEntries() == 2) {; 3926 TString key = ((TObjString*)objTags->At(0))->GetName();; 3927 TString value = ((TObjString*)objTags->At(1))->GetName();; 3928 if (key.CompareTo(""zip"", TString::kIgnoreCase)) {; 3929 if (optioncount!=0) {; 3930 newoptions += ""&"";; 3931 }; 3932 newoptions += key;; 3933 newoptions += ""="";; 3934 newoptions += value;; 3935 ++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144446,Performance,cache,cachefile,144446,"++optioncount;; 3936 } else {; 3937 zipname = value;; 3938 }; 3939 }; 3940 delete objTags;; 3941 }; 3942 delete objOptions;; 3943 fileurl.SetOptions(newoptions.Data());; 3944 cachefilepath += ""__"";; 3945 cachefilepath += zipname;; 3946 fileurl.SetAnchor("""");; 3947 }; 3948 ; 3949 Bool_t need2copy = kFALSE;; 3950 ; 3951 // check if file is in the cache; 3952 Long_t id;; 3953 Long64_t size;; 3954 Long_t flags;; 3955 Long_t modtime;; 3956 if (!gSystem->GetPathInfo(cachefilepath, &id, &size, &flags, &modtime)) {; 3957 // file is in the cache; 3958 if (!fgCacheFileDisconnected) {; 3959 char cacheblock[256];; 3960 char remotblock[256];; 3961 // check the remote file for it's size and compare some magic bytes; 3962 TString cfurl;; 3963 cfurl = cachefilepath;; 3964 cfurl += ""?filetype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""rem",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144610,Performance,cache,cachefile,144610,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144709,Performance,cache,cache,144709,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144729,Performance,cache,cache,144729,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144893,Performance,cache,cache,144893,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:144957,Performance,cache,cachefile,144957,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145022,Performance,cache,cachefile,145022,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145044,Performance,cache,cacheblock,145044,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145131,Performance,cache,cacheblock,145131,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145222,Performance,cache,cache,145222,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145401,Performance,cache,cache,145401,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145552,Performance,cache,cachefile,145552,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145808,Performance,cache,cachefilepathtmp,145808,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145827,Performance,cache,cachefilepath,145827,"iletype=raw"";; 3965 TUrl rurl(name);; 3966 TString ropt = rurl.GetOptions();; 3967 ropt += ""&filetype=raw"";; 3968 rurl.SetOptions(ropt);; 3969 ; 3970 Bool_t forcedcache = fgCacheFileForce;; 3971 fgCacheFileForce = kFALSE;; 3972 ; 3973 TFile *cachefile = TFile::Open(cfurl, ""READ"");; 3974 TFile *remotfile = TFile::Open(rurl.GetUrl(), ""READ"");; 3975 ; 3976 fgCacheFileForce = forcedcache;; 3977 ; 3978 if (!cachefile) {; 3979 need2copy = kTRUE;; 3980 ::Error(""TFile::OpenFromCache"",; 3981 ""cannot open the cache file to check cache consistency"");; 3982 return nullptr;; 3983 }; 3984 ; 3985 if (!remotfile) {; 3986 ::Error(""TFile::OpenFromCache"",; 3987 ""cannot open the remote file to check cache consistency"");; 3988 return nullptr;; 3989 }; 3990 ; 3991 cachefile->Seek(0);; 3992 remotfile->Seek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSyste",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:145914,Performance,cache,cachefilepathtmp,145914,"ek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 retur",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146009,Performance,cache,cache,146009,"ek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 retur",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146045,Performance,cache,cache,146045,"ek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 retur",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146091,Performance,cache,cachefilepathbasedir,146091,"ek(0);; 3993 ; 3994 if ((!cachefile->ReadBuffer(cacheblock,256)) &&; 3995 (!remotfile->ReadBuffer(remotblock,256))) {; 3996 if (memcmp(cacheblock, remotblock, 256)) {; 3997 ::Warning(""TFile::OpenFromCache"", ""the header of the cache file ""; 3998 ""differs from the remote file - forcing an update"");; 3999 need2copy = kTRUE;; 4000 }; 4001 } else {; 4002 ::Warning(""TFile::OpenFromCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 retur",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146223,Performance,cache,cachefilepath,146223,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146310,Performance,cache,cachefilepathtmp,146310,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146328,Performance,cache,cachefilepath,146328,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146471,Performance,cache,cachefilepathtmp,146471,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146586,Performance,cache,cache,146586,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146616,Performance,cache,cachefilepath,146616,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146754,Performance,cache,cachefilepath,146754,"onst auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", """,MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146816,Performance,cache,cachefilepath,146816,"onst auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", """,MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146855,Performance,cache,cachefile,146855,"020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146907,Performance,cache,cached,146907,"020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:146960,Performance,cache,cachefilepath,146960,"020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived class for which an; 4057/// plugin library handler has been registered with the plugin manager; 4058/// (for the plugin manager see the TPluginManager class). The returned; 4059/// type of TFile depends on the file name specified by 'url'.; 4060/// If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; 4061/// sequentially in the specified order until a successful open.; 4062/// If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; 4063/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:149070,Performance,cache,cache,149070,"r regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:149121,Performance,cache,cache,149121,"Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); 4092{; 4093 TPluginHandler *h;; 4094 TFile *f = nullptr;; 4095 EFileType type = kFile;; 4096 ; 4097 // Check input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:153689,Performance,cache,cache,153689,""");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter();; 4211 ; 4212 // change names to be recognized by the plugin manager; 4213 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4214 TUrl urlname(n, kTRUE);; 4215 name = urlname.GetUrl();; 4216 // Check first if a pending async open request matches this one; 4217 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4218 TIter nxr(fgAsyncOpenRequests);; 4219 TFileOpenHandle *fh = nullptr;; 4220 while ((fh = (TFileOpenHandle *)nxr())); 4221 if (fh->Matches(name)); 4222 return TFile::Open(fh);; 4223 }; 4224 ; 4225 TString urlOptions(urlname.GetOptions());; 4226 if (urlOptions.BeginsWith(""pmerge"") || urlOptions.Contains(""&pmerge"") || urlOptions.Contains("" pmerge"")) {; 4227 type = kMerge;; 4228 ; 4229 // Pass the full name including the url options:; 4230 f = (TFile*) gROOT->ProcessLineFast(TString::Format(""new",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:153854,Performance,cache,cache,153854,""");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t rediroutput = (ip != kNPOS &&; 4186 ip != namelist.Length()-1 && gDebug <= 0) ? kTRUE : kFALSE;; 4187 RedirectHandle_t rh;; 4188 if (rediroutput) {; 4189 TString outf = "".TFileOpen_"";; 4190 FILE *fout = gSystem->TempFileName(outf);; 4191 if (fout) {; 4192 fclose(fout);; 4193 gSystem->RedirectOutput(outf, ""w"", &rh);; 4194 }; 4195 }; 4196 ; 4197 // Try sequentially all names in 'names'; 4198 TString name, n;; 4199 Ssiz_t from = 0;; 4200 while (namelist.Tokenize(n, from, ""|"") && !f) {; 4201 ; 4202 // check if we read through a file cache; 4203 if (!strcasecmp(option, ""CACHEREAD"") ||; 4204 ((!strcasecmp(option,""READ"") || !option[0]) && fgCacheFileForce)) {; 4205 // Try opening the file from the cache; 4206 if ((f = TFile::OpenFromCache(n, option, ftitle, compress, netopt))); 4207 return f;; 4208 }; 4209 ; 4210 IncrementFileCounter();; 4211 ; 4212 // change names to be recognized by the plugin manager; 4213 // e.g. /protocol/path/to/file.root -> protocol:/path/to/file.root; 4214 TUrl urlname(n, kTRUE);; 4215 name = urlname.GetUrl();; 4216 // Check first if a pending async open request matches this one; 4217 if (fgAsyncOpenRequests && (fgAsyncOpenRequests->GetSize() > 0)) {; 4218 TIter nxr(fgAsyncOpenRequests);; 4219 TFileOpenHandle *fh = nullptr;; 4220 while ((fh = (TFileOpenHandle *)nxr())); 4221 if (fh->Matches(name)); 4222 return TFile::Open(fh);; 4223 }; 4224 ; 4225 TString urlOptions(urlname.GetOptions());; 4226 if (urlOptions.BeginsWith(""pmerge"") || urlOptions.Contains(""&pmerge"") || urlOptions.Contains("" pmerge"")) {; 4227 type = kMerge;; 4228 ; 4229 // Pass the full name including the url options:; 4230 f = (TFile*) gROOT->ProcessLineFast(TString::Format(""new",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:157805,Performance,cache,cache,157805," case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::Open( newUrl, option, ftitle, compress );; 4300 else; 4301 f = nullptr;; 4302 }; 4303 }; 4304 ; 4305 if (rediroutput) {; 4306 // Restore output to stdout; 4307 gSystem->RedirectOutput(0, """", &rh);; 4308 // If we failed print error messages; 4309 if (!f); 4310 gSystem->ShowOutput(&rh);; 4311 // Remove the file; 4312 gSystem->Unlink(rh.fFile);; 4313 }; 4314 ; 4315 // if the file is writable, non local, and not opened in raw mode; 4316 // we create a default write cache of 512 KBytes; 4317 if (type != kLocal && type != kFile &&; 4318 f && f->IsWritable() && !f->IsRaw()) {; 4319 new TFileCacheWrite(f, 1);; 4320 }; 4321 ; 4322 return f;; 4323}; 4324 ; 4325////////////////////////////////////////////////////////////////////////////////; 4326/// Submit an asynchronous open request.; 4327 ; 4328/// See TFile::Open(const char *, ...) for an; 4329/// explanation of the arguments. A handler is returned which is to be passed; 4330/// to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; 4331/// the file is open.; 4332/// This call never blocks and it is provided to allow parallel submission; 4333/// of file opening operations expected to take a long time.; 4334/// TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; 4335/// The sequence; 4336///; 4337/// TFile::Open(TFile::AsyncOpen(const char *, ...)); 4338///; 4339/// is equivalent to; 4340///; 4341/// TFile::Open(const char *, ...); 4342///; 4343/// To be effective, the underlying TFile implementation must be able to; 4344/// support asynchronous open functio",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:167319,Performance,cache,caches,167319, fsync().; 4552 ; 4553Int_t TFile::SysSync(Int_t fd); 4554{; 4555 if (TestBit(kDevNull)) return 0;; 4556 ; 4557#ifndef WIN32; 4558 return ::fsync(fd);; 4559#else; 4560 return ::_commit(fd);; 4561#endif; 4562}; 4563 ; 4564////////////////////////////////////////////////////////////////////////////////; 4565/// Return the total number of bytes written so far to the file.; 4566 ; 4567Long64_t TFile::GetBytesWritten() const; 4568{; 4569 return fCacheWrite ? fCacheWrite->GetBytesInCache() + fBytesWrite : fBytesWrite;; 4570}; 4571 ; 4572////////////////////////////////////////////////////////////////////////////////; 4573/// Static function returning the total number of bytes read from all files.; 4574 ; 4575Long64_t TFile::GetFileBytesRead(); 4576{; 4577 return fgBytesRead;; 4578}; 4579 ; 4580////////////////////////////////////////////////////////////////////////////////; 4581/// Static function returning the total number of bytes written to all files.; 4582/// Does not take into account what might still be in the write caches.; 4583 ; 4584Long64_t TFile::GetFileBytesWritten(); 4585{; 4586 return fgBytesWrite;; 4587}; 4588 ; 4589////////////////////////////////////////////////////////////////////////////////; 4590/// Static function returning the total number of read calls from all files.; 4591 ; 4592Int_t TFile::GetFileReadCalls(); 4593{; 4594 return fgReadCalls;; 4595}; 4596 ; 4597////////////////////////////////////////////////////////////////////////////////; 4598/// Static function returning the readahead buffer size.; 4599 ; 4600Int_t TFile::GetReadaheadSize(); 4601{; 4602 return fgReadaheadSize;; 4603}; 4604 ; 4605//______________________________________________________________________________; 4606void TFile::SetReadaheadSize(Int_t bytes) { fgReadaheadSize = bytes; }; 4607 ; 4608//______________________________________________________________________________; 4609void TFile::SetFileBytesRead(Long64_t bytes) { fgBytesRead = bytes; }; 4610 ; 4611//_________________,MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169057,Performance,cache,cache,169057,"/////////////////////////////////////////////////////////; 4590/// Static function returning the total number of read calls from all files.; 4591 ; 4592Int_t TFile::GetFileReadCalls(); 4593{; 4594 return fgReadCalls;; 4595}; 4596 ; 4597////////////////////////////////////////////////////////////////////////////////; 4598/// Static function returning the readahead buffer size.; 4599 ; 4600Int_t TFile::GetReadaheadSize(); 4601{; 4602 return fgReadaheadSize;; 4603}; 4604 ; 4605//______________________________________________________________________________; 4606void TFile::SetReadaheadSize(Int_t bytes) { fgReadaheadSize = bytes; }; 4607 ; 4608//______________________________________________________________________________; 4609void TFile::SetFileBytesRead(Long64_t bytes) { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 46",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169199,Performance,cache,cachedir,169199," { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCa",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169288,Performance,cache,cached,169288," { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCa",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169295,Performance,cache,cachedir,169295," { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCa",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169317,Performance,cache,cached,169317," { fgBytesRead = bytes; }; 4610 ; 4611//______________________________________________________________________________; 4612void TFile::SetFileBytesWritten(Long64_t bytes) { fgBytesWrite = bytes; }; 4613 ; 4614//______________________________________________________________________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCa",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169345,Performance,cache,cached,169345,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169401,Performance,cache,cached,169401,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169472,Performance,cache,cached,169472,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169522,Performance,cache,cached,169522,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169616,Performance,cache,cache,169616,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169665,Performance,cache,cachedir,169665,"______________________; 4615void TFile::SetFileReadCalls(Int_t readcalls) { fgReadCalls = readcalls; }; 4616 ; 4617//______________________________________________________________________________; 4618Long64_t TFile::GetFileCounter() { return fgFileCounter; }; 4619 ; 4620//______________________________________________________________________________; 4621void TFile::IncrementFileCounter() { fgFileCounter++; }; 4622 ; 4623////////////////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the min",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169761,Performance,cache,cached,169761,"//////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169818,Performance,cache,cached,169818,"//////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169866,Performance,cache,cached,169866,"//////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:169904,Performance,cache,cached,169904,"//////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:170176,Performance,cache,cache,170176,"//////////////////////////////////////////////////////////////////////; 4624/// Sets the directory where to locally stage/cache remote files.; 4625/// If the directory is not writable by us return kFALSE.; 4626 ; 4627Bool_t TFile::SetCacheFileDir(std::string_view cachedir, Bool_t operatedisconnected,; 4628 Bool_t forcecacheread ); 4629{; 4630 TString cached{cachedir};; 4631 if (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:170408,Performance,cache,cache,170408," (!cached.EndsWith(""/"")); 4632 cached += ""/"";; 4633 ; 4634 if (gSystem->AccessPathName(cached, kFileExists)) {; 4635 // try to create it; 4636 gSystem->mkdir(cached, kTRUE);; 4637 if (gSystem->AccessPathName(cached, kFileExists)) {; 4638 ::Error(""TFile::SetCacheFileDir"", ""no sufficient permissions on cache directory %s or cannot create it"", TString(cachedir).Data());; 4639 fgCacheFileDir = """";; 4640 return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is ski",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:170613,Performance,cache,cache,170613," return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", c",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:170836,Performance,cache,cache,170836," return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", c",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:170943,Performance,cache,cachetagfile,170943," return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", c",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:170980,Performance,cache,cachetagfile,170980," return kFALSE;; 4641 }; 4642 gSystem->Chmod(cached, 0700);; 4643 }; 4644 if (gSystem->AccessPathName(cached, kWritePermission)); 4645 gSystem->Chmod(cached, 0700);; 4646 fgCacheFileDir = cached;; 4647 fgCacheFileDisconnected = operatedisconnected;; 4648 fgCacheFileForce = forcecacheread;; 4649 return kTRUE;; 4650}; 4651 ; 4652////////////////////////////////////////////////////////////////////////////////; 4653/// Get the directory where to locally stage/cache remote files.; 4654 ; 4655const char *TFile::GetCacheFileDir(); 4656{; 4657 return fgCacheFileDir;; 4658}; 4659 ; 4660////////////////////////////////////////////////////////////////////////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", c",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171007,Performance,cache,cache,171007,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171047,Performance,cache,cachetagfile,171047,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171136,Performance,cache,cache,171136,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171476,Performance,cache,cache,171476,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171497,Performance,cache,cachetagfile,171497,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171603,Performance,cache,cachetagfile,171603,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171695,Performance,cache,cache,171695,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171715,Performance,cache,cachetagfile,171715,"/////////////; 4661/// Try to shrink the cache to the desired size.; 4662///; 4663/// With the clenupinterval you can specify the minimum amount of time after; 4664/// the previous cleanup before the cleanup operation is repeated in; 4665/// the cache directory; 4666 ; 4667Bool_t TFile::ShrinkCacheFileDir(Long64_t shrinksize, Long_t cleanupinterval); 4668{; 4669 if (fgCacheFileDir == """") {; 4670 return kFALSE;; 4671 }; 4672 ; 4673 // check the last clean-up in the cache; 4674 Long_t id;; 4675 Long64_t size;; 4676 Long_t flags;; 4677 Long_t modtime;; 4678 ; 4679 TString cachetagfile = fgCacheFileDir;; 4680 cachetagfile += "".tag.ROOT.cache"";; 4681 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171921,Performance,cache,cachefile,171921,"81 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172134,Performance,cache,cachepath,172134,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172158,Performance,cache,cachesize,172158,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172199,Performance,cache,cachepath,172199,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172451,Performance,cache,cachesize,172451,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172492,Performance,cache,cachefile,172492,"=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722/////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172559,Performance,cache,cachefile,172559,"File::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (i",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172686,Performance,cache,cachepath,172686,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172710,Performance,cache,cachesize,172710,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172751,Performance,cache,cachepath,172751,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173003,Performance,cache,cachesize,173003,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173044,Performance,cache,cachefile,173044," 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173111,Performance,cache,cachefile,173111,"= \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous va",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:177400,Performance,optimiz,optimize,177400,"protocol field in 'name'; 4817///; 4818/// If defined, the string 'prefix' is added when testing the locality of; 4819/// a 'name' with network-like structure (i.e. root://host//path); if the file; 4820/// is local, on return 'prefix' will contain the actual local path of the file.; 4821 ; 4822TFile::EFileType TFile::GetType(const char *name, Option_t *option, TString *prefix); 4823{; 4824 EFileType type = kDefault;; 4825 ; 4826 TPMERegexp re(""^(root|xroot).*"", ""i"");; 4827 if (re.Match(name)) {; 4828 //; 4829 // Should be a network file ...; 4830 type = kNet;; 4831 // ... but make sure that is not local or that a remote-like connection; 4832 // is forced. Treat it as local if:; 4833 // i) the url points to the localhost, the file will be opened in; 4834 // readonly mode and the current user has read access;; 4835 // ii) the specified user is equal to the current user then open local; 4836 // TFile.; 4837 Bool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:183296,Performance,optimiz,optimization,183296,"/size); 4987 fprintf(stderr, ""."");; 4988 } else; 4989 fprintf(stderr, ""="");; 4990 }; 4991 // Allow to update the GUI while uploading files; 4992 gSystem->ProcessEvents();; 4993 watch.Stop();; 4994 Double_t lCopy_time = watch.RealTime();; 4995 fprintf(stderr, ""| %.02f %% [%.01f MB/s]\r"",; 4996 100.0*(size?(bytesread/((float)size)):1), (lCopy_time>0.)?bytesread/lCopy_time/1048576.:0.);; 4997 watch.Continue();; 4998}; 4999 ; 5000////////////////////////////////////////////////////////////////////////////////; 5001/// Allows to copy this file to the dst URL. Returns kTRUE in case of success,; 5002/// kFALSE otherwise.; 5003 ; 5004Bool_t TFile::Cp(const char *dst, Bool_t progressbar, UInt_t buffersize); 5005{; 5006 Bool_t rmdestiferror = kFALSE;; 5007 TStopwatch watch;; 5008 Bool_t success = kFALSE;; 5009 ; 5010 TUrl dURL(dst, kTRUE);; 5011 ; 5012 TString oopt = ""RECREATE"";; 5013 TString ourl = dURL.GetUrl();; 5014 ; 5015 // Files will be open in RAW mode; 5016 TString raw = ""filetype=raw"";; 5017 ; 5018 // Set optimization options for the destination file; 5019 TString opt = dURL.GetOptions();; 5020 if (opt != """") opt += ""&"";; 5021 opt += raw;; 5022 ; 5023 // AliEn files need to know where the source file is; 5024 if (!strcmp(dURL.GetProtocol(), ""alien"")); 5025 opt += TString::Format(""&source=%s"", GetName());; 5026 ; 5027 dURL.SetOptions(opt);; 5028 ; 5029 char *copybuffer = nullptr;; 5030 ; 5031 TFile *sfile = this;; 5032 TFile *dfile = nullptr;; 5033 ; 5034 // ""RECREATE"" does not work always well with XROOTD; 5035 // namely when some pieces of the path are missing;; 5036 // we force ""NEW"" in such a case; 5037 if (TFile::GetType(ourl, """") == TFile::kNet) {; 5038 if (gSystem->AccessPathName(ourl)) {; 5039 oopt = ""NEW"";; 5040 // Force creation of the missing parts of the path; 5041 opt += ""&mkpath=1"";; 5042 dURL.SetOptions(opt);; 5043 }; 5044 }; 5045 ; 5046 // Open destination file; 5047 if (!(dfile = TFile::Open(dURL.GetUrl(), oopt))) {; 5048 ::Error(""TFile::Cp"", ""cannot",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:186935,Performance,optimiz,optimization,186935,"eop) {; 5103 ::Error(""TFile::Cp"", ""cannot write %lld bytes to destination file %s"", read, dst);; 5104 goto copyout;; 5105 }; 5106 totalread += read;; 5107 } while (read == (Long64_t)buffersize);; 5108 ; 5109 if (progressbar) {; 5110 CpProgress(totalread, filesize,watch);; 5111 fprintf(stderr, ""\n"");; 5112 }; 5113 ; 5114 success = kTRUE;; 5115 ; 5116copyout:; 5117 if (dfile) dfile->Close();; 5118 ; 5119 if (dfile) delete dfile;; 5120 if (copybuffer) delete[] copybuffer;; 5121 ; 5122 if (rmdestiferror && (success != kTRUE)); 5123 gSystem->Unlink(dst);; 5124 ; 5125 watch.Stop();; 5126 watch.Reset();; 5127 ; 5128 return success;; 5129}; 5130 ; 5131////////////////////////////////////////////////////////////////////////////////; 5132/// Allows to copy file from src to dst URL. Returns kTRUE in case of success,; 5133/// kFALSE otherwise.; 5134 ; 5135Bool_t TFile::Cp(const char *src, const char *dst, Bool_t progressbar,; 5136 UInt_t buffersize); 5137{; 5138 TUrl sURL(src, kTRUE);; 5139 ; 5140 // Files will be open in RAW mode; 5141 TString raw = ""filetype=raw"";; 5142 ; 5143 // Set optimization options for the source file; 5144 TString opt = sURL.GetOptions();; 5145 if (opt != """") opt += ""&"";; 5146 opt += raw;; 5147 // Netx-related options:; 5148 // cachesz = 4*buffersize -> 4 buffers as peak mem usage; 5149 // readaheadsz = 2*buffersize -> Keep at max 4*buffersize bytes outstanding when reading; 5150 // rmpolicy = 1 -> Remove from the cache the blk with the least offset; 5151 opt += TString::Format(""&cachesz=%d&readaheadsz=%d&rmpolicy=1"", 4*buffersize, 2*buffersize);; 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:187106,Performance,cache,cachesz,187106,"dfile->Close();; 5118 ; 5119 if (dfile) delete dfile;; 5120 if (copybuffer) delete[] copybuffer;; 5121 ; 5122 if (rmdestiferror && (success != kTRUE)); 5123 gSystem->Unlink(dst);; 5124 ; 5125 watch.Stop();; 5126 watch.Reset();; 5127 ; 5128 return success;; 5129}; 5130 ; 5131////////////////////////////////////////////////////////////////////////////////; 5132/// Allows to copy file from src to dst URL. Returns kTRUE in case of success,; 5133/// kFALSE otherwise.; 5134 ; 5135Bool_t TFile::Cp(const char *src, const char *dst, Bool_t progressbar,; 5136 UInt_t buffersize); 5137{; 5138 TUrl sURL(src, kTRUE);; 5139 ; 5140 // Files will be open in RAW mode; 5141 TString raw = ""filetype=raw"";; 5142 ; 5143 // Set optimization options for the source file; 5144 TString opt = sURL.GetOptions();; 5145 if (opt != """") opt += ""&"";; 5146 opt += raw;; 5147 // Netx-related options:; 5148 // cachesz = 4*buffersize -> 4 buffers as peak mem usage; 5149 // readaheadsz = 2*buffersize -> Keep at max 4*buffersize bytes outstanding when reading; 5150 // rmpolicy = 1 -> Remove from the cache the blk with the least offset; 5151 opt += TString::Format(""&cachesz=%d&readaheadsz=%d&rmpolicy=1"", 4*buffersize, 2*buffersize);; 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:187296,Performance,cache,cache,187296,"dfile->Close();; 5118 ; 5119 if (dfile) delete dfile;; 5120 if (copybuffer) delete[] copybuffer;; 5121 ; 5122 if (rmdestiferror && (success != kTRUE)); 5123 gSystem->Unlink(dst);; 5124 ; 5125 watch.Stop();; 5126 watch.Reset();; 5127 ; 5128 return success;; 5129}; 5130 ; 5131////////////////////////////////////////////////////////////////////////////////; 5132/// Allows to copy file from src to dst URL. Returns kTRUE in case of success,; 5133/// kFALSE otherwise.; 5134 ; 5135Bool_t TFile::Cp(const char *src, const char *dst, Bool_t progressbar,; 5136 UInt_t buffersize); 5137{; 5138 TUrl sURL(src, kTRUE);; 5139 ; 5140 // Files will be open in RAW mode; 5141 TString raw = ""filetype=raw"";; 5142 ; 5143 // Set optimization options for the source file; 5144 TString opt = sURL.GetOptions();; 5145 if (opt != """") opt += ""&"";; 5146 opt += raw;; 5147 // Netx-related options:; 5148 // cachesz = 4*buffersize -> 4 buffers as peak mem usage; 5149 // readaheadsz = 2*buffersize -> Keep at max 4*buffersize bytes outstanding when reading; 5150 // rmpolicy = 1 -> Remove from the cache the blk with the least offset; 5151 opt += TString::Format(""&cachesz=%d&readaheadsz=%d&rmpolicy=1"", 4*buffersize, 2*buffersize);; 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:187363,Performance,cache,cachesz,187363,"dfile->Close();; 5118 ; 5119 if (dfile) delete dfile;; 5120 if (copybuffer) delete[] copybuffer;; 5121 ; 5122 if (rmdestiferror && (success != kTRUE)); 5123 gSystem->Unlink(dst);; 5124 ; 5125 watch.Stop();; 5126 watch.Reset();; 5127 ; 5128 return success;; 5129}; 5130 ; 5131////////////////////////////////////////////////////////////////////////////////; 5132/// Allows to copy file from src to dst URL. Returns kTRUE in case of success,; 5133/// kFALSE otherwise.; 5134 ; 5135Bool_t TFile::Cp(const char *src, const char *dst, Bool_t progressbar,; 5136 UInt_t buffersize); 5137{; 5138 TUrl sURL(src, kTRUE);; 5139 ; 5140 // Files will be open in RAW mode; 5141 TString raw = ""filetype=raw"";; 5142 ; 5143 // Set optimization options for the source file; 5144 TString opt = sURL.GetOptions();; 5145 if (opt != """") opt += ""&"";; 5146 opt += raw;; 5147 // Netx-related options:; 5148 // cachesz = 4*buffersize -> 4 buffers as peak mem usage; 5149 // readaheadsz = 2*buffersize -> Keep at max 4*buffersize bytes outstanding when reading; 5150 // rmpolicy = 1 -> Remove from the cache the blk with the least offset; 5151 opt += TString::Format(""&cachesz=%d&readaheadsz=%d&rmpolicy=1"", 4*buffersize, 2*buffersize);; 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188072,Performance,perform,performance,188072,"-> Keep at max 4*buffersize bytes outstanding when reading; 5150 // rmpolicy = 1 -> Remove from the cache the blk with the least offset; 5151 opt += TString::Format(""&cachesz=%d&readaheadsz=%d&rmpolicy=1"", 4*buffersize, 2*buffersize);; 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188102,Performance,optimiz,optimized,188102,"-> Keep at max 4*buffersize bytes outstanding when reading; 5150 // rmpolicy = 1 -> Remove from the cache the blk with the least offset; 5151 opt += TString::Format(""&cachesz=%d&readaheadsz=%d&rmpolicy=1"", 4*buffersize, 2*buffersize);; 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188450,Performance,load,loading,188450," 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188494,Performance,cache,cache,188494," 5152 sURL.SetOptions(opt);; 5153 ; 5154 TFile *sfile = nullptr;; 5155 ; 5156 Bool_t success = kFALSE;; 5157 ; 5158 // Open source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:189725,Performance,cache,cache,189725,"s()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217////////////////////////////////////////////////////////////////////////////////; 5218/// Max number of bytes to prefetch.; 5219///; 5220/// By default this is 75% of the; 5221/// read cache size. But specific TFile implementations may need to change it; 5222 ; 5223Int_t TFile::GetBytesToPrefetch() const; 5224{; 5225 TFileCacheRead *cr = nullptr;; 5226 if ((cr = GetCacheRead())) {; 5227 Int_t bytes = cr->GetBufferSize() / 4 * 3;; 5228 return ((bytes < 0) ? 0 : bytes);; 5229 }; 5230 return 0;; 5231}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; Compression.h; RConcurrentHashColl.hxx; RConfig.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a squ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:202731,Performance,load,load,202731,"lass::HasInterpreterInfoBool_t HasInterpreterInfo() constDefinition TClass.h:410; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:208141,Performance,cache,cache,208141,"ely.Definition TDirectoryFile.cxx:1684; TDirectoryFile::fKeysTList * fKeysPointer to keys list in memory.Definition TDirectoryFile.h:46; TDirectoryFile::lsvoid ls(Option_t *option="""") const overrideList Directory contents.Definition TDirectoryFile.cxx:1171; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::GetListvirtual TList * GetList() constDefinition TDirectory.h:222; TDirectory::SetNamevoid SetName(const char *newname) overrideSet the name for directory If the directory name is changed after the directory was written once,...Definition TDirectory.cxx:1287; TDirectory::fUUIDTUUID fUUIDDefinition TDirectory.h:143; TDirectory::fListTList * fListDefinition TDirectory.h:142; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWri",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:208844,Performance,cache,cache,208844,"after the directory was written once,...Definition TDirectory.cxx:1287; TDirectory::fUUIDTUUID fUUIDDefinition TDirectory.h:143; TDirectory::fListTList * fListDefinition TDirectory.h:142; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definiti",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:208940,Performance,cache,cache,208940,"st * fListDefinition TDirectory.h:142; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:209243,Performance,cache,cache,209243,"acheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::GetCompr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:209300,Performance,cache,cache,209300,"acheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::GetCompr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:210604,Performance,cache,cache,210604,"he write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::GetCompressInt_t GetCompress() constDefinition TFile.h:380; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::fgBytesReadstatic std::atomic< Long64_t > fgBytesReadNumber of bytes read by all TFile objects.Definition TFile.h:131; TFile::fReadCallsInt_t fReadCallsNumber of read calls ( not counting the cache calls )Definition TFile.h:89; TFile::SetFileBytesWrittenstatic void SetFileBytesWritten(Long64_t bytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCach",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:211683,Performance,cache,cache,211683,"ile.h:89; TFile::SetFileBytesWrittenstatic void SetFileBytesWritten(Long64_t bytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadSt",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:212367,Performance,cache,cache,212367,"eg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:212397,Performance,cache,cached,212397,"eg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:212508,Performance,cache,cached,212508,"FileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction actio",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:213443,Performance,cache,cache,213443,"oCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; TFile::kStartBigFile@ kStartBigFileDefinition TFile.h:200; TFile::SetReadStreamerInfostatic void SetReadStreamerInfo(Bool_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefinition TFile.h:103; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)D",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:213531,Performance,cache,cache,213531,"oCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; TFile::kStartBigFile@ kStartBigFileDefinition TFile.h:200; TFile::SetReadStreamerInfostatic void SetReadStreamerInfo(Bool_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefinition TFile.h:103; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)D",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:215189,Performance,cache,cache,215189,"ol_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefinition TFile.h:103; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)Definition TFile.cxx:4608; TFile::fSeekInfoLong64_t fSeekInfoLocation on disk of StreamerInfo record.Definition TFile.h:81; TFile::Paintvoid Paint(Option_t *option="""") overridePaint all objects in the file.Definition TFile.cxx:1698; TFile::GetBestBufferInt_t GetBestBuffer() constReturn the best buffer size of objects on this file.Definition TFile.cxx:1183; TFile::fOpenPhasesTList * fOpenPhases!Time info about open phasesDefinition TFile.h:113; TFile::SetCompressionLevelvirtual void SetCompressionLevel(Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin)See comments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::Streamervoid Streamer(TBuffer &) overrideStream a TFile object.Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Return",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:216825,Performance,cache,cache,216825,"ile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::Streamervoid Streamer(TBuffer &) overrideStream a TFile object.Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:217101,Performance,cache,cache,217101,"Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:217999,Performance,cache,cache,217999,"l files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::kEternalTimeout@ kEternalTimeoutDefinition TFile.h:67; TFile::fNbytesInfoInt_t fNbytesInfoNumber of bytes for StreamerInfo record.Definition TFi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:220460,Performance,cache,cache,220460," TFile::GetBytesReadvirtual Long64_t GetBytesRead() constDefinition TFile.h:241; TFile::GetErrnovirtual Int_t GetErrno() constMethod returning errno.Definition TFile.cxx:1246; TFile::SetCompressionSettingsvirtual void SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Used to specify the compression level and algorithm.Definition TFile.cxx:2338; TFile::fgReadInfostatic Bool_t fgReadInfoif true (default) ReadStreamerInfo is called when opening a fileDefinition TFile.h:135; TFile::Initvirtual void Init(Bool_t create)Initialize a TFile object.Definition TFile.cxx:613; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TFile.h:64; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:220493,Performance,cache,cache,220493," TFile::GetBytesReadvirtual Long64_t GetBytesRead() constDefinition TFile.h:241; TFile::GetErrnovirtual Int_t GetErrno() constMethod returning errno.Definition TFile.cxx:1246; TFile::SetCompressionSettingsvirtual void SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Used to specify the compression level and algorithm.Definition TFile.cxx:2338; TFile::fgReadInfostatic Bool_t fgReadInfoif true (default) ReadStreamerInfo is called when opening a fileDefinition TFile.h:135; TFile::Initvirtual void Init(Bool_t create)Initialize a TFile object.Definition TFile.cxx:613; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TFile.h:64; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The cla",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:220951,Performance,cache,cache,220951,"rInfo is called when opening a fileDefinition TFile.h:135; TFile::Initvirtual void Init(Bool_t create)Initialize a TFile object.Definition TFile.cxx:613; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TFile.h:64; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::GetBytesWrittenvirtual Long64_t GetBytesWritten() constReturn the total number of bytes written so far to the file.Definition TFile.cxx:4566; TFile::ERelativeToERelativeToDefinition TFile.h:199; TFile::kCur@ kCurDefinition TFile.h:199; TFile::kBeg@ kBegDefinition TFile.h:199; TFile::kEnd@ kEndDefinition TFile.h:199; TFile::fCompressInt_t fCompressCompression level and algorithm.Definition TFil",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:222842,Performance,cache,cache,222842," TFile.h:199; TFile::fCompressInt_t fCompressCompression level and algorithm.Definition TFile.h:84; TFile::CurrentFilestatic TFile *& CurrentFile()Return the current ROOT file if any.Definition TFile.cxx:1067; TFile::SetCompressionAlgorithmvirtual void SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)See comments for function SetCompressionSettings.Definition TFile.cxx:2305; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::fNbytesFreeInt_t fNbytesFreeNumber of bytes for free segments structure.Definition TFile.h:85; TFile::fDInt_t fDFile descriptor.Definition TFile.h:82; TFile::Class_Versionstatic constexpr Version_t Class_Version()Definition TFile.h:344; TFile::ResetErrnovirtual void ResetErrno() constMethod resetting the errno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::EFileTypeEFileTypeFile type.Definition TFile.h:202; TFile",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:223129,Performance,cache,cache,223129,"OOT::RCompressionSetting::EAlgorithm::kUseGlobal)See comments for function SetCompressionSettings.Definition TFile.cxx:2305; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::fNbytesFreeInt_t fNbytesFreeNumber of bytes for free segments structure.Definition TFile.h:85; TFile::fDInt_t fDFile descriptor.Definition TFile.h:82; TFile::Class_Versionstatic constexpr Version_t Class_Version()Definition TFile.h:344; TFile::ResetErrnovirtual void ResetErrno() constMethod resetting the errno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::EFileTypeEFileTypeFile type.Definition TFile.h:202; TFile::kWeb@ kWebDefinition TFile.h:202; TFile::kDefault@ kDefaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:226544,Performance,cache,cache,226544,"tesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw map of objects in this file.Definition TFile.cxx:1128; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::fCacheWriteTFileCacheWrite * fCacheWrite!Pointer to the write cache (if any)Definition TFile.h:100; TFile::fRealNameTString fRealNameEffective real file name (not original url)Definition TFile.h:90; TFile::SetOffsetvirtual void SetOffset(Long64_t offset, ERelativeTo pos=kBeg)Set position from where to start reading.Definition TFile.cxx:2253; TFile::fOffsetLong64_t fOffset!Seek offset cacheDefinition TFile.h:96; TFile::fgBytesWritestatic std::atomic< Long64_t > fgBytesWriteNumber of bytes written by all TFile objects.Definition TFile.h:130; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' fo",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:226869,Performance,cache,cacheDefinition,226869,"e segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw map of objects in this file.Definition TFile.cxx:1128; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::fCacheWriteTFileCacheWrite * fCacheWrite!Pointer to the write cache (if any)Definition TFile.h:100; TFile::fRealNameTString fRealNameEffective real file name (not original url)Definition TFile.h:90; TFile::SetOffsetvirtual void SetOffset(Long64_t offset, ERelativeTo pos=kBeg)Set position from where to start reading.Definition TFile.cxx:2253; TFile::fOffsetLong64_t fOffset!Seek offset cacheDefinition TFile.h:96; TFile::fgBytesWritestatic std::atomic< Long64_t > fgBytesWriteNumber of bytes written by all TFile objects.Definition TFile.h:130; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TF",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:227937,Performance,cache,cacheDir,227937,"r of bytes written by all TFile objects.Definition TFile.h:130; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Drawvoid Draw(Option_t *option="""") overrideFill Graphics Structure and Paint.Definition TFile.cxx:1111; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:228052,Performance,cache,cache,228052,"r of bytes written by all TFile objects.Definition TFile.h:130; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Drawvoid Draw(Option_t *option="""") overrideFill Graphics Structure and Paint.Definition TFile.cxx:1111; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:230159,Performance,cache,cache,230159,"dCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetF",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:231274,Performance,cache,cache,231274,"nt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFreeService class for TFile.Definition TFree.h:27; TFree::GetLastLong64_t GetLast() constDefinition TFree.h:41; TFree::SizeofInt_t Sizeof() constreturn number of bytes occupied by this TFree on permanent storageDefinition TFree.cxx:184; TFree::ReadBuffervirtual void ReadBuffer(char *&buffer)Decode one free structure from input buffer.Definition TFree.cxx:167; TFree::GetFirstLong64_t GetFirst() constDefinition TFree.h:40; TFree::FillBuffervirtual void FillBuffer(char *&buffer)Encode fre structure into output buffer.Definition TFree.cxx:109; TFree::AddFreeTFree * AddFree(TList *lfree, Long64_t first, Long64_t last)Add a new free segment to the list of free segments.Definition TFree.cxx:67; TGlobalMappedFunction::MakeFunctorstatic void ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:243329,Performance,load,load,243329,"h:81; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::GetClassVersionInt_t GetClassVersion() const overrideDefinition TStreamerInfo.h:161; TStreamerInfo::GenerateHeaderFileInt_t GenerateHeaderFile(const char *dirname, const TList *subClasses=nullptr, const TList *extrainfos=nullptr) overrideGenerate header file for the class described by this TStreamerInfo the function is called by TFile::M...Definition TStreamerInfo.cxx:4007; TStreamerInfo::GetNumberInt_t GetNumber() const overrideDefinition TStreamerInfo.h:175; TStreamerInfo::IsATClass * IsA() const overrideDefinition TStreamerInfo.h:254; TStreamerInfo::GetClassTClass * GetClass() const overrideDefinition TStreamerInfo.h:158; TStreamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if built and consistent with the class dictionary.Definition TStreamerInfo.cxx:729; TStreamerInfo::Classstatic TClass * Class(); TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Clearvoid Clear()Clear string without changing its capacity.Definition TString.cxx:1235; TString::Dataconst char * Data() constDefinition TString.h:376; TString::",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:250434,Performance,load,loaded,250434,"ath)Change directory.Definition TSystem.cxx:862; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Definition TSystem.cxx:4021; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TUUIDThis class defines a UUID (Universally Unique",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:251173,Performance,optimiz,optimization,251173,"n TSystem.cxx:437; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::GetFlagsOptvirtual const char * GetFlagsOpt() constReturn the optimization flags.Definition TSystem.cxx:3935; TTimeStampThe TTimeStamp encapsulates seconds and ns since EPOCH.Definition TTimeStamp.h:45; TUUIDThis class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDent...Definition TUUID.h:42; TUUID::ReadBuffervoid ReadBuffer(char *&buffer)Stream UUID from input buffer.Definition TUUID.cxx:291; TUUID::FillBuffervoid FillBuffer(char *&buffer)Stream UUID into output buffer.Definition TUUID.cxx:275; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; TUrl::GetAnchorconst char * GetAnchor() constDefinition TUrl.h:70; TUrl::GetUrlconst char * GetUrl(Bool_t withDeflt=kFALSE) constReturn full URL.Definition TUrl.cxx:390; TUrl::SetAnchorvoid SetAnchor(const char *anchor)Definition TUrl.h:86; TUrl::GetFileAndOptionsconst char * GetFileAndOptions() constReturn the file and its options (the string specified behind the ?).Definition TUrl.cxx:504; TUrl::GetFileconst char *",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:12468,Safety,detect,detect,12468,"ight use more memory.; 283/// (For the currently supported algorithms, the maximum level is 9); 284/// If compress is negative it indicates the compression level is not set yet.; 285/// The enumeration ROOT::RCompressionSetting::EAlgorithm associates each; 286/// algorithm with a number. There is a utility function to help; 287/// to set the value of compress. For example,; 288/// ROOT::CompressionSettings(ROOT::kLZMA, 1); 289/// will build an integer which will set the compression to use; 290/// the LZMA algorithm and compression level 1. These are defined; 291/// in the header file <em>Compression.h</em>.; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 32",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:13097,Safety,detect,detected,13097,"; 292/// Note that the compression settings may be changed at any time.; 293/// The new compression settings will only apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read co",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:13339,Safety,recover,recovery,13339,"In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating temporary filenames) a value can be passed to the reproducible; 335/// option to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:30079,Safety,recover,recovering,30079,"t)skeys;; 792 }; 793 if (versiondir > 1) fUUID.ReadBuffer(buffer);; 794 ; 795 //*-*---------read TKey::FillBuffer info; 796 buffer_keyloc += sizeof(Int_t); // Skip NBytes;; 797 Version_t keyversion;; 798 frombuf(buffer_keyloc, &keyversion);; 799 // Skip ObjLen, DateTime, KeyLen, Cycle, SeekKey, SeekPdir; 800 if (keyversion > 1000) {; 801 // Large files; 802 buffer_keyloc += 2*sizeof(Int_t)+2*sizeof(Short_t)+2*sizeof(Long64_t);; 803 } else {; 804 buffer_keyloc += 2*sizeof(Int_t)+2*sizeof(Short_t)+2*sizeof(Int_t);; 805 }; 806 TString cname;; 807 cname.ReadBuffer(buffer_keyloc);; 808 cname.ReadBuffer(buffer_keyloc); // fName.ReadBuffer(buffer); file may have been renamed; 809 fTitle.ReadBuffer(buffer_keyloc);; 810 delete [] header;; 811 if (fNbytesName < 10 || fNbytesName > 10000) {; 812 Error(""Init"",""cannot read directory info of file %s"", GetName());; 813 goto zombie;; 814 }; 815 ; 816 //*-* -------------Check if file is truncated; 817 Long64_t size;; 818 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 819 Error(""Init"", ""cannot stat the file %s"", GetName());; 820 goto zombie;; 821 }; 822 ; 823 //*-* -------------Check if, in case of inconsistencies, we are requested to; 824 //*-* -------------attempt recovering the file; 825 Bool_t tryrecover = (gEnv->GetValue(""TFile.Recover"", 1) == 1) ? kTRUE : kFALSE;; 826 ; 827 //*-* -------------Check if we need to enable forward compatible with version; 828 //*-* -------------prior to v6.30; 829 if (gEnv->GetValue(""TFile.v630forwardCompatibility"", 0) == 1); 830 SetBit(k630forwardCompatibility);; 831 ; 832 //*-* -------------Read keys of the top directory; 833 if (fSeekKeys > fBEGIN && fEND <= size) {; 834 //normal case. Recover only if file has no keys; 835 TDirectoryFile::ReadKeys(kFALSE);; 836 gDirectory = this;; 837 if (!GetNkeys()) {; 838 if (tryrecover) {; 839 Recover(); // NOLINT: silence clang-tidy warnings; 840 } else {; 841 Error(""Init"", ""file %s has no keys"", GetName());; 842 goto zombie;; 843 }",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31155,Safety,recover,recover,31155,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31299,Safety,recover,recover,31299,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31578,Safety,recover,recover,31578,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31833,Safety,recover,recovered,31833,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:31906,Safety,recover,recovered,31906,"open by another process and nothing written to the file yet; 847 Warning(""Init"",""file %s has no keys"", GetName());; 848 gDirectory = this;; 849 } else {; 850 //something had been written to the file. Trailer is missing, must recover; 851 if (fEND > size) {; 852 if (tryrecover) {; 853 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld, ""; 854 ""trying to recover"", GetName(), size, fEND);; 855 } else {; 856 Error(""Init"",""file %s is truncated at %lld bytes: should be %lld"",; 857 GetName(), size, fEND);; 858 goto zombie;; 859 }; 860 } else {; 861 if (tryrecover) {; 862 Warning(""Init"",""file %s probably not closed, ""; 863 ""trying to recover"", GetName());; 864 } else {; 865 Warning(""Init"",""file %s probably not closed"", GetName());; 866 goto zombie;; 867 }; 868 }; 869 Int_t nrecov = Recover(); // NOLINT: silence clang-tidy warnings; 870 if (nrecov) {; 871 Warning(""Init"", ""successfully recovered %d keys"", nrecov);; 872 } else {; 873 Warning(""Init"", ""no keys recovered, file has been made a Zombie"");; 874 goto zombie;; 875 }; 876 }; 877 }; 878 ; 879 if (fGlobalRegistration) {; 880 R__LOCKGUARD(gROOTMutex);; 881 gROOT->GetListOfFiles()->Add(this);; 882 gROOT->GetUUIDs()->AddUUID(fUUID, this);; 883 }; 884 ; 885 // Create StreamerInfo index; 886 {; 887 Int_t lenIndex = gROOT->GetListOfStreamerInfo()->GetSize()+1;; 888 if (lenIndex < 5000) lenIndex = 5000;; 889 fClassIndex = new TArrayC(lenIndex);; 890 if (fgReadInfo) {; 891 if (fSeekInfo > fBEGIN) {; 892 ReadStreamerInfo(); // NOLINT: silence clang-tidy warnings; 893 if (IsZombie()) {; 894 R__LOCKGUARD(gROOTMutex);; 895 gROOT->GetListOfFiles()->Remove(this);; 896 goto zombie;; 897 }; 898 } else if (fVersion != gROOT->GetVersionInt() && fVersion > 30000) {; 899 // Don't complain about missing streamer info for empty files.; 900 if (fKeys->GetSize()) {; 901 // #14068: we take into account the different way of expressing the version; 902 const auto separator = fVersion < 63200 ? ""/"" : ""."";; 903 const auto thisVersion = ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:59617,Safety,avoid,avoid,59617,"08 if (!nbytes) {; 1609 Printf(""Address = %lld\tNbytes = %d\t=====E R R O R======="", idcur, nbytes);; 1610 date = 0; time = 0;; 1611 break;; 1612 }; 1613 if (nbytes < 0) {; 1614 Printf(""Address = %lld\tNbytes = %d\t=====G A P==========="", idcur, nbytes);; 1615 idcur -= nbytes;; 1616 Seek(idcur);; 1617 continue;; 1618 }; 1619 Version_t versionkey;; 1620 frombuf(buffer, &versionkey);; 1621 frombuf(buffer, &objlen);; 1622 frombuf(buffer, &datime);; 1623 frombuf(buffer, &keylen);; 1624 frombuf(buffer, &cycle);; 1625 if (versionkey > 1000) {; 1626 frombuf(buffer, &seekkey);; 1627 frombuf(buffer, &seekpdir);; 1628 } else {; 1629 Int_t skey,sdir;; 1630 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 1631 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 1632 }; 1633 frombuf(buffer, &nwhc);; 1634 if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1635 nwhc = nwheader - (buffer-header);; 1636 for (int i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 1637 classname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1638 if (idcur == fSeekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:60287,Safety,avoid,avoid,60287,", &skey); seekkey = (Long64_t)skey;; 1631 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 1632 }; 1633 frombuf(buffer, &nwhc);; 1634 if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1635 nwhc = nwheader - (buffer-header);; 1636 for (int i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 1637 classname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1638 if (idcur == fSeekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1662 nwhc = nwheader - (buffer-header);; 1663 }; 1664 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keytitle[i]);; 1665 keytitle[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1666 ; 1667 extrainfo.Form("" name: %-16s title: %s"", keyname, keytitle);; 1668 }; 1669 ; 1670 TDatime::GetDateTime(datime, date, time);; 1671 if (!forComp) {; 1672 if (objlen != nbytes - keylen) {; 1673 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1674 Printf(""%d/%06d At:%-*lld N=%-8d %-14s CX = %5.2f %s"", date, time, nDigits + 1, idcur, nbytes, classname,; 1675 cx, extrainfo.Data());; 1676 } else {; 1677 Printf(""%d/%06d At:%-*lld N=%-8d %-14",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:60734,Safety,avoid,avoid,60734,"ekFree) strlcpy(classname,""FreeSegments"",512);; 1639 if (idcur == fSeekInfo) strlcpy(classname,""StreamerInfo"",512);; 1640 if (idcur == fSeekKeys) strlcpy(classname,""KeysList"",512);; 1641 ; 1642 if (extended) {; 1643 if ( (buffer-header) >= nwheader ); 1644 nwhc = 0;; 1645 else {; 1646 frombuf(buffer, &nwhc);; 1647 if (nwhc < 0); 1648 nwhc = 0;; 1649 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1650 nwhc = nwheader - (buffer-header);; 1651 }; 1652 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keyname[i]);; 1653 keyname[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1654 ; 1655 if ( (buffer-header) >= nwheader ); 1656 nwhc = 0;; 1657 else {; 1658 frombuf(buffer, &nwhc);; 1659 if (nwhc < 0); 1660 nwhc = 0;; 1661 else if ( ((buffer-header) + nwhc) > nwheader ) // Don't read past the end of the part of the key we have read.; 1662 nwhc = nwheader - (buffer-header);; 1663 }; 1664 for (int i = 0;i < nwhc; i++) frombuf(buffer, &keytitle[i]);; 1665 keytitle[(int)nwhc] = '\0'; //cast to avoid warning with gcc3.4; 1666 ; 1667 extrainfo.Form("" name: %-16s title: %s"", keyname, keytitle);; 1668 }; 1669 ; 1670 TDatime::GetDateTime(datime, date, time);; 1671 if (!forComp) {; 1672 if (objlen != nbytes - keylen) {; 1673 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1674 Printf(""%d/%06d At:%-*lld N=%-8d %-14s CX = %5.2f %s"", date, time, nDigits + 1, idcur, nbytes, classname,; 1675 cx, extrainfo.Data());; 1676 } else {; 1677 Printf(""%d/%06d At:%-*lld N=%-8d %-14s %s"", date, time, nDigits + 1, idcur, nbytes, classname, extrainfo.Data());; 1678 }; 1679 } else {; 1680 // Printing to help compare two files.; 1681 if (objlen != nbytes - keylen) {; 1682 Float_t cx = Float_t(objlen + keylen) / Float_t(nbytes);; 1683 Printf(""At:%-*lld N=%-8d K=%-3d O=%-8d %-14s CX = %5.2f %s"", nDigits+1, idcur, nbytes, keylen, objlen, classname, cx, extrainfo.Data());; 1684 } else {; 1685 Printf(""At:%-*lld N=%-8d K=%-3d O=%",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:71659,Safety,recover,recover,71659," 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)pids->UncheckedAt(pidf);; 1957 if (pid) {; 1958 pid->CheckInit();; 1959 return pid;; 1960 }; 1961 ; 1962 //check if fProcessIDs[uid] is set in file; 1963 //if not set, read the process uid from file; 1964 char pidname[32];; 1965 snprintf(pidname,32,""ProcessID%d"",pidf);; 1966 pid = (TProcessID *)Get(pidname);; 1967 if (gDebug > 0) {; 1968 printf(""ReadProcessID, name=%s, file=%s, pid=%zx\n"",pidname,GetName(),(size_t)pid);; 1969 }; 1970 if (!pid) {; 1971 //file->Error(""ReadProcessID"",""Cannot find %s in file %s"",pidname,file->GetName());; 1972 return pid;; 1973 }; 1974 ; 1975 //check that a similar pid is not already registered in fgPIDs; 1976 TObjArray *pidslist = TProcessID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:71769,Safety,recover,recovered,71769," 1949///; 1950/// If the object is not already entered in the gROOT list, it is added.; 1951 ; 1952TProcessID *TFile::ReadProcessID(UShort_t pidf); 1953{; 1954 TProcessID *pid = nullptr;; 1955 TObjArray *pids = GetListOfProcessIDs();; 1956 if (pidf < pids->GetSize()) pid = (TProcessID *)pids->UncheckedAt(pidf);; 1957 if (pid) {; 1958 pid->CheckInit();; 1959 return pid;; 1960 }; 1961 ; 1962 //check if fProcessIDs[uid] is set in file; 1963 //if not set, read the process uid from file; 1964 char pidname[32];; 1965 snprintf(pidname,32,""ProcessID%d"",pidf);; 1966 pid = (TProcessID *)Get(pidname);; 1967 if (gDebug > 0) {; 1968 printf(""ReadProcessID, name=%s, file=%s, pid=%zx\n"",pidname,GetName(),(size_t)pid);; 1969 }; 1970 if (!pid) {; 1971 //file->Error(""ReadProcessID"",""Cannot find %s in file %s"",pidname,file->GetName());; 1972 return pid;; 1973 }; 1974 ; 1975 //check that a similar pid is not already registered in fgPIDs; 1976 TObjArray *pidslist = TProcessID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// th",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:71807,Safety,recover,recovered,71807,"ID::GetPIDs();; 1977 TIter next(pidslist);; 1978 TProcessID *p;; 1979 bool found = false;; 1980 ; 1981 {; 1982 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 1983 while ((p = (TProcessID*)next())) {; 1984 if (!strcmp(p->GetTitle(),pid->GetTitle())) {; 1985 found = true;; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has be",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72095,Safety,recover,recover,72095,"; 1986 break;; 1987 }; 1988 }; 1989 }; 1990 ; 1991 if (found) {; 1992 delete pid;; 1993 pids->AddAtAndExpand(p,pidf);; 1994 p->IncrementCount();; 1995 return p;; 1996 }; 1997 ; 1998 pids->AddAtAndExpand(pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72265,Safety,recover,recovered,72265,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72307,Safety,safe,safely,72307,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72634,Safety,recover,recovered,72634,"///////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 20",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72745,Safety,recover,recovered,72745,"ber of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy war",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72835,Safety,recover,recovered,72835," automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:73028,Safety,recover,recovered,73028,"pen in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 207",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:73253,Safety,recover,recovery,73253,"been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy warnings; 2062 Error(""Recover"", ""cannot stat the file %s"", GetName());; 2063 return 0;; 2064 }; 2065 ; 2066 fEND = Long64_t(size);; 2067 ; 2068 if (fWritable && !fFree) fFree = new TList;; 2069 ; 2070 TKey *key;; 2071 Int_t nrecov = 0;; 2072 nwheader = 1024;; 2073 Int_t nread = nwheader;; 2074 ; 2075 while (idcur < fEND) {; 2076 Seek(idcur); // NOLINT: silence clang-tidy warnings; 2077 if (idcur+nread >= fEND) nread = fEND-idcur-1;; 2078 if (ReadBuffer(header, nread)) { // NOLINT: silence clang-tidy warnings; 2079 ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:76031,Safety,recover,recovered,76031,"fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffer, &versionkey);; 2099 frombuf(buffer, &objlen);; 2100 frombuf(buffer, &datime);; 2101 frombuf(buffer, &keylen);; 2102 frombuf(buffer, &cycle);; 2103 if (versionkey > 1000) {; 2104 frombuf(buffer, &seekkey);; 2105 frombuf(buffer, &seekpdir);; 2106 } else {; 2107 Int_t skey,sdir;; 2108 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 2109 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 2110 }; 2111 frombuf(buffer, &nwhc);; 2112 char *classname = nullptr;; 2113 if (nwhc <= 0 || nwhc > 100) break;; 2114 classname = new char[nwhc+1];; 2115 int i, nwhci = nwhc;; 2116 for (i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 2117 classname[nwhci] = '\0';; 2118 TDatime::GetDateTime(datime, date, time);; 2119 TClass *tclass = TClass::GetClass(classname);; 2120 if (seekpdir == fSeekDir && tclass && !tclass->InheritsFrom(TFile::Class()); 2121 && strcmp(classname,""TBasket"")) {; 2122 key = new TKey(this);; 2123 key->ReadKeyBuffer(bufread);; 2124 if (!strcmp(key->GetName(),""StreamerInfo"")) {; 2125 fSeekInfo = seekkey;; 2126 SafeDelete(fInfoCache);; 2127 fNbytesInfo = nbytes;; 2128 } else {; 2129 AppendKey(key);; 2130 nrecov++;; 2131 SetBit(kRecovered);; 2132 Info(""Recover"", ""%s, recovered key %s:%s at address %lld"",GetName(),key->GetClassName(),key->GetName(),idcur);; 2133 }; 2134 }; 2135 delete [] classname;; 2136 idcur += nbytes;; 2137 }; 2138 if (fWritable) {; 2139 Long64_t max_file_size = Long64_t(kStartBigFile);; 2140 if (max_file_size < fEND) max_file_size = fEND+1000000000;; 2141 TFree *last = (TFree*)fFree->Last();; 2142 if (last) {; 2143 last->AddFree(fFree,fEND,max_file_size);; 2144 } else {; 2145 new TFree(fFree,fEND,max_file_size);; 2146 }; 2147 if (nrecov) Write();; 2148 }; 2149 return nrecov;; 2150}; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Reopen a file with a different access mode.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:84140,Safety,safe,safe,84140,"r = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:85872,Safety,avoid,avoid,85872,"TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TBuffer &b); 2407{; 2408 if (b.IsReading()) {; 2409 b.ReadVersion(); //Version_t v = b.ReadVersion();; 2410 } else {; 2411 b.WriteVersion(TFile::IsA());; 2412 }; 2413}; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Increment statistics for buffer sizes of objects in this file.; 2417 ; 2418void TFile::SumBuffer(Int_t bufsize); 2419{; 2420 fWritten++;; 2421 fSumBuffer += double(bufsize);; 2422 fSum2Buffer += double(bufsize) * double(bufsize); // avoid reaching MAXINT for temporary; 2423}; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Write memory objects to this file.; 2427///; 2428/// Loop on all objects in memory (including subdirectories).; 2429/// A new key is created in the KEYS linked list for each object.; 2430/// The list of keys is then saved on the file (via WriteKeys); 2431/// as a single data record.; 2432/// For values of opt see TObject::Write().; 2433/// The directory header info is rewritten on the directory header record.; 2434/// The linked list of FREE segments is written.; 2435/// The file header is written (bytes 1->fBEGIN).; 2436 ; 2437Int_t TFile::Write(const char *, Int_t opt, Int_t bufsiz); 2438{; 2439 if (!IsWritable()) {; 2440 if (!TestBit(kWriteError)) {; 2441 // Do not print the warning if we already had a SysError.; 2442 Warning(""Write"", ""file %s not opened in write mode"", GetName());; 2443 }; 2444 return 0;; 2445 }; 2446 ; 2447 if (gDebug) {; 244",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:148769,Safety,timeout,timeout,148769,"/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:148831,Safety,timeout,timeout,148831,"/// will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; 4064/// etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; 4065/// for regular expressions that will be checked) and as last a local file will; 4066/// be tried.; 4067/// Before opening a file via TNetFile a check is made to see if the URL; 4068/// specifies a local file. If that is the case the file will be opened; 4069/// via a normal TFile. To force the opening of a local file via a; 4070/// TNetFile use either TNetFile directly or specify as host ""localhost"".; 4071/// The netopt argument is only used by TNetFile. For the meaning of the; 4072/// options and other arguments see the constructors of the individual; 4073/// file classes. In case of error, it returns a nullptr.; 4074///; 4075/// For TFile implementations supporting asynchronous file open, see; 4076/// TFile::AsyncOpen(...), it is possible to request a timeout with the; 4077/// option <b>`TIMEOUT=<secs>`</b>: the timeout must be specified in seconds and; 4078/// it will be internally checked with granularity of one millisec.; 4079/// For remote files there is the option: <b>CACHEREAD</b> opens an existing; 4080/// file for reading through the file cache. The file will be downloaded to; 4081/// the cache and opened from there. If the download fails, it will be opened remotely.; 4082/// The file will be downloaded to the directory specified by SetCacheFileDir().; 4083///; 4084/// *The caller is responsible for deleting the pointer.*; 4085/// In READ mode, a nullptr is returned if the file does not exist or cannot be opened.; 4086/// In CREATE mode, a nullptr is returned if the file already exists or cannot be created.; 4087/// In RECREATE mode, a nullptr is returned if the file can not be created.; 4088/// In UPDATE mode, a nullptr is returned if the file cannot be created or opened.; 4089 ; 4090TFile *TFile::Open(const char *url, Option_t *options, const char *ftitle,; 4091 Int_t compress, Int_t netopt); ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:150918,Safety,timeout,timeout,150918,"input; 4098 if (!url || strlen(url) <= 0) {; 4099 ::Error(""TFile::Open"", ""no url specified"");; 4100 return f;; 4101 }; 4102 ; 4103 TString expandedUrl(url);; 4104 gSystem->ExpandPathName(expandedUrl);; 4105 ; 4106#ifdef R__UNIX; 4107 // If URL is a file on an EOS FUSE mount, attempt redirection to XRootD protocol.; 4108 if (gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) == 1) {; 4109 TUrl fileurl(expandedUrl, /* default is file */ kTRUE);; 4110 if (strcmp(fileurl.GetProtocol(), ""file"") == 0) {; 4111 ssize_t len = getxattr(fileurl.GetFile(), ""eos.url.xroot"", nullptr, 0);; 4112 if (len > 0) {; 4113 std::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:151543,Safety,timeout,timeout,151543,"td::string xurl(len, 0);; 4114 if (getxattr(fileurl.GetFile(), ""eos.url.xroot"", &xurl[0], len) == len) {; 4115 if ((f = TFile::Open(xurl.c_str(), options, ftitle, compress, netopt))) {; 4116 if (!f->IsZombie()) {; 4117 return f;; 4118 } else {; 4119 delete f;; 4120 f = nullptr;; 4121 }; 4122 }; 4123 }; 4124 }; 4125 }; 4126 }; 4127#endif; 4128 ; 4129 // If a timeout has been specified extract the value and try to apply it (it requires; 4130 // support for asynchronous open, though; the following is completely transparent if; 4131 // such support if not available for the required protocol); 4132 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:152444,Safety,timeout,timeout,152444,"32 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t red",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:152596,Safety,timeout,timeout,152596,"32 TString opts(options);; 4133 Int_t ito = opts.Index(""TIMEOUT="");; 4134 if (ito != kNPOS) {; 4135 TString sto = opts(ito + strlen(""TIMEOUT=""), opts.Length());; 4136 while (!(sto.IsDigit()) && !(sto.IsNull())) { sto.Remove(sto.Length()-1,1); }; 4137 if (!(sto.IsNull())) {; 4138 // Timeout in millisecs; 4139 Int_t toms = sto.Atoi() * 1000;; 4140 if (gDebug > 0) ::Info(""TFile::Open"", ""timeout of %d millisec requested"", toms);; 4141 // Remove from the options field; 4142 sto.Insert(0, ""TIMEOUT="");; 4143 opts.ReplaceAll(sto, """");; 4144 // Asynchronous open; 4145 TFileOpenHandle *fh = TFile::AsyncOpen(expandedUrl, opts, ftitle, compress, netopt);; 4146 // Check the result in steps of 1 millisec; 4147 TFile::EAsyncOpenStatus aos = TFile::kAOSNotAsync;; 4148 aos = TFile::GetAsyncOpenStatus(fh);; 4149 Int_t xtms = toms;; 4150 while (aos == TFile::kAOSInProgress && xtms > 0) {; 4151 gSystem->Sleep(1);; 4152 xtms -= 1;; 4153 aos = TFile::GetAsyncOpenStatus(fh);; 4154 }; 4155 if (aos == TFile::kAOSNotAsync || aos == TFile::kAOSSuccess) {; 4156 // Do open the file now; 4157 f = TFile::Open(fh);; 4158 if (gDebug > 0) {; 4159 if (aos == TFile::kAOSSuccess); 4160 ::Info(""TFile::Open"", ""waited %d millisec for asynchronous open"", toms - xtms);; 4161 else; 4162 ::Info(""TFile::Open"", ""timeout option not supported (requires asynchronous""; 4163 "" open support)"");; 4164 }; 4165 } else {; 4166 if (xtms <= 0); 4167 ::Error(""TFile::Open"", ""timeout expired while opening '%s'"", expandedUrl.Data());; 4168 // Cleanup the request; 4169 SafeDelete(fh);; 4170 }; 4171 // Done; 4172 return f;; 4173 } else {; 4174 ::Warning(""TFile::Open"", ""incomplete 'TIMEOUT=' option specification - ignored"");; 4175 opts.ReplaceAll(""TIMEOUT="", """");; 4176 }; 4177 }; 4178 ; 4179 // We will use this from now on; 4180 const char *option = opts;; 4181 ; 4182 // Many URLs? Redirect output and print errors in case of global failure; 4183 TString namelist(expandedUrl);; 4184 Ssiz_t ip = namelist.Index(""|"");; 4185 Bool_t red",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:162723,Safety,avoid,avoid,162723,"w TList;; 4435 fgAsyncOpenRequests->Add(fh);; 4436 }; 4437 ; 4438 // We are done; 4439 return fh;; 4440}; 4441 ; 4442////////////////////////////////////////////////////////////////////////////////; 4443/// Waits for the completion of an asynchronous open request.; 4444///; 4445/// Returns the pointer to the associated TFile, transferring ownership of the; 4446/// handle to the TFile instance.; 4447 ; 4448TFile *TFile::Open(TFileOpenHandle *fh); 4449{; 4450 TFile *f = nullptr;; 4451 ; 4452 // Note that the request may have failed; 4453 if (fh && fgAsyncOpenRequests) {; 4454 // Remove it from the pending list: we need to do it at this level to avoid; 4455 // recursive calls in the standard TFile::Open; 4456 fgAsyncOpenRequests->Remove(fh);; 4457 // Was asynchronous open functionality implemented?; 4458 if ((f = fh->GetFile()) && !(f->IsZombie())) {; 4459 // Yes: wait for the completion of the open phase, if needed; 4460 Bool_t cr = (!strcmp(f->GetOption(),""CREATE"") ||; 4461 !strcmp(f->GetOption(),""RECREATE"") ||; 4462 !strcmp(f->GetOption(),""NEW"")) ? kTRUE : kFALSE;; 4463 f->Init(cr);; 4464 } else {; 4465 // No: process a standard open; 4466 f = TFile::Open(fh->GetName(), fh->GetOpt(), fh->GetTitle(),; 4467 fh->GetCompress(), fh->GetNetOpt());; 4468 }; 4469 ; 4470 // Adopt the handle instance in the TFile instance so that it gets; 4471 // automatically cleaned up; 4472 if (f) f->fAsyncHandle = fh;; 4473 }; 4474 ; 4475 // We are done; 4476 return f;; 4477}; 4478 ; 4479////////////////////////////////////////////////////////////////////////////////; 4480/// Interface to system open. All arguments like in POSIX open().; 4481 ; 4482Int_t TFile::SysOpen(const char *pathname, Int_t flags, UInt_t mode); 4483{; 4484#if defined(R__WINGCC); 4485 // ALWAYS use binary mode - even cygwin text should be in unix format; 4486 // although this is posix default it has to be set explicitly; 4487 return ::open(pathname, flags | O_BINARY, mode);; 4488#elif defined(R__SEEK64); 4489 return :",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:171936,Safety,safe,safety,171936,"81 if (!gSystem->GetPathInfo(cachetagfile, &id, &size, &flags, &modtime)) {; 4682 // check the time passed since last cache cleanup; 4683 Long_t lastcleanuptime = ((Long_t)time(0) - modtime);; 4684 if (lastcleanuptime < cleanupinterval) {; 4685 ::Info(""TFile::ShrinkCacheFileDir"", ""clean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173578,Safety,timeout,timeout,173578,") = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173617,Safety,timeout,timeout,173617,"cheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173680,Safety,timeout,timeout,173680,"c stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged;; 4758}; 4759 ; 4760////////////////////////////////////////////////////////////////////////////////; 4761/// Return kTRUE if 'url' matches the coordinates o",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173751,Safety,timeout,timeout,173751,"c stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged;; 4758}; 4759 ; 4760////////////////////////////////////////////////////////////////////////////////; 4761/// Return kTRUE if 'url' matches the coordinates o",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:173899,Safety,timeout,timeout,173899,"c stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732////////////////////////////////////////////////////////////////////////////////; 4733/// Returns open timeout (in ms).; 4734 ; 4735UInt_t TFile::GetOpenTimeout(); 4736{; 4737 return fgOpenTimeout;; 4738}; 4739 ; 4740////////////////////////////////////////////////////////////////////////////////; 4741/// Sets only staged flag. Returns previous value of flag.; 4742/// When true we check before opening the file if it is staged, if not,; 4743/// the open fails.; 4744 ; 4745Bool_t TFile::SetOnlyStaged(Bool_t onlystaged); 4746{; 4747 Bool_t f = fgOnlyStaged;; 4748 fgOnlyStaged = onlystaged;; 4749 return f;; 4750}; 4751 ; 4752////////////////////////////////////////////////////////////////////////////////; 4753/// Returns staged only flag.; 4754 ; 4755Bool_t TFile::GetOnlyStaged(); 4756{; 4757 return fgOnlyStaged;; 4758}; 4759 ; 4760////////////////////////////////////////////////////////////////////////////////; 4761/// Return kTRUE if 'url' matches the coordinates o",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:188529,Safety,avoid,avoid,188529,"n source file; 5159 if (!(sfile = TFile::Open(sURL.GetUrl(), ""READ""))) {; 5160 ::Error(""TFile::Cp"", ""cannot open source file %s"", src);; 5161 } else {; 5162 success = sfile->Cp(dst, progressbar, buffersize);; 5163 }; 5164 ; 5165 if (sfile) {; 5166 sfile->Close();; 5167 delete sfile;; 5168 }; 5169 ; 5170 return success;; 5171}; 5172 ; 5173//______________________________________________________________________________; 5174//The next statement is not active anymore on Linux.; 5175//Using posix_fadvise introduces a performance penalty (10 %) on optimized files; 5176//and in addition it destroys the information of TTreePerfStats; 5177#if defined(R__neverLINUX) && !defined(R__WINGCC); 5178Bool_t TFile::ReadBufferAsync(Long64_t offset, Int_t len); 5179{; 5180 // Read specified byte range asynchronously. Actually we tell the kernel; 5181 // which blocks we are going to read so it can start loading these blocks; 5182 // in the buffer cache.; 5183 ; 5184 // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; 5185 // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.; 5186 if (IsA() != TFile::Class()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217//////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199239,Safety,safe,safe,199239,"gWriterDefinition TVirtualMonitoring.h:116; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPerfStats.h; gPerfStats#define gPerfStatsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFil",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:202993,Safety,safe,safe,202993,"f the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatime::GetDateTimestatic void GetDateTime(UInt_t datetime, Int_t &date, Int_t &time)Static function that returns the date and time.Definition TDati",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:216146,Safety,timeout,timeout,216146,"CacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::Streamervoid Streamer(TBuffer &) overrideStream a TFile object.Definition TFile.cxx:2405; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:224881,Safety,timeout,timeout,224881,"efaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linke",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:224899,Safety,timeout,timeout,224899,"efaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linke",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:224938,Safety,timeout,timeout,224938,".h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual B",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:229202,Safety,recover,recover,229202,"mory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Drawvoid Draw(Option_t *option="""") overrideFill Graphics Structure and Paint.Definition TFile.cxx:1111; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::IsATClass * IsA() const overrideDefinition TFile.h:344; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:8470,Security,access,access,8470," : TDirectoryFile(), fCompress(ROOT::RCompressionSetting::EAlgorithm::kUseGlobal); 203{; 204 fCacheReadMap = new TMap();; 205 SetBit(kBinaryFile, kTRUE);; 206 ; 207 if (gDebug); 208 Info(""TFile"", ""default ctor"");; 209}; 210 ; 211////////////////////////////////////////////////////////////////////////////////; 212/// Opens or creates a local ROOT file.; 213///; 214/// \param[in] fname1 The name of the file; 215/// \param[in] option Specifies the mode in which the file is opened; 216/// \param[in] ftitle The title of the file; 217/// \param[in] compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:8946,Security,access,access,8946," compress Specifies the compression algorithm and level; 218///; 219/// It is recommended to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allo",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:9032,Security,access,access,9032,"nded to specify fname1 as ""<file>.root"". The suffix "".root""; 220/// will be used by object browsers to automatically identify the file as; 221/// a ROOT file. If the constructor fails in any way IsZombie() will; 222/// return true. Use IsOpen() to check if the file is (still) open.; 223/// To open non-local files use the static TFile::Open() method, that; 224/// will take care of opening the files using the correct remote file; 225/// access plugin.; 226///; 227/// Option | Description; 228/// -------|------------; 229/// NEW or CREATE | Create a new file and open it for writing, if the file already exists the file is not opened.; 230/// RECREATE | Create a new file, if the file already exists it will be overwritten.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The ti",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:9734,Security,access,access,9734,"written.; 231/// UPDATE | Open an existing file for writing. If no file exists, it is created.; 232/// READ | Open an existing file for reading (default).; 233/// NET | Used by derived remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The title of the file (ftitle) will be shown by the ROOT browsers.; 258/// A ROOT file (like a Unix file system) may contain objects and; 259/// directories. There are no restrictions for the number of levels; 260/// of directories.; 261/// A ROOT file is designed such that one can write in the file in pure; 262/// sequential mode (case of BATCH jobs). In this case, the file may be; 263/// read sequentially again without using the file index written; 264/// at the end of the file. In case of a job crash, all the information; 265/// on the file is therefore protected.; 266/// A ROOT file can be used interactively. In this case, one has the; 267/// possibility to delete existing objects and add new ones.; 268/// When",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:9927,Security,access,access,9927,"ed remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The title of the file (ftitle) will be shown by the ROOT browsers.; 258/// A ROOT file (like a Unix file system) may contain objects and; 259/// directories. There are no restrictions for the number of levels; 260/// of directories.; 261/// A ROOT file is designed such that one can write in the file in pure; 262/// sequential mode (case of BATCH jobs). In this case, the file may be; 263/// read sequentially again without using the file index written; 264/// at the end of the file. In case of a job crash, all the information; 265/// on the file is therefore protected.; 266/// A ROOT file can be used interactively. In this case, one has the; 267/// possibility to delete existing objects and add new ones.; 268/// When an object is deleted from the file, the freed space is added; 269/// into the FREE linked list (fFree). The FREE list consists of a chain; 270/// of consecutive free segments on the",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:9961,Security,access,access,9961,"ed remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The title of the file (ftitle) will be shown by the ROOT browsers.; 258/// A ROOT file (like a Unix file system) may contain objects and; 259/// directories. There are no restrictions for the number of levels; 260/// of directories.; 261/// A ROOT file is designed such that one can write in the file in pure; 262/// sequential mode (case of BATCH jobs). In this case, the file may be; 263/// read sequentially again without using the file index written; 264/// at the end of the file. In case of a job crash, all the information; 265/// on the file is therefore protected.; 266/// A ROOT file can be used interactively. In this case, one has the; 267/// possibility to delete existing objects and add new ones.; 268/// When an object is deleted from the file, the freed space is added; 269/// into the FREE linked list (fFree). The FREE list consists of a chain; 270/// of consecutive free segments on the",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:15208,Security,access,access,15208,"to replace the name stored in the file.; 336/// ~~~{.cpp}; 337/// TFile *f = TFile::Open(""tmpname.root?reproducible=fixedname"",""RECREATE"",""File title"");; 338/// ~~~; 339 ; 340TFile::TFile(const char *fname1, Option_t *option, const char *ftitle, Int_t compress); 341 : TDirectoryFile(), fCompress(compress), fUrl(fname1,kTRUE); 342{; 343 if (!gROOT); 344 ::Fatal(""TFile::TFile"", ""ROOT system not initialized"");; 345 ; 346 auto zombify = [this] {; 347 // error in file opening occurred, make this object a zombie; 348 if (fGlobalRegistration) {; 349 R__LOCKGUARD(gROOTMutex);; 350 gROOT->GetListOfClosedObjects()->Add(this);; 351 }; 352 MakeZombie();; 353 gDirectory = gROOT;; 354 };; 355 ; 356 fOption = option;; 357 if (strlen(fUrl.GetProtocol()) != 0 && strcmp(fUrl.GetProtocol(), ""file"") != 0 && !fOption.BeginsWith(""NET"") &&; 358 !fOption.BeginsWith(""WEB"")) {; 359 Error(""TFile"",; 360 ""please use TFile::Open to access remote files:\n\tauto f = std::unique_ptr<TFile>{TFile::Open(\""%s\"")};"",; 361 fname1);; 362 zombify();; 363 return;; 364 }; 365 ; 366 // store name without the options as name and title; 367 TString sfname1 = fname1;; 368 if (sfname1.Index(""?"") != kNPOS) {; 369 TString s = sfname1(0, sfname1.Index(""?""));; 370 SetName(s);; 371 fNoAnchorInName = kTRUE;; 372 } else; 373 SetName(fname1);; 374 ; 375 SetTitle(ftitle);; 376 ; 377 // accept also URL like ""file:..."" syntax; 378 fname1 = fUrl.GetFile();; 379 ; 380 // if option contains filetype=raw then go into raw file mode; 381 if (strstr(fUrl.GetOptions(), ""filetype=raw"")); 382 fIsRootFile = kFALSE;; 383 ; 384 // if option contains filetype=pcm then go into ROOT PCM file mode; 385 if (strstr(fUrl.GetOptions(), ""filetype=pcm"")); 386 fIsPcmFile = kTRUE;; 387 ; 388 if (fUrl.HasOption(""reproducible"")); 389 SetBit(kReproducible);; 390 ; 391 // We are opening synchronously; 392 fAsyncOpenStatus = kAOSNotAsync;; 393 ; 394 BuildDirectoryFile(this, nullptr);; 395 ; 396 fVersion = gROOT->GetVersionInt(); //ROOT version in integ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49056,Security,hash,hash,49056,"Long_t id, flags, modtime;; 1356 if (const_cast<TFile*>(this)->SysStat(fD, &id, &size, &flags, &modtime)) { // NOLINT: silence clang-tidy warnings; 1357 Error(""GetSize"", ""cannot stat the file %s"", GetName());; 1358 return -1;; 1359 }; 1360 }; 1361 return size;; 1362}; 1363 ; 1364////////////////////////////////////////////////////////////////////////////////; 1365/// Returns the cached list of StreamerInfos used in this file.; 1366 ; 1367const TList *TFile::GetStreamerInfoCache(); 1368{; 1369 return fInfoCache ? fInfoCache : (fInfoCache=GetStreamerInfoList());; 1370}; 1371 ; 1372////////////////////////////////////////////////////////////////////////////////; 1373/// See documentation of GetStreamerInfoList for more details.; 1374/// This is an internal method which returns the list of streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uid",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49111,Security,hash,hash,49111,"Long_t id, flags, modtime;; 1356 if (const_cast<TFile*>(this)->SysStat(fD, &id, &size, &flags, &modtime)) { // NOLINT: silence clang-tidy warnings; 1357 Error(""GetSize"", ""cannot stat the file %s"", GetName());; 1358 return -1;; 1359 }; 1360 }; 1361 return size;; 1362}; 1363 ; 1364////////////////////////////////////////////////////////////////////////////////; 1365/// Returns the cached list of StreamerInfos used in this file.; 1366 ; 1367const TList *TFile::GetStreamerInfoCache(); 1368{; 1369 return fInfoCache ? fInfoCache : (fInfoCache=GetStreamerInfoList());; 1370}; 1371 ; 1372////////////////////////////////////////////////////////////////////////////////; 1373/// See documentation of GetStreamerInfoList for more details.; 1374/// This is an internal method which returns the list of streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uid",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49752,Security,hash,hash,49752,"f streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49845,Security,hash,hash,49845,"f streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49911,Security,hash,hashes,49911,"f streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:49938,Security,hash,hash,49938,"f streamer infos and also; 1375/// information about the success of the operation.; 1376 ; 1377TFile::InfoListRet TFile::GetStreamerInfoListImpl(bool lookupSICache); 1378{; 1379 ROOT::Internal::RConcurrentHashColl::HashValue hash;; 1380 ; 1381 if (fIsPcmFile) return {nullptr, 1, hash}; // No schema evolution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:50059,Security,hash,hash,50059,"lution for ROOT PCM files.; 1382 ; 1383 TList *list = nullptr;; 1384 if (fSeekInfo) {; 1385 TDirectory::TContext ctxt(this); // gFile and gDirectory used in ReadObj; 1386 auto key = std::make_unique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in ad",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:50323,Security,hash,hash,50323,"ique<TKey>(this);; 1387 std::vector<char> buffer(fNbytesInfo+1);; 1388 auto buf = buffer.data();; 1389 Seek(fSeekInfo); // NOLINT: silence clang-tidy warnings; 1390 if (ReadBuffer(buf,fNbytesInfo)) { // NOLINT: silence clang-tidy warnings; 1391 // ReadBuffer returns kTRUE in case of failure.; 1392 Warning(""GetRecordHeader"",""%s: failed to read the StreamerInfo data from disk."",; 1393 GetName());; 1394 return {nullptr, 1, hash};; 1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in addition to TStreamerInfo object, contains sometimes; 1433/// a TList named 'listOfRules' and containing the schema evolution rules; 1434/// related to the file's content.; 1435///; 1436/// Using",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:50741,Security,hash,hash,50741,"1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in addition to TStreamerInfo object, contains sometimes; 1433/// a TList named 'listOfRules' and containing the schema evolution rules; 1434/// related to the file's content.; 1435///; 1436/// Using the list, one can access additional information, e.g.:; 1437/// ~~~{.cpp}; 1438/// TFile f(""myfile.root"");; 1439/// auto list = f.GetStreamerInfoList();; 1440/// auto info = dynamic_cast<TStreamerInfo*>(list->FindObject(""MyClass""));; 1441/// if (info) auto classversionid = info->GetClassVersion();; 1442/// delete list;; 1443/// ~~~; 1444///; 1445 ; 1446TList *TFile::GetStreamerInfoList(); 1447{; 1448 return GetStreamerInfoListIm",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:50786,Security,hash,hash,50786,"1395 }; 1396 ; 1397 if (lookupSICache) {; 1398 // key data must be excluded from the hash, otherwise the timestamp will; 1399 // always lead to unique hashes for each file; 1400 hash = fgTsSIHashes.Hash(buf + key->GetKeylen(), fNbytesInfo - key->GetKeylen());; 1401 auto si_uids = fgTsSIHashes.Find(hash);; 1402 if (si_uids) {; 1403 if (gDebug > 0); 1404 Info(""GetStreamerInfo"", ""The streamer info record for file %s has already been treated, skipping it."", GetName());; 1405 for(auto uid : *si_uids); 1406 fClassIndex->fArray[uid] = 1;; 1407 return {nullptr, 0, hash};; 1408 }; 1409 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in addition to TStreamerInfo object, contains sometimes; 1433/// a TList named 'listOfRules' and containing the schema evolution rules; 1434/// related to the file's content.; 1435///; 1436/// Using the list, one can access additional information, e.g.:; 1437/// ~~~{.cpp}; 1438/// TFile f(""myfile.root"");; 1439/// auto list = f.GetStreamerInfoList();; 1440/// auto info = dynamic_cast<TStreamerInfo*>(list->FindObject(""MyClass""));; 1441/// if (info) auto classversionid = info->GetClassVersion();; 1442/// delete list;; 1443/// ~~~; 1444///; 1445 ; 1446TList *TFile::GetStreamerInfoList(); 1447{; 1448 return GetStreamerInfoListIm",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:51347,Security,access,access,51347,"9 }; 1410 key->ReadKeyBuffer(buf);; 1411 list = dynamic_cast<TList*>(key->ReadObjWithBuffer(buffer.data()));; 1412 if (list) list->SetOwner();; 1413 } else {; 1414 list = (TList*)Get(""StreamerInfo""); //for versions 2.26 (never released); 1415 }; 1416 ; 1417 if (!list) {; 1418 Info(""GetStreamerInfoList"", ""cannot find the StreamerInfo record in file %s"",; 1419 GetName());; 1420 return {nullptr, 1, hash};; 1421 }; 1422 ; 1423 return {list, 0, hash};; 1424}; 1425 ; 1426////////////////////////////////////////////////////////////////////////////////; 1427/// Read the list of TStreamerInfo objects written to this file.; 1428///; 1429/// The function returns a TList. It is the user's responsibility; 1430/// to delete the list created by this function.; 1431///; 1432/// Note the list, in addition to TStreamerInfo object, contains sometimes; 1433/// a TList named 'listOfRules' and containing the schema evolution rules; 1434/// related to the file's content.; 1435///; 1436/// Using the list, one can access additional information, e.g.:; 1437/// ~~~{.cpp}; 1438/// TFile f(""myfile.root"");; 1439/// auto list = f.GetStreamerInfoList();; 1440/// auto info = dynamic_cast<TStreamerInfo*>(list->FindObject(""MyClass""));; 1441/// if (info) auto classversionid = info->GetClassVersion();; 1442/// delete list;; 1443/// ~~~; 1444///; 1445 ; 1446TList *TFile::GetStreamerInfoList(); 1447{; 1448 return GetStreamerInfoListImpl(/*lookupSICache*/ false).fList;; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// List file contents.; 1453///; 1454/// Indentation is used to identify the file tree.; 1455/// Subdirectories are listed first, then objects in memory,; 1456/// then objects on the file.; 1457 ; 1458void TFile::ls(Option_t *option) const; 1459{; 1460 TROOT::IndentLevel();; 1461 std::cout <<ClassName()<<""**\t\t""<<GetName()<<""\t""<<GetTitle()<<std::endl;; 1462 TROOT::IncreaseDirLevel();; 1463 TDirectoryFile::ls(option);; 1464 TROOT::Decr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:76709,Security,access,access,76709,"fFree,idcur,idcur-nbytes-1);; 2094 Seek(idcur);; 2095 continue;; 2096 }; 2097 Version_t versionkey;; 2098 frombuf(buffer, &versionkey);; 2099 frombuf(buffer, &objlen);; 2100 frombuf(buffer, &datime);; 2101 frombuf(buffer, &keylen);; 2102 frombuf(buffer, &cycle);; 2103 if (versionkey > 1000) {; 2104 frombuf(buffer, &seekkey);; 2105 frombuf(buffer, &seekpdir);; 2106 } else {; 2107 Int_t skey,sdir;; 2108 frombuf(buffer, &skey); seekkey = (Long64_t)skey;; 2109 frombuf(buffer, &sdir); seekpdir = (Long64_t)sdir;; 2110 }; 2111 frombuf(buffer, &nwhc);; 2112 char *classname = nullptr;; 2113 if (nwhc <= 0 || nwhc > 100) break;; 2114 classname = new char[nwhc+1];; 2115 int i, nwhci = nwhc;; 2116 for (i = 0;i < nwhc; i++) frombuf(buffer, &classname[i]);; 2117 classname[nwhci] = '\0';; 2118 TDatime::GetDateTime(datime, date, time);; 2119 TClass *tclass = TClass::GetClass(classname);; 2120 if (seekpdir == fSeekDir && tclass && !tclass->InheritsFrom(TFile::Class()); 2121 && strcmp(classname,""TBasket"")) {; 2122 key = new TKey(this);; 2123 key->ReadKeyBuffer(bufread);; 2124 if (!strcmp(key->GetName(),""StreamerInfo"")) {; 2125 fSeekInfo = seekkey;; 2126 SafeDelete(fInfoCache);; 2127 fNbytesInfo = nbytes;; 2128 } else {; 2129 AppendKey(key);; 2130 nrecov++;; 2131 SetBit(kRecovered);; 2132 Info(""Recover"", ""%s, recovered key %s:%s at address %lld"",GetName(),key->GetClassName(),key->GetName(),idcur);; 2133 }; 2134 }; 2135 delete [] classname;; 2136 idcur += nbytes;; 2137 }; 2138 if (fWritable) {; 2139 Long64_t max_file_size = Long64_t(kStartBigFile);; 2140 if (max_file_size < fEND) max_file_size = fEND+1000000000;; 2141 TFree *last = (TFree*)fFree->Last();; 2142 if (last) {; 2143 last->AddFree(fFree,fEND,max_file_size);; 2144 } else {; 2145 new TFree(fFree,fEND,max_file_size);; 2146 }; 2147 if (nrecov) Write();; 2148 }; 2149 return nrecov;; 2150}; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Reopen a file with a different access mode.",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:94217,Security,access,access,94217," fNbytesName);; 2636 tobuf(buffer, fUnits);; 2637 tobuf(buffer, fCompress);; 2638 tobuf(buffer, (Int_t)fSeekInfo);; 2639 tobuf(buffer, fNbytesInfo);; 2640 } else {; 2641 tobuf(buffer, fEND);; 2642 tobuf(buffer, fSeekFree);; 2643 tobuf(buffer, fNbytesFree);; 2644 tobuf(buffer, nfree);; 2645 tobuf(buffer, fNbytesName);; 2646 tobuf(buffer, fUnits);; 2647 tobuf(buffer, fCompress);; 2648 tobuf(buffer, fSeekInfo);; 2649 tobuf(buffer, fNbytesInfo);; 2650 }; 2651 if (TestBit(kReproducible)); 2652 TUUID(""00000000-0000-0000-0000-000000000000"").FillBuffer(buffer);; 2653 else; 2654 fUUID.FillBuffer(buffer);; 2655 Int_t nbytes = buffer - psave;; 2656 Seek(0); // NOLINT: silence clang-tidy warnings; 2657 WriteBuffer(psave, nbytes); // NOLINT: silence clang-tidy warnings; 2658 Flush(); // NOLINT: silence clang-tidy warnings, Intentionally not conditional on fMustFlush, this is the 'obligatory' flush.; 2659 delete [] psave;; 2660}; 2661 ; 2662////////////////////////////////////////////////////////////////////////////////; 2663/// Generate source code necessary to access the objects stored in the file.; 2664///; 2665/// Generate code in directory dirname for all classes specified in; 2666/// argument classes If classes = ""*"" (default and currently the; 2667/// only supported value), the function generates an include file; 2668/// for each class in the StreamerInfo list for which a TClass; 2669/// object does not exist.; 2670///; 2671/// The code generated includes:; 2672/// - <em>dirnameProjectHeaders.h</em>, which contains one `#include` statement per generated header file; 2673/// - <em>dirnameProjectSource.cxx</em>,which contains all the constructors and destructors implementation.; 2674/// and one header per class that is not nested inside another class.; 2675/// The header file name is the fully qualified name of the class after all the special characters; 2676/// ""<>,:"" are replaced by underscored. For example for std::pair<edm::Vertex,int> the file name is; 2677/// pair_edm__",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172356,Security,access,accesstime,172356,"lean-up is skipped - last cleanup %lu seconds ago - you requested %lu"", lastcleanuptime, cleanupinterval);; 4686 return kTRUE;; 4687 }; 4688 }; 4689 ; 4690 // (re-)create the cache tag file; 4691 cachetagfile += ""?filetype=raw"";; 4692 TFile *tagfile = nullptr;; 4693 ; 4694 if (!(tagfile = TFile::Open(cachetagfile, ""RECREATE""))) {; 4695 ::Error(""TFile::ShrinkCacheFileDir"", ""cannot create the cache tag file %s"", cachetagfile.Data());; 4696 return kFALSE;; 4697 }; 4698 ; 4699 // the shortest garbage collector in the world - one long line of PERL - unlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSyst",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:172908,Security,access,accesstime,172908,"nlinks files only,; 4700 // if there is a symbolic link with '.ROOT.cachefile' for safety ;-); 4701 ; 4702 TString cmd;; 4703#if defined(R__WIN32); 4704 cmd = ""echo <TFile::ShrinkCacheFileDir>: cleanup to be implemented"";; 4705#elif defined(R__MACOSX); 4706 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -f \\\""\\%%a::\\%%N::\\%%z\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4707#else; 4708 cmd.Form(""perl -e 'my $cachepath = \""%s\""; my $cachesize = %lld;my $findcommand=\""find $cachepath -type f -exec stat -c \\\""\\%%x::\\%%n::\\%%s\\\"" \\{\\} \\\\\\;\"";my $totalsize=0;open FIND, \""$findcommand | sort -k 1 |\"";while (<FIND>) { my ($accesstime, $filename, $filesize) = split \""::\"",$_; $totalsize += $filesize;if ($totalsize > $cachesize) {if ( ( -e \""${filename}.ROOT.cachefile\"" ) || ( -e \""${filename}\"" ) ) {unlink \""$filename.ROOT.cachefile\"";unlink \""$filename\"";}}}close FIND;' "", fgCacheFileDir.Data(),shrinksize);; 4709#endif; 4710 ; 4711 tagfile->WriteBuffer(cmd, 4096);; 4712 delete tagfile;; 4713 ; 4714 if ((gSystem->Exec(cmd)) != 0) {; 4715 ::Error(""TFile::ShrinkCacheFileDir"", ""error executing clean-up script"");; 4716 return kFALSE;; 4717 }; 4718 ; 4719 return kTRUE;; 4720}; 4721 ; 4722////////////////////////////////////////////////////////////////////////////////; 4723/// Sets open timeout time (in ms). Returns previous timeout value.; 4724 ; 4725UInt_t TFile::SetOpenTimeout(UInt_t timeout); 4726{; 4727 UInt_t to = fgOpenTimeout;; 4728 fgOpenTimeout = timeout;; 4729 return to;; 4730}; 4731 ; 4732/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:177195,Security,access,access,177195," 4810 ; 4811 // Default is not matching; 4812 return kFALSE;; 4813}; 4814 ; 4815////////////////////////////////////////////////////////////////////////////////; 4816/// Resolve the file type as a function of the protocol field in 'name'; 4817///; 4818/// If defined, the string 'prefix' is added when testing the locality of; 4819/// a 'name' with network-like structure (i.e. root://host//path); if the file; 4820/// is local, on return 'prefix' will contain the actual local path of the file.; 4821 ; 4822TFile::EFileType TFile::GetType(const char *name, Option_t *option, TString *prefix); 4823{; 4824 EFileType type = kDefault;; 4825 ; 4826 TPMERegexp re(""^(root|xroot).*"", ""i"");; 4827 if (re.Match(name)) {; 4828 //; 4829 // Should be a network file ...; 4830 type = kNet;; 4831 // ... but make sure that is not local or that a remote-like connection; 4832 // is forced. Treat it as local if:; 4833 // i) the url points to the localhost, the file will be opened in; 4834 // readonly mode and the current user has read access;; 4835 // ii) the specified user is equal to the current user then open local; 4836 // TFile.; 4837 Bool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:178324,Security,access,access,178324,"ool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.IsNull() ||; 4868 !opt.CompareTo(""READ"", TString::kIgnoreCase)) ? kTRUE : kFALSE;; 4869 if (read) {; 4870 TString fn = TUrl(lfname).GetFile();; 4871 if (!gSystem->ExpandPathName(fn)) {; 4872 if (gSystem->AccessPathName(fn, kReadPermission)); 4873 localFile = kFALSE;; 4874 }; 4875 }; 4876 // Return full local path if requested (and if the case); 4877 if (localFile && prefix); 4878 *prefix = lfname;; 4879 }; 4880 }; 4881 //; 4882 // Adjust the type according to findings; 4883 type = (localFile) ? kLocal : type;; 4884 } else if (TPMERegexp(""^(http[s]?|s3http[s]?|[a]?s3|gs|gshttp[s]?){1}:"", ""i"").Match(name)) {; 4885 //; 4886 // Web file; 4887 type = kWeb;; 4888 } else if (!strncmp(name, ""file:"", 5)) {; 4889 //; 4890 // 'file' protocol; 4891 type = kFile;; 4892 }; 4893 // We are done; 4894 return type;; 4895}; 4896 ; 4897////////////////////////////////////////////////////////////////////////////////; 4898/// Ge",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199296,Security,hash,hash,199296,"gWriterDefinition TVirtualMonitoring.h:116; TVirtualMutex.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TVirtualPerfStats.h; gPerfStats#define gPerfStatsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFil",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199431,Security,hash,hash,199431,"atsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199466,Security,hash,hash,199466,"atsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFi",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199626,Security,hash,hash,199626,"efinition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFile::GetMemberTArchiveMember * GetMember() constDefinition TArchiveFile.h:51; TArchiveFile::Openstatic TArchiveFile * Open(const char *url, TFile *file)Return proper archive ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199785,Security,hash,hash,199785,"29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFile::GetMemberTArchiveMember * GetMember() constDefinition TArchiveFile.h:51; TArchiveFile::Openstatic TArchiveFile * Open(const char *url, TFile *file)Return proper archive file handler depending on passed url.Definition TArchiveFile.cxx:121; TArchiveFile::GetMemberFilePositionLong64_t GetMemberFilePosition() constReturn position in archive of current member.Definition TAr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199846,Security,hash,hash,199846,"29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFile::GetMemberTArchiveMember * GetMember() constDefinition TArchiveFile.h:51; TArchiveFile::Openstatic TArchiveFile * Open(const char *url, TFile *file)Return proper archive file handler depending on passed url.Definition TArchiveFile.cxx:121; TArchiveFile::GetMemberFilePositionLong64_t GetMemberFilePosition() constReturn position in archive of current member.Definition TAr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:199858,Security,hash,hash,199858,"29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFile::GetMemberTArchiveMember * GetMember() constDefinition TArchiveFile.h:51; TArchiveFile::Openstatic TArchiveFile * Open(const char *url, TFile *file)Return proper archive file handler depending on passed url.Definition TArchiveFile.cxx:121; TArchiveFile::GetMemberFilePositionLong64_t GetMemberFilePosition() constReturn position in archive of current member.Definition TAr",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:202968,Security,access,access,202968,"f the schema rules if any.Definition TClass.cxx:1999; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::AddRulestatic Bool_t AddRule(const char *rule)Add a schema evolution customization rule.Definition TClass.cxx:1957; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::SetOwnervirtual void SetOwner(Bool_t enable=kTRUE)Set whether this collection is the owner (enable==true) of its content.Definition TCollection.cxx:746; TCollection::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an collection using the Streamer facility.Definition TCollection.cxx:263; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatime::GetDateTimestatic void GetDateTime(UInt_t datetime, Int_t &date, Int_t &time)Static function that returns the date and time.Definition TDati",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:213077,Security,access,access,213077,"nition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::Classstatic TClass * Class(); TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; T",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:218656,Security,access,access,218656,"File.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::kEternalTimeout@ kEternalTimeoutDefinition TFile.h:67; TFile::fNbytesInfoInt_t fNbytesInfoNumber of bytes for StreamerInfo record.Definition TFile.h:86; TFile::GetSizevirtual Long64_t GetSize() constReturns the current file size.Definition TFile.cxx:1347; TFile::IsOpenvirtual Bool_t IsOpen() constReturns kTRUE in case file is open and kFALSE if file is not open.Definition TFile.cxx:1469; TFile::fAsyncHandleTFileOpenHandle * fAsyncHandle!For proper automatic cleanupDefinition TFile.h:108; TFile::SetOnlyStagedstatic Bool_t SetOnlyStaged(Bool_t onlystaged)Sets only staged flag.Definition TFile.cxx:4744; TFile::GetBytesReadvirtual Long64_t GetBytesRead() constDefinition TFile.h:241; TFile::GetErrnovirtual Int_t GetErrno() constMethod returning errno.Defini",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:225318,Security,hash,hashes,225318,"ace to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw ma",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:245953,Security,secur,secure,245953,"*s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::ReadBuffervirtual void ReadBuffer(char *&buffer)Read string from I/O buffer.Definition TString.cxx:1331; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::TempFileNamevirtual FILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr)Create a secure temporary file by appending a unique 6 letter string to base.Definition TSystem.cxx:1499; TSystem::GetMakeSharedLibvirtual const char * GetMakeSharedLib() constReturn the command line use to make a shared library.Definition TSystem.cxx:3956; TSystem::RedirectOutputvirtual Int_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr)Redirect standard output (stdout, stderr) to the specified file.Definition TSystem.cxx:1715; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)E",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:249076,Security,access,access,249076,"efinition TSystem.cxx:1725; TSystem::IsPathLocalvirtual Bool_t IsPathLocal(const char *path)Returns TRUE if the url in 'path' points to the local file system.Definition TSystem.cxx:1305; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Defini",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:249110,Security,access,access,249110,"efinition TSystem.cxx:1725; TSystem::IsPathLocalvirtual Bool_t IsPathLocal(const char *path)Returns TRUE if the url in 'path' points to the local file system.Definition TSystem.cxx:1305; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Defini",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:819,Testability,log,logical,819,". ROOT: io/io/src/TFile.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TFile.cxx. Go to the documentation of this file. 1// @(#)root/io:$Id: 3a19890259ad6443ee313e090166614971ad4296 $; 2// Author: Rene Brun 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13\file TFile.cxx; 14\class TFile; 15\ingroup IO; 16\brief A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies.; 17\sa \ref IO; 18\sa \ref rootio (or `io/doc/TFile` folder in your codebase); 19 ; 20<details>; 21<summary>ROOT file data format specification</summary>; 22 ; 23A ROOT file is composed of a header, followed by consecutive data records; 24(`TKey` instances) with a well defined format.; 25 ; 26The first data record starts at byte fBEGIN (currently set to kBEGIN).; 27Bytes 1->kBEGIN contain the file description, when fVersion >= 1000000; 28it is a large file (> 2 GB) and the offsets will be 8 bytes long and; 29fUnits will be set to 8:; 30 ; 31Byte Range | Record Name | Description; 32----------------|-------------|------------; 331->4 | ""root"" | Root file identifier; 345->8 | fVersion | File format version; 359->12 | fBEGIN | Pointer to first data record; 3613->16 [13->20] | fEND | Pointer to first free word at the EOF; 3717->20 [21->28] | fSeekFree | Pointer to FREE data record; 3821->24 [29->32] | fNbytesFree | Number of bytes in FREE data record; 3925->28 [33->36] | nfree | Number of free data records; 4029->32 [37->40] | fNbytesName | Number of bytes in TNamed at creation time; 4133->33 [41->41] | f",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:13210,Testability,log,logical,13210,"y apply to branches created; 294/// or attached after the setting is changed and other objects written; 295/// after the setting is changed.; 296/// In case the file does not exist or is not a valid ROOT file,; 297/// it is made a Zombie. One can detect this situation with a code like:; 298/// ~~~{.cpp}; 299/// TFile f(""file.root"");; 300/// if (f.IsZombie()) {; 301/// std::cout << ""Error opening file"" << std::endl;; 302/// exit(-1);; 303/// }; 304/// ~~~; 305/// If you open a file instead with TFile::Open(""file.root"") use rather; 306/// the following code as a nullptr is returned.; 307/// ~~~{.cpp}; 308/// TFile* f = TFile::Open(""file.root"");; 309/// if (!f) {; 310/// std::cout << ""Error opening file"" << std::endl;; 311/// exit(-1);; 312/// }; 313/// ~~~; 314/// When opening the file, the system checks the validity of this directory.; 315/// If something wrong is detected, an automatic Recovery is performed. In; 316/// this case, the file is scanned sequentially reading all logical blocks; 317/// and attempting to rebuild a correct directory (see TFile::Recover).; 318/// One can disable the automatic recovery procedure when reading one; 319/// or more files by setting the environment variable ""TFile.Recover: 0""; 320/// in the system.rootrc file.; 321///; 322/// A bit `TFile::kReproducible` can be enabled specifying; 323/// the `""reproducible""` url option when creating the file:; 324/// ~~~{.cpp}; 325/// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; 326/// ~~~; 327/// Unlike regular `TFile`s, the content of such file has reproducible binary; 328/// content when writing exactly same data. This achieved by writing pre-defined; 329/// values for creation and modification date of TKey/TDirectory objects and; 330/// null value for TUUID objects inside TFile. As drawback, TRef objects stored; 331/// in such file cannot be read correctly.; 332///; 333/// In case the name of the file is not reproducible either (in case of; 334/// creating tempora",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:45525,Testability,log,logical,45525,"/////////////; 1253/// Method resetting the errno.; 1254 ; 1255void TFile::ResetErrno() const; 1256{; 1257 TSystem::ResetErrno();; 1258}; 1259 ; 1260////////////////////////////////////////////////////////////////////////////////; 1261/// Return a pointer to the current read cache.; 1262 ; 1263TFileCacheRead *TFile::GetCacheRead(const TObject* tree) const; 1264{; 1265 if (!tree) {; 1266 if (!fCacheRead && fCacheReadMap->GetSize() == 1) {; 1267 TIter next(fCacheReadMap);; 1268 return (TFileCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The function reads nread bytes; 1297/// where nread is the minimum of maxbytes and the number of bytes; 1298/// before the end of file. The function returns nread.; 1299/// Note that the arguments objlen and keylen are returned only; 1300/// if maxbytes >=16; 1301 ; 1302Int_t TFile::GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen); 1303{; 1304 nbytes = 0;; 1305 objlen = 0;;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:45975,Testability,log,logical,45975,"leCacheRead *)fCacheReadMap->GetValue(next());; 1269 }; 1270 return fCacheRead;; 1271 }; 1272 TFileCacheRead *cache = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 1273 if (!cache) return fCacheRead;; 1274 return cache;; 1275}; 1276 ; 1277////////////////////////////////////////////////////////////////////////////////; 1278/// Return a pointer to the current write cache.; 1279 ; 1280TFileCacheWrite *TFile::GetCacheWrite() const; 1281{; 1282 return fCacheWrite;; 1283}; 1284 ; 1285////////////////////////////////////////////////////////////////////////////////; 1286/// Read the logical record header starting at a certain postion.; 1287///; 1288/// \param[in] buf pointer to buffer; 1289/// \param[in] first read offset; 1290/// \param[in] maxbytes Bytes which are read into buf.; 1291/// \param[out] nbytes Number of bytes in record if negative, this is a deleted; 1292/// record if 0, cannot read record, wrong value of argument first; 1293/// \param[out] objlen Uncompressed object size; 1294/// \param[out] keylen Length of logical record header; 1295///; 1296/// The function reads nread bytes; 1297/// where nread is the minimum of maxbytes and the number of bytes; 1298/// before the end of file. The function returns nread.; 1299/// Note that the arguments objlen and keylen are returned only; 1300/// if maxbytes >=16; 1301 ; 1302Int_t TFile::GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen); 1303{; 1304 nbytes = 0;; 1305 objlen = 0;; 1306 keylen = 0;; 1307 if (first < fBEGIN) return 0;; 1308 if (first > fEND) return 0;; 1309 Seek(first);; 1310 Int_t nread = maxbytes;; 1311 if (first+maxbytes > fEND) nread = fEND-maxbytes;; 1312 if (nread < 4) {; 1313 Warning(""GetRecordHeader"",""%s: parameter maxbytes = %d must be >= 4"",; 1314 GetName(), nread);; 1315 return nread;; 1316 }; 1317 if (ReadBuffer(buf,nread)) {; 1318 // ReadBuffer return kTRUE in case of failure.; 1319 Warning(""GetRecordHeader"",""%s: failed to read header ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:54378,Testability,log,logical,54378,"e->GetLast();; 1493 Long64_t nbytesl= nlast-nfirst+1;; 1494 if (nbytesl > 2000000000) nbytesl = 2000000000;; 1495 Int_t nbytes = -Int_t (nbytesl);; 1496 Int_t nb = sizeof(Int_t);; 1497 char * buffer = new char[nb];; 1498 char * psave = buffer;; 1499 tobuf(buffer, nbytes);; 1500 if (last == fEND-1) fEND = nfirst;; 1501 Seek(nfirst);; 1502 // We could not update the meta data for this block on the file.; 1503 // This is not fatal as this only means that we won't get it 'right'; 1504 // if we ever need to Recover the file before the block is actually; 1505 // (attempted to be reused.; 1506 // coverity[unchecked_value]; 1507 WriteBuffer(psave, nb);; 1508 if (fMustFlush) Flush();; 1509 delete [] psave;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// List the contents of a file sequentially.; 1514/// For each logical record found, it prints:; 1515///; 1516/// Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor; 1517///; 1518/// Example of output; 1519///; 1520/// 20010404/150437 At:64 N=150 TFile; 1521/// 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 1522/// 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 1523/// 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 1524/// 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 1525/// 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 1526/// 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 1527/// 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 1528/// 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 1529/// 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 1530/// 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 1531/// 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 1532/// 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 1533/// 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 1534/// 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 1535/// 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 153",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72410,Testability,test,test,72410,"id);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 20",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72719,Testability,test,test,72719,"ber of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 2058 Long64_t idcur = fBEGIN;; 2059 ; 2060 Long64_t size;; 2061 if ((size = GetSize()) == -1) { // NOLINT: silence clang-tidy war",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:80086,Testability,log,logical,80086,"; 2231 fD = SysOpen(fRealName, O_RDWR | O_CREAT, 0644);; 2232#else; 2233 fD = SysOpen(fRealName, O_RDWR | O_CREAT | O_BINARY, S_IREAD | S_IWRITE);; 2234#endif; 2235 if (fD == -1) {; 2236 SysError(""ReOpen"", ""file %s can not be opened in update mode"", GetName());; 2237 return -1;; 2238 }; 2239 SetWritable(kTRUE);; 2240 ; 2241 fFree = new TList;; 2242 if (fSeekFree > fBEGIN); 2243 ReadFree();; 2244 else; 2245 Warning(""ReOpen"",""file %s probably not closed, cannot read free segments"", GetName());; 2246 }; 2247 ; 2248 return 0;; 2249}; 2250 ; 2251////////////////////////////////////////////////////////////////////////////////; 2252/// Set position from where to start reading.; 2253 ; 2254void TFile::SetOffset(Long64_t offset, ERelativeTo pos); 2255{; 2256 switch (pos) {; 2257 case kBeg:; 2258 fOffset = offset + fArchiveOffset;; 2259 break;; 2260 case kCur:; 2261 fOffset += offset;; 2262 break;; 2263 case kEnd:; 2264 // this option is not used currently in the ROOT code; 2265 if (fArchiveOffset); 2266 Error(""SetOffset"", ""seeking from end in archive is not (yet) supported"");; 2267 fOffset = fEND + offset; // is fEND really EOF or logical EOF?; 2268 break;; 2269 }; 2270}; 2271 ; 2272////////////////////////////////////////////////////////////////////////////////; 2273/// Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.; 2274 ; 2275void TFile::Seek(Long64_t offset, ERelativeTo pos); 2276{; 2277 int whence = 0;; 2278 switch (pos) {; 2279 case kBeg:; 2280 whence = SEEK_SET;; 2281 offset += fArchiveOffset;; 2282 break;; 2283 case kCur:; 2284 whence = SEEK_CUR;; 2285 break;; 2286 case kEnd:; 2287 whence = SEEK_END;; 2288 // this option is not used currently in the ROOT code; 2289 if (fArchiveOffset); 2290 Error(""Seek"", ""seeking from end in archive is not (yet) supported"");; 2291 break;; 2292 }; 2293 Long64_t retpos;; 2294 if ((retpos = SysSeek(fD, offset, whence)) < 0) // NOLINT: silence clang-tidy warnings; 2295 SysError(""Seek"", ""cannot seek to position ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:122121,Testability,test,test,122121,"ata());; 3346 ; 3347 //dynamically link the generated shared lib; 3348 if (opt.Contains(""++"")) {; 3349 res = !gSystem->Load(path);; 3350 if (res) printf(""Shared lib %s has been dynamically linked\n"",path.Data());; 3351 }; 3352 }; 3353 ; 3354 delete list;; 3355 filelist->Delete();; 3356 delete filelist;; 3357}; 3358 ; 3359////////////////////////////////////////////////////////////////////////////////; 3360/// Create makefile at 'filemake' for PAR package 'pack'.; 3361///; 3362/// Called by MakeProject when option 'par' is given.; 3363/// Return 0 on success, -1 on error.; 3364 ; 3365Int_t TFile::MakeProjectParMake(const char *pack, const char *filemake); 3366{; 3367 // Output file path must be defined; 3368 if (!filemake || (filemake && strlen(filemake) <= 0)) {; 3369 Error(""MakeProjectParMake"", ""path for output file undefined!"");; 3370 return -1;; 3371 }; 3372 ; 3373 // Package name must be defined; 3374 if (!pack || (pack && strlen(pack) <= 0)) {; 3375 Error(""MakeProjectParMake"", ""package name undefined!"");; 3376 return -1;; 3377 }; 3378 ; 3379#ifdef R__WINGCC; 3380 FILE *fmk = fopen(filemake, ""wb"");; 3381#else; 3382 FILE *fmk = fopen(filemake, ""w"");; 3383#endif; 3384 if (!fmk) {; 3385 Error(""MakeProjectParMake"", ""cannot create file '%s' (errno: %d)"", filemake, TSystem::GetErrno());; 3386 return -1;; 3387 }; 3388 ; 3389 // Fill the file now; 3390 fprintf(fmk, ""# Makefile for the ROOT test programs.\n"");; 3391 fprintf(fmk, ""# This Makefile shows how to compile and link applications\n"");; 3392 fprintf(fmk, ""# using the ROOT libraries on all supported platforms.\n"");; 3393 fprintf(fmk, ""#\n"");; 3394 fprintf(fmk, ""# Copyright (c) 2000 Rene Brun and Fons Rademakers\n"");; 3395 fprintf(fmk, ""#\n"");; 3396 fprintf(fmk, ""# Author: this makefile has been automatically generated via TFile::MakeProject\n"");; 3397 fprintf(fmk, ""\n"");; 3398 fprintf(fmk, ""include Makefile.arch\n"");; 3399 fprintf(fmk, ""\n"");; 3400 fprintf(fmk, ""#----------------------------------------------------",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:125686,Testability,log,log,125686,"440 fprintf(fmk, ""else\n"");; 3441 fprintf(fmk, ""ifeq ($(PLATFORM),win32)\n"");; 3442 fprintf(fmk, ""\t\tbindexplib $* $^ > $*.def\n"");; 3443 fprintf(fmk, ""\t\tlib -nologo -MACHINE:IX86 $^ -def:$*.def \\\n"");; 3444 fprintf(fmk, ""\t\t $(OutPutOpt)$(PACKLIB)\n"");; 3445 fprintf(fmk, ""\t\t$(LD) $(SOFLAGS) $(LDFLAGS) $^ $*.exp $(LIBS) \\\n"");; 3446 fprintf(fmk, ""\t\t $(OutPutOpt)$@\n"");; 3447 fprintf(fmk, ""else\n"");; 3448 fprintf(fmk, ""\t\t$(LD) $(SOFLAGS) $(LDFLAGS) $^ $(OutPutOpt) $@ $(LIBS) $(EXPLLINKLIBS)\n"");; 3449 fprintf(fmk, ""endif\n"");; 3450 fprintf(fmk, ""endif\n"");; 3451 fprintf(fmk, ""endif\n"");; 3452 fprintf(fmk, ""endif\n"");; 3453 fprintf(fmk, ""\t\t@echo \""$@ done\""\n"");; 3454 fprintf(fmk, ""\n"");; 3455 fprintf(fmk, ""clean:\n"");; 3456 fprintf(fmk, ""\t\t@rm -f $(OBJS) core\n"");; 3457 fprintf(fmk, ""\n"");; 3458 fprintf(fmk, ""distclean: clean\n"");; 3459 fprintf(fmk, ""\t\t@rm -f $(PROGRAMS) $(PACKSO) $(PACKLIB) *Dict.* *.def *.exp \\\n"");; 3460 fprintf(fmk, ""\t\t *.so *.lib *.dll *.d *.log .def so_locations\n"");; 3461 fprintf(fmk, ""\t\t@rm -rf cxx_repository\n"");; 3462 fprintf(fmk, ""\n"");; 3463 fprintf(fmk, ""# Dependencies\n"");; 3464 fprintf(fmk, ""\n"");; 3465 fprintf(fmk, ""%sProjectSource.$(ObjSuf): %sProjectHeaders.h %sLinkDef.h %sProjectDict.$(SrcSuf)\n"", pack, pack, pack, pack);; 3466 fprintf(fmk, ""\n"");; 3467 fprintf(fmk, ""%sProjectDict.$(SrcSuf): %sProjectHeaders.h %sLinkDef.h\n"", pack, pack, pack);; 3468 fprintf(fmk, ""\t\t@echo \""Generating dictionary $@...\""\n"");; 3469 fprintf(fmk, ""\t\t@rootcint -f $@ $^\n"");; 3470 fprintf(fmk, ""\n"");; 3471 fprintf(fmk, "".$(SrcSuf).$(ObjSuf):\n"");; 3472 fprintf(fmk, ""\t\t$(CXX) $(CXXFLAGS) -c $<\n"");; 3473 fprintf(fmk, ""\n"");; 3474 ; 3475 // Close the file; 3476 fclose(fmk);; 3477 ; 3478 // Done; 3479 return 0;; 3480}; 3481 ; 3482////////////////////////////////////////////////////////////////////////////////; 3483/// Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; 3484/// Called by MakeProject when option ",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128311,Testability,test,test,128311,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:128482,Testability,test,test,128482,"513 path.Form(""%s/BUILD.sh"", proofinf);; 3514#ifdef R__WINGCC; 3515 FILE *f = fopen(path.Data(), ""wb"");; 3516#else; 3517 FILE *f = fopen(path.Data(), ""w"");; 3518#endif; 3519 if (!f) {; 3520 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3521 path.Data(), TSystem::GetErrno());; 3522 return -1;; 3523 }; 3524 ; 3525 fprintf(f, ""#! /bin/sh\n"");; 3526 fprintf(f, ""# Build libEvent library.\n"");; 3527 fprintf(f, ""\n"");; 3528 fprintf(f, ""#\n"");; 3529 fprintf(f, ""# The environment variables ROOTPROOFLITE and ROOTPROOFCLIENT can be used to\n"");; 3530 fprintf(f, ""# adapt the script to the calling environment\n"");; 3531 fprintf(f, ""#\n"");; 3532 fprintf(f, ""# if test ! \""x$ROOTPROOFLITE\"" = \""x\""; then\n"");; 3533 fprintf(f, ""# echo \""event-BUILD: PROOF-Lite node (session has $ROOTPROOFLITE workers)\""\n"");; 3534 fprintf(f, ""# elif test ! \""x$ROOTPROOFCLIENT\"" = \""x\""; then\n"");; 3535 fprintf(f, ""# echo \""event-BUILD: PROOF client\""\n"");; 3536 fprintf(f, ""# else\n"");; 3537 fprintf(f, ""# echo \""event-BUILD: standard PROOF node\""\n"");; 3538 fprintf(f, ""# fi\n"");; 3539 fprintf(f, ""\n"");; 3540 fprintf(f, ""if [ \""\"" = \""clean\"" ]; then\n"");; 3541 fprintf(f, "" make distclean\n"");; 3542 fprintf(f, "" exit 0\n"");; 3543 fprintf(f, ""fi\n"");; 3544 fprintf(f, ""\n"");; 3545 fprintf(f, ""make\n"");; 3546 fprintf(f, ""rc=$?\n"");; 3547 fprintf(f, ""echo \""rc=$?\""\n"");; 3548 fprintf(f, ""if [ $? != \""0\"" ] ; then\n"");; 3549 fprintf(f, "" exit 1\n"");; 3550 fprintf(f, ""fi\n"");; 3551 fprintf(f, ""exit 0\n"");; 3552 ; 3553 // Close the file; 3554 fclose(f);; 3555 ; 3556 // Then SETUP.C; 3557 path.Form(""%s/SETUP.C"", proofinf);; 3558#ifdef R__WINGCC; 3559 f = fopen(path.Data(), ""wb"");; 3560#else; 3561 f = fopen(path.Data(), ""w"");; 3562#endif; 3563 if (!f) {; 3564 Error(""MakeProjectParProofInf"", ""cannot create file '%s' (errno: %d)"",; 3565 path.Data(), TSystem::GetErrno());; 3566 return -1;; 3567 }; 3568 ; 3569 fprintf(f, ""Int_t SETUP()\n"");; 3570 fprintf(f, ""{\n"");; 3571 fprintf(f, ""\n"");;",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:176473,Testability,test,testing,176473,"FQDN())) {; 4777 // Ok, coordinates match; 4778 return kTRUE;; 4779 }; 4780 }; 4781 }; 4782 ; 4783 // Default is not matching; 4784 return kFALSE;; 4785}; 4786 ; 4787////////////////////////////////////////////////////////////////////////////////; 4788/// Return kTRUE if this async request matches the open request; 4789/// specified by 'url'; 4790 ; 4791Bool_t TFileOpenHandle::Matches(const char *url); 4792{; 4793 if (fFile) {; 4794 return fFile->Matches(url);; 4795 } else if (fName.Length() > 0){; 4796 // Deep check of URLs; 4797 TUrl u(url);; 4798 TUrl uref(fName);; 4799 if (!strcmp(u.GetFile(), uref.GetFile())) {; 4800 // Check ports; 4801 if (u.GetPort() == uref.GetPort()) {; 4802 // Check also the host name; 4803 if (!strcmp(u.GetHostFQDN(), uref.GetHostFQDN())) {; 4804 // Ok, coordinates match; 4805 return kTRUE;; 4806 }; 4807 }; 4808 }; 4809 }; 4810 ; 4811 // Default is not matching; 4812 return kFALSE;; 4813}; 4814 ; 4815////////////////////////////////////////////////////////////////////////////////; 4816/// Resolve the file type as a function of the protocol field in 'name'; 4817///; 4818/// If defined, the string 'prefix' is added when testing the locality of; 4819/// a 'name' with network-like structure (i.e. root://host//path); if the file; 4820/// is local, on return 'prefix' will contain the actual local path of the file.; 4821 ; 4822TFile::EFileType TFile::GetType(const char *name, Option_t *option, TString *prefix); 4823{; 4824 EFileType type = kDefault;; 4825 ; 4826 TPMERegexp re(""^(root|xroot).*"", ""i"");; 4827 if (re.Match(name)) {; 4828 //; 4829 // Should be a network file ...; 4830 type = kNet;; 4831 // ... but make sure that is not local or that a remote-like connection; 4832 // is forced. Treat it as local if:; 4833 // i) the url points to the localhost, the file will be opened in; 4834 // readonly mode and the current user has read access;; 4835 // ii) the specified user is equal to the current user then open local; 4836 // TFile.; 4837 Bool_t",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:177800,Testability,test,test,177800,"Regexp re(""^(root|xroot).*"", ""i"");; 4827 if (re.Match(name)) {; 4828 //; 4829 // Should be a network file ...; 4830 type = kNet;; 4831 // ... but make sure that is not local or that a remote-like connection; 4832 // is forced. Treat it as local if:; 4833 // i) the url points to the localhost, the file will be opened in; 4834 // readonly mode and the current user has read access;; 4835 // ii) the specified user is equal to the current user then open local; 4836 // TFile.; 4837 Bool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.IsNull() ||; 4868 !opt.CompareTo(""READ"", TString::kIgnoreCase)) ? kTRUE : kFALSE;; 4869 if (read) {; 4870 TString fn = TUrl(lfname).GetFile();; 4871 if (!gSystem->ExpandPathName(fn)) {; 4872 if (gSystem->AccessPathName(fn, kReadPermission)); 4873 localFile = kFALSE;; 4874 }; 4875 }; 4876 // Return full local path if requested (and if the case); 4877 if (localFile && prefix); 4878 *prefix = lfname;; 4879 }; 4880 }; 4881 //; 4882 // Adj",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:178305,Testability,test,test,178305,"ool_t localFile = kFALSE;; 4838 TUrl url(name);; 4839 //; 4840 // Check whether we should try to optimize for local files; 4841 Bool_t forceRemote = gEnv->GetValue(""Path.ForceRemote"", 0);; 4842 forceRemote = (forceRemote) ? kTRUE : gEnv->GetValue(""TFile.ForceRemote"", 0);; 4843 TString opts = url.GetOptions();; 4844 if (opts.Contains(""remote=1"")); 4845 forceRemote = kTRUE;; 4846 else if (opts.Contains(""remote=0"")); 4847 forceRemote = kFALSE;; 4848 if (!forceRemote) {; 4849 // Generic locality test; 4850 localFile = gSystem->IsPathLocal(name);; 4851 if (localFile) {; 4852 // Local path including the prefix; 4853 const char *fname = url.GetFileAndOptions();; 4854 TString lfname;; 4855 if (fname[0] == '/') {; 4856 if (prefix); 4857 lfname.Form(""%s%s"", prefix->Data(), fname);; 4858 else; 4859 lfname = fname;; 4860 } else if (fname[0] == '~' || fname[0] == '$') {; 4861 lfname = fname;; 4862 } else {; 4863 lfname.Form(""%s/%s"", gSystem->HomeDirectory(), fname);; 4864 }; 4865 // If option ""READ"" test existence and access; 4866 TString opt = option;; 4867 Bool_t read = (opt.IsNull() ||; 4868 !opt.CompareTo(""READ"", TString::kIgnoreCase)) ? kTRUE : kFALSE;; 4869 if (read) {; 4870 TString fn = TUrl(lfname).GetFile();; 4871 if (!gSystem->ExpandPathName(fn)) {; 4872 if (gSystem->AccessPathName(fn, kReadPermission)); 4873 localFile = kFALSE;; 4874 }; 4875 }; 4876 // Return full local path if requested (and if the case); 4877 if (localFile && prefix); 4878 *prefix = lfname;; 4879 }; 4880 }; 4881 //; 4882 // Adjust the type according to findings; 4883 type = (localFile) ? kLocal : type;; 4884 } else if (TPMERegexp(""^(http[s]?|s3http[s]?|[a]?s3|gs|gshttp[s]?){1}:"", ""i"").Match(name)) {; 4885 //; 4886 // Web file; 4887 type = kWeb;; 4888 } else if (!strncmp(name, ""file:"", 5)) {; 4889 //; 4890 // 'file' protocol; 4891 type = kFile;; 4892 }; 4893 // We are done; 4894 return type;; 4895}; 4896 ; 4897////////////////////////////////////////////////////////////////////////////////; 4898/// Ge",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:230519,Testability,log,logical,230519,"File Header.Definition TFile.cxx:2615; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFre",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72288,Usability,usab,usable,72288,"pid,pidf);; 1999 pid->IncrementCount();; 2000 ; 2001 {; 2002 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 2003 pidslist->Add(pid);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 204",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:72383,Usability,usab,usable,72383,"id);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 20",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:97342,Usability,clear,clear,97342," content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname).; 2691///; 2692/// If, in addition to one of the 3 above options, the option ""+"" is specified,; 2693/// the function will generate:; 2694/// - a script called MAKEP to build the shared lib; 2695/// - a dirnameLinkDef.h file; 2696/// - rootcint will be run to generate a dirnameProjectDict.cxx file; 2697/// - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; 2698/// - a shared lib dirname.so will be created.; 2699/// If the option ""++"" is specified, the generated shared lib is dynamically; 2700/// linked with the current executable module.; 2701/// If the option ""+"" and ""nocompile"" are specified, the utility files are generated; 2702/// as in the option ""+"" but they are not executed.; 2703/// Example:; 2704/// file.MakeProject(""demo"",""*"",""recreate++"");; 2705/// - creates a new directory demo unless it already exist; 2706/// - clear the previous directory content; 2707/// - generate the xxx.h files for all classes xxx found in this file; 2708/// and not yet known to the CINT dictionary.; 2709/// - creates the build script MAKEP; 2710/// - creates a LinkDef.h file; 2711/// - runs rootcint generating demoProjectDict.cxx; 2712/// - compiles demoProjectDict.cxx into demoProjectDict.o; 2713/// - generates a shared lib demo.so; 2714/// - dynamically links the shared lib demo.so to the executable; 2715/// If only the option ""+"" had been specified, one can still link the; 2716/// shared lib to the current executable module with:; 2717///; 2718/// gSystem->load(""demo/demo.so"");; 2719///; 2720/// The following feature is not yet enabled:; 2721/// One can restrict the list of classes to be generated by using expressions like:; 2722///; 2723/// classes = ""Ali*"" generate code only for classes starting with Ali; 2724/// classes = ""myClass"" generate code for class MyClass only.; 2725///; 2726 ; 2727",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8cxx_source.html:100953,Usability,clear,clear,100953,"'%s', '%s')"", filepath.Data(), path.Data(), afile);; 2767 }; 2768 gSystem->FreeDirectory(dirp);; 2769 if (gSystem->Unlink(path)); 2770 Warning(""MakeProject"", ""problems unlinking '%s'"", path.Data());; 2771 }; 2772 }; 2773 // Make sure that the relevant dirs exists: this is mandatory, so we fail if unsuccessful; 2774 path.Form(""%s/%s/PROOF-INF"", pardir.Data(), parname.Data());; 2775 if (gSystem->mkdir(path, kTRUE)) {; 2776 Error(""MakeProject"", ""problems creating '%s'"", path.Data());; 2777 return;; 2778 }; 2779 makepar = kTRUE;; 2780 ; 2781 } else {; 2782 void *dir = gSystem->OpenDirectory(dirname);; 2783 TString dirpath;; 2784 ; 2785 if (opt.Contains(""update"")) {; 2786 // check that directory exist, if not create it; 2787 if (!dir) {; 2788 gSystem->mkdir(dirname);; 2789 }; 2790 ; 2791 } else if (opt.Contains(""recreate"")) {; 2792 // check that directory exist, if not create it; 2793 if (!dir) {; 2794 if (gSystem->mkdir(dirname) < 0) {; 2795 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2796 return;; 2797 }; 2798 }; 2799 // clear directory; 2800 while (dir) {; 2801 const char *afile = gSystem->GetDirEntry(dir);; 2802 if (!afile) break;; 2803 if (strcmp(afile,""."") == 0) continue;; 2804 if (strcmp(afile,"".."") == 0) continue;; 2805 dirpath.Form(""%s/%s"",dirname,afile);; 2806 gSystem->Unlink(dirpath);; 2807 }; 2808 ; 2809 } else {; 2810 // new is assumed; 2811 // if directory already exist, print error message and return; 2812 if (dir) {; 2813 Error(""MakeProject"",""cannot create directory %s, already existing"",dirname);; 2814 gSystem->FreeDirectory(dir);; 2815 return;; 2816 }; 2817 if (gSystem->mkdir(dirname) < 0) {; 2818 Error(""MakeProject"",""cannot create directory '%s'"",dirname);; 2819 return;; 2820 }; 2821 }; 2822 if (dir) {; 2823 gSystem->FreeDirectory(dir);; 2824 }; 2825 }; 2826 Bool_t genreflex = opt.Contains(""genreflex"");; 2827 ; 2828 // we are now ready to generate the classes; 2829 // loop on all TStreamerInfo; 2830 TList *filelist = (TList*)GetStream",MatchSource.WIKI,doc/master/TFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html
https://root.cern/doc/master/TFile_8h.html:379,Integrability,depend,dependency,379,". ROOT: io/io/inc/TFile.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros ; TFile.h File Reference. #include <atomic>; #include <string>; #include ""Compression.h""; #include ""TDirectoryFile.h""; #include ""TUrl.h""; #include ""ROOT/RConcurrentHashColl.hxx""; #include ""ROOT/TRWSpinLock.hxx""; #include <mutex>. Include dependency graph for TFile.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TFile::InfoListRet;  Simple struct of the return value of GetStreamerInfoListImpl. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  . Macros; #define gFile   (TFile::CurrentFile());  . Macro Definition Documentation. ◆ gFile. #define gFile   (TFile::CurrentFile()). Definition at line 347 of file TFile.h. ioioincTFile.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFile_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h.html
https://root.cern/doc/master/TFile_8h.html:883,Testability,log,logical,883,". ROOT: io/io/inc/TFile.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros ; TFile.h File Reference. #include <atomic>; #include <string>; #include ""Compression.h""; #include ""TDirectoryFile.h""; #include ""TUrl.h""; #include ""ROOT/RConcurrentHashColl.hxx""; #include ""ROOT/TRWSpinLock.hxx""; #include <mutex>. Include dependency graph for TFile.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TFile::InfoListRet;  Simple struct of the return value of GetStreamerInfoListImpl. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  . Macros; #define gFile   (TFile::CurrentFile());  . Macro Definition Documentation. ◆ gFile. #define gFile   (TFile::CurrentFile()). Definition at line 347 of file TFile.h. ioioincTFile.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFile_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h.html
https://root.cern/doc/master/TFile_8h_source.html:47335,Availability,recover,recover,47335,"Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::EStatusBitsEStatusBitsTFile status bits. BIT(13) is taken up by TObject.Definition TFile.h:183; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:8851,Deployability,release,releases,8851,"nt_t SysSync(Int_t fd);; 165 ; 166 // Interface for text-based TDirectory I/O; 167 virtual Long64_t DirCreateEntry(TDirectory*) { return 0; }; 168 virtual Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:50045,Energy Efficiency,efficient,efficient,50045,"ile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFreeService class for TFile.Definition TFree.h:27; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListA doubly linked list.Definition TList.h:38; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TProcessIDA TProcessID identifies a ROOT job in a unique way in time and space.Definition TProcessID.h:74; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TUrlThis class represents a WWW compatible URL.Definition TUrl.h:33; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:1079,Integrability,interface,interface,1079,".; Searching...; No Matches. TFile.h. Go to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Rene Brun 28/11/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TFile; 13#define ROOT_TFile; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TFile //; 19// //; 20// ROOT file. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include <atomic>; 25#include <string>; 26 ; 27#include ""Compression.h""; 28#include ""TDirectoryFile.h""; 29#include ""TUrl.h""; 30#include ""ROOT/RConcurrentHashColl.hxx""; 31 ; 32// Not a part of TFile interface; provide a forward declaration instead of #include.; 33// #ifndef R__LESS_INCLUDES; 34// #include ""TMap.h""; 35// #endif; 36 ; 37#ifdef R__USE_IMT; 38#include ""ROOT/TRWSpinLock.hxx""; 39#include <mutex>; 40#endif; 41 ; 42class TMap;; 43class TFree;; 44class TArrayC;; 45class TArchiveFile;; 46class TFileOpenHandle;; 47class TFileCacheRead;; 48class TFileCacheWrite;; 49class TProcessID;; 50class TStopwatch;; 51class TFilePrefetch;; 52 ; 53class TFile : public TDirectoryFile {; 54 friend class TDirectoryFile;; 55 friend class TFilePrefetch;; 56// TODO: We need to make sure only one TBasket is being written at a time; 57// if we are writing multiple baskets in parallel.; 58#ifdef R__USE_IMT; 59 friend class TBasket;; 60#endif; 61 ; 62public:; 63 /// Asynchronous open request status; 64 enum EAsyncOpenStatus { kAOSNotAsync = -1, kAOSFailure = 0,; 65 kAOSInProgress = 1, kAOSSuccess = 2 };; 66 /// Open timeout constants; 67 enum EOpenTimeOut { kInstantTimeout = 0, kEternalTimeout = 999999999 };; 6",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:7444,Integrability,rout,routines,7444," buffer size; 135 static Bool_t fgReadInfo; ///<if true (default) ReadStreamerInfo is called when opening a file; 136 ; 137 virtual EAsyncOpenStatus GetAsyncOpenStatus() { return fAsyncOpenStatus; }; 138 virtual void Init(Bool_t create);; 139 Bool_t FlushWriteCache();; 140 Int_t ReadBufferViaCache(char *buf, Int_t len);; 141 Int_t WriteBufferViaCache(const char *buf, Int_t len);; 142 ; 143 ////////////////////////////////////////////////////////////////////////////////; 144 /// \brief Simple struct of the return value of GetStreamerInfoListImpl; 145 struct InfoListRet {; 146 TList *fList;; 147 Int_t fReturnCode;; 148 ROOT::Internal::RConcurrentHashColl::HashValue fHash;; 149 };; 150 ; 151 virtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache);; 152 ; 153 // Creating projects; 154 Int_t MakeProjectParMake(const char *packname, const char *filename);; 155 Int_t MakeProjectParProofInf(const char *packname, const char *proofinfdir);; 156 ; 157 // Interface to basic system I/O routines; 158 virtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode);; 159 virtual Int_t SysClose(Int_t fd);; 160 virtual Int_t SysRead(Int_t fd, void *buf, Int_t len);; 161 virtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len);; 162 virtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence);; 163 virtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime);; 164 virtual Int_t SysSync(Int_t fd);; 165 ; 166 // Interface for text-based TDirectory I/O; 167 virtual Long64_t DirCreateEntry(TDirectory*) { return 0; }; 168 virtual Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:9022,Integrability,depend,dependency,9022," Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 virtual Bool_t Cp(const char *dst, Bool_t progressbar = kTRUE,UInt_t buffersize = 1000000);; 211 virtual TKey* CreateKey(TDirectory* mother, const TObjec",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:41182,Integrability,protocol,protocol,41182,"rrno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::SetOptionvirtual void SetOption(Option_t *option="">"")Definition TFile.h:289; TFile::EFileTypeEFileTypeFile type.Definition TFile.h:202; TFile::kWeb@ kWebDefinition TFile.h:202; TFile::kDefault@ kDefaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBy",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:3360,Performance,cache,cache,3360,bjects written so far; 75 Long64_t fBytesWrite{0}; ///<Number of bytes written to this file; 76 Long64_t fBytesRead{0}; ///<Number of bytes read from this file; 77 Long64_t fBytesReadExtra{0}; ///<Number of extra bytes (overhead) read by the readahead buffer; 78 Long64_t fBEGIN{0}; ///<First used byte in file; 79 Long64_t fEND{0}; ///<Last used byte in file; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to f,MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:3815,Performance,cache,cache,3815,"ile; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to force the anchor to be appended to the file name; 104 Bool_t fIsRootFile{kTRUE}; ///<!True is this is a ROOT file, raw file otherwise; 105 Bool_t fInitDone{kFALSE}; ///<!True if the file has been initialized; 106 Bool_t fMustFlush{kTRUE}; ///<!True if the file buffers must be flushed; 107 Bool_t fIsPcmFile{kFALSE}; ///<!True if the file is a ROOT pcm file.",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:3971,Performance,cache,cache,3971,"ile; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to force the anchor to be appended to the file name; 104 Bool_t fIsRootFile{kTRUE}; ///<!True is this is a ROOT file, raw file otherwise; 105 Bool_t fInitDone{kFALSE}; ///<!True if the file has been initialized; 106 Bool_t fMustFlush{kTRUE}; ///<!True if the file buffers must be flushed; 107 Bool_t fIsPcmFile{kFALSE}; ///<!True if the file is a ROOT pcm file.",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:4045,Performance,cache,cache,4045,"ile; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to force the anchor to be appended to the file name; 104 Bool_t fIsRootFile{kTRUE}; ///<!True is this is a ROOT file, raw file otherwise; 105 Bool_t fInitDone{kFALSE}; ///<!True if the file has been initialized; 106 Bool_t fMustFlush{kTRUE}; ///<!True if the file buffers must be flushed; 107 Bool_t fIsPcmFile{kFALSE}; ///<!True if the file is a ROOT pcm file.",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:4130,Performance,cache,cache,4130,"ile; 80 Long64_t fSeekFree{0}; ///<Location on disk of free segments structure; 81 Long64_t fSeekInfo{0}; ///<Location on disk of StreamerInfo record; 82 Int_t fD{-1}; ///<File descriptor; 83 Int_t fVersion{0}; ///<File format version; 84 Int_t fCompress{0}; ///<Compression level and algorithm; 85 Int_t fNbytesFree{0}; ///<Number of bytes for free segments structure; 86 Int_t fNbytesInfo{0}; ///<Number of bytes for StreamerInfo record; 87 Int_t fWritten{0}; ///<Number of objects written so far; 88 Int_t fNProcessIDs{0}; ///<Number of TProcessID written to this file; 89 Int_t fReadCalls{0}; ///<Number of read calls ( not counting the cache calls ); 90 TString fRealName; ///<Effective real file name (not original url); 91 TString fOption; ///<File options; 92 Char_t fUnits{0}; ///<Number of bytes for file pointers; 93 TList *fFree{nullptr}; ///<Free segments linked list table; 94 TArrayC *fClassIndex{nullptr}; ///<!Index of TStreamerInfo classes written to this file; 95 TObjArray *fProcessIDs{nullptr}; ///<!Array of pointers to TProcessIDs; 96 Long64_t fOffset{0}; ///<!Seek offset cache; 97 TArchiveFile *fArchive{nullptr}; ///<!Archive file from which we read this file; 98 TFileCacheRead *fCacheRead{nullptr}; ///<!Pointer to the read cache (if any); 99 TMap *fCacheReadMap{nullptr}; ///<!Pointer to the read cache (if any); 100 TFileCacheWrite *fCacheWrite{nullptr}; ///<!Pointer to the write cache (if any); 101 Long64_t fArchiveOffset{0}; ///<!Offset at which file starts in archive; 102 Bool_t fIsArchive{kFALSE}; ///<!True if this is a pure archive file; 103 Bool_t fNoAnchorInName{kFALSE}; ///<!True if we don't want to force the anchor to be appended to the file name; 104 Bool_t fIsRootFile{kTRUE}; ///<!True is this is a ROOT file, raw file otherwise; 105 Bool_t fInitDone{kFALSE}; ///<!True if the file has been initialized; 106 Bool_t fMustFlush{kTRUE}; ///<!True if the file buffers must be flushed; 107 Bool_t fIsPcmFile{kFALSE}; ///<!True if the file is a ROOT pcm file.",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:5673,Performance,cache,cache,5673,,MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:5703,Performance,cache,cached,5703,,MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:13997,Performance,cache,cache,13997,");; 264 virtual void MakeProject(const char *dirname, const char *classes=""*"",; 265 Option_t *option=""new""); // *MENU*; 266 virtual void Map(Option_t *opt); // *MENU*; 267 virtual void Map() { Map(""""); }; // *MENU*; 268 virtual Bool_t Matches(const char *name);; 269 virtual Bool_t MustFlush() const {return fMustFlush;}; 270 void Paint(Option_t *option="""") override;; 271 void Print(Option_t *option="""") const override;; 272 virtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len);; 273 virtual Bool_t ReadBuffer(char *buf, Int_t len);; 274 virtual Bool_t ReadBuffer(char *buf, Long64_t pos, Int_t len);; 275 virtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);; 276 virtual void ReadFree();; 277 virtual TProcessID *ReadProcessID(UShort_t pidf);; 278 virtual void ReadStreamerInfo();; 279 virtual Int_t Recover();; 280 virtual Int_t ReOpen(Option_t *mode);; 281 virtual void Seek(Long64_t offset, ERelativeTo pos = kBeg);; 282 virtual void SetCacheRead(TFileCacheRead *cache, TObject *tree = nullptr, ECacheAction action = kDisconnect);; 283 virtual void SetCacheWrite(TFileCacheWrite *cache);; 284 virtual void SetCompressionAlgorithm(Int_t algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 285 virtual void SetCompressionLevel(Int_t level = ROOT::RCompressionSetting::ELevel::kUseMin);; 286 virtual void SetCompressionSettings(Int_t settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 287 virtual void SetEND(Long64_t last) { fEND = last; }; 288 virtual void SetOffset(Long64_t offset, ERelativeTo pos = kBeg);; 289 virtual void SetOption(Option_t *option="">"") { fOption = option; }; 290 virtual void SetReadCalls(Int_t readcalls = 0) { fReadCalls = readcalls; }; 291 virtual void ShowStreamerInfo();; 292 Int_t Sizeof() const override;; 293 void SumBuffer(Int_t bufsize);; 294 virtual Bool_t WriteBuffer(const char *buf, Int_t len);; 295 Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) override;; 296 Int_t Write(co",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:14114,Performance,cache,cache,14114,"*; 266 virtual void Map(Option_t *opt); // *MENU*; 267 virtual void Map() { Map(""""); }; // *MENU*; 268 virtual Bool_t Matches(const char *name);; 269 virtual Bool_t MustFlush() const {return fMustFlush;}; 270 void Paint(Option_t *option="""") override;; 271 void Print(Option_t *option="""") const override;; 272 virtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len);; 273 virtual Bool_t ReadBuffer(char *buf, Int_t len);; 274 virtual Bool_t ReadBuffer(char *buf, Long64_t pos, Int_t len);; 275 virtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);; 276 virtual void ReadFree();; 277 virtual TProcessID *ReadProcessID(UShort_t pidf);; 278 virtual void ReadStreamerInfo();; 279 virtual Int_t Recover();; 280 virtual Int_t ReOpen(Option_t *mode);; 281 virtual void Seek(Long64_t offset, ERelativeTo pos = kBeg);; 282 virtual void SetCacheRead(TFileCacheRead *cache, TObject *tree = nullptr, ECacheAction action = kDisconnect);; 283 virtual void SetCacheWrite(TFileCacheWrite *cache);; 284 virtual void SetCompressionAlgorithm(Int_t algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);; 285 virtual void SetCompressionLevel(Int_t level = ROOT::RCompressionSetting::ELevel::kUseMin);; 286 virtual void SetCompressionSettings(Int_t settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 287 virtual void SetEND(Long64_t last) { fEND = last; }; 288 virtual void SetOffset(Long64_t offset, ERelativeTo pos = kBeg);; 289 virtual void SetOption(Option_t *option="">"") { fOption = option; }; 290 virtual void SetReadCalls(Int_t readcalls = 0) { fReadCalls = readcalls; }; 291 virtual void ShowStreamerInfo();; 292 Int_t Sizeof() const override;; 293 void SumBuffer(Int_t bufsize);; 294 virtual Bool_t WriteBuffer(const char *buf, Int_t len);; 295 Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) override;; 296 Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) const override;; 297 virtual void WriteFree();; 298 virtual void",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:16651,Performance,cache,cacheDir,16651,"TFile *Open(TFileOpenHandle *handle);; 310 ; 311 static EFileType GetType(const char *name, Option_t *option = """", TString *prefix = nullptr);; 312 ; 313 static EAsyncOpenStatus GetAsyncOpenStatus(const char *name);; 314 static EAsyncOpenStatus GetAsyncOpenStatus(TFileOpenHandle *handle);; 315 static const TUrl *GetEndpointUrl(const char *name);; 316 ; 317 static Long64_t GetFileBytesRead();; 318 static Long64_t GetFileBytesWritten();; 319 static Int_t GetFileReadCalls();; 320 static Int_t GetReadaheadSize();; 321 ; 322 static void SetFileBytesRead(Long64_t bytes = 0);; 323 static void SetFileBytesWritten(Long64_t bytes = 0);; 324 static void SetFileReadCalls(Int_t readcalls = 0);; 325 static void SetReadaheadSize(Int_t bufsize = 256000);; 326 static void SetReadStreamerInfo(Bool_t readinfo=kTRUE);; 327 static Bool_t GetReadStreamerInfo();; 328 ; 329 static Long64_t GetFileCounter();; 330 static void IncrementFileCounter();; 331 ; 332 static Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected = kTRUE,; 333 Bool_t forceCacheread = kFALSE);; 334 static const char *GetCacheFileDir();; 335 static Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0);; 336 static Bool_t Cp(const char *src, const char *dst, Bool_t progressbar = kTRUE,; 337 UInt_t buffersize = 1000000);; 338 ; 339 static UInt_t SetOpenTimeout(UInt_t timeout); // in ms; 340 static UInt_t GetOpenTimeout(); // in ms; 341 static Bool_t SetOnlyStaged(Bool_t onlystaged);; 342 static Bool_t GetOnlyStaged();; 343 ; 344 ClassDefOverride(TFile,8) //ROOT file; 345};; 346 ; 347#define gFile (TFile::CurrentFile()); 348 ; 349/**; 350\class TFileOpenHandle; 351\ingroup IO; 352Class holding info about the file being opened; 353*/; 354class TFileOpenHandle : public TNamed {; 355 ; 356friend class TFile;; 357 ; 358private:; 359 TString fOpt; ///< Options; 360 Int_t fCompress{0}; ///< Compression level and algorithm; 361 Int_t fNetOpt{0}; ///< Network options; 362 TFile *fFile{null",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:24436,Performance,cache,cache,24436,"x; TUrl.h; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; TArchiveFileClass describing an archive file containing multiple sub-files, like a ZIP or TAR archive.Definition TArchiveFile.h:24; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFileA ROOT file is structured in Directories (like a file system).Definition TDirectoryFile.h:32; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::fNetOptInt_t fNetOptNetwork options.Definition TFile.h:361; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(TFile *f)Definition TFile.h:364; TFileOpenHandle::fOptTString fOptOptions.Definition TFile.h:359; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp, Int_t no)Definition TFile.h:366; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::operator=TFileOpenHandle & operator=(const TFileOpenHandle &)=delete; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::fCompressInt_t fCompressCompression level and algor",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:24527,Performance,cache,cache,24527,"x:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; TArchiveFileClass describing an archive file containing multiple sub-files, like a ZIP or TAR archive.Definition TArchiveFile.h:24; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFileA ROOT file is structured in Directories (like a file system).Definition TDirectoryFile.h:32; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::fNetOptInt_t fNetOptNetwork options.Definition TFile.h:361; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(TFile *f)Definition TFile.h:364; TFileOpenHandle::fOptTString fOptOptions.Definition TFile.h:359; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp, Int_t no)Definition TFile.h:366; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::operator=TFileOpenHandle & operator=(const TFileOpenHandle &)=delete; TFileOpenHandle::GetFileTFile * GetFile() constDefinition TFile.h:372; TFileOpenHandle::fCompressInt_t fCompressCompression level and algorithm.Definition TFile.h:360; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition T",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:26432,Performance,cache,cache,26432,"_t fCompressCompression level and algorithm.Definition TFile.h:360; TFileOpenHandle::GetOptconst char * GetOpt() constDefinition TFile.h:379; TFileOpenHandle::TFileOpenHandleTFileOpenHandle(const TFileOpenHandle &)=delete; TFileOpenHandle::MatchesBool_t Matches(const char *name)Return kTRUE if this async request matches the open request specified by 'url'.Definition TFile.cxx:4790; TFileOpenHandle::~TFileOpenHandle~TFileOpenHandle() overrideDefinition TFile.h:375; TFileOpenHandle::GetCompressInt_t GetCompress() constDefinition TFile.h:380; TFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a bloc...Definition TFilePrefetch.h:33; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::fgBytesReadstatic std::atomic< Long64_t > fgBytesReadNumber of bytes read by all TFile objects.Definition TFile.h:131; TFile::fReadCallsInt_t fReadCallsNumber of read calls ( not counting the cache calls )Definition TFile.h:89; TFile::SetFileBytesWrittenstatic void SetFileBytesWritten(Long64_t bytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::GetSeekFreevirtual Long64_t GetSeekFree() constDefinition TFile.h:252; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounter",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:27589,Performance,cache,cache,27589,"ytes=0)Definition TFile.cxx:4611; TFile::fgCacheFileForcestatic Bool_t fgCacheFileForceIndicates, to force all READ to CACHEREAD.Definition TFile.h:126; TFile::fBytesReadLong64_t fBytesReadNumber of bytes read from this file.Definition TFile.h:76; TFile::GetSeekFreevirtual Long64_t GetSeekFree() constDefinition TFile.h:252; TFile::ReadProcessIDvirtual TProcessID * ReadProcessID(UShort_t pidf)The TProcessID with number pidf is read from this file.Definition TFile.cxx:1951; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Seekvirtual void Seek(Long64_t offset, ERelativeTo pos=kBeg)Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefiniti",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:28273,Performance,cache,cache,28273,"eg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefinition TFile.h:245; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this fi",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:28303,Performance,cache,cached,28303,"eg, kCur or kEnd.Definition TFile.cxx:2274; TFile::GetOnlyStagedstatic Bool_t GetOnlyStaged()Returns staged only flag.Definition TFile.cxx:4754; TFile::IncrementFileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefinition TFile.h:245; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this fi",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:28414,Performance,cache,cached,28414,"FileCounterstatic void IncrementFileCounter()Definition TFile.cxx:4620; TFile::ShrinkCacheFileDirstatic Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval=0)Try to shrink the cache to the desired size.Definition TFile.cxx:4666; TFile::fSeekFreeLong64_t fSeekFreeLocation on disk of free segments structure.Definition TFile.h:80; TFile::fgReadaheadSizestatic Int_t fgReadaheadSizeReadahead buffer size.Definition TFile.h:134; TFile::FillBuffervoid FillBuffer(char *&buffer) overrideEncode file output buffer.Definition TFile.cxx:1170; TFile::fSum2BufferDouble_t fSum2BufferSum of squares of buffer sizes of objects written so far.Definition TFile.h:74; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefinition TFile.h:245; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.c",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:29585,Performance,cache,cache,29585,"adStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::IsBinaryBool_t IsBinary() constDefinition TFile.h:259; TFile::IsRawBool_t IsRaw() constDefinition TFile.h:260; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; TFile::kStartBigFile@ kStartBigFileDefinition TFile.h:200; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::SetReadStreamerInfostatic void SetReadStreamerInfo(Bool_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefini",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:29673,Performance,cache,cache,29673,"adStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::IsBinaryBool_t IsBinary() constDefinition TFile.h:259; TFile::IsRawBool_t IsRaw() constDefinition TFile.h:260; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lookupSICache)See documentation of GetStreamerInfoList for more details.Definition TFile.cxx:1376; TFile::kStartBigFile@ kStartBigFileDefinition TFile.h:200; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::SetReadStreamerInfostatic void SetReadStreamerInfo(Bool_t readinfo=kTRUE)Specify if the streamerinfos must be read at file opening.Definition TFile.cxx:3732; TFile::fNoAnchorInNameBool_t fNoAnchorInName!True if we don't want to force the anchor to be appended to the file nameDefini",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:31649,Performance,cache,cache,31649,"tion TFile.h:103; TFile::DirReadKeysvirtual Int_t DirReadKeys(TDirectory *)Definition TFile.h:168; TFile::SetFileBytesReadstatic void SetFileBytesRead(Long64_t bytes=0)Definition TFile.cxx:4608; TFile::GetClassIndexTArrayC * GetClassIndex() constDefinition TFile.h:226; TFile::fSeekInfoLong64_t fSeekInfoLocation on disk of StreamerInfo record.Definition TFile.h:81; TFile::Paintvoid Paint(Option_t *option="""") overridePaint all objects in the file.Definition TFile.cxx:1698; TFile::GetListOfFreeTList * GetListOfFree() constDefinition TFile.h:237; TFile::GetBestBufferInt_t GetBestBuffer() constReturn the best buffer size of objects on this file.Definition TFile.cxx:1183; TFile::fOpenPhasesTList * fOpenPhases!Time info about open phasesDefinition TFile.h:113; TFile::SetCompressionLevelvirtual void SetCompressionLevel(Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin)See comments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::Copyvoid Copy(TObject &) const overrideC",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:33355,Performance,cache,cache,33355,"for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::Copyvoid Copy(TObject &) const overrideCopy this to obj.Definition TFile.h:209; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::GetArchiveOffsetLong64_t GetArchiveOffset() constDefinition TFile.h:221; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::operator=void operator=(const TFile &)=delete; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBu",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:33631,Performance,cache,cache,33631,"onst overrideCopy this to obj.Definition TFile.h:209; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::GetArchiveOffsetLong64_t GetArchiveOffset() constDefinition TFile.h:221; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total number of bytes read from all files.Definition TFile.cxx:4574; TFile::ReadBufferViaCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::operator=void operator=(const TFile &)=delete; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cac",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:34583,Performance,cache,cache,34583,"aCacheInt_t ReadBufferViaCache(char *buf, Int_t len)Read buffer via cache.Definition TFile.cxx:1889; TFile::operator=void operator=(const TFile &)=delete; TFile::CreateKeyvirtual TKey * CreateKey(TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize)Creates key for object and converts data to buffer.Definition TFile.cxx:1047; TFile::Mapvirtual void Map()Definition TFile.h:267; TFile::WriteFreevirtual void WriteFree()Write FREE linked list on the file.Definition TFile.cxx:2543; TFile::GetReadaheadSizestatic Int_t GetReadaheadSize()Static function returning the readahead buffer size.Definition TFile.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::EOpenTimeOutEOpenTimeOutOpen timeout constants.Definition TFile.h:67; TFile::kInstantTimeout@ kInstantTimeoutDefinition TFile.h:67; TFile::kEter",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:37593,Performance,cache,cache,37593,"l void SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Used to specify the compression level and algorithm.Definition TFile.cxx:2338; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::fgReadInfostatic Bool_t fgReadInfoif true (default) ReadStreamerInfo is called when opening a fileDefinition TFile.h:135; TFile::Initvirtual void Init(Bool_t create)Initialize a TFile object.Definition TFile.cxx:613; TFile::TFileTFile(const TFile &)=delete; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::SetReadCallsvirtual void SetReadCalls(Int_t readcalls=0)Definition TFile.h:290; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::GetNfreevirtual Int_t GetNfree() constDefinition TFile.h:238; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TF",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:37626,Performance,cache,cache,37626,"l void SetCompressionSettings(Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault)Used to specify the compression level and algorithm.Definition TFile.cxx:2338; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::fgReadInfostatic Bool_t fgReadInfoif true (default) ReadStreamerInfo is called when opening a fileDefinition TFile.h:135; TFile::Initvirtual void Init(Bool_t create)Initialize a TFile object.Definition TFile.cxx:613; TFile::TFileTFile(const TFile &)=delete; TFile::GetRelOffsetLong64_t GetRelOffset() constDefinition TFile.h:251; TFile::SetReadCallsvirtual void SetReadCalls(Int_t readcalls=0)Definition TFile.h:290; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::GetNfreevirtual Int_t GetNfree() constDefinition TFile.h:238; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TF",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:38221,Performance,cache,cache,38221,"; TFile::SetReadCallsvirtual void SetReadCalls(Int_t readcalls=0)Definition TFile.h:290; TFile::AsyncOpenstatic TFileOpenHandle * AsyncOpen(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Submit an asynchronous open request.Definition TFile.cxx:4351; TFile::SetCacheWritevirtual void SetCacheWrite(TFileCacheWrite *cache)Set a pointer to the write cache.Definition TFile.cxx:2388; TFile::fOptionTString fOptionFile options.Definition TFile.h:91; TFile::GetNfreevirtual Int_t GetNfree() constDefinition TFile.h:238; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteBuffervirtual Bool_t WriteBuffer(const char *buf, Int_t len)Write a buffer to the file.Definition TFile.cxx:2476; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::GetCacheFileDirstatic const char * GetCacheFileDir()Get the directory where to locally stage/cache remote files.Definition TFile.cxx:4654; TFile::EAsyncOpenStatusEAsyncOpenStatusAsynchronous open request status.Definition TFile.h:64; TFile::kAOSSuccess@ kAOSSuccessDefinition TFile.h:65; TFile::kAOSNotAsync@ kAOSNotAsyncDefinition TFile.h:64; TFile::kAOSInProgress@ kAOSInProgressDefinition TFile.h:65; TFile::kAOSFailure@ kAOSFailureDefinition TFile.h:64; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::GetBytesWrittenvirtual Long64_t GetBytesWritten() constReturn the total number of bytes written so far to the file.Definition TFile.cxx:4566; TFile::ERelativeToERelativeToDefinition TFile.h:199; TFile::kCur@ kCurDefinition TFile.h:199; TFile::kBeg@ kBegDefinition TFile.h:199; TFile::kEnd@ kEndDefinition TFile.h:199; TFile::GetSeekInfovirtual Long64_t GetSeekInfo() constDefinition TFile.h:253; ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:40326,Performance,cache,cache,40326,"tNbytesFree() constDefinition TFile.h:249; TFile::IsArchivevirtual Bool_t IsArchive() constDefinition TFile.h:258; TFile::CurrentFilestatic TFile *& CurrentFile()Return the current ROOT file if any.Definition TFile.cxx:1067; TFile::SetENDvirtual void SetEND(Long64_t last)Definition TFile.h:287; TFile::SetCompressionAlgorithmvirtual void SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)See comments for function SetCompressionSettings.Definition TFile.cxx:2305; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::fNbytesFreeInt_t fNbytesFreeNumber of bytes for free segments structure.Definition TFile.h:85; TFile::fDInt_t fDFile descriptor.Definition TFile.h:82; TFile::ResetErrnovirtual void ResetErrno() constMethod resetting the errno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::SetOptionvirtual void SetOption(Option_t *option="">"")Defi",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:40613,Performance,cache,cache,40613,"; TFile::SetCompressionAlgorithmvirtual void SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)See comments for function SetCompressionSettings.Definition TFile.cxx:2305; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::fNbytesFreeInt_t fNbytesFreeNumber of bytes for free segments structure.Definition TFile.h:85; TFile::fDInt_t fDFile descriptor.Definition TFile.h:82; TFile::ResetErrnovirtual void ResetErrno() constMethod resetting the errno.Definition TFile.cxx:1254; TFile::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the file header.Definition TFile.cxx:2397; TFile::FlushWriteCacheBool_t FlushWriteCache()Flush the write cache if active.Definition TFile.cxx:1158; TFile::IncrementProcessIDsvirtual void IncrementProcessIDs()Definition TFile.h:257; TFile::fIsPcmFileBool_t fIsPcmFile!True if the file is a ROOT pcm file.Definition TFile.h:107; TFile::fCacheReadTFileCacheRead * fCacheRead!Pointer to the read cache (if any)Definition TFile.h:98; TFile::SysClosevirtual Int_t SysClose(Int_t fd)Interface to system close. All arguments like in POSIX close().Definition TFile.cxx:4497; TFile::TFileTFile()File default Constructor.Definition TFile.cxx:201; TFile::fUnitsChar_t fUnitsNumber of bytes for file pointers.Definition TFile.h:92; TFile::fProcessIDsTObjArray * fProcessIDs!Array of pointers to TProcessIDsDefinition TFile.h:95; TFile::GetTypestatic EFileType GetType(const char *name, Option_t *option="""", TString *prefix=nullptr)Resolve the file type as a function of the protocol field in 'name'.Definition TFile.cxx:4821; TFile::SetOptionvirtual void SetOption(Option_t *option="">"")Definition TFile.h:289; TFile::EFileTypeEFileTypeFile type.Definition TFile.h:202; TFile::kWeb@ kWebDefinition TFile.h:202; TFile::kDefault@ kDefaultDefinition TFile.h:202; TFile::kLocal@ kLocalDefinition TFile.h:202; TFile::kMerge@ kMergeDefinition TFile.h:202; TFile::kNet@ kNetDefinition TFile.h:",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:44609,Performance,cache,cache,44609,"efinition TFile.cxx:1141; TFile::DirWriteKeysvirtual void DirWriteKeys(TDirectory *)Definition TFile.h:169; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::fWriteMutexstd::mutex fWriteMutex!Lock for writing baskets / keys into the file.Definition TFile.h:118; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw map of objects in this file.Definition TFile.cxx:1128; TFile::DirWriteHeadervirtual void DirWriteHeader(TDirectory *)Definition TFile.h:170; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::fCacheWriteTFileCacheWrite * fCacheWrite!Pointer to the write cache (if any)Definition TFile.h:100; TFile::fRealNameTString fRealNameEffective real file name (not original url)Definition TFile.h:90; TFile::SetOffsetvirtual void SetOffset(Long64_t offset, ERelativeTo pos=kBeg)Set position from where to start reading.Definition TFile.cxx:2253; TFile::fOffsetLong64_t fOffset!Seek offset cacheDefinition TFile.h:96; TFile::fgBytesWritestatic std::atomic< Long64_t > fgBytesWriteNumber of bytes written by all TFile objects.Definition TFile.h:130; TFile::GetNbytesInfovirtual Int_t GetNbytesInfo() constDefinition TFile.h:248; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::MustFlushvirtual Bool_t MustFlush() constDefinition TFile.h:269; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:44934,Performance,cache,cacheDefinition,44934,"!Lock for writing baskets / keys into the file.Definition TFile.h:118; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw map of objects in this file.Definition TFile.cxx:1128; TFile::DirWriteHeadervirtual void DirWriteHeader(TDirectory *)Definition TFile.h:170; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::fCacheWriteTFileCacheWrite * fCacheWrite!Pointer to the write cache (if any)Definition TFile.h:100; TFile::fRealNameTString fRealNameEffective real file name (not original url)Definition TFile.h:90; TFile::SetOffsetvirtual void SetOffset(Long64_t offset, ERelativeTo pos=kBeg)Set position from where to start reading.Definition TFile.cxx:2253; TFile::fOffsetLong64_t fOffset!Seek offset cacheDefinition TFile.h:96; TFile::fgBytesWritestatic std::atomic< Long64_t > fgBytesWriteNumber of bytes written by all TFile objects.Definition TFile.h:130; TFile::GetNbytesInfovirtual Int_t GetNbytesInfo() constDefinition TFile.h:248; TFile::fInfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::MustFlushvirtual Bool_t MustFlush() constDefinition TFile.h:269; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:46153,Performance,cache,cacheDir,46153,"InfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::MustFlushvirtual Bool_t MustFlush() constDefinition TFile.h:269; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallss",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:46268,Performance,cache,cache,46268,"InfoCacheTList * fInfoCache!Cached list of the streamer infos in this fileDefinition TFile.h:112; TFile::MustFlushvirtual Bool_t MustFlush() constDefinition TFile.h:269; TFile::GetBytesToPrefetchvirtual Int_t GetBytesToPrefetch() constMax number of bytes to prefetch.Definition TFile.cxx:5222; TFile::fgOpenTimeoutstatic UInt_t fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o.Definition TFile.h:127; TFile::MakeProjectParMakeInt_t MakeProjectParMake(const char *packname, const char *filename)Create makefile at 'filemake' for PAR package 'pack'.Definition TFile.cxx:3364; TFile::fENDLong64_t fENDLast used byte in file.Definition TFile.h:79; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallss",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:48450,Performance,cache,cache,48450,"to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::EStatusBitsEStatusBitsTFile status bits. BIT(13) is taken up by TObject.Definition TFile.h:183; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetF",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:49565,Performance,cache,cache,49565,"nt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFreeService class for TFile.Definition TFree.h:27; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListA doubly linked list.Definition TList.h:38; TMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval ...Definition TMap.h:40; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:1996,Safety,timeout,timeout,1996,"; 58#ifdef R__USE_IMT; 59 friend class TBasket;; 60#endif; 61 ; 62public:; 63 /// Asynchronous open request status; 64 enum EAsyncOpenStatus { kAOSNotAsync = -1, kAOSFailure = 0,; 65 kAOSInProgress = 1, kAOSSuccess = 2 };; 66 /// Open timeo",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:9005,Safety,avoid,avoid,9005," Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 virtual Bool_t Cp(const char *dst, Bool_t progressbar = kTRUE,UInt_t buffersize = 1000000);; 211 virtual TKey* CreateKey(TDirectory* mother, const TObjec",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:17031,Safety,timeout,timeout,17031,"leBytesRead();; 318 static Long64_t GetFileBytesWritten();; 319 static Int_t GetFileReadCalls();; 320 static Int_t GetReadaheadSize();; 321 ; 322 static void SetFileBytesRead(Long64_t bytes = 0);; 323 static void SetFileBytesWritten(Long64_t bytes = 0);; 324 static void SetFileReadCalls(Int_t readcalls = 0);; 325 static void SetReadaheadSize(Int_t bufsize = 256000);; 326 static void SetReadStreamerInfo(Bool_t readinfo=kTRUE);; 327 static Bool_t GetReadStreamerInfo();; 328 ; 329 static Long64_t GetFileCounter();; 330 static void IncrementFileCounter();; 331 ; 332 static Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected = kTRUE,; 333 Bool_t forceCacheread = kFALSE);; 334 static const char *GetCacheFileDir();; 335 static Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0);; 336 static Bool_t Cp(const char *src, const char *dst, Bool_t progressbar = kTRUE,; 337 UInt_t buffersize = 1000000);; 338 ; 339 static UInt_t SetOpenTimeout(UInt_t timeout); // in ms; 340 static UInt_t GetOpenTimeout(); // in ms; 341 static Bool_t SetOnlyStaged(Bool_t onlystaged);; 342 static Bool_t GetOnlyStaged();; 343 ; 344 ClassDefOverride(TFile,8) //ROOT file; 345};; 346 ; 347#define gFile (TFile::CurrentFile()); 348 ; 349/**; 350\class TFileOpenHandle; 351\ingroup IO; 352Class holding info about the file being opened; 353*/; 354class TFileOpenHandle : public TNamed {; 355 ; 356friend class TFile;; 357 ; 358private:; 359 TString fOpt; ///< Options; 360 Int_t fCompress{0}; ///< Compression level and algorithm; 361 Int_t fNetOpt{0}; ///< Network options; 362 TFile *fFile{nullptr}; ///< TFile instance of the file being opened; 363 ; 364 TFileOpenHandle(TFile *f) : TNamed("""",""""), fOpt(""""), fCompress(ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault),; 365 fNetOpt(0), fFile(f) { }; 366 TFileOpenHandle(const char *n, const char *o, const char *t, Int_t cmp,; 367 Int_t no) : TNamed(n,t), fOpt(o), fCompress(cmp),; 368 fNetOpt(no), fFile(nullptr)",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:23600,Safety,safe,safe,23600,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; TRWSpinLock.hxx; TUrl.h; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; TArchiveFileClass describing an archive file containing multiple sub-files, like a ZIP or TAR archive.Definition TArchiveFile.h:24; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFileA ROOT file is structured in Directories (like a file system).Definition TDirectoryFile.h:32; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFile",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:32509,Safety,timeout,timeout,32509,"omments for function SetCompressionSettings.Definition TFile.cxx:2319; TFile::GetCacheWriteTFileCacheWrite * GetCacheWrite() constReturn a pointer to the current write cache.Definition TFile.cxx:1279; TFile::SetFileReadCallsstatic void SetFileReadCalls(Int_t readcalls=0)Definition TFile.cxx:4614; TFile::fgCacheFileDirstatic TString fgCacheFileDirDirectory where to locally stage files.Definition TFile.h:124; TFile::SysReadvirtual Int_t SysRead(Int_t fd, void *buf, Int_t len)Interface to system read. All arguments like in POSIX read().Definition TFile.cxx:4506; TFile::fVersionInt_t fVersionFile format version.Definition TFile.h:83; TFile::Printvoid Print(Option_t *option="""") const overridePrint all objects in the file.Definition TFile.cxx:1706; TFile::fgFileCounterstatic std::atomic< Long64_t > fgFileCounterCounter for all opened files.Definition TFile.h:132; TFile::GetAsyncOpenStatusvirtual EAsyncOpenStatus GetAsyncOpenStatus()Definition TFile.h:137; TFile::GetOpenTimeoutstatic UInt_t GetOpenTimeout()Returns open timeout (in ms).Definition TFile.cxx:4734; TFile::Copyvoid Copy(TObject &) const overrideCopy this to obj.Definition TFile.h:209; TFile::CpProgressstatic void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch)Print file copy progress.Definition TFile.cxx:4975; TFile::GetArchiveOffsetLong64_t GetArchiveOffset() constDefinition TFile.h:221; TFile::fgOnlyStagedstatic Bool_t fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails.Definition TFile.h:128; TFile::GetNProcessIDsvirtual Int_t GetNProcessIDs() constDefinition TFile.h:239; TFile::fMustFlushBool_t fMustFlush!True if the file buffers must be flushedDefinition TFile.h:106; TFile::fUrlTUrl fUrl!URL of fileDefinition TFile.h:110; TFile::WriteBufferViaCacheInt_t WriteBufferViaCache(const char *buf, Int_t len)Write buffer via cache.Definition TFile.cxx:2519; TFile::GetFileBytesReadstatic Long64_t GetFileBytesRead()Static function returning the total n",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:35448,Safety,timeout,timeout,35448,":1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::EOpenTimeOutEOpenTimeOutOpen timeout constants.Definition TFile.h:67; TFile::kInstantTimeout@ kInstantTimeoutDefinition TFile.h:67; TFile::kEternalTimeout@ kEternalTimeoutDefinition TFile.h:67; TFile::fNbytesInfoInt_t fNbytesInfoNumber of bytes for StreamerInfo record.Definition TFile.h:86; TFile::GetSizevirtual Long64_t GetSize() constReturns the current file size.Definition TFile.cxx:1347; TFile::GetFdInt_t GetFd() constDefinition TFile.h:234; TFile::IsOpenvirtual Bool_t IsOpen() constReturns kTRUE in case file is open and kFALSE if file is not open.Definition TFile.cxx:1469; TFile::fAsyncHandleTFileOpenHandle * fAsyncHandle!For proper automatic cleanupDefinition TFile.h:108; TFile::SetOnlyStagedstatic Bool_t SetOnlyStaged(Bool_t onlystaged)Sets only staged flag.Definition TFile.cxx:4744; TFile::GetReadCallsvirtual Int_t GetReadCalls() constDefinition TFile.h:244; TFile::GetNewUrlvirtual TString GetNewUrl()Definition TFile.h:250; TFile::GetBytesReadvirtual Long64_t GetBytesRead() constDefinition TFil",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:42593,Safety,timeout,timeout,42593,"ion TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk stat",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:42611,Safety,timeout,timeout,42611,"ion TFile.h:202; TFile::kFile@ kFileDefinition TFile.h:202; TFile::ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk stat",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:42650,Safety,timeout,timeout,42650,"ShowStreamerInfovirtual void ShowStreamerInfo()Show the StreamerInfo of all classes written to this file.Definition TFile.cxx:3750; TFile::SysSeekvirtual Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence)Interface to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::DirWriteKeysvirtual void DirWr",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:47335,Safety,recover,recover,47335,"Int_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::fAsyncOpenStatusEAsyncOpenStatus fAsyncOpenStatus!Status of an asynchronous open requestDefinition TFile.h:109; TFile::fGlobalRegistrationbool fGlobalRegistration! if true, bypass use of global listsDefinition TFile.h:115; TFile::fSumBufferDouble_t fSumBufferSum of buffer sizes of objects written so far.Definition TFile.h:73; TFile::fIsArchiveBool_t fIsArchive!True if this is a pure archive fileDefinition TFile.h:102; TFile::GetListOfProcessIDsTObjArray * GetListOfProcessIDs() constDefinition TFile.h:236; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TFile::GetCompressionAlgorithmInt_t GetCompressionAlgorithm() constDefinition TFile.h:385; TFile::fgReadCallsstatic std::atomic< Int_t > fgReadCallsNumber of bytes read from all TFile objects.Definition TFile.h:133; TFile::Recovervirtual Int_t Recover()Attempt to recover file if not correctly closed.Definition TFile.cxx:2048; TFile::GetStreamerInfoListvirtual TList * GetStreamerInfoList() finalRead the list of TStreamerInfo objects written to this file.Definition TFile.cxx:1445; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::EStatusBitsEStatusBitsTFile status bits. BIT(13) is taken up by TObject.Definition TFile.h:183; TFile::kRecovered@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t ",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:5372,Security,hash,hashes,5372,,MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:23657,Security,hash,hash,23657,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; TRWSpinLock.hxx; TUrl.h; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; TArchiveFileClass describing an archive file containing multiple sub-files, like a ZIP or TAR archive.Definition TArchiveFile.h:24; TArrayCArray of chars or bytes (8 bits per element).Definition TArrayC.h:27; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFileA ROOT file is structured in Directories (like a file system).Definition TDirectoryFile.h:32; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFile",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:29101,Security,access,access,29101,"4; TFile::SetReadaheadSizestatic void SetReadaheadSize(Int_t bufsize=256000)Definition TFile.cxx:4605; TFile::fgCacheFileDisconnectedstatic Bool_t fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file.Definition TFile.h:125; TFile::GetStreamerInfoCacheconst TList * GetStreamerInfoCache()Returns the cached list of StreamerInfos used in this file.Definition TFile.cxx:1366; TFile::GetVersionInt_t GetVersion() constDefinition TFile.h:245; TFile::GetReadStreamerInfostatic Bool_t GetReadStreamerInfo()If the streamerinfos are to be read at file opening.Definition TFile.cxx:3742; TFile::fArchiveTArchiveFile * fArchive!Archive file from which we read this fileDefinition TFile.h:97; TFile::SysSyncvirtual Int_t SysSync(Int_t fd)Interface to system fsync. All arguments like in POSIX fsync().Definition TFile.cxx:4552; TFile::DirCreateEntryvirtual Long64_t DirCreateEntry(TDirectory *)Definition TFile.h:167; TFile::ReOpenvirtual Int_t ReOpen(Option_t *mode)Reopen a file with a different access mode.Definition TFile.cxx:2162; TFile::ReadStreamerInfovirtual void ReadStreamerInfo()Read the list of StreamerInfo from this file.Definition TFile.cxx:3605; TFile::Matchesvirtual Bool_t Matches(const char *name)Return kTRUE if 'url' matches the coordinates of this file.Definition TFile.cxx:4766; TFile::IsBinaryBool_t IsBinary() constDefinition TFile.h:259; TFile::IsRawBool_t IsRaw() constDefinition TFile.h:260; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::fClassIndexTArrayC * fClassIndex!Index of TStreamerInfo classes written to this fileDefinition TFile.h:94; TFile::GetFileBytesWrittenstatic Long64_t GetFileBytesWritten()Static function returning the total number of bytes written to all files.Definition TFile.cxx:4583; TFile::GetStreamerInfoListImplvirtual InfoListRet GetStreamerInfoListImpl(bool lo",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:35240,Security,access,access,35240,"File.cxx:4599; TFile::~TFile~TFile() overrideFile destructor.Definition TFile.cxx:563; TFile::ReadBuffersvirtual Bool_t ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf)Read the nbuf blocks described in arrays pos and len.Definition TFile.cxx:1821; TFile::GetFileCounterstatic Long64_t GetFileCounter()Definition TFile.cxx:4617; TFile::fCacheReadMapTMap * fCacheReadMap!Pointer to the read cache (if any)Definition TFile.h:99; TFile::fBEGINLong64_t fBEGINFirst used byte in file.Definition TFile.h:78; TFile::MakeProjectParProofInfInt_t MakeProjectParProofInf(const char *packname, const char *proofinfdir)Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.Definition TFile.cxx:3486; TFile::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)Check if the ProcessID pidd is already in the file, if not, add it and return the index number in the...Definition TFile.cxx:3763; TFile::MakeProjectvirtual void MakeProject(const char *dirname, const char *classes=""*"", Option_t *option=""new"")Generate source code necessary to access the objects stored in the file.Definition TFile.cxx:2726; TFile::fArchiveOffsetLong64_t fArchiveOffset!Offset at which file starts in archiveDefinition TFile.h:101; TFile::EOpenTimeOutEOpenTimeOutOpen timeout constants.Definition TFile.h:67; TFile::kInstantTimeout@ kInstantTimeoutDefinition TFile.h:67; TFile::kEternalTimeout@ kEternalTimeoutDefinition TFile.h:67; TFile::fNbytesInfoInt_t fNbytesInfoNumber of bytes for StreamerInfo record.Definition TFile.h:86; TFile::GetSizevirtual Long64_t GetSize() constReturns the current file size.Definition TFile.cxx:1347; TFile::GetFdInt_t GetFd() constDefinition TFile.h:234; TFile::IsOpenvirtual Bool_t IsOpen() constReturns kTRUE in case file is open and kFALSE if file is not open.Definition TFile.cxx:1469; TFile::fAsyncHandleTFileOpenHandle * fAsyncHandle!For proper automatic cleanupDefinition TFile.h:108; TFile::SetOnlyStagedstatic Bool_t SetOnlyStaged(Bool_t onlystaged)Sets only",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:43030,Security,hash,hashes,43030,"modtime)Return file stat information.Definition TFile.cxx:4543; TFile::GetBytesReadExtravirtual Long64_t GetBytesReadExtra() constDefinition TFile.h:242; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::kDisconnect@ kDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::GetArchiveTArchiveFile * GetArchive() constDefinition TFile.h:220; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::DirWriteKeysvirtual void DirWriteKeys(TDirectory *)Definition TFile.h:169; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::fWriteMutexstd::mutex fWriteMutex!Lock for writing baskets / keys into the file.Definition TFile.h:118; TFile::Deletevoid Del",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFile_8h_source.html:48810,Testability,log,logical,48810,"d@ kRecoveredDefinition TFile.h:191; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kDevNull@ kDevNullDefinition TFile.h:193; TFile::kHasReferences@ kHasReferencesDefinition TFile.h:192; TFile::kRedirected@ kRedirectedDefinition TFile.h:196; TFile::k630forwardCompatibility@ k630forwardCompatibilityDefinition TFile.h:190; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::kBinaryFile@ kBinaryFileDefinition TFile.h:195; TFile::OpenFromCachestatic TFile * OpenFromCache(const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Open a file for reading through the file cache.Definition TFile.cxx:3874; TFile::fNProcessIDsInt_t fNProcessIDsNumber of TProcessID written to this file.Definition TFile.h:88; TFile::fWrittenInt_t fWrittenNumber of objects written so far.Definition TFile.h:87; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; TFile::GetCompressionFactorFloat_t GetCompressionFactor()Return the file compression factor.Definition TFile.cxx:1202; TFile::SysWritevirtual Int_t SysWrite(Int_t fd, const void *buf, Int_t len)Interface to system write. All arguments like in POSIX write().Definition TFile.cxx:4514; TFile::GetFileReadCallsstatic Int_t GetFileReadCalls()Static function returning the total number of read calls from all files.Definition TFile.cxx:4591; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFile::GetOptionOption_t * GetOption() const overrideDefinition TFile.h:240; TFile::fgAsyncOpenRequestsstatic TList * fgAsyncOpenRequestsDefinition TFile.h:122; TFre",MatchSource.WIKI,doc/master/TFile_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html
https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:4230,Availability,error,error,4230,"////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitResult object and delete previous one if existing; 93 ; 94TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr& rhs); 95{; 96 if ( &rhs == this) return *this; // self assignment; 97 fStatus = rhs.fStatus;; 98 fPointer = rhs.fPointer; ; 99 // if ( fPointer ) delete fPointer;; 100 // fPointer = 0;; 101 // if (rhs.fPointer != 0) fPointer = new TFitResult(*rhs);; 102 return *this;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make th",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:5573,Modifiability,inherit,inheritance,5573,"///////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34. histhistsrcTFitResultPtr.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:2313,Testability,assert,assert,2313,",; 30 fPointer(p); 31{; 32 if (fPointer) fStatus = fPointer->Status();; 33}; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/// Constructor from a TFitResult pointer; 37 ; 38TFitResultPtr::TFitResultPtr(TFitResult * p) :; 39 fStatus(-1),; 40 fPointer(std::shared_ptr<TFitResult>(p)); 41{; 42 if (fPointer) fStatus = fPointer->Status();; 43}; 44 ; 45TFitResultPtr::TFitResultPtr(const TFitResultPtr& rhs) :; 46 fStatus(rhs.fStatus), fPointer(rhs.fPointer); 47{; 48}; 49 ; 50////////////////////////////////////////////////////////////////////////////////; 51/// Destructor. Delete the contained TFitResult pointer if needed; 52/// if ( fPointer != 0); 53/// delete fPointer;; 54 ; 55TFitResultPtr::~TFitResultPtr(); 56{; 57}; 58 ; 59////////////////////////////////////////////////////////////////////////////////; 60/// Implement the de-reference operator to make the class acts as a pointer to a TFitResult; 61/// assert in case the class does not contain a pointer to TFitResult; 62 ; 63TFitResult& TFitResultPtr::operator*() const; 64{; 65 if (!fPointer) {; 66 Error(""TFitResultPtr"",""TFitResult is empty - use the fit option S"");; 67 }; 68 return *fPointer;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Implement the -> operator to make the class acts as a pointer to a TFitResult.; 73/// assert in case the class does not contain a pointer to TFitResult; 74 ; 75TFitResult* TFitResultPtr::operator->() const; 76{; 77 if (!fPointer) {; 78 Error(""TFitResultPtr"",""TFitResult is empty - use the fit option S"");; 79 }; 80 return fPointer.get();; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Return contained pointer; 85 ; 86TFitResult * TFitResultPtr::Get() const {; 87 return fPointer.get();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitR",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:2746,Testability,assert,assert,2746,"49 ; 50////////////////////////////////////////////////////////////////////////////////; 51/// Destructor. Delete the contained TFitResult pointer if needed; 52/// if ( fPointer != 0); 53/// delete fPointer;; 54 ; 55TFitResultPtr::~TFitResultPtr(); 56{; 57}; 58 ; 59////////////////////////////////////////////////////////////////////////////////; 60/// Implement the de-reference operator to make the class acts as a pointer to a TFitResult; 61/// assert in case the class does not contain a pointer to TFitResult; 62 ; 63TFitResult& TFitResultPtr::operator*() const; 64{; 65 if (!fPointer) {; 66 Error(""TFitResultPtr"",""TFitResult is empty - use the fit option S"");; 67 }; 68 return *fPointer;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// Implement the -> operator to make the class acts as a pointer to a TFitResult.; 73/// assert in case the class does not contain a pointer to TFitResult; 74 ; 75TFitResult* TFitResultPtr::operator->() const; 76{; 77 if (!fPointer) {; 78 Error(""TFitResultPtr"",""TFitResult is empty - use the fit option S"");; 79 }; 80 return fPointer.get();; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Return contained pointer; 85 ; 86TFitResult * TFitResultPtr::Get() const {; 87 return fPointer.get();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitResult object and delete previous one if existing; 93 ; 94TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr& rhs); 95{; 96 if ( &rhs == this) return *this; // self assignment; 97 fStatus = rhs.fStatus;; 98 fPointer = rhs.fPointer; ; 99 // if ( fPointer ) delete fPointer;; 100 // fPointer = 0;; 101 // if (rhs.fPointer != 0) fPointer = new TFitResult(*rhs);; 102 return *this;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Print the TFitResul",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:5082,Testability,assert,assert,5082,"///////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34. histhistsrcTFitResultPtr.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html
https://root.cern/doc/master/TFitResultPtr_8h_source.html:3333,Modifiability,inherit,inheritance,3333,">() const;; 48 ; 49 TFitResult* Get() const;; 50 ; 51 TFitResultPtr& operator= (const TFitResultPtr& rhs);; 52 ; 53 virtual ~TFitResultPtr();; 54 ; 55private:; 56 ; 57 int fStatus; ///< fit status code; 58 std::shared_ptr<TFitResult> fPointer; ///<! Smart Pointer to TFitResult class; 59 ; 60 ClassDef(TFitResultPtr,2) //indirection to TFitResult; 61};; 62 ; 63namespace cling {; 64 std::string printValue(const TFitResultPtr* val);; 65}; 66#endif; Rtypes.h; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; int. histhistincTFitResultPtr.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8h_source.html
https://root.cern/doc/master/TFitResultPtr_8h_source.html:2842,Testability,assert,assert,2842,">() const;; 48 ; 49 TFitResult* Get() const;; 50 ; 51 TFitResultPtr& operator= (const TFitResultPtr& rhs);; 52 ; 53 virtual ~TFitResultPtr();; 54 ; 55private:; 56 ; 57 int fStatus; ///< fit status code; 58 std::shared_ptr<TFitResult> fPointer; ///<! Smart Pointer to TFitResult class; 59 ; 60 ClassDef(TFitResultPtr,2) //indirection to TFitResult; 61};; 62 ; 63namespace cling {; 64 std::string printValue(const TFitResultPtr* val);; 65}; 66#endif; Rtypes.h; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make the class acts as a pointer to a TFitResult.Definition TFitResultPtr.cxx:75; TFitResultPtr::operator=TFitResultPtr & operator=(const TFitResultPtr &rhs)Assignment operator.Definition TFitResultPtr.cxx:94; TFitResultPtr::TFitResultPtrTFitResultPtr(int status=-1)Definition TFitResultPtr.h:35; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; int. histhistincTFitResultPtr.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResultPtr_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8h_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:1592,Availability,error,errors,1592," 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TFitResult.h""; 13#include ""Math/WrappedMultiTF1.h""; 14#include ""TGraph.h""; 15 ; 16 ; 17#include <iostream>; 18 ; 19/** \class TFitResult; 20 \ingroup Hist; 21Extends the ROOT::Fit::Result class with a TNamed inheritance; 22providing easy possibility for I/O; 23*/; 24 ; 25ClassImp(TFitResult);; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// Constructor from a ROOT::Fit::FitResult; 29/// copy the contained TF1 pointer function if it is; 30 ; 31TFitResult::TFitResult(const ROOT::Fit::FitResult& f) :; 32 TNamed(""TFitResult"",""TFitResult""),; 33 ROOT::Fit::FitResult(f); 34{; 35 ROOT::Math::WrappedMultiTF1 * wfunc = dynamic_cast<ROOT::Math::WrappedMultiTF1 *>(ModelFunction().get() );; 36 if (wfunc) wfunc->SetAndCopyFunction();; 37}; 38 ; 39 ; 40////////////////////////////////////////////////////////////////////////////////; 41/// Print result of the fit, by default chi2, parameter values and errors.; 42/// if option ""V"" is given print also error matrix and correlation; 43 ; 44void TFitResult::Print(Option_t *option) const; 45{; 46 TString opt(option);; 47 opt.ToUpper();; 48 bool doCovMat = opt.Contains(""V"");; 49 ROOT::Fit::FitResult::Print( std::cout, doCovMat);; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Return the covariance matrix from fit; 54///; 55/// The matrix is a symmetric matrix with a size N equal to; 56/// the total number of parameters considered in the fit including the fixed ones; 57/// The matrix row and columns corresponding to the fixed parameters will contain only zero's; 58 ; 59TMatrixDSym TFitResult::GetCovarianceMatrix() const; 60{; 61 if (CovMatrixStatus() == 0) {; 62 Warning(""GetCovarianceMatrix"",""covariance matrix is not available"");; 63 return TMatrixDSym();; 64 }; 65 TMatrixDSym mat(NP",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:1641,Availability,error,error,1641,"ppedMultiTF1.h""; 14#include ""TGraph.h""; 15 ; 16 ; 17#include <iostream>; 18 ; 19/** \class TFitResult; 20 \ingroup Hist; 21Extends the ROOT::Fit::Result class with a TNamed inheritance; 22providing easy possibility for I/O; 23*/; 24 ; 25ClassImp(TFitResult);; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// Constructor from a ROOT::Fit::FitResult; 29/// copy the contained TF1 pointer function if it is; 30 ; 31TFitResult::TFitResult(const ROOT::Fit::FitResult& f) :; 32 TNamed(""TFitResult"",""TFitResult""),; 33 ROOT::Fit::FitResult(f); 34{; 35 ROOT::Math::WrappedMultiTF1 * wfunc = dynamic_cast<ROOT::Math::WrappedMultiTF1 *>(ModelFunction().get() );; 36 if (wfunc) wfunc->SetAndCopyFunction();; 37}; 38 ; 39 ; 40////////////////////////////////////////////////////////////////////////////////; 41/// Print result of the fit, by default chi2, parameter values and errors.; 42/// if option ""V"" is given print also error matrix and correlation; 43 ; 44void TFitResult::Print(Option_t *option) const; 45{; 46 TString opt(option);; 47 opt.ToUpper();; 48 bool doCovMat = opt.Contains(""V"");; 49 ROOT::Fit::FitResult::Print( std::cout, doCovMat);; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Return the covariance matrix from fit; 54///; 55/// The matrix is a symmetric matrix with a size N equal to; 56/// the total number of parameters considered in the fit including the fixed ones; 57/// The matrix row and columns corresponding to the fixed parameters will contain only zero's; 58 ; 59TMatrixDSym TFitResult::GetCovarianceMatrix() const; 60{; 61 if (CovMatrixStatus() == 0) {; 62 Warning(""GetCovarianceMatrix"",""covariance matrix is not available"");; 63 return TMatrixDSym();; 64 }; 65 TMatrixDSym mat(NPar());; 66 ROOT::Fit::FitResult::GetCovarianceMatrix<TMatrixDSym>(mat);; 67 return mat;; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Return ",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:2418,Availability,avail,available,2418,"sult(f); 34{; 35 ROOT::Math::WrappedMultiTF1 * wfunc = dynamic_cast<ROOT::Math::WrappedMultiTF1 *>(ModelFunction().get() );; 36 if (wfunc) wfunc->SetAndCopyFunction();; 37}; 38 ; 39 ; 40////////////////////////////////////////////////////////////////////////////////; 41/// Print result of the fit, by default chi2, parameter values and errors.; 42/// if option ""V"" is given print also error matrix and correlation; 43 ; 44void TFitResult::Print(Option_t *option) const; 45{; 46 TString opt(option);; 47 opt.ToUpper();; 48 bool doCovMat = opt.Contains(""V"");; 49 ROOT::Fit::FitResult::Print( std::cout, doCovMat);; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Return the covariance matrix from fit; 54///; 55/// The matrix is a symmetric matrix with a size N equal to; 56/// the total number of parameters considered in the fit including the fixed ones; 57/// The matrix row and columns corresponding to the fixed parameters will contain only zero's; 58 ; 59TMatrixDSym TFitResult::GetCovarianceMatrix() const; 60{; 61 if (CovMatrixStatus() == 0) {; 62 Warning(""GetCovarianceMatrix"",""covariance matrix is not available"");; 63 return TMatrixDSym();; 64 }; 65 TMatrixDSym mat(NPar());; 66 ROOT::Fit::FitResult::GetCovarianceMatrix<TMatrixDSym>(mat);; 67 return mat;; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Return the correlation matrix from fit.; 72///; 73/// The matrix is a symmetric matrix with a size N equal to; 74/// the total number of parameters considered in the fit including the fixed ones; 75/// The matrix row and columns corresponding to the fixed parameters will contain only zero's; 76 ; 77TMatrixDSym TFitResult::GetCorrelationMatrix() const; 78{; 79 if (CovMatrixStatus() == 0) {; 80 Warning(""GetCorrelationMatrix"",""correlation matrix is not available"");; 81 return TMatrixDSym();; 82 }; 83 TMatrixDSym mat(NPar());; 84 ROOT::Fit::FitResult::GetCorrelationMatrix<TMatrix",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:3128,Availability,avail,available,3128,"Sym>(mat);; 67 return mat;; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Return the correlation matrix from fit.; 72///; 73/// The matrix is a symmetric matrix with a size N equal to; 74/// the total number of parameters considered in the fit including the fixed ones; 75/// The matrix row and columns corresponding to the fixed parameters will contain only zero's; 76 ; 77TMatrixDSym TFitResult::GetCorrelationMatrix() const; 78{; 79 if (CovMatrixStatus() == 0) {; 80 Warning(""GetCorrelationMatrix"",""correlation matrix is not available"");; 81 return TMatrixDSym();; 82 }; 83 TMatrixDSym mat(NPar());; 84 ROOT::Fit::FitResult::GetCorrelationMatrix<TMatrixDSym>(mat);; 85 return mat;; 86}; 87 ; 88////////////////////////////////////////////////////////////////////////////////; 89/// Scan parameter ipar between value of xmin and xmax; 90/// A graph must be given which will be on return filled with the scan resul; 91/// If the graph size is zero, a default size n = 40 will be used; 92 ; 93bool TFitResult::Scan(unsigned int ipar, TGraph *gr, double xmin, double xmax); 94{; 95 if (!gr); 96 return false;; 97 ; 98 unsigned int npoints = gr->GetN();; 99 if (npoints == 0) {; 100 npoints = 40;; 101 gr->Set(npoints);; 102 }; 103 bool ret = ROOT::Fit::FitResult::Scan(ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; 104 if ((int)npoints < gr->GetN()); 105 gr->Set(npoints);; 106 return ret;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a 2D contour around the minimum for the parameter ipar and jpar; 111/// if a minimum does not exist or is invalid it will return false; 112/// on exit a TGraph is filled with the contour points; 113/// the number of contour points is determined by the size of the TGraph.; 114/// if the size is zero a default number of points = 20 is used; 115/// pass optionally the confidence level, default is 0.683; 116/// it is assumed that ErrorDef",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:4567,Availability,error,error,4567," default size n = 40 will be used; 92 ; 93bool TFitResult::Scan(unsigned int ipar, TGraph *gr, double xmin, double xmax); 94{; 95 if (!gr); 96 return false;; 97 ; 98 unsigned int npoints = gr->GetN();; 99 if (npoints == 0) {; 100 npoints = 40;; 101 gr->Set(npoints);; 102 }; 103 bool ret = ROOT::Fit::FitResult::Scan(ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; 104 if ((int)npoints < gr->GetN()); 105 gr->Set(npoints);; 106 return ret;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a 2D contour around the minimum for the parameter ipar and jpar; 111/// if a minimum does not exist or is invalid it will return false; 112/// on exit a TGraph is filled with the contour points; 113/// the number of contour points is determined by the size of the TGraph.; 114/// if the size is zero a default number of points = 20 is used; 115/// pass optionally the confidence level, default is 0.683; 116/// it is assumed that ErrorDef() defines the right error definition; 117/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 118 ; 119bool TFitResult::Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel); 120{; 121 if (!gr); 122 return false;; 123 ; 124 unsigned int npoints = gr->GetN();; 125 if (npoints == 0) {; 126 npoints = 40;; 127 gr->Set(npoints);; 128 }; 129 bool ret = ROOT::Fit::FitResult::Contour(ipar, jpar, npoints, gr->GetX(), gr->GetY(), confLevel);; 130 if ((int)npoints < gr->GetN()); 131 gr->Set(npoints);; 132 ; 133 return ret;; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Print the TFitResult.; 138 ; 139std::string cling::printValue(const TFitResult* val); 140{; 141 std::stringstream outs;; 142 val->ROOT::Fit::FitResult::Print(outs, false /*doCovMat*/);; 143 return outs.str();; 144}; f#define f(i)Definition RSha256.hxx:104; Option_tconst char Option_tDefinition RtypesCore.h:66; Clas",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:4605,Availability,error,error,4605,"an(unsigned int ipar, TGraph *gr, double xmin, double xmax); 94{; 95 if (!gr); 96 return false;; 97 ; 98 unsigned int npoints = gr->GetN();; 99 if (npoints == 0) {; 100 npoints = 40;; 101 gr->Set(npoints);; 102 }; 103 bool ret = ROOT::Fit::FitResult::Scan(ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; 104 if ((int)npoints < gr->GetN()); 105 gr->Set(npoints);; 106 return ret;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a 2D contour around the minimum for the parameter ipar and jpar; 111/// if a minimum does not exist or is invalid it will return false; 112/// on exit a TGraph is filled with the contour points; 113/// the number of contour points is determined by the size of the TGraph.; 114/// if the size is zero a default number of points = 20 is used; 115/// pass optionally the confidence level, default is 0.683; 116/// it is assumed that ErrorDef() defines the right error definition; 117/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 118 ; 119bool TFitResult::Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel); 120{; 121 if (!gr); 122 return false;; 123 ; 124 unsigned int npoints = gr->GetN();; 125 if (npoints == 0) {; 126 npoints = 40;; 127 gr->Set(npoints);; 128 }; 129 bool ret = ROOT::Fit::FitResult::Contour(ipar, jpar, npoints, gr->GetX(), gr->GetY(), confLevel);; 130 if ((int)npoints < gr->GetN()); 131 gr->Set(npoints);; 132 ; 133 return ret;; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Print the TFitResult.; 138 ; 139std::string cling::printValue(const TFitResult* val); 140{; 141 std::stringstream outs;; 142 val->ROOT::Fit::FitResult::Print(outs, false /*doCovMat*/);; 143 return outs.str();; 144}; f#define f(i)Definition RSha256.hxx:104; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TFitResult.",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:8434,Availability,error,errors,8434," WrappedMultiTF1.h:48; ROOT::Math::WrappedMultiTF1Templ::SetAndCopyFunctionvoid SetAndCopyFunction(const TF1 *f=nullptr)method to set a new function pointer and copy it inside.Definition WrappedMultiTF1.h:399; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObj",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:7328,Integrability,interface,interface,7328,"rint(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::NParunsigned int NPar() consttotal number of parameters (abbreviation)Definition FitResult.h:122; ROOT::Fit::FitResult::CovMatrixStatusint CovMatrixStatus() constcovariance matrix status code using Minuit convention : =0 not calculated, =1 approximated,...Definition FitResult.h:133; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; ROOT::Math::WrappedMultiTF1Templ::SetAndCopyFunctionvoid SetAndCopyFunction(const TF1 *f=nullptr)method to set a new function pointer and copy it inside.Definition WrappedMultiTF1.h:399; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:9348,Integrability,message,message,9348,"urbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::GetYDouble_t * GetY() constDefinition TGraph.h:140; TGraph::GetNInt_t GetN() constDefinition TGraph.h:132; TGraph::GetXDouble_t * GetX() constDefinition TGraph.h:139; TGraph::Setvirtual void Set(Int_t n)Set number of points in the graph Existing coordinates are preserved New coordinates above fNpoints a...Definition TGraph.cxx:2277; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TStringBasic string class.Definition TString.h:139; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; grTGraphErrors * grDefinition legend1.C:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. histhistsrcTFitResult.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:854,Modifiability,inherit,inheritance,854," File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TFitResult.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: David Gonzalez Maline 12/11/09; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TFitResult.h""; 13#include ""Math/WrappedMultiTF1.h""; 14#include ""TGraph.h""; 15 ; 16 ; 17#include <iostream>; 18 ; 19/** \class TFitResult; 20 \ingroup Hist; 21Extends the ROOT::Fit::Result class with a TNamed inheritance; 22providing easy possibility for I/O; 23*/; 24 ; 25ClassImp(TFitResult);; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// Constructor from a ROOT::Fit::FitResult; 29/// copy the contained TF1 pointer function if it is; 30 ; 31TFitResult::TFitResult(const ROOT::Fit::FitResult& f) :; 32 TNamed(""TFitResult"",""TFitResult""),; 33 ROOT::Fit::FitResult(f); 34{; 35 ROOT::Math::WrappedMultiTF1 * wfunc = dynamic_cast<ROOT::Math::WrappedMultiTF1 *>(ModelFunction().get() );; 36 if (wfunc) wfunc->SetAndCopyFunction();; 37}; 38 ; 39 ; 40////////////////////////////////////////////////////////////////////////////////; 41/// Print result of the fit, by default chi2, parameter values and errors.; 42/// if option ""V"" is given print also error matrix and correlation; 43 ; 44void TFitResult::Print(Option_t *option) const; 45{; 46 TString opt(option);; 47 opt.ToUpper();; 48 bool doCovMat = opt.Contains(""V"");; 49 ROOT::Fit::FitResult::Print( std::cout, doCovMat);; 50}; 51 ; 52////////////////////////////////////////////////////////////////////////////////; 53/// Return the covariance matrix from fit; 54///; 55/// The matrix is a symmetr",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8cxx_source.html:7640,Modifiability,inherit,inheritance,7640,"OT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::NParunsigned int NPar() consttotal number of parameters (abbreviation)Definition FitResult.h:122; ROOT::Fit::FitResult::CovMatrixStatusint CovMatrixStatus() constcovariance matrix status code using Minuit convention : =0 not calculated, =1 approximated,...Definition FitResult.h:133; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; ROOT::Math::WrappedMultiTF1Templ::SetAndCopyFunctionvoid SetAndCopyFunction(const TF1 *f=nullptr)method to set a new function pointer and copy it inside.Definition WrappedMultiTF1.h:399; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given ",MatchSource.WIKI,doc/master/TFitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html
https://root.cern/doc/master/TFitResult_8h.html:273,Integrability,depend,dependency,273,". ROOT: hist/hist/inc/TFitResult.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TFitResult.h File Reference. #include ""TNamed.h""; #include ""Fit/FitResult.h""; #include ""TMatrixDSym.h""; #include <string>. Include dependency graph for TFitResult.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  . histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h.html
https://root.cern/doc/master/TFitResult_8h.html:630,Modifiability,inherit,inheritance,630,". ROOT: hist/hist/inc/TFitResult.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TFitResult.h File Reference. #include ""TNamed.h""; #include ""Fit/FitResult.h""; #include ""TMatrixDSym.h""; #include <string>. Include dependency graph for TFitResult.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  . histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h.html
https://root.cern/doc/master/TFitResult_8h_source.html:3285,Availability,error,error,3285,"ouble confLevel = 0.683);; 70 ; 71 using TObject::Error;; 72 ; 73 // need to re-implement to solve conflict with TObject::Error; 74 double Error(unsigned int i) const {; 75 return ParError(i);; 76 }; 77 ; 78private:; 79 ClassDefOverride(TFitResult, 0); // Class holding the result of the fit; 80};; 81 ; 82namespace cling {; 83 std::string printValue(const TFitResult* val);; 84}; 85#endif; FitResult.h; f#define f(i)Definition RSha256.hxx:104; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMatrixDSym.h; TNamed.h; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::Scanbool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)scan likelihood value of parameter and fill the given graph.Definition FitResult.cxx:639; ROOT::Fit::FitResult::FitResultFitResult()Default constructor for an empty (non valid) fit result.Definition FitResult.cxx:45; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
https://root.cern/doc/master/TFitResult_8h_source.html:5066,Availability,error,errors,5066,"t fStatusminimizer status codeDefinition FitResult.h:348; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult.h:53; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::Errordouble Error(unsigned int i) constDefinition TFitResult.h:74; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::TFitResultTFitResult(const char *name, const char *title)Definition TFitResult.h:45; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; grTGraphErrors * grDefinition legend1.C:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. histhistincTFitResult.h. ROOT master - Reference Gui",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
https://root.cern/doc/master/TFitResult_8h_source.html:5722,Availability,error,error,5722,"e ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult.h:53; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::Errordouble Error(unsigned int i) constDefinition TFitResult.h:74; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::TFitResultTFitResult(const char *name, const char *title)Definition TFitResult.h:45; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; grTGraphErrors * grDefinition legend1.C:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
https://root.cern/doc/master/TFitResult_8h_source.html:5728,Integrability,message,message,5728,"e ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult.h:53; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::Errordouble Error(unsigned int i) constDefinition TFitResult.h:74; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitResult::TFitResultTFitResult(const char *name, const char *title)Definition TFitResult.h:45; TFitResult::Scanbool Scan(unsigned int ipar, TGraph *gr, double xmin=0, double xmax=0)Scan parameter ipar between value of xmin and xmax A graph must be given which will be on return fill...Definition TFitResult.cxx:93; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TMatrixTSym< Double_t >; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; grTGraphErrors * grDefinition legend1.C:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. histhistincTFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
https://root.cern/doc/master/TFitResult_8h_source.html:4120,Modifiability,inherit,inheritance,4120,"of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::Scanbool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)scan likelihood value of parameter and fill the given graph.Definition FitResult.cxx:639; ROOT::Fit::FitResult::FitResultFitResult()Default constructor for an empty (non valid) fit result.Definition FitResult.cxx:45; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; TFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O.Definition TFitResult.h:34; TFitResult::~TFitResult~TFitResult() overrideDefinition TFitResult.h:53; TFitResult::TFitResultTFitResult(int status=0)Definition TFitResult.h:39; TFitResult::Errordouble Error(unsigned int i) constDefinition TFitResult.h:74; TFitResult::GetCorrelationMatrixTMatrixDSym GetCorrelationMatrix() constReturn the correlation matrix from fit.Definition TFitResult.cxx:77; TFitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel=0.683)Create a 2D contour around the minimum for the parameter ipar and jpar if a minimum does not exist or...Definition TFitResult.cxx:119; TFitResult::GetCovarianceMatrixTMatrixDSym GetCovarianceMatrix() constReturn the covariance matrix from fit.Definition TFitResult.cxx:59; TFitResult::Printvoid Print(Option_t *option="""") const overridePrint result of the fit, by default chi2, parameter values and errors.Definition TFitResult.cxx:44; TFitRes",MatchSource.WIKI,doc/master/TFitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFitResult_8h_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:1562,Availability,avail,available,1562,"; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TBuffer.h""; 14#include ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*pow([1],4)`; 62 - `2*pi*sqrt(x/y)`; 63 - `gaus(0)*expo(3) + ypol3(5)*x`; 64 - `gausn(0)*expo(3) + ypol3(5)*x`; 65 - `gaus(x, [0..2]) + expo(y, [3..4])`; 66 ; 67 In the last examples above:; 68 ; 69 - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; 70 and (0) means start numbering parameters at 0; 71 - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; 72 and (0) means start numberin",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:1647,Availability,avail,available,1647,"e ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*pow([1],4)`; 62 - `2*pi*sqrt(x/y)`; 63 - `gaus(0)*expo(3) + ypol3(5)*x`; 64 - `gausn(0)*expo(3) + ypol3(5)*x`; 65 - `gaus(x, [0..2]) + expo(y, [3..4])`; 66 ; 67 In the last examples above:; 68 ; 69 - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; 70 and (0) means start numbering parameters at 0; 71 - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; 72 and (0) means start numbering parameters at 0; 73 - `expo(3)` is a substitute for `exp([3]+[4]*x)`; 74 - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:1723,Availability,avail,available,1723,"e ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*pow([1],4)`; 62 - `2*pi*sqrt(x/y)`; 63 - `gaus(0)*expo(3) + ypol3(5)*x`; 64 - `gausn(0)*expo(3) + ypol3(5)*x`; 65 - `gaus(x, [0..2]) + expo(y, [3..4])`; 66 ; 67 In the last examples above:; 68 ; 69 - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; 70 and (0) means start numbering parameters at 0; 71 - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; 72 and (0) means start numbering parameters at 0; 73 - `expo(3)` is a substitute for `exp([3]+[4]*x)`; 74 - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:5783,Availability,avail,available,5783,"is class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `HessianPar` returns a flattened matrix:; 156 ; 157 ```; 158 TFormula::CladStorage hess(4);; 159 f.HessianPar(x, hess);; 160 ```; 161 ; 162 \anchor FormulaFuncs; 163 ### List of predefined functions; 164 ; 165 The list of available predefined functions which can be used as shortcuts is the following:; 166 1. One Dimensional functions:; 167 - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x-[Mean])/[Sigma]))`; 168 - `landau` is a substitute for `[Constant]*TMath::Landau (x,[MPV],[Sigma],false)`; 169 - `expo` is a substitute for `exp([Constant]+[Slope]*x)`; 170 - `crystalball` is substitute for `[Constant]*ROOT::Math::crystalball_function (x,[Alpha],[N],[Sigma],[Mean])`; 171 - `breitwigner` is a substitute for `[p0]*ROOT::Math::breitwigner_pdf (x,[p2],[p1])`; 172 - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` :; 173 `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`; 174 - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`:; 175 `ROOT::Math::Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.; 176 2. Two Dimensional functions:; 177 - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:9047,Availability,error,error,9047,"]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ; 232 All operators of C/C++ are allowed in a TFormula with a few caveats.; 233 ; 234 The operators `|`, `&`, `%` can be used but will raise an error if used in; 235 conjunction with a variable or a parameter. Variables and parameters are treated; 236 as doubles internally for which these operators are not defined.; 237 This means the following command will run successfully; 238 ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; 239 but not; 240 ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```.; 241 ; 242 The operator `^` is defined to mean exponentiation instead of the C/C++; 243 interpretation xor. `**` is added, also meaning exponentiation.; 244 ; 245 The operators `++` and `@` are added, and are shorthand for the a linear; 246 function. That means the expression `x@2` will be expanded to; 247 ```[n]*x + [n+1]*2``` where n is the first previously unused parameter number.; 248 ; 249 \class TFormulaFunction; 250 Helper class for TFormula; 251 ; 252 \class TFormulaVariable; 253 Another helper class for TFormula; 254 ; 255 \class TFormulaParamOrder; 256 Functor defining the parameter order; 257*/; 258 ; 259// prefix used f",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:21241,Availability,error,error,21241," 536 fLambdaPtr = nullptr;; 537 fFuncPtr = nullptr;; 538 fGradFuncPtr = nullptr;; 539 fHessFuncPtr = nullptr;; 540 ; 541 ; 542 fNdim = ndim;; 543 for (int i = 0; i < npar; ++i) {; 544 DoAddParameter(TString::Format(""p%d"",i), 0, false);; 545 }; 546 fAllParametersSetted = true;; 547 assert (fNpar == npar);; 548 ; 549 bool ret = InitLambdaExpression(formula);; 550 ; 551 if (ret) {; 552 ; 553 SetBit(TFormula::kLambda);; 554 ; 555 fReadyToExecute = true;; 556 ; 557 if (addToGlobList && gROOT) {; 558 TFormula *old = nullptr;; 559 R__LOCKGUARD(gROOTMutex);; 560 old = dynamic_cast<TFormula*> ( gROOT->GetListOfFunctions()->FindObject(name) );; 561 if (old); 562 gROOT->GetListOfFunctions()->Remove(old);; 563 if (IsReservedName(name)); 564 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",name);; 565 else; 566 gROOT->GetListOfFunctions()->Add(this);; 567 }; 568 SetBit(kNotGlobal,!addToGlobList);; 569 }; 570 else; 571 Error(""TFormula"",""Syntax error in building the lambda expression %s"", formula );; 572}; 573 ; 574////////////////////////////////////////////////////////////////////////////////; 575TFormula::TFormula(const TFormula &formula) :; 576 TNamed(formula.GetName(),formula.GetTitle()); 577{; 578 formula.TFormula::Copy(*this);; 579 ; 580 if (!TestBit(TFormula::kNotGlobal) && gROOT ) {; 581 R__LOCKGUARD(gROOTMutex);; 582 TFormula *old = (TFormula*)gROOT->GetListOfFunctions()->FindObject(formula.GetName());; 583 if (old); 584 gROOT->GetListOfFunctions()->Remove(old);; 585 ; 586 if (IsReservedName(formula.GetName())) {; 587 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",formula.GetName());; 588 } else; 589 gROOT->GetListOfFunctions()->Add(this);; 590 }; 591 ; 592}; 593 ; 594////////////////////////////////////////////////////////////////////////////////; 595/// = operator.; 596 ; 597TFormula& TFormula::operator=(const TFormula &rhs); 598{; 599 if (this != &rhs); 600 rhs.TFormula::Copy(*this);; 601 return *this;; 602}; 603 ; 60",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:27423,Availability,error,error,27423,"arNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; 739 bool ret = fnew.InitLambdaExpression(fnew.fFormula);; 740 if (ret) {; 741 fnew.SetBit(TFormula::kLambda);; 742 fnew.fReadyToExecute = true;; 743 }; 744 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 f",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28869,Availability,failure,failure,28869,"nInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = false) {; 801 std::unique_ptr<TMethodCall>; 802 Method = std::make_unique<TMethodCall>();; 803 ; 804 TString prototypeArguments = """";; 805 if (HasVariables || HasParameters) {; 806 if (IsVectorized); 807 prototypeArguments.Append(""ROOT::Double_v*"");; 808 else; 809 prototypeArguments.Append(""Double_t*"");; 810 }; 811 auto AddDoublePtrParam = [&prototypeArguments]() {; 812 prototypeArguments.Append("","");; 813 prototypeArguments.Append(""Double_t*"");; 814 };; 815 if (HasParameters); 816 AddDoublePtrParam();; 817 ; 818 // We need an extra Double_t* for the gradient return result.; 819 if (AddCladArrayRef) {; 820 prototypeArguments.Append("","");; 821 prototypeArguments.Append(""Double_t*"");; 822 }; 823 ; 824 // Initialize the method call using real function name (cling name) defined; 825 // by Process",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:31028,Availability,failure,failure,31028,"ith arguments %s"", FuncName,; 830 prototypeArguments.Data());; 831 return nullptr;; 832 }; 833 ; 834 return Method;; 835}; 836 ; 837static TInterpreter::CallFuncIFacePtr_t::Generic_t prepareFuncPtr(TMethodCall *method) {; 838 if (!method) return nullptr;; 839 CallFunc_t *callfunc = method->GetCallFunc();; 840 ; 841 if (!gCling->CallFunc_IsValid(callfunc)) {; 842 Error(""prepareFuncPtr"", ""Callfunc retuned from Cling is not valid"");; 843 return nullptr;; 844 }; 845 ; 846 TInterpreter::CallFuncIFacePtr_t::Generic_t Result; 847 = gCling->CallFunc_IFacePtr(callfunc).fGeneric;; 848 if (!Result) {; 849 Error(""prepareFuncPtr"", ""Compiled function pointer is null"");; 850 return nullptr;; 851 }; 852 return Result;; 853}; 854 ; 855////////////////////////////////////////////////////////////////////////////////; 856/// Sets TMethodCall to function inside Cling environment.; 857/// TFormula uses it to execute function.; 858/// After call, TFormula should be ready to evaluate formula.; 859/// Returns false on failure.; 860 ; 861bool TFormula::PrepareEvalMethod(); 862{; 863 if (!fMethod) {; 864 Bool_t hasParameters = (fNpar > 0);; 865 Bool_t hasVariables = (fNdim > 0);; 866 fMethod = prepareMethod(hasParameters, hasVariables, fClingName,fVectorized);; 867 if (!fMethod) return false;; 868 fFuncPtr = prepareFuncPtr(fMethod.get());; 869 }; 870 return fFuncPtr;; 871}; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Inputs formula, transfered to C++ code into Cling; 875 ; 876void TFormula::InputFormulaIntoCling(); 877{; 878 ; 879 if (!fClingInitialized && fReadyToExecute && fClingInput.Length() > 0) {; 880 // make sure the interpreter is initialized; 881 ROOT::GetROOT();; 882 R__ASSERT(gCling);; 883 ; 884 // Trigger autoloading / autoparsing (ROOT-9840):; 885 TString triggerAutoparsing = ""namespace ROOT_TFormula_triggerAutoParse {\n""; triggerAutoparsing += fClingInput + ""\n}"";; 886 gCling->ProcessLine(triggerAutoparsing);; 887 ; 888 // ad",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:62781,Availability,down,down,62781," is : "" << formula << std::endl;; 1615 } else {; 1616 Warning(""HandleFunctionArguments"", ""Unable to make replacement. Number of parameters doesn't work : ""; 1617 ""%d arguments, %d dimensions, %d parameters"",; 1618 nArguments, ndim, npar);; 1619 i = j;; 1620 }; 1621 ; 1622 } else {; 1623 i = j; // skip to end of candidate ""name""; 1624 }; 1625 }; 1626 }; 1627 ; 1628}; 1629 ; 1630////////////////////////////////////////////////////////////////////////////////; 1631/// Handling exponentiation; 1632/// Can handle multiple carets, eg.; 1633/// 2^3^4 will be treated like 2^(3^4); 1634 ; 1635void TFormula::HandleExponentiation(TString &formula); 1636{; 1637 Int_t caretPos = formula.Last('^');; 1638 while (caretPos != kNPOS && !IsAParameterName(formula, caretPos)) {; 1639 ; 1640 TString right, left;; 1641 Int_t temp = caretPos;; 1642 temp--;; 1643 // get the expression in ( ) which has the operator^ applied; 1644 if (formula[temp] == ')') {; 1645 Int_t depth = 1;; 1646 temp--;; 1647 while (depth != 0 && temp > 0) {; 1648 if (formula[temp] == ')'); 1649 depth++;; 1650 if (formula[temp] == '('); 1651 depth--;; 1652 temp--;; 1653 }; 1654 if (depth == 0); 1655 temp++;; 1656 }; 1657 // this in case of someting like sin(x+2)^2; 1658 do {; 1659 temp--; // go down one; 1660 // handle scientific notation cases (1.e-2 ^ 3 ); 1661 if (temp >= 2 && IsScientificNotation(formula, temp - 1)); 1662 temp -= 3;; 1663 } while (temp >= 0 && !IsOperator(formula[temp]) && !IsBracket(formula[temp]));; 1664 ; 1665 assert(temp + 1 >= 0);; 1666 Int_t leftPos = temp + 1;; 1667 left = formula(leftPos, caretPos - leftPos);; 1668 // std::cout << ""left to replace is "" << left << std::endl;; 1669 ; 1670 // look now at the expression after the ^ operator; 1671 temp = caretPos;; 1672 temp++;; 1673 if (temp >= formula.Length()) {; 1674 Error(""HandleExponentiation"", ""Invalid position of operator ^"");; 1675 return;; 1676 }; 1677 if (formula[temp] == '(') {; 1678 Int_t depth = 1;; 1679 temp++;; 1680 while (depth",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:91055,Availability,failure,failure,91055,"::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput == fClingInput); 2353 // inputIntoCling = false;; 2354 // else; 2355 // fClingInitialized = false;; 2356 // }; 2357 ; 2358 if (inputIntoCling) {; 2359 if (!fLazyInitialization) {; 2360 InputFormulaIntoCling();; 2361 if (fClingInitialized) {; 2362 // if Cling has been successfully initialized; 2363 // put function ptr in the static map; 2364 R__LOCKGUARD(gROOTMutex);; 2365 gClingFunctions.insert(std::make_pair(inputFormulaVecFlag, (void *)fFuncPtr));; 2366 }; 2367 }; 2368 if (!fClingInitialized) {; 2369 // needed in case of lazy initialization of failure compiling the expression; 2370 fSavedInputFormula = inputFormulaVecFlag;; 2371 }; 2372 ; 2373 } else {; 2374 fAllParametersSetted = true;; 2375 fClingInitialized = true;; 2376 }; 2377 }; 2378 }; 2379 ; 2380 // In case of a Cling Error check components which are not found in Cling; 2381 // check that all formula components are matched otherwise emit an error; 2382 if (!fClingInitialized && !fLazyInitialization) {; 2383 //Bool_t allFunctorsMatched = false;; 2384 for (list<TFormulaFunction>::iterator it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 2385 // functions are now by default always not checked; 2386 if (!it->fFound && !it->IsFuncCall()) {; 2387 //allFunctorsMatched = false;; 2388 if (it->GetNargs() == 0); 2389 Error(""ProcessFormula"", ""\""%s\"" has not been matched in the formula expression"", it->GetName());; 2390 else; 2391 Error(""ProcessFormula"", ""Could not find %s function with %d argument(s)"", it->GetName(), it->GetNargs());; 2392 }; 2393 }; 2394 Error(""ProcessFormula"",""Formula \""%s\"" is invalid !"", GetExpFormula().Data() );; 2395 fReadyToExecute = false;; 2396 }; 2397 ; 2398 // clean up un-used default variables in case formula is valid; 2399 //",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:91417,Availability,error,error,91417,"::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput == fClingInput); 2353 // inputIntoCling = false;; 2354 // else; 2355 // fClingInitialized = false;; 2356 // }; 2357 ; 2358 if (inputIntoCling) {; 2359 if (!fLazyInitialization) {; 2360 InputFormulaIntoCling();; 2361 if (fClingInitialized) {; 2362 // if Cling has been successfully initialized; 2363 // put function ptr in the static map; 2364 R__LOCKGUARD(gROOTMutex);; 2365 gClingFunctions.insert(std::make_pair(inputFormulaVecFlag, (void *)fFuncPtr));; 2366 }; 2367 }; 2368 if (!fClingInitialized) {; 2369 // needed in case of lazy initialization of failure compiling the expression; 2370 fSavedInputFormula = inputFormulaVecFlag;; 2371 }; 2372 ; 2373 } else {; 2374 fAllParametersSetted = true;; 2375 fClingInitialized = true;; 2376 }; 2377 }; 2378 }; 2379 ; 2380 // In case of a Cling Error check components which are not found in Cling; 2381 // check that all formula components are matched otherwise emit an error; 2382 if (!fClingInitialized && !fLazyInitialization) {; 2383 //Bool_t allFunctorsMatched = false;; 2384 for (list<TFormulaFunction>::iterator it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 2385 // functions are now by default always not checked; 2386 if (!it->fFound && !it->IsFuncCall()) {; 2387 //allFunctorsMatched = false;; 2388 if (it->GetNargs() == 0); 2389 Error(""ProcessFormula"", ""\""%s\"" has not been matched in the formula expression"", it->GetName());; 2390 else; 2391 Error(""ProcessFormula"", ""Could not find %s function with %d argument(s)"", it->GetName(), it->GetNargs());; 2392 }; 2393 }; 2394 Error(""ProcessFormula"",""Formula \""%s\"" is invalid !"", GetExpFormula().Data() );; 2395 fReadyToExecute = false;; 2396 }; 2397 ; 2398 // clean up un-used default variables in case formula is valid; 2399 //",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:108519,Availability,error,error,108519,"gParameters.reserve(TMath::Max(int(fParams.size()), pos + 1));; 2794 fClingParameters.insert(fClingParameters.end(), pos + 1 - fClingParameters.size(), 0.0);; 2795 fClingParameters[pos] = value;; 2796 }; 2797 ; 2798 // need to adjust all other positions; 2799 for (auto it = ret.first; it != fParams.end(); ++it) {; 2800 it->second = pos;; 2801 pos++;; 2802 }; 2803 ; 2804 // for (auto & p : fParams); 2805 // std::cout << ""Parameter "" << p.first << "" position "" << p.second << "" value "" <<; 2806 // fClingParameters[p.second] << std::endl;; 2807 // printf(""inserted parameters size params %d size cling %d \n"",fParams.size(), fClingParameters.size() );; 2808 }; 2809 if (processFormula) {; 2810 // replace first in input parameter name with [name]; 2811 fClingInput.ReplaceAll(name, TString::Format(""[%s]"", name.Data()));; 2812 ProcessFormula(fClingInput);; 2813 }; 2814 }; 2815}; 2816 ; 2817////////////////////////////////////////////////////////////////////////////////; 2818/// Return parameter index given a name (return -1 for not existing parameters); 2819/// non need to print an error; 2820 ; 2821Int_t TFormula::GetParNumber(const char * name) const {; 2822 auto it = fParams.find(name);; 2823 if (it == fParams.end()) {; 2824 return -1;; 2825 }; 2826 return it->second;; 2827 ; 2828}; 2829 ; 2830////////////////////////////////////////////////////////////////////////////////; 2831/// Returns parameter value given by string.; 2832 ; 2833Double_t TFormula::GetParameter(const char * name) const; 2834{; 2835 const int i = GetParNumber(name);; 2836 if (i == -1) {; 2837 Error(""GetParameter"",""Parameter %s is not defined."",name);; 2838 return TMath::QuietNaN();; 2839 }; 2840 ; 2841 return GetParameter( i );; 2842}; 2843 ; 2844////////////////////////////////////////////////////////////////////////////////; 2845/// Return parameter value given by integer.; 2846 ; 2847Double_t TFormula::GetParameter(Int_t param) const; 2848{; 2849 //TString name = TString::Format(""%d"",param);; 2850 if",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:128688,Availability,error,error,128688,"s shown.; 3358 ; 3359Double_t TFormula::DoEval(const double * x, const double * params) const; 3360{; 3361 if(!fReadyToExecute); 3362 {; 3363 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3364 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3365 TFormulaFunction fun = *it;; 3366 if (!fun.fFound) {; 3367 printf(""%s is unknown.\n"", fun.GetName());; 3368 }; 3369 }; 3370 return TMath::QuietNaN();; 3371 }; 3372 ; 3373 // Lazy initialization is set and needed when reading from a file; 3374 if (!fClingInitialized && fLazyInitialization) {; 3375 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3376 R__LOCKGUARD(gROOTMutex);; 3377 // check again in case another thread has initialized the formula (see ROOT-10994); 3378 if (!fClingInitialized) {; 3379 auto thisFormula = const_cast<TFormula*>(this);; 3380 thisFormula->ReInitializeEvalMethod();; 3381 }; 3382 if (!fClingInitialized) {; 3383 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3384 return TMath::QuietNaN();; 3385 }; 3386 }; 3387 ; 3388 if (fLambdaPtr && TestBit(TFormula::kLambda)) {// case of lambda functions; 3389 std::function<double(double *, double *)> & fptr = * ( (std::function<double(double *, double *)> *) fLambdaPtr);; 3390 assert(x);; 3391 //double * v = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3392 double * v = const_cast<double*>(x);; 3393 double * p = (params) ? const_cast<double*>(params) : const_cast<double*>(fClingParameters.data());; 3394 return fptr(v, p);; 3395 }; 3396 ; 3397 ; 3398 Double_t result = 0;; 3399 void* args[2];; 3400 double * vars = (x) ? const_cast<double*>(x) : const_cast<double*>(fClingVariables.data());; 3401 args[0] = &vars;; 3402 if (fNpar <= 0) {; 3403 (*fFuncPtr)(nullptr, 1, args, &result);; 3404 } else {; 3405 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3406 args[1] = &pars;; 3407 (*fFunc",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:130914,Availability,error,error,130914,"; 3415ROOT::Double_v TFormula::DoEvalVec(const ROOT::Double_v *x, const double *params) const; 3416{; 3417 if (!fReadyToExecute) {; 3418 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3419 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3420 TFormulaFunction fun = *it;; 3421 if (!fun.fFound) {; 3422 printf(""%s is unknown.\n"", fun.GetName());; 3423 }; 3424 }; 3425 return TMath::QuietNaN();; 3426 }; 3427 // todo maybe save lambda ptr stuff for later; 3428 ; 3429 if (!fClingInitialized && fLazyInitialization) {; 3430 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3431 R__LOCKGUARD(gROOTMutex);; 3432 // check again in case another thread has initialized the formula (see ROOT-10994); 3433 if (!fClingInitialized) {; 3434 auto thisFormula = const_cast<TFormula*>(this);; 3435 thisFormula->ReInitializeEvalMethod();; 3436 }; 3437 if (!fClingInitialized) {; 3438 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3439 ROOT::Double_v res = TMath::QuietNaN();; 3440 return res;; 3441 }; 3442 }; 3443 ; 3444 ROOT::Double_v result = 0;; 3445 void *args[2];; 3446 ; 3447 ROOT::Double_v *vars = const_cast<ROOT::Double_v *>(x);; 3448 args[0] = &vars;; 3449 if (fNpar <= 0) {; 3450 (*fFuncPtr)(0, 1, args, &result);; 3451 }else {; 3452 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3453 args[1] = &pars;; 3454 (*fFuncPtr)(0, 2, args, &result);; 3455 }; 3456 return result;; 3457}; 3458#endif // R__HAS_VECCORE; 3459 ; 3460 ; 3461//////////////////////////////////////////////////////////////////////////////; 3462/// Re-initialize eval method; 3463///; 3464/// This function is called by DoEval and DoEvalVector in case of a previous failure; 3465/// or in case of reading from a file; 3466////////////////////////////////////////////////////////////////////////////////; 3467void TFormula::ReInitializeEvalMethod() {; 3468 ; 3469 ; 3470 if (TestBit(TF",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:131733,Availability,failure,failure,131733,"cast<TFormula*>(this);; 3435 thisFormula->ReInitializeEvalMethod();; 3436 }; 3437 if (!fClingInitialized) {; 3438 Error(""DoEval"", ""Formula has error and it is not properly initialized "");; 3439 ROOT::Double_v res = TMath::QuietNaN();; 3440 return res;; 3441 }; 3442 }; 3443 ; 3444 ROOT::Double_v result = 0;; 3445 void *args[2];; 3446 ; 3447 ROOT::Double_v *vars = const_cast<ROOT::Double_v *>(x);; 3448 args[0] = &vars;; 3449 if (fNpar <= 0) {; 3450 (*fFuncPtr)(0, 1, args, &result);; 3451 }else {; 3452 double *pars = (params) ? const_cast<double *>(params) : const_cast<double *>(fClingParameters.data());; 3453 args[1] = &pars;; 3454 (*fFuncPtr)(0, 2, args, &result);; 3455 }; 3456 return result;; 3457}; 3458#endif // R__HAS_VECCORE; 3459 ; 3460 ; 3461//////////////////////////////////////////////////////////////////////////////; 3462/// Re-initialize eval method; 3463///; 3464/// This function is called by DoEval and DoEvalVector in case of a previous failure; 3465/// or in case of reading from a file; 3466////////////////////////////////////////////////////////////////////////////////; 3467void TFormula::ReInitializeEvalMethod() {; 3468 ; 3469 ; 3470 if (TestBit(TFormula::kLambda) ) {; 3471 Info(""ReInitializeEvalMethod"",""compile now lambda expression function using Cling"");; 3472 InitLambdaExpression(fFormula);; 3473 fLazyInitialization = false;; 3474 return;; 3475 }; 3476 fMethod.reset();; 3477 ; 3478 if (!fLazyInitialization) Warning(""ReInitializeEvalMethod"", ""Formula is NOT properly initialized - try calling again TFormula::PrepareEvalMethod"");; 3479 //else Info(""ReInitializeEvalMethod"", ""Compile now the formula expression using Cling"");; 3480 ; 3481 // check first if formula exists in the global map; 3482 {; 3483 ; 3484 R__LOCKGUARD(gROOTMutex);; 3485 ; 3486 // std::cout << ""gClingFunctions list"" << std::endl;; 3487 // for (auto thing : gClingFunctions); 3488 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 3489 ; 3490 auto funcit = gClingFunctions",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:145369,Availability,error,error,145369,";; 3798 ; 3799 return;; 3800 }; 3801 else {; 3802 Error(""Streamer"",""Reading version %d is not supported"",v);; 3803 return;; 3804 }; 3805 }; 3806 else {; 3807 // case of writing; 3808 b.WriteClassBuffer(TFormula::Class(), this);; 3809 // std::cout << ""writing npar = "" << GetNpar() << std::endl;; 3810 }; 3811}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; StringUtils.hxx; TBenchmark.h; TBuffer.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1.h; GetParametersvoid GetParameters(TFitEditor::FuncParams_t &pars, TF1 *func)Stores the parameters of the given function into pars.Definition TFitEditor.cxx:256; gClingFunctionsstatic std::unordered_map< std::string, void * > gClingFunctionsDefinition TFormula.cxx:264; IncludeCladRuntimestatic void IncludeCladRuntime(Bool_t &IsCladRuntimeIncluded)Definition TFormula.cxx:3127; TFormulaUpdater_tvoid(*)(Int_t nobjects, TObject **from, TObject **to) TFormulaUpdater_tDefinition TFormula.cxx:280; gNamePrefixstatic const TString gNamePrefixDefinition TFormula.cxx:260; CallCladFunctionstatic void CallCladFunction(TInterpreter::CallFuncIFacePtr_t::Generic_t FuncPtr, const Double_t *vars, const Double_t *pars, Double_t *result, const Int_t)Definition TFormula.cxx:3159; prepareMethodstatic std:",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:145504,Availability,error,error,145504,"3807 // case of writing; 3808 b.WriteClassBuffer(TFormula::Class(), this);; 3809 // std::cout << ""writing npar = "" << GetNpar() << std::endl;; 3810 }; 3811}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; StringUtils.hxx; TBenchmark.h; TBuffer.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1.h; GetParametersvoid GetParameters(TFitEditor::FuncParams_t &pars, TF1 *func)Stores the parameters of the given function into pars.Definition TFitEditor.cxx:256; gClingFunctionsstatic std::unordered_map< std::string, void * > gClingFunctionsDefinition TFormula.cxx:264; IncludeCladRuntimestatic void IncludeCladRuntime(Bool_t &IsCladRuntimeIncluded)Definition TFormula.cxx:3127; TFormulaUpdater_tvoid(*)(Int_t nobjects, TObject **from, TObject **to) TFormulaUpdater_tDefinition TFormula.cxx:280; gNamePrefixstatic const TString gNamePrefixDefinition TFormula.cxx:260; CallCladFunctionstatic void CallCladFunction(TInterpreter::CallFuncIFacePtr_t::Generic_t FuncPtr, const Double_t *vars, const Double_t *pars, Double_t *result, const Int_t)Definition TFormula.cxx:3159; prepareMethodstatic std::unique_ptr< TMethodCall > prepareMethod(bool HasParameters, bool HasVariables, const char *FuncName, bool IsVectorized, bool AddCladArrayRef=false)Defin",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:165690,Availability,error,error,165690,"s, eg.Definition TFormula.cxx:1635; TFormula::IsFunctionNameCharstatic Bool_t IsFunctionNameChar(const char c)Definition TFormula.cxx:306; TFormula::fHessGenerationInputstd::string fHessGenerationInput! Input query to clad to generate a hessianDefinition TFormula.h:106; TFormula::DoEvalDouble_t DoEval(const Double_t *x, const Double_t *p=nullptr) constEvaluate formula.Definition TFormula.cxx:3359; TFormula::fReadyToExecuteBool_t fReadyToExecute! Transient to force initializationDefinition TFormula.h:96; TFormula::GenerateGradientParbool GenerateGradientPar()Generate gradient computation routine with respect to the parameters.Definition TFormula.cxx:3192; TFormula::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TFormula.cxx:3679; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TInterpreter::ProcessLinevirtual Longptr_t ProcessLine(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::Declarevirtual Bool_t Declare(const char *code)=0; TInterpreter::CallFunc_IsValidvirtual Bool_t CallFunc_IsValid(CallFunc_t *) constDefinition TInterpreter.h:327; TInterpreter::CallFunc_IFacePtrvirtual CallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *) constDefinition TInterpreter.h:328; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodCall::GetCallFuncCallFunc_t * GetCallFunc() constDefinition TMethodCall.h:93; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNam",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:167683,Availability,error,error,167683,"rideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:170476,Availability,down,downward,170476,"ontains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; double; int; unsigned int; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; ROOT::Splitstd::vector< std::string > Split(std::string_view str, std::string_view delims, bool skipEmpty=false)Splits a string at each character in delims.Definition StringUtils.cxx:23; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472; TMath::Gconstexpr Double_t G()Gravitational constant in: .Definition TMath.h:135; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Defini",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:48109,Deployability,update,update,48109,"formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" : """"), counter);; 1293 }; 1294 if (defaultCounter && !defaultVariables) {; 1295 pattern = TString::Format(""%s%s[%s]"", funName.Data(), (isNormalized ? ""n"" : """"), varList.Data());; 1296 }; 1297 if (!defaultCounter && !defaultVariables) {; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:48195,Deployability,update,update,48195,"formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" : """"), counter);; 1293 }; 1294 if (defaultCounter && !defaultVariables) {; 1295 pattern = TString::Format(""%s%s[%s]"", funName.Data(), (isNormalized ? ""n"" : """"), varList.Data());; 1296 }; 1297 if (!defaultCounter && !defaultVariables) {; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:68112,Deployability,update,update,68112,"eAll(""**"",""^"");; 1774 formula.ReplaceAll(""++"",""@""); // for linear functions; 1775 formula.ReplaceAll("" "","""");; 1776 HandlePolN(formula);; 1777 HandleParametrizedFunctions(formula);; 1778 HandleParamRanges(formula);; 1779 HandleFunctionArguments(formula);; 1780 HandleExponentiation(formula);; 1781 // ""++"" wil be dealt with Handle Linear; 1782 HandleLinear(formula);; 1783 // special case for ""--"" and ""++""; 1784 // (""++"" needs to be written with whitespace that is removed before but then we re-add it again; 1785 formula.ReplaceAll(""--"",""- -"");; 1786 formula.ReplaceAll(""++"",""+ +"");; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// prepare the formula to be executed; 1791/// normally is called with fFormula; 1792 ; 1793Bool_t TFormula::PrepareFormula(TString &formula); 1794{; 1795 fFuncs.clear();; 1796 fReadyToExecute = false;; 1797 ExtractFunctors(formula);; 1798 ; 1799 // update the expression with the new formula; 1800 fFormula = formula;; 1801 // save formula to parse variable and parameters for Cling; 1802 fClingInput = formula;; 1803 // replace all { and }; 1804 fFormula.ReplaceAll(""{"","""");; 1805 fFormula.ReplaceAll(""}"","""");; 1806 ; 1807 // std::cout << ""functors are extracted formula is "" << std::endl;; 1808 // std::cout << fFormula << std::endl << std::endl;; 1809 ; 1810 fFuncs.sort();; 1811 fFuncs.unique();; 1812 ; 1813 // use inputFormula for Cling; 1814 ProcessFormula(fClingInput);; 1815 ; 1816 // for pre-defined functions (need after processing); 1817 if (fNumber != 0) SetPredefinedParamNames();; 1818 ; 1819 return fReadyToExecute && fClingInitialized;; 1820}; 1821 ; 1822////////////////////////////////////////////////////////////////////////////////; 1823/// Extracts functors from formula, and put them in fFuncs.; 1824/// Simple grammar:; 1825/// - `<function>` := name(arg1,arg2...); 1826/// - `<variable>` := name; 1827/// - `<parameter>` := [number]; 1828/// - `<name>` := String containing lower and ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:155206,Integrability,rout,routine,155206," the operator ++.Definition TFormula.cxx:1735; TFormula::fClingNameTString fClingName! Unique name passed to Cling to define the function ( double clingName(double*x, double*p) )Definition TFormula.h:101; TFormula::GetVarNameTString GetVarName(Int_t ivar) constReturns variable name given its position in the array.Definition TFormula.cxx:2712; TFormula::SetVariablevoid SetVariable(const TString &name, Double_t value)Sets variable value.Definition TFormula.cxx:2728; TFormula::HessianParvoid HessianPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3286; TFormula::GetParNumberInt_t GetParNumber(const char *name) constReturn parameter index given a name (return -1 for not existing parameters) non need to print an erro...Definition TFormula.cxx:2821; TFormula::DoSetParametersvoid DoSetParameters(const Double_t *p, Int_t size)Definition TFormula.cxx:2949; TFormula::GenerateHessianParbool GenerateHessianPar()Generate hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; TFormula::GetGradientFormulaTString GetGradientFormula() constDefinition TFormula.cxx:3594; TFormula::HandleParametrizedFunctionsvoid HandleParametrizedFunctions(TString &formula)Handling parametrized functions Function can be normalized, and have different variable then x.Definition TFormula.cxx:1103; TFormula::~TFormula~TFormula() overrideDefinition TFormula.cxx:465; TFormula::CallFuncSignatureTInterpreter::CallFuncIFacePtr_t::Generic_t CallFuncSignatureDefinition TFormula.h:104; TFormula::GetParametersDouble_t * GetParameters() constDefinition TFormula.cxx:2873; TFormula::SetParNamevoid SetParName(Int_t ipar, const char *name)Definition TFormula.cxx:2990; TFormula::SetNamevoid SetName(const char *name) overrideSet the name of the formula.Definition TFormula.cxx:2640; TFormula::GetHessianFuncNamestd::string GetHessianFuncName() constDefinition TFormula.h:131; TFormula::fGradGenerationInputs",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:165332,Integrability,rout,routine,165332,"dVariablevoid AddVariable(const TString &name, Double_t value=0)Adds variable to known variables, and reprocess formula.Definition TFormula.cxx:2569; TFormula::fLazyInitializationBool_t fLazyInitialization! Transient flag to control lazy initialization (needed for reading from files)Definition TFormula.h:99; TFormula::HandleExponentiationvoid HandleExponentiation(TString &formula)Handling exponentiation Can handle multiple carets, eg.Definition TFormula.cxx:1635; TFormula::IsFunctionNameCharstatic Bool_t IsFunctionNameChar(const char c)Definition TFormula.cxx:306; TFormula::fHessGenerationInputstd::string fHessGenerationInput! Input query to clad to generate a hessianDefinition TFormula.h:106; TFormula::DoEvalDouble_t DoEval(const Double_t *x, const Double_t *p=nullptr) constEvaluate formula.Definition TFormula.cxx:3359; TFormula::fReadyToExecuteBool_t fReadyToExecute! Transient to force initializationDefinition TFormula.h:96; TFormula::GenerateGradientParbool GenerateGradientPar()Generate gradient computation routine with respect to the parameters.Definition TFormula.cxx:3192; TFormula::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TFormula.cxx:3679; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TInterpreter::ProcessLinevirtual Longptr_t ProcessLine(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::Declarevirtual Bool_t Declare(const char *code)=0; TInterpreter::CallFunc_IsValidvirtual Bool_t CallFunc_IsValid(CallFunc_t *) constDefinition TInterpreter.h:327; TInterpreter::CallFunc_IFacePtrvirtual CallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *) constDefinition TInterpreter.h:328; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodCall::GetCallFuncCallFunc_t * GetCallFunc() constDefinition TMethodCall.h:93; TMethodEach ROOT class (see TClass) has a linked ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:166133,Integrability,interface,interface,166133,"ion TFormula.cxx:3359; TFormula::fReadyToExecuteBool_t fReadyToExecute! Transient to force initializationDefinition TFormula.h:96; TFormula::GenerateGradientParbool GenerateGradientPar()Generate gradient computation routine with respect to the parameters.Definition TFormula.cxx:3192; TFormula::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TFormula.cxx:3679; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TInterpreter::ProcessLinevirtual Longptr_t ProcessLine(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::Declarevirtual Bool_t Declare(const char *code)=0; TInterpreter::CallFunc_IsValidvirtual Bool_t CallFunc_IsValid(CallFunc_t *) constDefinition TInterpreter.h:327; TInterpreter::CallFunc_IFacePtrvirtual CallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *) constDefinition TInterpreter.h:328; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodCall::GetCallFuncCallFunc_t * GetCallFunc() constDefinition TMethodCall.h:93; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::T",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:167295,Integrability,message,message,167295,"ass) has a linked list of methods.Definition TMethod.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::InsertTString & Insert(Ssiz_t pos, const cha",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:167689,Integrability,message,message,167689,"rideReturns title of object.Definition TNamed.h:48; TNamed::fTitleTString fTitleDefinition TNamed.h:33; TNamed::fNameTString fNameDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:167816,Integrability,message,message,167816,"meDefinition TNamed.h:32; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TRegexp::IndexSsiz_t Index(const TString &str, Ssiz_t *len, Ssiz_t start=0) constFind the first occurrence of the regexp in string and return the position, or -1 if there is no match...Definition TRegexp.cxx:213; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TStrin",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:3556,Modifiability,variab,variable,3556," means start numbering parameters at 0; 73 - `expo(3)` is a substitute for `exp([3]+[4]*x)`; 74 - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; 75 (`PolN` stands for Polynomial of degree N); 76 - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; 77 - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`; 78 ; 79 See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; 80 TFormula.; 81 ; 82 `TMath` functions can be part of the expression, eg:; 83 ; 84 - `TMath::Landau(x)*sin(x)`; 85 - `TMath::Erf(x)`; 86 ; 87 Formula may contain constants, eg:; 88 ; 89 - `sqrt2`; 90 - `e`; 91 - `pi`; 92 - `ln10`; 93 - `infinity`; 94 ; 95 and more.; 96 ; 97 Formulas may also contain other user-defined ROOT functions defined with a; 98 TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:; 99 ; 100 - `f1(x, [omega], [phi])`; 101 - `f1([0..1])`; 102 - `f1([1], [0])`; 103 - `f1(y)`; 104 ; 105 To replace only parameter names, the dimension variable can be dropped.; 106 Alternatively, to change only the dimension variable, the parameters can be; 107 dropped. Note that if a parameter is dropped or keeps its old name, its old; 108 value will be copied to the new function. The syntax used in the examples; 109 above also applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:3630,Modifiability,variab,variable,3630,"s a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; 75 (`PolN` stands for Polynomial of degree N); 76 - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; 77 - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`; 78 ; 79 See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; 80 TFormula.; 81 ; 82 `TMath` functions can be part of the expression, eg:; 83 ; 84 - `TMath::Landau(x)*sin(x)`; 85 - `TMath::Erf(x)`; 86 ; 87 Formula may contain constants, eg:; 88 ; 89 - `sqrt2`; 90 - `e`; 91 - `pi`; 92 - `ln10`; 93 - `infinity`; 94 ; 95 and more.; 96 ; 97 Formulas may also contain other user-defined ROOT functions defined with a; 98 TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:; 99 ; 100 - `f1(x, [omega], [phi])`; 101 - `f1([0..1])`; 102 - `f1([1], [0])`; 103 - `f1(y)`; 104 ; 105 To replace only parameter names, the dimension variable can be dropped.; 106 Alternatively, to change only the dimension variable, the parameters can be; 107 dropped. Note that if a parameter is dropped or keeps its old name, its old; 108 value will be copied to the new function. The syntax used in the examples; 109 above also applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:4583,Modifiability,variab,variables,4583,"le can be dropped.; 106 Alternatively, to change only the dimension variable, the parameters can be; 107 dropped. Note that if a parameter is dropped or keeps its old name, its old; 108 value will be copied to the new function. The syntax used in the examples; 109 above also applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the names which can be used for the variables are `x,y,z,t` or; 134 `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.; 135 ; 136 This class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:4661,Modifiability,variab,variables,4661,"; 107 dropped. Note that if a parameter is dropped or keeps its old name, its old; 108 value will be copied to the new function. The syntax used in the examples; 109 above also applies to the predefined parametrized functions like `gaus` and; 110 `expo`.; 111 ; 112 Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`; 113 ; 114 Examples:; 115 ; 116 `sin(x*(x&lt;0.5 || x&gt;1))`; 117 ; 118 If the result of a comparison is TRUE, the result is 1, otherwise 0.; 119 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the names which can be used for the variables are `x,y,z,t` or; 134 `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.; 135 ; 136 This class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `HessianPar` returns a flattened matrix:; 156 ; 157 ```; 158 TFormula::CladStorage hess(4);; 159 f.He",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:5141,Modifiability,variab,variables,5141,"19 ; 120 Already predefined names can be given. For example, if the formula; 121 ; 122 `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`; 123 ; 124 one can assign a name to the formula. By default the name of the object = title = formula itself.; 125 ; 126 `TFormula new(""new"",""x*old"")`; 127 ; 128 is equivalent to:; 129 ; 130 `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`; 131 ; 132 The class supports unlimited number of variables and parameters.; 133 By default the names which can be used for the variables are `x,y,z,t` or; 134 `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas.; 135 ; 136 This class is not anymore the base class for the function classes `TF1`, but it has now; 137 a data member of TF1 which can be accessed via `TF1::GetFormula`.; 138 ; 139 TFormula supports gradient and hessian calculations through clad.; 140 To calculate the gradient one needs to first declare a `CladStorage` of the; 141 same size as the number of parameters and then pass the variables and the; 142 created `CladStorage`:; 143 ; 144 ```; 145 TFormula f(""f"", ""x*[0] - y*[1]"");; 146 Double_t p[] = {40, 30};; 147 Double_t x[] = {1, 2};; 148 f.SetParameters(p);; 149 TFormula::CladStorage grad(2);; 150 f.GradientPar(x, grad);; 151 ```; 152 ; 153 The process is similar for hessians, except that the size of the created; 154 CladStorage should be the square of the number of parameters because; 155 `HessianPar` returns a flattened matrix:; 156 ; 157 ```; 158 TFormula::CladStorage hess(4);; 159 f.HessianPar(x, hess);; 160 ```; 161 ; 162 \anchor FormulaFuncs; 163 ### List of predefined functions; 164 ; 165 The list of available predefined functions which can be used as shortcuts is the following:; 166 1. One Dimensional functions:; 167 - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x-[Mean])/[Sigma]))`; 168 - `landau` is a substitute for `[Constant]*TMath::Landau (x,[MPV],[Sigma],false)`; 169 - `expo` is a substitute for `exp([Constant]+[Slope]*x)`; 170 -",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:7292,Modifiability,variab,variables,7292,")`; 172 - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` :; 173 `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`; 174 - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`:; 175 `ROOT::Math::Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.; 176 2. Two Dimensional functions:; 177 - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; 178 - `bigaus` is a substitute for `[Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 179 3. Three Dimensional functions:; 180 - `xyzgaus` is for a 3d Gaussians without correlations:; 181 `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`; 182 ; 183 ; 184 ### An expanded note on variables and parameters; 185 ; 186 In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; 187 index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.; 188 ; 189 ```; 190 TFormula("""", ""x[0] * x[1] + 10""); 191 ```; 192 ; 193 Parameters are similar and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data prov",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:7345,Modifiability,variab,variable,7345,")`; 172 - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` :; 173 `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`; 174 - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`:; 175 `ROOT::Math::Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.; 176 2. Two Dimensional functions:; 177 - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; 178 - `bigaus` is a substitute for `[Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 179 3. Three Dimensional functions:; 180 - `xyzgaus` is for a 3d Gaussians without correlations:; 181 `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`; 182 ; 183 ; 184 ### An expanded note on variables and parameters; 185 ; 186 In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; 187 index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.; 188 ; 189 ```; 190 TFormula("""", ""x[0] * x[1] + 10""); 191 ```; 192 ; 193 Parameters are similar and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data prov",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:8225,Modifiability,variab,variables,8225,"SigmaZ]),2))`; 182 ; 183 ; 184 ### An expanded note on variables and parameters; 185 ; 186 In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; 187 index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.; 188 ; 189 ```; 190 TFormula("""", ""x[0] * x[1] + 10""); 191 ```; 192 ; 193 Parameters are similar and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ; 232 All operators of C/C++ are allowed in a TFormula with a few caveats.; 233 ; 234 The operators `|`, `&`, `%` can be used but will raise an error if used in; 235 conjunction with a variable or a parameter. Variables and parameters are treated; 236 as doubles internally for which these operators are not defined.; 237 This means t",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:8367,Modifiability,variab,variables,8367,"a, a variable is a defined by a name `x`, `y`, `z` or `t` or an; 187 index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer.; 188 ; 189 ```; 190 TFormula("""", ""x[0] * x[1] + 10""); 191 ```; 192 ; 193 Parameters are similar and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ; 232 All operators of C/C++ are allowed in a TFormula with a few caveats.; 233 ; 234 The operators `|`, `&`, `%` can be used but will raise an error if used in; 235 conjunction with a variable or a parameter. Variables and parameters are treated; 236 as doubles internally for which these operators are not defined.; 237 This means the following command will run successfully; 238 ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; 23",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:8601,Modifiability,variab,variables,8601,"and can take any name. It is specified using brackets; 194 e.g. `[expected_mass]` or `[0]`.; 195 ; 196 ```; 197 TFormula("""", ""exp([expected_mass])-1""); 198 ```; 199 ; 200 Variables and parameters can be combined in the same TFormula. Here we consider; 201 a very simple case where we have an exponential decay after some time t and a; 202 number of events with timestamps for which we want to evaluate this function.; 203 ; 204 ```; 205 TFormula tf ("""", ""[0]*exp(-[1]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ; 232 All operators of C/C++ are allowed in a TFormula with a few caveats.; 233 ; 234 The operators `|`, `&`, `%` can be used but will raise an error if used in; 235 conjunction with a variable or a parameter. Variables and parameters are treated; 236 as doubles internally for which these operators are not defined.; 237 This means the following command will run successfully; 238 ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; 239 but not; 240 ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```.; 241 ; 242 The operator `^` is defined to mean exponentiation instead of the C/C++; 243 interpretation xor. `**` is added, also meaning exponentiation.; 244 ; 245 The opera",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:9088,Modifiability,variab,variable,9088,"]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ; 232 All operators of C/C++ are allowed in a TFormula with a few caveats.; 233 ; 234 The operators `|`, `&`, `%` can be used but will raise an error if used in; 235 conjunction with a variable or a parameter. Variables and parameters are treated; 236 as doubles internally for which these operators are not defined.; 237 This means the following command will run successfully; 238 ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; 239 but not; 240 ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```.; 241 ; 242 The operator `^` is defined to mean exponentiation instead of the C/C++; 243 interpretation xor. `**` is added, also meaning exponentiation.; 244 ; 245 The operators `++` and `@` are added, and are shorthand for the a linear; 246 function. That means the expression `x@2` will be expanded to; 247 ```[n]*x + [n+1]*2``` where n is the first previously unused parameter number.; 248 ; 249 \class TFormulaFunction; 250 Helper class for TFormula; 251 ; 252 \class TFormulaVariable; 253 Another helper class for TFormula; 254 ; 255 \class TFormulaParamOrder; 256 Functor defining the parameter order; 257*/; 258 ; 259// prefix used f",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:19690,Modifiability,variab,variable,19690,"r (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 478 }; 479}; 480 ; 481////////////////////////////////////////////////////////////////////////////////; 482TFormula::TFormula(const char *name, const char *formula, bool addToGlobList, bool vectorize) :; 483 TNamed(name,formula),; 484 fClingInput(formula),fFormula(formula); 485{; 486 fReadyToExecute = false;; 487 fClingInitialized = false;; 488 fNdim = 0;; 489 fNpar = 0;; 490 fNumber = 0;; 491 fLambdaPtr = nullptr;; 492 fVectorized = vectorize;; 493#ifndef R__HAS_VECCORE; 494 fVectorized = false;; 495#endif; 496 ; 497 FillDefaults();; 498 ; 499 ; 500 //fName = gNamePrefix + name; // is this needed; 501 ; 502 // do not process null formulas.; 503 if (!fFormula.IsNull() ) {; 504 PreProcessFormula(fFormula);; 505 ; 506 bool ok = PrepareFormula(fFormula);; 507 // if the formula has been correctly initialized add to the list of global functions; 508 if (ok) {; 509 if (addToGlobList && gROOT) {; 510 TFormula *old = nullptr;; 511 R__LOCKGUARD(gROOTMutex);; 512 old = dynamic_cast<TFormula *>(gROOT->GetListOfFunctions()->FindObject(name));; 513 if (old); 514 gROOT->GetListOfFunctions()->Remove(old);; 515 if (IsReservedName(name)); 516 Error(""TFormula"", ""The name %s is reserved as a TFormula variable name.\n"", name);; 517 else; 518 gROOT->GetListOfFunctions()->Add(this);; 519 }; 520 SetBit(kNotGlobal,!addToGlobList);; 521 }; 522 }; 523}; 524 ; 525////////////////////////////////////////////////////////////////////////////////; 526/// Constructor from a full compile-able C++ expression; 527 ; 528TFormula::TFormula(const char *name, const char *formula, int ndim, int npar, bool addToGlobList) :; 529 TNamed(name,formula),; 530 fClingInput(formula),fFormula(formula); 531{; 532 fReadyToExecute = false;; 533 fClingInitialized = false;; 534 fNpar = 0;; 535 fNumber = 0;; 536 fLambdaPtr = nullptr;; 537 fFuncPtr = nullptr;; 538 fGradFuncPtr = nullptr;; 539 fHessFuncPtr = nullptr;; 540 ; 541 ; 542 fNdim = ndim;; 543 for (int i = ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:21067,Modifiability,variab,variable,21067,"510 TFormula *old = nullptr;; 511 R__LOCKGUARD(gROOTMutex);; 512 old = dynamic_cast<TFormula *>(gROOT->GetListOfFunctions()->FindObject(name));; 513 if (old); 514 gROOT->GetListOfFunctions()->Remove(old);; 515 if (IsReservedName(name)); 516 Error(""TFormula"", ""The name %s is reserved as a TFormula variable name.\n"", name);; 517 else; 518 gROOT->GetListOfFunctions()->Add(this);; 519 }; 520 SetBit(kNotGlobal,!addToGlobList);; 521 }; 522 }; 523}; 524 ; 525////////////////////////////////////////////////////////////////////////////////; 526/// Constructor from a full compile-able C++ expression; 527 ; 528TFormula::TFormula(const char *name, const char *formula, int ndim, int npar, bool addToGlobList) :; 529 TNamed(name,formula),; 530 fClingInput(formula),fFormula(formula); 531{; 532 fReadyToExecute = false;; 533 fClingInitialized = false;; 534 fNpar = 0;; 535 fNumber = 0;; 536 fLambdaPtr = nullptr;; 537 fFuncPtr = nullptr;; 538 fGradFuncPtr = nullptr;; 539 fHessFuncPtr = nullptr;; 540 ; 541 ; 542 fNdim = ndim;; 543 for (int i = 0; i < npar; ++i) {; 544 DoAddParameter(TString::Format(""p%d"",i), 0, false);; 545 }; 546 fAllParametersSetted = true;; 547 assert (fNpar == npar);; 548 ; 549 bool ret = InitLambdaExpression(formula);; 550 ; 551 if (ret) {; 552 ; 553 SetBit(TFormula::kLambda);; 554 ; 555 fReadyToExecute = true;; 556 ; 557 if (addToGlobList && gROOT) {; 558 TFormula *old = nullptr;; 559 R__LOCKGUARD(gROOTMutex);; 560 old = dynamic_cast<TFormula*> ( gROOT->GetListOfFunctions()->FindObject(name) );; 561 if (old); 562 gROOT->GetListOfFunctions()->Remove(old);; 563 if (IsReservedName(name)); 564 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",name);; 565 else; 566 gROOT->GetListOfFunctions()->Add(this);; 567 }; 568 SetBit(kNotGlobal,!addToGlobList);; 569 }; 570 else; 571 Error(""TFormula"",""Syntax error in building the lambda expression %s"", formula );; 572}; 573 ; 574////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:21892,Modifiability,variab,variable,21892,"> ( gROOT->GetListOfFunctions()->FindObject(name) );; 561 if (old); 562 gROOT->GetListOfFunctions()->Remove(old);; 563 if (IsReservedName(name)); 564 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",name);; 565 else; 566 gROOT->GetListOfFunctions()->Add(this);; 567 }; 568 SetBit(kNotGlobal,!addToGlobList);; 569 }; 570 else; 571 Error(""TFormula"",""Syntax error in building the lambda expression %s"", formula );; 572}; 573 ; 574////////////////////////////////////////////////////////////////////////////////; 575TFormula::TFormula(const TFormula &formula) :; 576 TNamed(formula.GetName(),formula.GetTitle()); 577{; 578 formula.TFormula::Copy(*this);; 579 ; 580 if (!TestBit(TFormula::kNotGlobal) && gROOT ) {; 581 R__LOCKGUARD(gROOTMutex);; 582 TFormula *old = (TFormula*)gROOT->GetListOfFunctions()->FindObject(formula.GetName());; 583 if (old); 584 gROOT->GetListOfFunctions()->Remove(old);; 585 ; 586 if (IsReservedName(formula.GetName())) {; 587 Error(""TFormula"",""The name %s is reserved as a TFormula variable name.\n"",formula.GetName());; 588 } else; 589 gROOT->GetListOfFunctions()->Add(this);; 590 }; 591 ; 592}; 593 ; 594////////////////////////////////////////////////////////////////////////////////; 595/// = operator.; 596 ; 597TFormula& TFormula::operator=(const TFormula &rhs); 598{; 599 if (this != &rhs); 600 rhs.TFormula::Copy(*this);; 601 return *this;; 602}; 603 ; 604////////////////////////////////////////////////////////////////////////////////; 605Bool_t TFormula::InitLambdaExpression(const char * formula) {; 606 ; 607 std::string lambdaExpression = formula;; 608 ; 609 // check if formula exist already in the map; 610 {; 611 R__LOCKGUARD(gROOTMutex);; 612 ; 613 auto funcit = gClingFunctions.find(lambdaExpression);; 614 if (funcit != gClingFunctions.end() ) {; 615 fLambdaPtr = funcit->second;; 616 fClingInitialized = true;; 617 return true;; 618 }; 619 }; 620 ; 621 // to be sure the interpreter is initialized; 622 ROOT::GetROOT();; 623 R__ASS",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:28126,Modifiability,variab,variables,28126," = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; 739 bool ret = fnew.InitLambdaExpression(fnew.fFormula);; 740 if (ret) {; 741 fnew.SetBit(TFormula::kLambda);; 742 fnew.fReadyToExecute = true;; 743 }; 744 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 fReadyToExecute = false;; 780 fClingInitialized = false;; 781 fAllParametersSetted = false;; 782 fFuncs.clear();; 783 fVars.clear();; 784 fParams.clear();; 785 fConsts.clear();; 786 fFunctionsShortcuts.clear();; 787 ; 788 // delete linear parts; 789 int nLinParts = fLinearParts.size();; 790 if (nLinParts > 0) {; 791 for (int i = 0; i < nLinParts; ++i) delete fLinearParts[i];; 792 }; 793 fLinearParts.clear();; 794 ; 795}; 796 ; 797// Returns nullptr on failure.; 798static std::unique_ptr<TMethodCall>; 799prepareMethod(bool HasParameters, bool HasVariables, const char* FuncName,; 800 bool IsVectorized, bool AddCladArrayRef = fals",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:32580,Modifiability,variab,variables,32580,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:34353,Modifiability,variab,variables,34353,"ath::LogE()}, {""true"",1},{""false"",0} };; 923 const pair<TString,TString> funShortcuts[] =; 924 { {""sin"",""TMath::Sin"" },; 925 {""cos"",""TMath::Cos"" }, {""exp"",""TMath::Exp""}, {""log"",""TMath::Log""}, {""log10"",""TMath::Log10""},; 926 {""tan"",""TMath::Tan""}, {""sinh"",""TMath::SinH""}, {""cosh"",""TMath::CosH""},; 927 {""tanh"",""TMath::TanH""}, {""asin"",""TMath::ASin""}, {""acos"",""TMath::ACos""},; 928 {""atan"",""TMath::ATan""}, {""atan2"",""TMath::ATan2""}, {""sqrt"",""TMath::Sqrt""},; 929 {""ceil"",""TMath::Ceil""}, {""floor"",""TMath::Floor""}, {""pow"",""TMath::Power""},; 930 {""binomial"",""TMath::Binomial""},{""abs"",""TMath::Abs""},; 931 {""min"",""TMath::Min""},{""max"",""TMath::Max""},{""sign"",""TMath::Sign"" },; 932 {""sq"",""TMath::Sq""}; 933 };; 934 ; 935 std::vector<TString> defvars2(10);; 936 for (int i = 0; i < 9; ++i); 937 defvars2[i] = TString::Format(""x[%d]"",i);; 938 ; 939 for (const auto &var : defvars) {; 940 int pos = fVars.size();; 941 fVars[var] = TFormulaVariable(var, 0, pos);; 942 fClingVariables.push_back(0);; 943 }; 944 // add also the variables defined like x[0],x[1],x[2],...; 945 // support up to x[9] - if needed extend that to higher value; 946 // const int maxdim = 10;; 947 // for (int i = 0; i < maxdim; ++i) {; 948 // TString xvar = TString::Format(""x[%d]"",i);; 949 // fVars[xvar] = TFormulaVariable(xvar,0,i);; 950 // fClingVariables.push_back(0);; 951 // }; 952 ; 953 for (auto con : defconsts) {; 954 fConsts[con.first] = con.second;; 955 }; 956 if (fVectorized) {; 957 FillVecFunctionsShurtCuts();; 958 } else {; 959 for (auto fun : funShortcuts) {; 960 fFunctionsShortcuts[fun.first] = fun.second;; 961 }; 962 }; 963}; 964 ; 965////////////////////////////////////////////////////////////////////////////////; 966/// Fill the shortcuts for vectorized functions; 967/// We will replace for example sin with vecCore::Mat::Sin; 968///; 969 ; 970void TFormula::FillVecFunctionsShurtCuts() {; 971#ifdef R__HAS_VECCORE; 972 const pair<TString,TString> vecFunShortcuts[] =; 973 { {""sin"",""vecCore::math::Sin"" },; 974 {""cos"",""vecC",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:34434,Modifiability,extend,extend,34434,",""TMath::Log""}, {""log10"",""TMath::Log10""},; 926 {""tan"",""TMath::Tan""}, {""sinh"",""TMath::SinH""}, {""cosh"",""TMath::CosH""},; 927 {""tanh"",""TMath::TanH""}, {""asin"",""TMath::ASin""}, {""acos"",""TMath::ACos""},; 928 {""atan"",""TMath::ATan""}, {""atan2"",""TMath::ATan2""}, {""sqrt"",""TMath::Sqrt""},; 929 {""ceil"",""TMath::Ceil""}, {""floor"",""TMath::Floor""}, {""pow"",""TMath::Power""},; 930 {""binomial"",""TMath::Binomial""},{""abs"",""TMath::Abs""},; 931 {""min"",""TMath::Min""},{""max"",""TMath::Max""},{""sign"",""TMath::Sign"" },; 932 {""sq"",""TMath::Sq""}; 933 };; 934 ; 935 std::vector<TString> defvars2(10);; 936 for (int i = 0; i < 9; ++i); 937 defvars2[i] = TString::Format(""x[%d]"",i);; 938 ; 939 for (const auto &var : defvars) {; 940 int pos = fVars.size();; 941 fVars[var] = TFormulaVariable(var, 0, pos);; 942 fClingVariables.push_back(0);; 943 }; 944 // add also the variables defined like x[0],x[1],x[2],...; 945 // support up to x[9] - if needed extend that to higher value; 946 // const int maxdim = 10;; 947 // for (int i = 0; i < maxdim; ++i) {; 948 // TString xvar = TString::Format(""x[%d]"",i);; 949 // fVars[xvar] = TFormulaVariable(xvar,0,i);; 950 // fClingVariables.push_back(0);; 951 // }; 952 ; 953 for (auto con : defconsts) {; 954 fConsts[con.first] = con.second;; 955 }; 956 if (fVectorized) {; 957 FillVecFunctionsShurtCuts();; 958 } else {; 959 for (auto fun : funShortcuts) {; 960 fFunctionsShortcuts[fun.first] = fun.second;; 961 }; 962 }; 963}; 964 ; 965////////////////////////////////////////////////////////////////////////////////; 966/// Fill the shortcuts for vectorized functions; 967/// We will replace for example sin with vecCore::Mat::Sin; 968///; 969 ; 970void TFormula::FillVecFunctionsShurtCuts() {; 971#ifdef R__HAS_VECCORE; 972 const pair<TString,TString> vecFunShortcuts[] =; 973 { {""sin"",""vecCore::math::Sin"" },; 974 {""cos"",""vecCore::math::Cos"" }, {""exp"",""vecCore::math::Exp""}, {""log"",""vecCore::math::Log""}, {""log10"",""vecCore::math::Log10""},; 975 {""tan"",""vecCore::math::Tan""},; 976 //{""sinh"",""vecCore::mat",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:36598,Modifiability,variab,variable,36598,"ore::math::Tan""},; 976 //{""sinh"",""vecCore::math::Sinh""}, {""cosh"",""vecCore::math::Cosh""},{""tanh"",""vecCore::math::Tanh""},; 977 {""asin"",""vecCore::math::ASin""},; 978 {""acos"",""TMath::Pi()/2-vecCore::math::ASin""},; 979 {""atan"",""vecCore::math::ATan""},; 980 {""atan2"",""vecCore::math::ATan2""}, {""sqrt"",""vecCore::math::Sqrt""},; 981 {""ceil"",""vecCore::math::Ceil""}, {""floor"",""vecCore::math::Floor""}, {""pow"",""vecCore::math::Pow""},; 982 {""cbrt"",""vecCore::math::Cbrt""},{""abs"",""vecCore::math::Abs""},; 983 {""min"",""vecCore::math::Min""},{""max"",""vecCore::math::Max""},{""sign"",""vecCore::math::Sign"" }; 984 //{""sq"",""TMath::Sq""}, {""binomial"",""TMath::Binomial""} // this last two functions will not work in vectorized mode; 985 };; 986 // replace in the data member maps fFunctionsShortcuts; 987 for (auto fun : vecFunShortcuts) {; 988 fFunctionsShortcuts[fun.first] = fun.second;; 989 }; 990#endif; 991 // do nothing in case Veccore is not enabled; 992}; 993 ; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Handling polN; 997/// If before 'pol' exist any name, this name will be treated as variable used in polynomial; 998/// eg.; 999/// varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; 1000/// Empty name is treated like variable x.; 1001 ; 1002void TFormula::HandlePolN(TString &formula); 1003{; 1004 Int_t polPos = formula.Index(""pol"");; 1005 while (polPos != kNPOS && !IsAParameterName(formula, polPos)) {; 1006 ; 1007 Bool_t defaultVariable = false;; 1008 TString variable;; 1009 Int_t openingBracketPos = formula.Index('(', polPos);; 1010 Bool_t defaultCounter = openingBracketPos == kNPOS;; 1011 Bool_t defaultDegree = true;; 1012 Int_t degree, counter;; 1013 TString sdegree;; 1014 if (!defaultCounter) {; 1015 // verify first of opening parenthesis belongs to pol expression; 1016 // character between 'pol' and '(' must all be digits; 1017 sdegree = formula(polPos + 3, openingBracketPos - polPos - 3);; 1018 if (!sdegree.IsDigit()); 1019 defaultCounter",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:36742,Modifiability,variab,variable,36742,"{""atan"",""vecCore::math::ATan""},; 980 {""atan2"",""vecCore::math::ATan2""}, {""sqrt"",""vecCore::math::Sqrt""},; 981 {""ceil"",""vecCore::math::Ceil""}, {""floor"",""vecCore::math::Floor""}, {""pow"",""vecCore::math::Pow""},; 982 {""cbrt"",""vecCore::math::Cbrt""},{""abs"",""vecCore::math::Abs""},; 983 {""min"",""vecCore::math::Min""},{""max"",""vecCore::math::Max""},{""sign"",""vecCore::math::Sign"" }; 984 //{""sq"",""TMath::Sq""}, {""binomial"",""TMath::Binomial""} // this last two functions will not work in vectorized mode; 985 };; 986 // replace in the data member maps fFunctionsShortcuts; 987 for (auto fun : vecFunShortcuts) {; 988 fFunctionsShortcuts[fun.first] = fun.second;; 989 }; 990#endif; 991 // do nothing in case Veccore is not enabled; 992}; 993 ; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Handling polN; 997/// If before 'pol' exist any name, this name will be treated as variable used in polynomial; 998/// eg.; 999/// varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; 1000/// Empty name is treated like variable x.; 1001 ; 1002void TFormula::HandlePolN(TString &formula); 1003{; 1004 Int_t polPos = formula.Index(""pol"");; 1005 while (polPos != kNPOS && !IsAParameterName(formula, polPos)) {; 1006 ; 1007 Bool_t defaultVariable = false;; 1008 TString variable;; 1009 Int_t openingBracketPos = formula.Index('(', polPos);; 1010 Bool_t defaultCounter = openingBracketPos == kNPOS;; 1011 Bool_t defaultDegree = true;; 1012 Int_t degree, counter;; 1013 TString sdegree;; 1014 if (!defaultCounter) {; 1015 // verify first of opening parenthesis belongs to pol expression; 1016 // character between 'pol' and '(' must all be digits; 1017 sdegree = formula(polPos + 3, openingBracketPos - polPos - 3);; 1018 if (!sdegree.IsDigit()); 1019 defaultCounter = true;; 1020 }; 1021 if (!defaultCounter) {; 1022 degree = sdegree.Atoi();; 1023 counter = TString(formula(openingBracketPos + 1, formula.Index(')', polPos) - openingBracketPos)).Atoi();; 1024 } else {; 1025 In",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:36989,Modifiability,variab,variable,36989,"""vecCore::math::Abs""},; 983 {""min"",""vecCore::math::Min""},{""max"",""vecCore::math::Max""},{""sign"",""vecCore::math::Sign"" }; 984 //{""sq"",""TMath::Sq""}, {""binomial"",""TMath::Binomial""} // this last two functions will not work in vectorized mode; 985 };; 986 // replace in the data member maps fFunctionsShortcuts; 987 for (auto fun : vecFunShortcuts) {; 988 fFunctionsShortcuts[fun.first] = fun.second;; 989 }; 990#endif; 991 // do nothing in case Veccore is not enabled; 992}; 993 ; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Handling polN; 997/// If before 'pol' exist any name, this name will be treated as variable used in polynomial; 998/// eg.; 999/// varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; 1000/// Empty name is treated like variable x.; 1001 ; 1002void TFormula::HandlePolN(TString &formula); 1003{; 1004 Int_t polPos = formula.Index(""pol"");; 1005 while (polPos != kNPOS && !IsAParameterName(formula, polPos)) {; 1006 ; 1007 Bool_t defaultVariable = false;; 1008 TString variable;; 1009 Int_t openingBracketPos = formula.Index('(', polPos);; 1010 Bool_t defaultCounter = openingBracketPos == kNPOS;; 1011 Bool_t defaultDegree = true;; 1012 Int_t degree, counter;; 1013 TString sdegree;; 1014 if (!defaultCounter) {; 1015 // verify first of opening parenthesis belongs to pol expression; 1016 // character between 'pol' and '(' must all be digits; 1017 sdegree = formula(polPos + 3, openingBracketPos - polPos - 3);; 1018 if (!sdegree.IsDigit()); 1019 defaultCounter = true;; 1020 }; 1021 if (!defaultCounter) {; 1022 degree = sdegree.Atoi();; 1023 counter = TString(formula(openingBracketPos + 1, formula.Index(')', polPos) - openingBracketPos)).Atoi();; 1024 } else {; 1025 Int_t temp = polPos + 3;; 1026 while (temp < formula.Length() && isdigit(formula[temp])) {; 1027 defaultDegree = false;; 1028 temp++;; 1029 }; 1030 degree = TString(formula(polPos + 3, temp - polPos - 3)).Atoi();; 1031 counter = 0;; 1032 }; 1033 ; 10",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:38110,Modifiability,variab,variable,38110," sdegree;; 1014 if (!defaultCounter) {; 1015 // verify first of opening parenthesis belongs to pol expression; 1016 // character between 'pol' and '(' must all be digits; 1017 sdegree = formula(polPos + 3, openingBracketPos - polPos - 3);; 1018 if (!sdegree.IsDigit()); 1019 defaultCounter = true;; 1020 }; 1021 if (!defaultCounter) {; 1022 degree = sdegree.Atoi();; 1023 counter = TString(formula(openingBracketPos + 1, formula.Index(')', polPos) - openingBracketPos)).Atoi();; 1024 } else {; 1025 Int_t temp = polPos + 3;; 1026 while (temp < formula.Length() && isdigit(formula[temp])) {; 1027 defaultDegree = false;; 1028 temp++;; 1029 }; 1030 degree = TString(formula(polPos + 3, temp - polPos - 3)).Atoi();; 1031 counter = 0;; 1032 }; 1033 ; 1034 TString replacement = TString::Format(""[%d]"", counter);; 1035 if (polPos - 1 < 0 || !IsFunctionNameChar(formula[polPos - 1]) || formula[polPos - 1] == ':') {; 1036 variable = ""x"";; 1037 defaultVariable = true;; 1038 } else {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultV",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:38312,Modifiability,variab,variable,38312," sdegree;; 1014 if (!defaultCounter) {; 1015 // verify first of opening parenthesis belongs to pol expression; 1016 // character between 'pol' and '(' must all be digits; 1017 sdegree = formula(polPos + 3, openingBracketPos - polPos - 3);; 1018 if (!sdegree.IsDigit()); 1019 defaultCounter = true;; 1020 }; 1021 if (!defaultCounter) {; 1022 degree = sdegree.Atoi();; 1023 counter = TString(formula(openingBracketPos + 1, formula.Index(')', polPos) - openingBracketPos)).Atoi();; 1024 } else {; 1025 Int_t temp = polPos + 3;; 1026 while (temp < formula.Length() && isdigit(formula[temp])) {; 1027 defaultDegree = false;; 1028 temp++;; 1029 }; 1030 degree = TString(formula(polPos + 3, temp - polPos - 3)).Atoi();; 1031 counter = 0;; 1032 }; 1033 ; 1034 TString replacement = TString::Format(""[%d]"", counter);; 1035 if (polPos - 1 < 0 || !IsFunctionNameChar(formula[polPos - 1]) || formula[polPos - 1] == ':') {; 1036 variable = ""x"";; 1037 defaultVariable = true;; 1038 } else {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultV",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:38535,Modifiability,variab,variable,38535,"tCounter) {; 1022 degree = sdegree.Atoi();; 1023 counter = TString(formula(openingBracketPos + 1, formula.Index(')', polPos) - openingBracketPos)).Atoi();; 1024 } else {; 1025 Int_t temp = polPos + 3;; 1026 while (temp < formula.Length() && isdigit(formula[temp])) {; 1027 defaultDegree = false;; 1028 temp++;; 1029 }; 1030 degree = TString(formula(polPos + 3, temp - polPos - 3)).Atoi();; 1031 counter = 0;; 1032 }; 1033 ; 1034 TString replacement = TString::Format(""[%d]"", counter);; 1035 if (polPos - 1 < 0 || !IsFunctionNameChar(formula[polPos - 1]) || formula[polPos - 1] == ':') {; 1036 variable = ""x"";; 1037 defaultVariable = true;; 1038 } else {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultVariable ? """" : variable.Data()), degree, counter);; 1067 }; 1068 ; 1069 if (!formula.Contains(pattern)) {; 1070 Error(""HandlePolN"", ""Error handling polynomial function - expression is %s - trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == p",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:38630,Modifiability,variab,variable,38630,", formula.Index(')', polPos) - openingBracketPos)).Atoi();; 1024 } else {; 1025 Int_t temp = polPos + 3;; 1026 while (temp < formula.Length() && isdigit(formula[temp])) {; 1027 defaultDegree = false;; 1028 temp++;; 1029 }; 1030 degree = TString(formula(polPos + 3, temp - polPos - 3)).Atoi();; 1031 counter = 0;; 1032 }; 1033 ; 1034 TString replacement = TString::Format(""[%d]"", counter);; 1035 if (polPos - 1 < 0 || !IsFunctionNameChar(formula[polPos - 1]) || formula[polPos - 1] == ':') {; 1036 variable = ""x"";; 1037 defaultVariable = true;; 1038 } else {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultVariable ? """" : variable.Data()), degree, counter);; 1067 }; 1068 ; 1069 if (!formula.Contains(pattern)) {; 1070 Error(""HandlePolN"", ""Error handling polynomial function - expression is %s - trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + d",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:38960,Modifiability,variab,variable,38960,"olPos - 3)).Atoi();; 1031 counter = 0;; 1032 }; 1033 ; 1034 TString replacement = TString::Format(""[%d]"", counter);; 1035 if (polPos - 1 < 0 || !IsFunctionNameChar(formula[polPos - 1]) || formula[polPos - 1] == ':') {; 1036 variable = ""x"";; 1037 defaultVariable = true;; 1038 } else {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultVariable ? """" : variable.Data()), degree, counter);; 1067 }; 1068 ; 1069 if (!formula.Contains(pattern)) {; 1070 Error(""HandlePolN"", ""Error handling polynomial function - expression is %s - trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can b",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:39104,Modifiability,variab,variable,39104,"NameChar(formula[polPos - 1]) || formula[polPos - 1] == ':') {; 1036 variable = ""x"";; 1037 defaultVariable = true;; 1038 } else {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultVariable ? """" : variable.Data()), degree, counter);; 1067 }; 1068 ; 1069 if (!formula.Contains(pattern)) {; 1070 Error(""HandlePolN"", ""Error handling polynomial function - expression is %s - trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can be normalized, and have different variable then x.; 1087/// Variables should be placed in brackets after function name.; 1088/// No brackets are treated lik",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:39209,Modifiability,variab,variable,39209,"lse {; 1039 Int_t tmp = polPos - 1;; 1040 while (tmp >= 0 && IsFunctionNameChar(formula[tmp]) && formula[tmp] != ':') {; 1041 tmp--;; 1042 }; 1043 variable = formula(tmp + 1, polPos - (tmp + 1));; 1044 }; 1045 Int_t param = counter + 1;; 1046 Int_t tmp = 1;; 1047 while (tmp <= degree) {; 1048 if (tmp > 1); 1049 replacement.Append(TString::Format(""+[%d]*%s^%d"", param, variable.Data(), tmp));; 1050 else; 1051 replacement.Append(TString::Format(""+[%d]*%s"", param, variable.Data()));; 1052 param++;; 1053 tmp++;; 1054 }; 1055 // add parenthesis before and after; 1056 if (degree > 0) {; 1057 replacement.Insert(0, '(');; 1058 replacement.Append(')');; 1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultVariable ? """" : variable.Data()), degree, counter);; 1067 }; 1068 ; 1069 if (!formula.Contains(pattern)) {; 1070 Error(""HandlePolN"", ""Error handling polynomial function - expression is %s - trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can be normalized, and have different variable then x.; 1087/// Variables should be placed in brackets after function name.; 1088/// No brackets are treated like [x].; 1089/// Normalized function has char 'n' after name, eg.; 1090/// gausn[var](0) will be replaced with [0]*exp(-0.5*((",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:39919,Modifiability,variab,variable,39919,"1059 }; 1060 TString pattern;; 1061 if (defaultCounter && !defaultDegree) {; 1062 pattern = TString::Format(""%spol%d"", (defaultVariable ? """" : variable.Data()), degree);; 1063 } else if (defaultCounter && defaultDegree) {; 1064 pattern = TString::Format(""%spol"", (defaultVariable ? """" : variable.Data()));; 1065 } else {; 1066 pattern = TString::Format(""%spol%d(%d)"", (defaultVariable ? """" : variable.Data()), degree, counter);; 1067 }; 1068 ; 1069 if (!formula.Contains(pattern)) {; 1070 Error(""HandlePolN"", ""Error handling polynomial function - expression is %s - trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can be normalized, and have different variable then x.; 1087/// Variables should be placed in brackets after function name.; 1088/// No brackets are treated like [x].; 1089/// Normalized function has char 'n' after name, eg.; 1090/// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); 1091///; 1092/// Adding function is easy, just follow these rules, and add to; 1093/// `TFormula::FillParametrizedFunctions` defined further below:; 1094///; 1095/// - Key for function map is pair of name and dimension of function; 1096/// - value of key is a pair function body and normalized function body; 1097/// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; 1098/// Count starts from 0.; 1099/// - [num] stands for parameter number.; 1100/// If user pass to function argument 5, num will stand for (5 + num) parameter.; 1101///; 1102 ; 1103void TFormula::HandleParametr",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:40542,Modifiability,variab,variable,40542,"trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can be normalized, and have different variable then x.; 1087/// Variables should be placed in brackets after function name.; 1088/// No brackets are treated like [x].; 1089/// Normalized function has char 'n' after name, eg.; 1090/// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); 1091///; 1092/// Adding function is easy, just follow these rules, and add to; 1093/// `TFormula::FillParametrizedFunctions` defined further below:; 1094///; 1095/// - Key for function map is pair of name and dimension of function; 1096/// - value of key is a pair function body and normalized function body; 1097/// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; 1098/// Count starts from 0.; 1099/// - [num] stands for parameter number.; 1100/// If user pass to function argument 5, num will stand for (5 + num) parameter.; 1101///; 1102 ; 1103void TFormula::HandleParametrizedFunctions(TString &formula); 1104{; 1105 // define all parametrized functions; 1106 map< pair<TString,Int_t> ,pair<TString,TString> > functions;; 1107 FillParametrizedFunctions(functions);; 1108 ; 1109 map<TString,Int_t> functionsNumbers;; 1110 functionsNumbers[""gaus""] = 100;; 1111 functionsNumbers[""bigaus""] = 102;; 1112 functionsNumbers[""landau""] = 400;; 1113 functionsNumbers[""expo""] = 200;; 1114 functionsNumbers[""crystalball""] = 500;; 1115 ; 1116 // replace old names xygaus -> gaus[x,y]; 1117 formula.ReplaceAll(""xyzgaus"",""gaus[x,y,z]"");; 1118 formula.Rep",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:40577,Modifiability,variab,variable,40577,"trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can be normalized, and have different variable then x.; 1087/// Variables should be placed in brackets after function name.; 1088/// No brackets are treated like [x].; 1089/// Normalized function has char 'n' after name, eg.; 1090/// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); 1091///; 1092/// Adding function is easy, just follow these rules, and add to; 1093/// `TFormula::FillParametrizedFunctions` defined further below:; 1094///; 1095/// - Key for function map is pair of name and dimension of function; 1096/// - value of key is a pair function body and normalized function body; 1097/// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; 1098/// Count starts from 0.; 1099/// - [num] stands for parameter number.; 1100/// If user pass to function argument 5, num will stand for (5 + num) parameter.; 1101///; 1102 ; 1103void TFormula::HandleParametrizedFunctions(TString &formula); 1104{; 1105 // define all parametrized functions; 1106 map< pair<TString,Int_t> ,pair<TString,TString> > functions;; 1107 FillParametrizedFunctions(functions);; 1108 ; 1109 map<TString,Int_t> functionsNumbers;; 1110 functionsNumbers[""gaus""] = 100;; 1111 functionsNumbers[""bigaus""] = 102;; 1112 functionsNumbers[""landau""] = 400;; 1113 functionsNumbers[""expo""] = 200;; 1114 functionsNumbers[""crystalball""] = 500;; 1115 ; 1116 // replace old names xygaus -> gaus[x,y]; 1117 formula.ReplaceAll(""xyzgaus"",""gaus[x,y,z]"");; 1118 formula.Rep",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:40591,Modifiability,variab,variable,40591,"trying to replace %s with %s "",; 1071 formula.Data(), pattern.Data(), replacement.Data());; 1072 break;; 1073 }; 1074 if (formula == pattern) {; 1075 // case of single polynomial; 1076 SetBit(kLinear, true);; 1077 fNumber = 300 + degree;; 1078 }; 1079 formula.ReplaceAll(pattern, replacement);; 1080 polPos = formula.Index(""pol"");; 1081 }; 1082}; 1083 ; 1084////////////////////////////////////////////////////////////////////////////////; 1085/// Handling parametrized functions; 1086/// Function can be normalized, and have different variable then x.; 1087/// Variables should be placed in brackets after function name.; 1088/// No brackets are treated like [x].; 1089/// Normalized function has char 'n' after name, eg.; 1090/// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); 1091///; 1092/// Adding function is easy, just follow these rules, and add to; 1093/// `TFormula::FillParametrizedFunctions` defined further below:; 1094///; 1095/// - Key for function map is pair of name and dimension of function; 1096/// - value of key is a pair function body and normalized function body; 1097/// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; 1098/// Count starts from 0.; 1099/// - [num] stands for parameter number.; 1100/// If user pass to function argument 5, num will stand for (5 + num) parameter.; 1101///; 1102 ; 1103void TFormula::HandleParametrizedFunctions(TString &formula); 1104{; 1105 // define all parametrized functions; 1106 map< pair<TString,Int_t> ,pair<TString,TString> > functions;; 1107 FillParametrizedFunctions(functions);; 1108 ; 1109 map<TString,Int_t> functionsNumbers;; 1110 functionsNumbers[""gaus""] = 100;; 1111 functionsNumbers[""bigaus""] = 102;; 1112 functionsNumbers[""landau""] = 400;; 1113 functionsNumbers[""expo""] = 200;; 1114 functionsNumbers[""crystalball""] = 500;; 1115 ; 1116 // replace old names xygaus -> gaus[x,y]; 1117 formula.ReplaceAll(""xyzgaus"",""gaus[x,y,z]"");; 1118 formula.Rep",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:43675,Modifiability,variab,variables,43675,"6 // std::endl;; 1147 if (iposBefore >= 0) {; 1148 assert(iposBefore < formula.Length());; 1149 //if (isalpha(formula[iposBefore])) {; 1150 if (IsFunctionNameChar(formula[iposBefore])) {; 1151 // std::cout << ""previous character for function "" << funName << "" is "" << formula[iposBefore] << ""- skip; 1152 // "" << std::endl;; 1153 funPos = formula.Index(funName, lastFunPos);; 1154 continue;; 1155 }; 1156 }; 1157 ; 1158 Bool_t isNormalized = false;; 1159 if (lastFunPos < formula.Length()) {; 1160 // check if function is normalized by looking at ""n"" character after function name (e.g. gausn); 1161 isNormalized = (formula[lastFunPos] == 'n');; 1162 if (isNormalized); 1163 lastFunPos += 1;; 1164 if (lastFunPos < formula.Length()) {; 1165 char c = formula[lastFunPos];; 1166 // check if also last character is not alphanumeric or is not an operator and not a parenthesis ( or [.; 1167 // Parenthesis [] are used to express the variables; 1168 if (isalnum(c) || (!IsOperator(c) && c != '(' && c != ')' && c != '[' && c != ']')) {; 1169 // std::cout << ""last character for function "" << funName << "" is "" << c << "" skip .."" << std::endl;; 1170 funPos = formula.Index(funName, lastFunPos);; 1171 continue;; 1172 }; 1173 }; 1174 }; 1175 ; 1176 if (isNormalized) {; 1177 SetBit(kNormalized, true);; 1178 }; 1179 std::vector<TString> variables;; 1180 Int_t dim = 0;; 1181 TString varList = """";; 1182 Bool_t defaultVariables = false;; 1183 ; 1184 // check if function has specified the [...] e.g. gaus[x,y]; 1185 Int_t openingBracketPos = funPos + funName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function d",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:44076,Modifiability,variab,variables,44076,";; 1153 funPos = formula.Index(funName, lastFunPos);; 1154 continue;; 1155 }; 1156 }; 1157 ; 1158 Bool_t isNormalized = false;; 1159 if (lastFunPos < formula.Length()) {; 1160 // check if function is normalized by looking at ""n"" character after function name (e.g. gausn); 1161 isNormalized = (formula[lastFunPos] == 'n');; 1162 if (isNormalized); 1163 lastFunPos += 1;; 1164 if (lastFunPos < formula.Length()) {; 1165 char c = formula[lastFunPos];; 1166 // check if also last character is not alphanumeric or is not an operator and not a parenthesis ( or [.; 1167 // Parenthesis [] are used to express the variables; 1168 if (isalnum(c) || (!IsOperator(c) && c != '(' && c != ')' && c != '[' && c != ']')) {; 1169 // std::cout << ""last character for function "" << funName << "" is "" << c << "" skip .."" << std::endl;; 1170 funPos = formula.Index(funName, lastFunPos);; 1171 continue;; 1172 }; 1173 }; 1174 }; 1175 ; 1176 if (isNormalized) {; 1177 SetBit(kNormalized, true);; 1178 }; 1179 std::vector<TString> variables;; 1180 Int_t dim = 0;; 1181 TString varList = """";; 1182 Bool_t defaultVariables = false;; 1183 ; 1184 // check if function has specified the [...] e.g. gaus[x,y]; 1185 Int_t openingBracketPos = funPos + funName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.L",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:44484,Modifiability,variab,variables,44484,"tFunPos < formula.Length()) {; 1165 char c = formula[lastFunPos];; 1166 // check if also last character is not alphanumeric or is not an operator and not a parenthesis ( or [.; 1167 // Parenthesis [] are used to express the variables; 1168 if (isalnum(c) || (!IsOperator(c) && c != '(' && c != ')' && c != '[' && c != ']')) {; 1169 // std::cout << ""last character for function "" << funName << "" is "" << c << "" skip .."" << std::endl;; 1170 funPos = formula.Index(funName, lastFunPos);; 1171 continue;; 1172 }; 1173 }; 1174 }; 1175 ; 1176 if (isNormalized) {; 1177 SetBit(kNormalized, true);; 1178 }; 1179 std::vector<TString> variables;; 1180 Int_t dim = 0;; 1181 TString varList = """";; 1182 Bool_t defaultVariables = false;; 1183 ; 1184 // check if function has specified the [...] e.g. gaus[x,y]; 1185 Int_t openingBracketPos = funPos + funName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compa",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:44560,Modifiability,variab,variables,44560," an operator and not a parenthesis ( or [.; 1167 // Parenthesis [] are used to express the variables; 1168 if (isalnum(c) || (!IsOperator(c) && c != '(' && c != ')' && c != '[' && c != ']')) {; 1169 // std::cout << ""last character for function "" << funName << "" is "" << c << "" skip .."" << std::endl;; 1170 funPos = formula.Index(funName, lastFunPos);; 1171 continue;; 1172 }; 1173 }; 1174 }; 1175 ; 1176 if (isNormalized) {; 1177 SetBit(kNormalized, true);; 1178 }; 1179 std::vector<TString> variables;; 1180 Int_t dim = 0;; 1181 TString varList = """";; 1182 Bool_t defaultVariables = false;; 1183 ; 1184 // check if function has specified the [...] e.g. gaus[x,y]; 1185 Int_t openingBracketPos = funPos + funName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimensio",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:44712,Modifiability,variab,variables,44712,"lnum(c) || (!IsOperator(c) && c != '(' && c != ')' && c != '[' && c != ']')) {; 1169 // std::cout << ""last character for function "" << funName << "" is "" << c << "" skip .."" << std::endl;; 1170 funPos = formula.Index(funName, lastFunPos);; 1171 continue;; 1172 }; 1173 }; 1174 }; 1175 ; 1176 if (isNormalized) {; 1177 SetBit(kNormalized, true);; 1178 }; 1179 std::vector<TString> variables;; 1180 Int_t dim = 0;; 1181 TString varList = """";; 1182 Bool_t defaultVariables = false;; 1183 ; 1184 // check if function has specified the [...] e.g. gaus[x,y]; 1185 Int_t openingBracketPos = funPos + funName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:44958,Modifiability,variab,variables,44958,"; 1172 }; 1173 }; 1174 }; 1175 ; 1176 if (isNormalized) {; 1177 SetBit(kNormalized, true);; 1178 }; 1179 std::vector<TString> variables;; 1180 Int_t dim = 0;; 1181 TString varList = """";; 1182 Bool_t defaultVariables = false;; 1183 ; 1184 // check if function has specified the [...] e.g. gaus[x,y]; 1185 Int_t openingBracketPos = funPos + funName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);; 1220 if (functions.find(key) == functions.end()) {; 1221 Error(""PreProcessFormula"", ""Dimension of function %s is detected to be of dimension %d and is not ""; 1222 ""compatible with existing pre-defined function which has dim %d"",; 1223 funName.Data()",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:45207,Modifiability,variab,variables,45207,"nName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);; 1220 if (functions.find(key) == functions.end()) {; 1221 Error(""PreProcessFormula"", ""Dimension of function %s is detected to be of dimension %d and is not ""; 1222 ""compatible with existing pre-defined function which has dim %d"",; 1223 funName.Data(), dim, funDim);; 1224 return;; 1225 }; 1226 // skip the particular function found - we might find later on the corresponding pre-defined function; 1227 funPos = formula.Index(funName, lastFunPos);; 1228 continue;; 1229 }; 1230 // look now for the (..) brackets to get the parameter counter (e.g. gaus(0) + gaus(3) ); 1231 // need to start fo",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:45330,Modifiability,variab,variable,45330,"nName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);; 1220 if (functions.find(key) == functions.end()) {; 1221 Error(""PreProcessFormula"", ""Dimension of function %s is detected to be of dimension %d and is not ""; 1222 ""compatible with existing pre-defined function which has dim %d"",; 1223 funName.Data(), dim, funDim);; 1224 return;; 1225 }; 1226 // skip the particular function found - we might find later on the corresponding pre-defined function; 1227 funPos = formula.Index(funName, lastFunPos);; 1228 continue;; 1229 }; 1230 // look now for the (..) brackets to get the parameter counter (e.g. gaus(0) + gaus(3) ); 1231 // need to start fo",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:45353,Modifiability,variab,variables,45353,"nName.Length() + (isNormalized ? 1 : 0);; 1186 Int_t closingBracketPos = kNPOS;; 1187 if (openingBracketPos > formula.Length() || formula[openingBracketPos] != '[') {; 1188 dim = funDim;; 1189 variables.resize(dim);; 1190 for (Int_t idim = 0; idim < dim; ++idim); 1191 variables[idim] = defaultVariableNames[idim];; 1192 defaultVariables = true;; 1193 } else {; 1194 // in case of [..] found, assume they specify all the variables. Use it to get function dimension; 1195 closingBracketPos = formula.Index(']', openingBracketPos);; 1196 varList = formula(openingBracketPos + 1, closingBracketPos - openingBracketPos - 1);; 1197 dim = varList.CountChar(',') + 1;; 1198 variables.resize(dim);; 1199 Int_t Nvar = 0;; 1200 TString varName = """";; 1201 for (Int_t i = 0; i < varList.Length(); ++i) {; 1202 if (IsFunctionNameChar(varList[i])) {; 1203 varName.Append(varList[i]);; 1204 }; 1205 if (varList[i] == ',') {; 1206 variables[Nvar] = varName;; 1207 varName = """";; 1208 Nvar++;; 1209 }; 1210 }; 1211 if (varName != """") // we will miss last variable; 1212 {; 1213 variables[Nvar] = varName;; 1214 }; 1215 }; 1216 // check if dimension obtained from [...] is compatible with what is defined in existing pre-defined functions; 1217 // std::cout << "" Found dim = "" << dim << "" and function dimension is "" << funDim << std::endl;; 1218 if (dim != funDim) {; 1219 pair<TString, Int_t> key = make_pair(funName, dim);; 1220 if (functions.find(key) == functions.end()) {; 1221 Error(""PreProcessFormula"", ""Dimension of function %s is detected to be of dimension %d and is not ""; 1222 ""compatible with existing pre-defined function which has dim %d"",; 1223 funName.Data(), dim, funDim);; 1224 return;; 1225 }; 1226 // skip the particular function found - we might find later on the corresponding pre-defined function; 1227 funPos = formula.Index(funName, lastFunPos);; 1228 continue;; 1229 }; 1230 // look now for the (..) brackets to get the parameter counter (e.g. gaus(0) + gaus(3) ); 1231 // need to start fo",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:47747,Modifiability,variab,variable,47747," // Check whether this is just a number in parentheses. If not, leave; 1242 // it to `HandleFunctionArguments` to be parsed; 1243 ; 1244 TRegexp counterPattern(""([0-9]+)"");; 1245 Ssiz_t len;; 1246 if (counterPattern.Index(formula, &len, openingParenthesisPos) == -1) {; 1247 funPos = formula.Index(funName, funPos + 1);; 1248 continue;; 1249 } else {; 1250 counter =; 1251 TString(formula(openingParenthesisPos + 1, formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", fu",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:47877,Modifiability,variab,variable,47877,"Ssiz_t len;; 1246 if (counterPattern.Index(formula, &len, openingParenthesisPos) == -1) {; 1247 funPos = formula.Index(funName, funPos + 1);; 1248 continue;; 1249 } else {; 1250 counter =; 1251 TString(formula(openingParenthesisPos + 1, formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:47888,Modifiability,variab,variables,47888,"Ssiz_t len;; 1246 if (counterPattern.Index(formula, &len, openingParenthesisPos) == -1) {; 1247 funPos = formula.Index(funName, funPos + 1);; 1248 continue;; 1249 } else {; 1250 counter =; 1251 TString(formula(openingParenthesisPos + 1, formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:48042,Modifiability,variab,variable,48042,".Index(funName, funPos + 1);; 1248 continue;; 1249 } else {; 1250 counter =; 1251 TString(formula(openingParenthesisPos + 1, formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" : """"), counter);; 1293 }; 1294 if (defaultCounter && !defaultVariables) {; 1295 pattern = TString::Format(""%s%s[%",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:48052,Modifiability,variab,variable,48052,".Index(funName, funPos + 1);; 1248 continue;; 1249 } else {; 1250 counter =; 1251 TString(formula(openingParenthesisPos + 1, formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" : """"), counter);; 1293 }; 1294 if (defaultCounter && !defaultVariables) {; 1295 pattern = TString::Format(""%s%s[%",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:48083,Modifiability,variab,variable,48083,"1248 continue;; 1249 } else {; 1250 counter =; 1251 TString(formula(openingParenthesisPos + 1, formula.Index(')', funPos) - openingParenthesisPos - 1)); 1252 .Atoi();; 1253 }; 1254 }; 1255 // std::cout << ""openingParenthesisPos "" << openingParenthesisPos << "" counter is "" << counter << std::endl;; 1256 ; 1257 TString body = (isNormalized ? it->second.second : it->second.first);; 1258 if (isNormalized && body == """") {; 1259 Error(""PreprocessFormula"", ""%d dimension function %s has no normalized form."", it->first.second,; 1260 funName.Data());; 1261 break;; 1262 }; 1263 for (int i = 0; i < body.Length(); ++i) {; 1264 if (body[i] == '{') {; 1265 // replace {Vn} with variable names; 1266 i += 2; // skip '{' and 'V'; 1267 Int_t num = TString(body(i, body.Index('}', i) - i)).Atoi();; 1268 TString variable = variables[num];; 1269 TString pattern = TString::Format(""{V%d}"", num);; 1270 i -= 2; // restore original position; 1271 body.Replace(i, pattern.Length(), variable, variable.Length());; 1272 i += variable.Length() - 1; // update i to reflect change in body string; 1273 } else if (body[i] == '[') {; 1274 // update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) ); 1275 Int_t tmp = i;; 1276 while (tmp < body.Length() && body[tmp] != ']') {; 1277 tmp++;; 1278 }; 1279 Int_t num = TString(body(i + 1, tmp - 1 - i)).Atoi();; 1280 num += counter;; 1281 TString replacement = TString::Format(""%d"", num);; 1282 ; 1283 body.Replace(i + 1, tmp - 1 - i, replacement, replacement.Length());; 1284 i += replacement.Length() + 1;; 1285 }; 1286 }; 1287 TString pattern;; 1288 if (defaultCounter && defaultVariables) {; 1289 pattern = TString::Format(""%s%s"", funName.Data(), (isNormalized ? ""n"" : """"));; 1290 }; 1291 if (!defaultCounter && defaultVariables) {; 1292 pattern = TString::Format(""%s%s(%d)"", funName.Data(), (isNormalized ? ""n"" : """"), counter);; 1293 }; 1294 if (defaultCounter && !defaultVariables) {; 1295 pattern = TString::Format(""%s%s[%s]"", funName.Data(), (isNormal",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:51421,Modifiability,variab,variables,51421,"ing(formula(endIdx, formula.Length())).Atoi();; 1330 ; 1331 if (endCnt <= startCnt); 1332 Error(""HandleParamRanges"", ""End parameter (%d) <= start parameter (%d) in parameter range"", endCnt, startCnt);; 1333 ; 1334 TString newString = ""["";; 1335 for (int cnt = startCnt; cnt < endCnt; cnt++); 1336 newString += TString::Format(""%d],["", cnt);; 1337 newString += TString::Format(""%d]"", endCnt);; 1338 ; 1339 // std::cout << ""newString generated by HandleParamRanges is "" << newString << std::endl;; 1340 formula.Replace(matchIdx, formula.Index(""]"", matchIdx) + 1 - matchIdx, newString);; 1341 ; 1342 matchIdx += newString.Length();; 1343 }; 1344 ; 1345 // std::cout << ""final formula is now "" << formula << std::endl;; 1346}; 1347 ; 1348////////////////////////////////////////////////////////////////////////////////; 1349/// Handling user functions (and parametrized functions); 1350/// to take variables and optionally parameters as arguments; 1351void TFormula::HandleFunctionArguments(TString &formula); 1352{; 1353 // std::cout << ""calling `HandleFunctionArguments` on "" << formula << std::endl;; 1354 ; 1355 // Define parametrized functions, in case we need to use them; 1356 std::map<std::pair<TString, Int_t>, std::pair<TString, TString>> parFunctions;; 1357 FillParametrizedFunctions(parFunctions);; 1358 ; 1359 // loop through characters; 1360 for (Int_t i = 0; i < formula.Length(); ++i) {; 1361 // List of things to ignore (copied from `TFormula::ExtractFunctors`); 1362 ; 1363 // ignore things that start with square brackets; 1364 if (formula[i] == '[') {; 1365 while (formula[i] != ']'); 1366 i++;; 1367 continue;; 1368 }; 1369 // ignore strings; 1370 if (formula[i] == '\""') {; 1371 do; 1372 i++;; 1373 while (formula[i] != '\""');; 1374 continue;; 1375 }; 1376 // ignore numbers (scientific notation); 1377 if (IsScientificNotation(formula, i)); 1378 continue;; 1379 // ignore x in hexadecimal number; 1380 if (IsHexadecimal(formula, i)) {; 1381 while (!IsOperator(formula[i]) && i < for",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:56971,Modifiability,variab,variables,56971,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:57123,Modifiability,variab,variable,57123,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:57449,Modifiability,variab,variable,57449,"= '(') {; 1487 // std::cout << ""naive replacement formula: "" << replacementFormula << std::endl;; 1488 // std::cout << ""formula: "" << formula << std::endl;; 1489 ; 1490 // map to rename each argument in `replacementFormula`; 1491 map<TString, TString> argSubstitutions;; 1492 ; 1493 const char *defaultVariableNames[] = {""x"", ""y"", ""z"", ""t""};; 1494 ; 1495 // check nArguments and add to argSubstitutions map as appropriate; 1496 bool canReplace = false;; 1497 if (nArguments == ndim + npar) {; 1498 // loop through all variables and parameters, filling in argSubstitutions; 1499 for (int argNr = 0; argNr < nArguments; argNr++) {; 1500 ; 1501 // Get new name (for either variable or parameter); 1502 TString newName =; 1503 TString(formula(argSeparators[argNr] + 1, argSeparators[argNr + 1] - argSeparators[argNr] - 1));; 1504 PreProcessFormula(newName); // so that nesting works; 1505 ; 1506 // Get old name(s); 1507 // and add to argSubstitutions map as appropriate; 1508 if (argNr < ndim) { // variable; 1509 TString oldName = (f) ? TString::Format(""x[%d]"", argNr) : TString::Format(""{V%d}"", argNr);; 1510 argSubstitutions[oldName] = newName;; 1511 ; 1512 if (f); 1513 argSubstitutions[defaultVariableNames[argNr]] = newName;; 1514 ; 1515 } else { // parameter; 1516 int parNr = argNr - ndim;; 1517 TString oldName =; 1518 (f) ? TString::Format(""[%s]"", f->GetParName(parNr)) : TString::Format(""[%d]"", parNr);; 1519 argSubstitutions[oldName] = newName;; 1520 ; 1521 // If the name stays the same, keep the old value of the parameter; 1522 if (f && oldName == newName); 1523 DoAddParameter(f->GetParName(parNr), f->GetParameter(parNr), false);; 1524 }; 1525 }; 1526 ; 1527 canReplace = true;; 1528 } else if (nArguments == npar) {; 1529 // Try to assume variables are implicit (need all arguments to be; 1530 // parameters); 1531 ; 1532 // loop to check if all arguments are parameters; 1533 bool varsImplicit = true;; 1534 for (int argNr = 0; argNr < nArguments && varsImplicit; argNr++) {; 1535 int ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:58207,Modifiability,variab,variables,58207,"; 1499 for (int argNr = 0; argNr < nArguments; argNr++) {; 1500 ; 1501 // Get new name (for either variable or parameter); 1502 TString newName =; 1503 TString(formula(argSeparators[argNr] + 1, argSeparators[argNr + 1] - argSeparators[argNr] - 1));; 1504 PreProcessFormula(newName); // so that nesting works; 1505 ; 1506 // Get old name(s); 1507 // and add to argSubstitutions map as appropriate; 1508 if (argNr < ndim) { // variable; 1509 TString oldName = (f) ? TString::Format(""x[%d]"", argNr) : TString::Format(""{V%d}"", argNr);; 1510 argSubstitutions[oldName] = newName;; 1511 ; 1512 if (f); 1513 argSubstitutions[defaultVariableNames[argNr]] = newName;; 1514 ; 1515 } else { // parameter; 1516 int parNr = argNr - ndim;; 1517 TString oldName =; 1518 (f) ? TString::Format(""[%s]"", f->GetParName(parNr)) : TString::Format(""[%d]"", parNr);; 1519 argSubstitutions[oldName] = newName;; 1520 ; 1521 // If the name stays the same, keep the old value of the parameter; 1522 if (f && oldName == newName); 1523 DoAddParameter(f->GetParName(parNr), f->GetParameter(parNr), false);; 1524 }; 1525 }; 1526 ; 1527 canReplace = true;; 1528 } else if (nArguments == npar) {; 1529 // Try to assume variables are implicit (need all arguments to be; 1530 // parameters); 1531 ; 1532 // loop to check if all arguments are parameters; 1533 bool varsImplicit = true;; 1534 for (int argNr = 0; argNr < nArguments && varsImplicit; argNr++) {; 1535 int openIdx = argSeparators[argNr] + 1;; 1536 int closeIdx = argSeparators[argNr + 1] - 1;; 1537 ; 1538 // check brackets on either end; 1539 if (formula[openIdx] != '[' || formula[closeIdx] != ']' || closeIdx <= openIdx + 1); 1540 varsImplicit = false;; 1541 ; 1542 // check that the middle is a single function-name; 1543 for (int idx = openIdx + 1; idx < closeIdx && varsImplicit; idx++); 1544 if (!IsFunctionNameChar(formula[idx])); 1545 varsImplicit = false;; 1546 ; 1547 if (!varsImplicit); 1548 Warning(""HandleFunctionArguments"",; 1549 ""Argument %d is not a parameter.",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:59040,Modifiability,variab,variables,59040,"->GetParName(parNr), f->GetParameter(parNr), false);; 1524 }; 1525 }; 1526 ; 1527 canReplace = true;; 1528 } else if (nArguments == npar) {; 1529 // Try to assume variables are implicit (need all arguments to be; 1530 // parameters); 1531 ; 1532 // loop to check if all arguments are parameters; 1533 bool varsImplicit = true;; 1534 for (int argNr = 0; argNr < nArguments && varsImplicit; argNr++) {; 1535 int openIdx = argSeparators[argNr] + 1;; 1536 int closeIdx = argSeparators[argNr + 1] - 1;; 1537 ; 1538 // check brackets on either end; 1539 if (formula[openIdx] != '[' || formula[closeIdx] != ']' || closeIdx <= openIdx + 1); 1540 varsImplicit = false;; 1541 ; 1542 // check that the middle is a single function-name; 1543 for (int idx = openIdx + 1; idx < closeIdx && varsImplicit; idx++); 1544 if (!IsFunctionNameChar(formula[idx])); 1545 varsImplicit = false;; 1546 ; 1547 if (!varsImplicit); 1548 Warning(""HandleFunctionArguments"",; 1549 ""Argument %d is not a parameter. Cannot assume variables are implicit."", argNr);; 1550 }; 1551 ; 1552 // loop to replace parameter names; 1553 if (varsImplicit) {; 1554 // if parametrized function, still need to replace parameter names; 1555 if (!f) {; 1556 for (int dim = 0; dim < ndim; dim++) {; 1557 argSubstitutions[TString::Format(""{V%d}"", dim)] = defaultVariableNames[dim];; 1558 }; 1559 }; 1560 ; 1561 for (int argNr = 0; argNr < nArguments; argNr++) {; 1562 TString oldName =; 1563 (f) ? TString::Format(""[%s]"", f->GetParName(argNr)) : TString::Format(""[%d]"", argNr);; 1564 TString newName =; 1565 TString(formula(argSeparators[argNr] + 1, argSeparators[argNr + 1] - argSeparators[argNr] - 1));; 1566 ; 1567 // preprocess the formula so that nesting works; 1568 PreProcessFormula(newName);; 1569 argSubstitutions[oldName] = newName;; 1570 ; 1571 // If the name stays the same, keep the old value of the parameter; 1572 if (f && oldName == newName); 1573 DoAddParameter(f->GetParName(argNr), f->GetParameter(argNr), false);; 1574 }; 1575 ; 1576",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:60197,Modifiability,variab,variable,60197," to replace parameter names; 1555 if (!f) {; 1556 for (int dim = 0; dim < ndim; dim++) {; 1557 argSubstitutions[TString::Format(""{V%d}"", dim)] = defaultVariableNames[dim];; 1558 }; 1559 }; 1560 ; 1561 for (int argNr = 0; argNr < nArguments; argNr++) {; 1562 TString oldName =; 1563 (f) ? TString::Format(""[%s]"", f->GetParName(argNr)) : TString::Format(""[%d]"", argNr);; 1564 TString newName =; 1565 TString(formula(argSeparators[argNr] + 1, argSeparators[argNr + 1] - argSeparators[argNr] - 1));; 1566 ; 1567 // preprocess the formula so that nesting works; 1568 PreProcessFormula(newName);; 1569 argSubstitutions[oldName] = newName;; 1570 ; 1571 // If the name stays the same, keep the old value of the parameter; 1572 if (f && oldName == newName); 1573 DoAddParameter(f->GetParName(argNr), f->GetParameter(argNr), false);; 1574 }; 1575 ; 1576 canReplace = true;; 1577 }; 1578 }; 1579 if (!canReplace && nArguments == ndim) {; 1580 // Treat parameters as implicit; 1581 ; 1582 // loop to replace variable names; 1583 for (int argNr = 0; argNr < nArguments; argNr++) {; 1584 TString oldName = (f) ? TString::Format(""x[%d]"", argNr) : TString::Format(""{V%d}"", argNr);; 1585 TString newName =; 1586 TString(formula(argSeparators[argNr] + 1, argSeparators[argNr + 1] - argSeparators[argNr] - 1));; 1587 ; 1588 // preprocess so nesting works; 1589 PreProcessFormula(newName);; 1590 argSubstitutions[oldName] = newName;; 1591 ; 1592 if (f) // x, y, z are not used in parametrized function definitions; 1593 argSubstitutions[defaultVariableNames[argNr]] = newName;; 1594 }; 1595 ; 1596 if (f) {; 1597 // keep old values of the parameters; 1598 for (int parNr = 0; parNr < npar; parNr++); 1599 DoAddParameter(f->GetParName(parNr), f->GetParameter(parNr), false);; 1600 }; 1601 ; 1602 canReplace = true;; 1603 }; 1604 ; 1605 if (canReplace); 1606 ReplaceAllNames(replacementFormula, argSubstitutions);; 1607 // std::cout << ""after replacement, replacementFormula is "" << replacementFormula << std::endl;; 1608 ;",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:68212,Modifiability,variab,variable,68212,"eAll(""**"",""^"");; 1774 formula.ReplaceAll(""++"",""@""); // for linear functions; 1775 formula.ReplaceAll("" "","""");; 1776 HandlePolN(formula);; 1777 HandleParametrizedFunctions(formula);; 1778 HandleParamRanges(formula);; 1779 HandleFunctionArguments(formula);; 1780 HandleExponentiation(formula);; 1781 // ""++"" wil be dealt with Handle Linear; 1782 HandleLinear(formula);; 1783 // special case for ""--"" and ""++""; 1784 // (""++"" needs to be written with whitespace that is removed before but then we re-add it again; 1785 formula.ReplaceAll(""--"",""- -"");; 1786 formula.ReplaceAll(""++"",""+ +"");; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// prepare the formula to be executed; 1791/// normally is called with fFormula; 1792 ; 1793Bool_t TFormula::PrepareFormula(TString &formula); 1794{; 1795 fFuncs.clear();; 1796 fReadyToExecute = false;; 1797 ExtractFunctors(formula);; 1798 ; 1799 // update the expression with the new formula; 1800 fFormula = formula;; 1801 // save formula to parse variable and parameters for Cling; 1802 fClingInput = formula;; 1803 // replace all { and }; 1804 fFormula.ReplaceAll(""{"","""");; 1805 fFormula.ReplaceAll(""}"","""");; 1806 ; 1807 // std::cout << ""functors are extracted formula is "" << std::endl;; 1808 // std::cout << fFormula << std::endl << std::endl;; 1809 ; 1810 fFuncs.sort();; 1811 fFuncs.unique();; 1812 ; 1813 // use inputFormula for Cling; 1814 ProcessFormula(fClingInput);; 1815 ; 1816 // for pre-defined functions (need after processing); 1817 if (fNumber != 0) SetPredefinedParamNames();; 1818 ; 1819 return fReadyToExecute && fClingInitialized;; 1820}; 1821 ; 1822////////////////////////////////////////////////////////////////////////////////; 1823/// Extracts functors from formula, and put them in fFuncs.; 1824/// Simple grammar:; 1825/// - `<function>` := name(arg1,arg2...); 1826/// - `<variable>` := name; 1827/// - `<parameter>` := [number]; 1828/// - `<name>` := String containing lower and ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:69065,Modifiability,variab,variable,69065,"rmula = formula;; 1801 // save formula to parse variable and parameters for Cling; 1802 fClingInput = formula;; 1803 // replace all { and }; 1804 fFormula.ReplaceAll(""{"","""");; 1805 fFormula.ReplaceAll(""}"","""");; 1806 ; 1807 // std::cout << ""functors are extracted formula is "" << std::endl;; 1808 // std::cout << fFormula << std::endl << std::endl;; 1809 ; 1810 fFuncs.sort();; 1811 fFuncs.unique();; 1812 ; 1813 // use inputFormula for Cling; 1814 ProcessFormula(fClingInput);; 1815 ; 1816 // for pre-defined functions (need after processing); 1817 if (fNumber != 0) SetPredefinedParamNames();; 1818 ; 1819 return fReadyToExecute && fClingInitialized;; 1820}; 1821 ; 1822////////////////////////////////////////////////////////////////////////////////; 1823/// Extracts functors from formula, and put them in fFuncs.; 1824/// Simple grammar:; 1825/// - `<function>` := name(arg1,arg2...); 1826/// - `<variable>` := name; 1827/// - `<parameter>` := [number]; 1828/// - `<name>` := String containing lower and upper letters, numbers, underscores; 1829/// - `<number>` := Integer number; 1830/// Operators are omitted.; 1831 ; 1832void TFormula::ExtractFunctors(TString &formula); 1833{; 1834 // std::cout << ""Commencing ExtractFunctors on "" << formula << std::endl;; 1835 ; 1836 TString name = """";; 1837 TString body = """";; 1838 // printf(""formula is : %s \n"",formula.Data() );; 1839 for (Int_t i = 0; i < formula.Length(); ++i) {; 1840 ; 1841 // std::cout << ""loop on character : "" << i << "" "" << formula[i] << std::endl;; 1842 // case of parameters; 1843 if (formula[i] == '[') {; 1844 Int_t tmp = i;; 1845 i++;; 1846 TString param = """";; 1847 while (i < formula.Length() && formula[i] != ']') {; 1848 param.Append(formula[i++]);; 1849 }; 1850 i++;; 1851 // rename parameter name XX to pXX; 1852 // std::cout << ""examine parameters "" << param << std::endl;; 1853 int paramIndex = -1;; 1854 if (param.IsDigit()) {; 1855 paramIndex = param.Atoi();; 1856 param.Insert(0, 'p'); // needed for the replaceme",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:72266,Modifiability,variab,variable,72266,"ength());; 1880 fFuncs.push_back(TFormulaFunction(param));; 1881 // we need to change index i after replacing since string length changes; 1882 // and we need to re-calculate i position; 1883 int deltai = replacement.Length() - (i-tmp);; 1884 i += deltai;; 1885 // printf(""found parameter %s \n"",param.Data() );; 1886 continue;; 1887 }; 1888 // case of strings; 1889 if (formula[i] == '\""') {; 1890 // look for next instance of ""\""; 1891 do {; 1892 i++;; 1893 } while (formula[i] != '\""');; 1894 }; 1895 // case of e or E for numbers in exponential notation (e.g. 2.2e-3); 1896 if (IsScientificNotation(formula, i)); 1897 continue;; 1898 // case of x for hexadecimal numbers; 1899 if (IsHexadecimal(formula, i)) {; 1900 // find position of operator; 1901 // do not check cases if character is not only a to f, but accept anything; 1902 while (!IsOperator(formula[i]) && i < formula.Length()) {; 1903 i++;; 1904 }; 1905 continue;; 1906 }; 1907 ; 1908 // std::cout << ""investigating character : "" << i << "" "" << formula[i] << "" of formula "" << formula <<; 1909 // std::endl;; 1910 // look for variable and function names. They start in C++ with alphanumeric characters; 1911 if (isalpha(formula[i]) &&; 1912 !IsOperator(formula[i])) // not really needed to check if operator (if isalpha is not an operator); 1913 {; 1914 // std::cout << ""character : "" << i << "" "" << formula[i] << "" is not an operator and is alpha "" <<; 1915 // std::endl;; 1916 ; 1917 while (i < formula.Length() && IsFunctionNameChar(formula[i])) {; 1918 // need special case for separating operator "":"" from scope operator ""::""; 1919 if (formula[i] == ':' && ((i + 1) < formula.Length())) {; 1920 if (formula[i + 1] == ':') {; 1921 // case of :: (scopeOperator); 1922 name.Append(""::"");; 1923 i += 2;; 1924 continue;; 1925 } else; 1926 break;; 1927 }; 1928 ; 1929 name.Append(formula[i++]);; 1930 }; 1931 // printf("" build a name %s \n"",name.Data() );; 1932 if (formula[i] == '(') {; 1933 i++;; 1934 if (formula[i] == ')') {; 1935 fF",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:74748,Modifiability,variab,variables,74748,"yLen = body.Length();; 1956 ExtractFunctors(body);; 1957 formula.Replace(i - originalBodyLen, originalBodyLen, body, body.Length());; 1958 i += body.Length() - originalBodyLen;; 1959 fFuncs.push_back(TFormulaFunction(name, body, args));; 1960 } else {; 1961 ; 1962 // std::cout << ""check if character : "" << i << "" "" << formula[i] << "" from name "" << name << "" is a; 1963 // function "" << std::endl;; 1964 ; 1965 // check if function is provided by gROOT; 1966 TObject *obj = nullptr;; 1967 // exclude case function name is x,y,z,t; 1968 if (!IsReservedName(name)); 1969 {; 1970 R__LOCKGUARD(gROOTMutex);; 1971 obj = gROOT->GetListOfFunctions()->FindObject(name);; 1972 }; 1973 TFormula *f = dynamic_cast<TFormula *>(obj);; 1974 if (!f) {; 1975 // maybe object is a TF1; 1976 TF1 *f1 = dynamic_cast<TF1 *>(obj);; 1977 if (f1); 1978 f = f1->GetFormula();; 1979 }; 1980 if (f) {; 1981 // Replacing user formula the old way (as opposed to 'HandleFunctionArguments'); 1982 // Note this is only for replacing functions that do; 1983 // not specify variables and/or parameters in brackets; 1984 // (the other case is done by `HandleFunctionArguments`); 1985 ; 1986 TString replacementFormula = f->GetExpFormula();; 1987 ; 1988 // analyze expression string; 1989 // std::cout << ""formula to replace for "" << f->GetName() << "" is "" << replacementFormula <<; 1990 // std::endl;; 1991 PreProcessFormula(replacementFormula);; 1992 // we need to define different parameters if we use the unnamed default parameters ([0]); 1993 // I need to replace all the terms in the functor for backward compatibility of the case; 1994 // f1(""[0]*x"") f2(""[0]*x"") f1+f2 - it is weird but it is better to support; 1995 // std::cout << ""current number of parameter is "" << fNpar << std::endl;; 1996 int nparOffset = 0;; 1997 // if (fParams.find(""0"") != fParams.end() ) {; 1998 // do in any case if parameters are existing; 1999 std::vector<TString> newNames;; 2000 if (fNpar > 0) {; 2001 nparOffset = fNpar;; 2002 newNames.resize(",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:78340,Modifiability,variab,variable,78340,"acementFormula.Length());; 2036 // move forward the index i of the main loop; 2037 i += replacementFormula.Length() - name.Length();; 2038 ; 2039 // we have extracted all the functor for ""fname""; 2040 // std::cout << ""We have extracted all the functors for fname"" << std::endl;; 2041 // std::cout << "" i = "" << i << "" f[i] = "" << formula[i] << "" - "" << formula << std::endl;; 2042 name = """";; 2043 ; 2044 continue;; 2045 }; 2046 ; 2047 // add now functor in; 2048 TString replacement = TString::Format(""{%s}"", name.Data());; 2049 formula.Replace(i - name.Length(), name.Length(), replacement, replacement.Length());; 2050 i += 2;; 2051 fFuncs.push_back(TFormulaFunction(name));; 2052 }; 2053 }; 2054 name = body = """";; 2055 }; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Iterates through functors in fFuncs and performs the appropriate action.; 2060/// If functor has 0 arguments (has only name) can be:; 2061/// - variable; 2062/// * will be replaced with x[num], where x is an array containing value of this variable under num.; 2063/// - pre-defined formula; 2064/// * will be replaced with formulas body; 2065/// - constant; 2066/// * will be replaced with constant value; 2067/// - parameter; 2068/// * will be replaced with p[num], where p is an array containing value of this parameter under num.; 2069/// If has arguments it can be :; 2070/// - function shortcut, eg. sin; 2071/// * will be replaced with fullname of function, eg. sin -> TMath::Sin; 2072/// - function from cling environment, eg. TMath::BreitWigner(x,y,z); 2073/// * first check if function exists, and has same number of arguments, then accept it and set as found.; 2074/// If all functors after iteration are matched with corresponding action,; 2075/// it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.; 2076 ; 2077void TFormula::ProcessFormula(TString &formula); 2078{; 2079 // std::cout << ""Begin: formula is "" << fo",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:78435,Modifiability,variab,variable,78435,"acementFormula.Length());; 2036 // move forward the index i of the main loop; 2037 i += replacementFormula.Length() - name.Length();; 2038 ; 2039 // we have extracted all the functor for ""fname""; 2040 // std::cout << ""We have extracted all the functors for fname"" << std::endl;; 2041 // std::cout << "" i = "" << i << "" f[i] = "" << formula[i] << "" - "" << formula << std::endl;; 2042 name = """";; 2043 ; 2044 continue;; 2045 }; 2046 ; 2047 // add now functor in; 2048 TString replacement = TString::Format(""{%s}"", name.Data());; 2049 formula.Replace(i - name.Length(), name.Length(), replacement, replacement.Length());; 2050 i += 2;; 2051 fFuncs.push_back(TFormulaFunction(name));; 2052 }; 2053 }; 2054 name = body = """";; 2055 }; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Iterates through functors in fFuncs and performs the appropriate action.; 2060/// If functor has 0 arguments (has only name) can be:; 2061/// - variable; 2062/// * will be replaced with x[num], where x is an array containing value of this variable under num.; 2063/// - pre-defined formula; 2064/// * will be replaced with formulas body; 2065/// - constant; 2066/// * will be replaced with constant value; 2067/// - parameter; 2068/// * will be replaced with p[num], where p is an array containing value of this parameter under num.; 2069/// If has arguments it can be :; 2070/// - function shortcut, eg. sin; 2071/// * will be replaced with fullname of function, eg. sin -> TMath::Sin; 2072/// - function from cling environment, eg. TMath::BreitWigner(x,y,z); 2073/// * first check if function exists, and has same number of arguments, then accept it and set as found.; 2074/// If all functors after iteration are matched with corresponding action,; 2075/// it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.; 2076 ; 2077void TFormula::ProcessFormula(TString &formula); 2078{; 2079 // std::cout << ""Begin: formula is "" << fo",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:83462,Modifiability,variab,variables,83462,"53 if (f && fun.GetNargs() <= f->GetNargs() && fun.GetNargs() >= f->GetNargs() - f->GetNargsOpt()) {; 2154 fun.fFound = true;; 2155 }; 2156 }; 2157 ; 2158 if (!fun.fFound) {; 2159 // ignore not found functions; 2160 if (gDebug); 2161 Info(""TFormula"", ""Could not find %s function with %d argument(s)"", fun.GetName(), fun.GetNargs());; 2162 fun.fFound = false;; 2163 }; 2164#endif; 2165 } else {; 2166 TFormula *old = nullptr;; 2167 {; 2168 R__LOCKGUARD(gROOTMutex);; 2169 old = (TFormula *)gROOT->GetListOfFunctions()->FindObject(gNamePrefix + fun.fName);; 2170 }; 2171 if (old) {; 2172 // we should not go here (this analysis is done before in ExtractFunctors); 2173 assert(false);; 2174 fun.fFound = true;; 2175 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2176 TString replacement = old->GetExpFormula();; 2177 PreProcessFormula(replacement);; 2178 ExtractFunctors(replacement);; 2179 formula.ReplaceAll(pattern, replacement);; 2180 continue;; 2181 }; 2182 // looking for default variables defined in fVars; 2183 ; 2184 map<TString, TFormulaVariable>::iterator varsIt = fVars.find(fun.GetName());; 2185 if (varsIt != fVars.end()) {; 2186 ; 2187 TString name = (*varsIt).second.GetName();; 2188 Double_t value = (*varsIt).second.fValue;; 2189 ; 2190 AddVariable(name, value); // this set the cling variable; 2191 if (!fVars[name].fFound) {; 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added with position less; 2199 for (auto &v : fVars) {; 2200 if (v.second.fArrayPos < varDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:83779,Modifiability,variab,variable,83779,"t(s)"", fun.GetName(), fun.GetNargs());; 2162 fun.fFound = false;; 2163 }; 2164#endif; 2165 } else {; 2166 TFormula *old = nullptr;; 2167 {; 2168 R__LOCKGUARD(gROOTMutex);; 2169 old = (TFormula *)gROOT->GetListOfFunctions()->FindObject(gNamePrefix + fun.fName);; 2170 }; 2171 if (old) {; 2172 // we should not go here (this analysis is done before in ExtractFunctors); 2173 assert(false);; 2174 fun.fFound = true;; 2175 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2176 TString replacement = old->GetExpFormula();; 2177 PreProcessFormula(replacement);; 2178 ExtractFunctors(replacement);; 2179 formula.ReplaceAll(pattern, replacement);; 2180 continue;; 2181 }; 2182 // looking for default variables defined in fVars; 2183 ; 2184 map<TString, TFormulaVariable>::iterator varsIt = fVars.find(fun.GetName());; 2185 if (varsIt != fVars.end()) {; 2186 ; 2187 TString name = (*varsIt).second.GetName();; 2188 Double_t value = (*varsIt).second.fValue;; 2189 ; 2190 AddVariable(name, value); // this set the cling variable; 2191 if (!fVars[name].fFound) {; 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added with position less; 2199 for (auto &v : fVars) {; 2200 if (v.second.fArrayPos < varDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d]"", (*varsIt).second.fArrayPos);; 2210 formula.ReplaceAll(pattern, replacement);; 2211 ; 2212 // std::cout << ""Found an observable for "" << fun.GetName() << std::endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // mayb",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:83911,Modifiability,variab,variable,83911," 2170 }; 2171 if (old) {; 2172 // we should not go here (this analysis is done before in ExtractFunctors); 2173 assert(false);; 2174 fun.fFound = true;; 2175 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2176 TString replacement = old->GetExpFormula();; 2177 PreProcessFormula(replacement);; 2178 ExtractFunctors(replacement);; 2179 formula.ReplaceAll(pattern, replacement);; 2180 continue;; 2181 }; 2182 // looking for default variables defined in fVars; 2183 ; 2184 map<TString, TFormulaVariable>::iterator varsIt = fVars.find(fun.GetName());; 2185 if (varsIt != fVars.end()) {; 2186 ; 2187 TString name = (*varsIt).second.GetName();; 2188 Double_t value = (*varsIt).second.fValue;; 2189 ; 2190 AddVariable(name, value); // this set the cling variable; 2191 if (!fVars[name].fFound) {; 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added with position less; 2199 for (auto &v : fVars) {; 2200 if (v.second.fArrayPos < varDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d]"", (*varsIt).second.fArrayPos);; 2210 formula.ReplaceAll(pattern, replacement);; 2211 ; 2212 // std::cout << ""Found an observable for "" << fun.GetName() << std::endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // maybe could use a regular expression here; 2219 // only in case match with defined variables is not successful; 2220 TString funname = fun.GetName();; 2221 if (funname.Contains(""x["") && funname.Contains(""]"")) {; 2222 TString sdigit = funname(2, funname.Index(""]""));",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:84065,Modifiability,variab,variables,84065," 2170 }; 2171 if (old) {; 2172 // we should not go here (this analysis is done before in ExtractFunctors); 2173 assert(false);; 2174 fun.fFound = true;; 2175 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2176 TString replacement = old->GetExpFormula();; 2177 PreProcessFormula(replacement);; 2178 ExtractFunctors(replacement);; 2179 formula.ReplaceAll(pattern, replacement);; 2180 continue;; 2181 }; 2182 // looking for default variables defined in fVars; 2183 ; 2184 map<TString, TFormulaVariable>::iterator varsIt = fVars.find(fun.GetName());; 2185 if (varsIt != fVars.end()) {; 2186 ; 2187 TString name = (*varsIt).second.GetName();; 2188 Double_t value = (*varsIt).second.fValue;; 2189 ; 2190 AddVariable(name, value); // this set the cling variable; 2191 if (!fVars[name].fFound) {; 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added with position less; 2199 for (auto &v : fVars) {; 2200 if (v.second.fArrayPos < varDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d]"", (*varsIt).second.fArrayPos);; 2210 formula.ReplaceAll(pattern, replacement);; 2211 ; 2212 // std::cout << ""Found an observable for "" << fun.GetName() << std::endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // maybe could use a regular expression here; 2219 // only in case match with defined variables is not successful; 2220 TString funname = fun.GetName();; 2221 if (funname.Contains(""x["") && funname.Contains(""]"")) {; 2222 TString sdigit = funname(2, funname.Index(""]""));",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:84347,Modifiability,variab,variable,84347,"formula.ReplaceAll(pattern, replacement);; 2180 continue;; 2181 }; 2182 // looking for default variables defined in fVars; 2183 ; 2184 map<TString, TFormulaVariable>::iterator varsIt = fVars.find(fun.GetName());; 2185 if (varsIt != fVars.end()) {; 2186 ; 2187 TString name = (*varsIt).second.GetName();; 2188 Double_t value = (*varsIt).second.fValue;; 2189 ; 2190 AddVariable(name, value); // this set the cling variable; 2191 if (!fVars[name].fFound) {; 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added with position less; 2199 for (auto &v : fVars) {; 2200 if (v.second.fArrayPos < varDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d]"", (*varsIt).second.fArrayPos);; 2210 formula.ReplaceAll(pattern, replacement);; 2211 ; 2212 // std::cout << ""Found an observable for "" << fun.GetName() << std::endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // maybe could use a regular expression here; 2219 // only in case match with defined variables is not successful; 2220 TString funname = fun.GetName();; 2221 if (funname.Contains(""x["") && funname.Contains(""]"")) {; 2222 TString sdigit = funname(2, funname.Index(""]""));; 2223 int digit = sdigit.Atoi();; 2224 if (digit >= fNdim) {; 2225 fNdim = digit + 1;; 2226 // we need to add the variables in fVars all of them before x[n]; 2227 for (int j = 0; j < fNdim; ++j) {; 2228 TString vname = TString::Format(""x[%d]"", j);; 2229 if (fVars.find(vname) == fVars.end()) {; 2230 fVars[vname] = TFormulaVariable(vname, 0, j);",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:84840,Modifiability,variab,variables,84840," 2192 ; 2193 fVars[name].fFound = true;; 2194 int varDim = (*varsIt).second.fArrayPos; // variable dimensions (0 for x, 1 for y, 2, for z); 2195 if (varDim >= fNdim) {; 2196 fNdim = varDim + 1;; 2197 ; 2198 // we need to be sure that all other variables are added with position less; 2199 for (auto &v : fVars) {; 2200 if (v.second.fArrayPos < varDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d]"", (*varsIt).second.fArrayPos);; 2210 formula.ReplaceAll(pattern, replacement);; 2211 ; 2212 // std::cout << ""Found an observable for "" << fun.GetName() << std::endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // maybe could use a regular expression here; 2219 // only in case match with defined variables is not successful; 2220 TString funname = fun.GetName();; 2221 if (funname.Contains(""x["") && funname.Contains(""]"")) {; 2222 TString sdigit = funname(2, funname.Index(""]""));; 2223 int digit = sdigit.Atoi();; 2224 if (digit >= fNdim) {; 2225 fNdim = digit + 1;; 2226 // we need to add the variables in fVars all of them before x[n]; 2227 for (int j = 0; j < fNdim; ++j) {; 2228 TString vname = TString::Format(""x[%d]"", j);; 2229 if (fVars.find(vname) == fVars.end()) {; 2230 fVars[vname] = TFormulaVariable(vname, 0, j);; 2231 fVars[vname].fFound = true;; 2232 AddVariable(vname, 0.);; 2233 }; 2234 }; 2235 }; 2236 // std::cout << ""Found matching observable for "" << funname << std::endl;; 2237 fun.fFound = true;; 2238 // remove the ""{.. }"" added around the variable; 2239 TString pattern = TString::Format(""{%s}"", funname.Data());; 2240 formula.ReplaceAll(pattern, funname);; 2241 continue;; 2242 }; 2243 //}; 2244 ; 2245 auto paramsIt = fParams.find(fun.GetName());; 2246",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:85137,Modifiability,variab,variables,85137,"rDim && !v.second.fFound) {; 2201 AddVariable(v.first, v.second.fValue);; 2202 v.second.fFound = true;; 2203 }; 2204 }; 2205 }; 2206 }; 2207 // remove the ""{.. }"" added around the variable; 2208 TString pattern = TString::Format(""{%s}"", name.Data());; 2209 TString replacement = TString::Format(""x[%d]"", (*varsIt).second.fArrayPos);; 2210 formula.ReplaceAll(pattern, replacement);; 2211 ; 2212 // std::cout << ""Found an observable for "" << fun.GetName() << std::endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // maybe could use a regular expression here; 2219 // only in case match with defined variables is not successful; 2220 TString funname = fun.GetName();; 2221 if (funname.Contains(""x["") && funname.Contains(""]"")) {; 2222 TString sdigit = funname(2, funname.Index(""]""));; 2223 int digit = sdigit.Atoi();; 2224 if (digit >= fNdim) {; 2225 fNdim = digit + 1;; 2226 // we need to add the variables in fVars all of them before x[n]; 2227 for (int j = 0; j < fNdim; ++j) {; 2228 TString vname = TString::Format(""x[%d]"", j);; 2229 if (fVars.find(vname) == fVars.end()) {; 2230 fVars[vname] = TFormulaVariable(vname, 0, j);; 2231 fVars[vname].fFound = true;; 2232 AddVariable(vname, 0.);; 2233 }; 2234 }; 2235 }; 2236 // std::cout << ""Found matching observable for "" << funname << std::endl;; 2237 fun.fFound = true;; 2238 // remove the ""{.. }"" added around the variable; 2239 TString pattern = TString::Format(""{%s}"", funname.Data());; 2240 formula.ReplaceAll(pattern, funname);; 2241 continue;; 2242 }; 2243 //}; 2244 ; 2245 auto paramsIt = fParams.find(fun.GetName());; 2246 if (paramsIt != fParams.end()) {; 2247 // TString name = (*paramsIt).second.GetName();; 2248 TString pattern = TString::Format(""{[%s]}"", fun.GetName());; 2249 // std::cout << ""pattern is "" << pattern << std::endl;; 2250 if (formula.Index(pattern) != kNPOS) {; 2251 // TString replacement = TString::Format(""p[%d]"",(*paramsIt).second.fArrayPos);;",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:85607,Modifiability,variab,variable,85607,"endl;; 2213 ; 2214 fun.fFound = true;; 2215 continue;; 2216 }; 2217 // check for observables defined as x[0],x[1],....; 2218 // maybe could use a regular expression here; 2219 // only in case match with defined variables is not successful; 2220 TString funname = fun.GetName();; 2221 if (funname.Contains(""x["") && funname.Contains(""]"")) {; 2222 TString sdigit = funname(2, funname.Index(""]""));; 2223 int digit = sdigit.Atoi();; 2224 if (digit >= fNdim) {; 2225 fNdim = digit + 1;; 2226 // we need to add the variables in fVars all of them before x[n]; 2227 for (int j = 0; j < fNdim; ++j) {; 2228 TString vname = TString::Format(""x[%d]"", j);; 2229 if (fVars.find(vname) == fVars.end()) {; 2230 fVars[vname] = TFormulaVariable(vname, 0, j);; 2231 fVars[vname].fFound = true;; 2232 AddVariable(vname, 0.);; 2233 }; 2234 }; 2235 }; 2236 // std::cout << ""Found matching observable for "" << funname << std::endl;; 2237 fun.fFound = true;; 2238 // remove the ""{.. }"" added around the variable; 2239 TString pattern = TString::Format(""{%s}"", funname.Data());; 2240 formula.ReplaceAll(pattern, funname);; 2241 continue;; 2242 }; 2243 //}; 2244 ; 2245 auto paramsIt = fParams.find(fun.GetName());; 2246 if (paramsIt != fParams.end()) {; 2247 // TString name = (*paramsIt).second.GetName();; 2248 TString pattern = TString::Format(""{[%s]}"", fun.GetName());; 2249 // std::cout << ""pattern is "" << pattern << std::endl;; 2250 if (formula.Index(pattern) != kNPOS) {; 2251 // TString replacement = TString::Format(""p[%d]"",(*paramsIt).second.fArrayPos);; 2252 TString replacement = TString::Format(""p[%d]"", (*paramsIt).second);; 2253 // std::cout << ""replace pattern "" << pattern << "" with "" << replacement << std::endl;; 2254 formula.ReplaceAll(pattern, replacement);; 2255 }; 2256 fun.fFound = true;; 2257 continue;; 2258 } else {; 2259 // std::cout << ""functor "" << fun.GetName() << "" is not a parameter "" << std::endl;; 2260 }; 2261 ; 2262 // looking for constants (needs to be done after looking at the paramet",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:87509,Modifiability,variab,variables,87509,"< std::endl;; 2260 }; 2261 ; 2262 // looking for constants (needs to be done after looking at the parameters); 2263 map<TString, Double_t>::iterator constIt = fConsts.find(fun.GetName());; 2264 if (constIt != fConsts.end()) {; 2265 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2266 TString value = TString::Format(""%lf"", (*constIt).second);; 2267 formula.ReplaceAll(pattern, value);; 2268 fun.fFound = true;; 2269 // std::cout << ""constant with name "" << fun.GetName() << "" is found "" << std::endl;; 2270 continue;; 2271 }; 2272 ; 2273 fun.fFound = false;; 2274 }; 2275 }; 2276 // std::cout << ""End: formula is "" << formula << std::endl;; 2277 ; 2278 // ignore case of functors have been matched - try to pass it to Cling; 2279 if (!fReadyToExecute) {; 2280 fReadyToExecute = true;; 2281 Bool_t hasVariables = (fNdim > 0);; 2282 Bool_t hasParameters = (fNpar > 0);; 2283 if (!hasParameters) {; 2284 fAllParametersSetted = true;; 2285 }; 2286 // assume a function without variables is always 1-dimensional ???; 2287 // if (hasParameters && !hasVariables) {; 2288 // fNdim = 1;; 2289 // AddVariable(""x"", 0);; 2290 // hasVariables = true;; 2291 // }; 2292 // does not make sense to vectorize function which is of FNDim=0; 2293 if (!hasVariables) fVectorized=false;; 2294 // when there are no variables but only parameter we still need to ad; 2295 //Bool_t hasBoth = hasVariables && hasParameters;; 2296 Bool_t inputIntoCling = (formula.Length() > 0);; 2297 if (inputIntoCling) {; 2298 // save copy of inputFormula in a std::strig for the unordered map; 2299 // and also formula is same as FClingInput typically and it will be modified; 2300 std::string inputFormula(formula.Data());; 2301 ; 2302 // The name we really use for the unordered map will have a flag that; 2303 // says whether the formula is vectorized; 2304 std::string inputFormulaVecFlag = inputFormula;; 2305 if (fVectorized); 2306 inputFormulaVecFlag += "" (vectorized)"";; 2307 ; 2308 TString argType = fVectorized ? ""ROOT::D",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:87827,Modifiability,variab,variables,87827,"< std::endl;; 2260 }; 2261 ; 2262 // looking for constants (needs to be done after looking at the parameters); 2263 map<TString, Double_t>::iterator constIt = fConsts.find(fun.GetName());; 2264 if (constIt != fConsts.end()) {; 2265 TString pattern = TString::Format(""{%s}"", fun.GetName());; 2266 TString value = TString::Format(""%lf"", (*constIt).second);; 2267 formula.ReplaceAll(pattern, value);; 2268 fun.fFound = true;; 2269 // std::cout << ""constant with name "" << fun.GetName() << "" is found "" << std::endl;; 2270 continue;; 2271 }; 2272 ; 2273 fun.fFound = false;; 2274 }; 2275 }; 2276 // std::cout << ""End: formula is "" << formula << std::endl;; 2277 ; 2278 // ignore case of functors have been matched - try to pass it to Cling; 2279 if (!fReadyToExecute) {; 2280 fReadyToExecute = true;; 2281 Bool_t hasVariables = (fNdim > 0);; 2282 Bool_t hasParameters = (fNpar > 0);; 2283 if (!hasParameters) {; 2284 fAllParametersSetted = true;; 2285 }; 2286 // assume a function without variables is always 1-dimensional ???; 2287 // if (hasParameters && !hasVariables) {; 2288 // fNdim = 1;; 2289 // AddVariable(""x"", 0);; 2290 // hasVariables = true;; 2291 // }; 2292 // does not make sense to vectorize function which is of FNDim=0; 2293 if (!hasVariables) fVectorized=false;; 2294 // when there are no variables but only parameter we still need to ad; 2295 //Bool_t hasBoth = hasVariables && hasParameters;; 2296 Bool_t inputIntoCling = (formula.Length() > 0);; 2297 if (inputIntoCling) {; 2298 // save copy of inputFormula in a std::strig for the unordered map; 2299 // and also formula is same as FClingInput typically and it will be modified; 2300 std::string inputFormula(formula.Data());; 2301 ; 2302 // The name we really use for the unordered map will have a flag that; 2303 // says whether the formula is vectorized; 2304 std::string inputFormulaVecFlag = inputFormula;; 2305 if (fVectorized); 2306 inputFormulaVecFlag += "" (vectorized)"";; 2307 ; 2308 TString argType = fVectorized ? ""ROOT::D",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:88623,Modifiability,variab,variables,88623,"t variables is always 1-dimensional ???; 2287 // if (hasParameters && !hasVariables) {; 2288 // fNdim = 1;; 2289 // AddVariable(""x"", 0);; 2290 // hasVariables = true;; 2291 // }; 2292 // does not make sense to vectorize function which is of FNDim=0; 2293 if (!hasVariables) fVectorized=false;; 2294 // when there are no variables but only parameter we still need to ad; 2295 //Bool_t hasBoth = hasVariables && hasParameters;; 2296 Bool_t inputIntoCling = (formula.Length() > 0);; 2297 if (inputIntoCling) {; 2298 // save copy of inputFormula in a std::strig for the unordered map; 2299 // and also formula is same as FClingInput typically and it will be modified; 2300 std::string inputFormula(formula.Data());; 2301 ; 2302 // The name we really use for the unordered map will have a flag that; 2303 // says whether the formula is vectorized; 2304 std::string inputFormulaVecFlag = inputFormula;; 2305 if (fVectorized); 2306 inputFormulaVecFlag += "" (vectorized)"";; 2307 ; 2308 TString argType = fVectorized ? ""ROOT::Double_v"" : ""Double_t"";; 2309 ; 2310 // valid input formula - try to put into Cling (in case of no variables but only parameter we need to add the standard signature); 2311 TString argumentsPrototype = TString::Format(""%s%s%s"", ( (hasVariables || hasParameters) ? (argType + "" *x"").Data() : """"),; 2312 (hasParameters ? "","" : """"), (hasParameters ? ""Double_t *p"" : """"));; 2313 ; 2314 // set the name for Cling using the hash_function; 2315 fClingName = gNamePrefix;; 2316 ; 2317 // check if formula exist already in the map; 2318 R__LOCKGUARD(gROOTMutex);; 2319 ; 2320 // std::cout << ""gClingFunctions list"" << std::endl;; 2321 // for (auto thing : gClingFunctions); 2322 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 2323 ; 2324 auto funcit = gClingFunctions.find(inputFormulaVecFlag);; 2325 ; 2326 if (funcit != gClingFunctions.end()) {; 2327 fFuncPtr = (TFormula::CallFuncSignature)funcit->second;; 2328 fClingInitialized = true;; 2329 inputIntoCling = false;; 2",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:92193,Modifiability,variab,variables,92193,"2378 }; 2379 ; 2380 // In case of a Cling Error check components which are not found in Cling; 2381 // check that all formula components are matched otherwise emit an error; 2382 if (!fClingInitialized && !fLazyInitialization) {; 2383 //Bool_t allFunctorsMatched = false;; 2384 for (list<TFormulaFunction>::iterator it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 2385 // functions are now by default always not checked; 2386 if (!it->fFound && !it->IsFuncCall()) {; 2387 //allFunctorsMatched = false;; 2388 if (it->GetNargs() == 0); 2389 Error(""ProcessFormula"", ""\""%s\"" has not been matched in the formula expression"", it->GetName());; 2390 else; 2391 Error(""ProcessFormula"", ""Could not find %s function with %d argument(s)"", it->GetName(), it->GetNargs());; 2392 }; 2393 }; 2394 Error(""ProcessFormula"",""Formula \""%s\"" is invalid !"", GetExpFormula().Data() );; 2395 fReadyToExecute = false;; 2396 }; 2397 ; 2398 // clean up un-used default variables in case formula is valid; 2399 //if (fClingInitialized && fReadyToExecute) {; 2400 //don't check fClingInitialized in case of lazy execution; 2401 if (fReadyToExecute) {; 2402 auto itvar = fVars.begin();; 2403 // need this loop because after erase change iterators; 2404 do {; 2405 if (!itvar->second.fFound) {; 2406 // std::cout << ""Erase variable "" << itvar->first << std::endl;; 2407 itvar = fVars.erase(itvar);; 2408 } else; 2409 itvar++;; 2410 } while (itvar != fVars.end());; 2411 }; 2412}; 2413 ; 2414////////////////////////////////////////////////////////////////////////////////; 2415/// Fill map with parametrized functions; 2416 ; 2417void TFormula::FillParametrizedFunctions(map<pair<TString, Int_t>, pair<TString, TString>> &functions); 2418{; 2419 // map< pair<TString,Int_t> ,pair<TString,TString> > functions;; 2420 functions.insert(; 2421 make_pair(make_pair(""gaus"", 1), make_pair(""[0]*exp(-0.5*(({V0}-[1])/[2])*(({V0}-[1])/[2]))"",; 2422 ""[0]*exp(-0.5*(({V0}-[1])/[2])*(({V0}-[1])/[2]))/(sqrt(2*pi)*[2])"")));; 2423 functions.inser",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:92543,Modifiability,variab,variable,92543,">::iterator it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 2385 // functions are now by default always not checked; 2386 if (!it->fFound && !it->IsFuncCall()) {; 2387 //allFunctorsMatched = false;; 2388 if (it->GetNargs() == 0); 2389 Error(""ProcessFormula"", ""\""%s\"" has not been matched in the formula expression"", it->GetName());; 2390 else; 2391 Error(""ProcessFormula"", ""Could not find %s function with %d argument(s)"", it->GetName(), it->GetNargs());; 2392 }; 2393 }; 2394 Error(""ProcessFormula"",""Formula \""%s\"" is invalid !"", GetExpFormula().Data() );; 2395 fReadyToExecute = false;; 2396 }; 2397 ; 2398 // clean up un-used default variables in case formula is valid; 2399 //if (fClingInitialized && fReadyToExecute) {; 2400 //don't check fClingInitialized in case of lazy execution; 2401 if (fReadyToExecute) {; 2402 auto itvar = fVars.begin();; 2403 // need this loop because after erase change iterators; 2404 do {; 2405 if (!itvar->second.fFound) {; 2406 // std::cout << ""Erase variable "" << itvar->first << std::endl;; 2407 itvar = fVars.erase(itvar);; 2408 } else; 2409 itvar++;; 2410 } while (itvar != fVars.end());; 2411 }; 2412}; 2413 ; 2414////////////////////////////////////////////////////////////////////////////////; 2415/// Fill map with parametrized functions; 2416 ; 2417void TFormula::FillParametrizedFunctions(map<pair<TString, Int_t>, pair<TString, TString>> &functions); 2418{; 2419 // map< pair<TString,Int_t> ,pair<TString,TString> > functions;; 2420 functions.insert(; 2421 make_pair(make_pair(""gaus"", 1), make_pair(""[0]*exp(-0.5*(({V0}-[1])/[2])*(({V0}-[1])/[2]))"",; 2422 ""[0]*exp(-0.5*(({V0}-[1])/[2])*(({V0}-[1])/[2]))/(sqrt(2*pi)*[2])"")));; 2423 functions.insert(make_pair(make_pair(""landau"", 1), make_pair(""[0]*TMath::Landau({V0},[1],[2],false)"",; 2424 ""[0]*TMath::Landau({V0},[1],[2],true)"")));; 2425 functions.insert(make_pair(make_pair(""expo"", 1), make_pair(""exp([0]+[1]*{V0})"", """")));; 2426 functions.insert(; 2427 make_pair(make_pair(""crystalball"", 1), make_",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:99265,Modifiability,variab,variable,99265,"needed anymore (p0 is assigned by default); 2535 // if (fNumber == (300+fNpar-1) ) {; 2536 // for (int i = 0; i < fNpar; i++) SetParName(i,TString::Format(""p%d"",i));; 2537 // return;; 2538 // }; 2539 ; 2540 // // general case if parameters are digits (XX) change to pXX; 2541 // auto paramMap = fParams; // need to copy the map because SetParName is going to modify it; 2542 // for ( auto & p : paramMap) {; 2543 // if (p.first.IsDigit() ); 2544 // SetParName(p.second,TString::Format(""p%s"",p.first.Data()));; 2545 // }; 2546 ; 2547 return;; 2548}; 2549 ; 2550////////////////////////////////////////////////////////////////////////////////; 2551/// Return linear part.; 2552 ; 2553const TObject* TFormula::GetLinearPart(Int_t i) const; 2554{; 2555 if (!fLinearParts.empty()) {; 2556 int n = fLinearParts.size();; 2557 if (i < 0 || i >= n ) {; 2558 Error(""GetLinearPart"",""Formula %s has only %d linear parts - requested %d"",GetName(),n,i);; 2559 return nullptr;; 2560 }; 2561 return fLinearParts[i];; 2562 }; 2563 return nullptr;; 2564}; 2565 ; 2566////////////////////////////////////////////////////////////////////////////////; 2567/// Adds variable to known variables, and reprocess formula.; 2568 ; 2569void TFormula::AddVariable(const TString &name, double value); 2570{; 2571 if (fVars.find(name) != fVars.end()) {; 2572 TFormulaVariable &var = fVars[name];; 2573 var.fValue = value;; 2574 ; 2575 // If the position is not defined in the Cling vectors, make space for it; 2576 // but normally is variable is defined in fVars a slot should be also present in fClingVariables; 2577 if (var.fArrayPos < 0) {; 2578 var.fArrayPos = fVars.size();; 2579 }; 2580 if (var.fArrayPos >= (int)fClingVariables.size()) {; 2581 fClingVariables.resize(var.fArrayPos + 1);; 2582 }; 2583 fClingVariables[var.fArrayPos] = value;; 2584 } else {; 2585 TFormulaVariable var(name, value, fVars.size());; 2586 fVars[name] = var;; 2587 fClingVariables.push_back(value);; 2588 if (!fFormula.IsNull()) {; 2589 // printf(",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:99283,Modifiability,variab,variables,99283,"needed anymore (p0 is assigned by default); 2535 // if (fNumber == (300+fNpar-1) ) {; 2536 // for (int i = 0; i < fNpar; i++) SetParName(i,TString::Format(""p%d"",i));; 2537 // return;; 2538 // }; 2539 ; 2540 // // general case if parameters are digits (XX) change to pXX; 2541 // auto paramMap = fParams; // need to copy the map because SetParName is going to modify it; 2542 // for ( auto & p : paramMap) {; 2543 // if (p.first.IsDigit() ); 2544 // SetParName(p.second,TString::Format(""p%s"",p.first.Data()));; 2545 // }; 2546 ; 2547 return;; 2548}; 2549 ; 2550////////////////////////////////////////////////////////////////////////////////; 2551/// Return linear part.; 2552 ; 2553const TObject* TFormula::GetLinearPart(Int_t i) const; 2554{; 2555 if (!fLinearParts.empty()) {; 2556 int n = fLinearParts.size();; 2557 if (i < 0 || i >= n ) {; 2558 Error(""GetLinearPart"",""Formula %s has only %d linear parts - requested %d"",GetName(),n,i);; 2559 return nullptr;; 2560 }; 2561 return fLinearParts[i];; 2562 }; 2563 return nullptr;; 2564}; 2565 ; 2566////////////////////////////////////////////////////////////////////////////////; 2567/// Adds variable to known variables, and reprocess formula.; 2568 ; 2569void TFormula::AddVariable(const TString &name, double value); 2570{; 2571 if (fVars.find(name) != fVars.end()) {; 2572 TFormulaVariable &var = fVars[name];; 2573 var.fValue = value;; 2574 ; 2575 // If the position is not defined in the Cling vectors, make space for it; 2576 // but normally is variable is defined in fVars a slot should be also present in fClingVariables; 2577 if (var.fArrayPos < 0) {; 2578 var.fArrayPos = fVars.size();; 2579 }; 2580 if (var.fArrayPos >= (int)fClingVariables.size()) {; 2581 fClingVariables.resize(var.fArrayPos + 1);; 2582 }; 2583 fClingVariables[var.fArrayPos] = value;; 2584 } else {; 2585 TFormulaVariable var(name, value, fVars.size());; 2586 fVars[name] = var;; 2587 fClingVariables.push_back(value);; 2588 if (!fFormula.IsNull()) {; 2589 // printf(",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:99624,Modifiability,variab,variable,99624,"""p%s"",p.first.Data()));; 2545 // }; 2546 ; 2547 return;; 2548}; 2549 ; 2550////////////////////////////////////////////////////////////////////////////////; 2551/// Return linear part.; 2552 ; 2553const TObject* TFormula::GetLinearPart(Int_t i) const; 2554{; 2555 if (!fLinearParts.empty()) {; 2556 int n = fLinearParts.size();; 2557 if (i < 0 || i >= n ) {; 2558 Error(""GetLinearPart"",""Formula %s has only %d linear parts - requested %d"",GetName(),n,i);; 2559 return nullptr;; 2560 }; 2561 return fLinearParts[i];; 2562 }; 2563 return nullptr;; 2564}; 2565 ; 2566////////////////////////////////////////////////////////////////////////////////; 2567/// Adds variable to known variables, and reprocess formula.; 2568 ; 2569void TFormula::AddVariable(const TString &name, double value); 2570{; 2571 if (fVars.find(name) != fVars.end()) {; 2572 TFormulaVariable &var = fVars[name];; 2573 var.fValue = value;; 2574 ; 2575 // If the position is not defined in the Cling vectors, make space for it; 2576 // but normally is variable is defined in fVars a slot should be also present in fClingVariables; 2577 if (var.fArrayPos < 0) {; 2578 var.fArrayPos = fVars.size();; 2579 }; 2580 if (var.fArrayPos >= (int)fClingVariables.size()) {; 2581 fClingVariables.resize(var.fArrayPos + 1);; 2582 }; 2583 fClingVariables[var.fArrayPos] = value;; 2584 } else {; 2585 TFormulaVariable var(name, value, fVars.size());; 2586 fVars[name] = var;; 2587 fClingVariables.push_back(value);; 2588 if (!fFormula.IsNull()) {; 2589 // printf(""process formula again - %s \n"",fClingInput.Data() );; 2590 ProcessFormula(fClingInput);; 2591 }; 2592 }; 2593}; 2594 ; 2595////////////////////////////////////////////////////////////////////////////////; 2596/// Adds multiple variables.; 2597/// First argument is an array of pairs<TString,Double>, where; 2598/// first argument is name of variable,; 2599/// second argument represents value.; 2600/// size - number of variables passed in first argument; 2601 ; 2602void TFormula::Ad",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:100349,Modifiability,variab,variables,100349,"ds variable to known variables, and reprocess formula.; 2568 ; 2569void TFormula::AddVariable(const TString &name, double value); 2570{; 2571 if (fVars.find(name) != fVars.end()) {; 2572 TFormulaVariable &var = fVars[name];; 2573 var.fValue = value;; 2574 ; 2575 // If the position is not defined in the Cling vectors, make space for it; 2576 // but normally is variable is defined in fVars a slot should be also present in fClingVariables; 2577 if (var.fArrayPos < 0) {; 2578 var.fArrayPos = fVars.size();; 2579 }; 2580 if (var.fArrayPos >= (int)fClingVariables.size()) {; 2581 fClingVariables.resize(var.fArrayPos + 1);; 2582 }; 2583 fClingVariables[var.fArrayPos] = value;; 2584 } else {; 2585 TFormulaVariable var(name, value, fVars.size());; 2586 fVars[name] = var;; 2587 fClingVariables.push_back(value);; 2588 if (!fFormula.IsNull()) {; 2589 // printf(""process formula again - %s \n"",fClingInput.Data() );; 2590 ProcessFormula(fClingInput);; 2591 }; 2592 }; 2593}; 2594 ; 2595////////////////////////////////////////////////////////////////////////////////; 2596/// Adds multiple variables.; 2597/// First argument is an array of pairs<TString,Double>, where; 2598/// first argument is name of variable,; 2599/// second argument represents value.; 2600/// size - number of variables passed in first argument; 2601 ; 2602void TFormula::AddVariables(const TString *vars, const Int_t size); 2603{; 2604 Bool_t anyNewVar = false;; 2605 for (Int_t i = 0; i < size; ++i) {; 2606 ; 2607 const TString &vname = vars[i];; 2608 ; 2609 TFormulaVariable &var = fVars[vname];; 2610 if (var.fArrayPos < 0) {; 2611 ; 2612 var.fName = vname;; 2613 var.fArrayPos = fVars.size();; 2614 anyNewVar = true;; 2615 var.fValue = 0;; 2616 if (var.fArrayPos >= (int)fClingVariables.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 f",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:100463,Modifiability,variab,variable,100463,"()) {; 2572 TFormulaVariable &var = fVars[name];; 2573 var.fValue = value;; 2574 ; 2575 // If the position is not defined in the Cling vectors, make space for it; 2576 // but normally is variable is defined in fVars a slot should be also present in fClingVariables; 2577 if (var.fArrayPos < 0) {; 2578 var.fArrayPos = fVars.size();; 2579 }; 2580 if (var.fArrayPos >= (int)fClingVariables.size()) {; 2581 fClingVariables.resize(var.fArrayPos + 1);; 2582 }; 2583 fClingVariables[var.fArrayPos] = value;; 2584 } else {; 2585 TFormulaVariable var(name, value, fVars.size());; 2586 fVars[name] = var;; 2587 fClingVariables.push_back(value);; 2588 if (!fFormula.IsNull()) {; 2589 // printf(""process formula again - %s \n"",fClingInput.Data() );; 2590 ProcessFormula(fClingInput);; 2591 }; 2592 }; 2593}; 2594 ; 2595////////////////////////////////////////////////////////////////////////////////; 2596/// Adds multiple variables.; 2597/// First argument is an array of pairs<TString,Double>, where; 2598/// first argument is name of variable,; 2599/// second argument represents value.; 2600/// size - number of variables passed in first argument; 2601 ; 2602void TFormula::AddVariables(const TString *vars, const Int_t size); 2603{; 2604 Bool_t anyNewVar = false;; 2605 for (Int_t i = 0; i < size; ++i) {; 2606 ; 2607 const TString &vname = vars[i];; 2608 ; 2609 TFormulaVariable &var = fVars[vname];; 2610 if (var.fArrayPos < 0) {; 2611 ; 2612 var.fName = vname;; 2613 var.fArrayPos = fVars.size();; 2614 anyNewVar = true;; 2615 var.fValue = 0;; 2616 if (var.fArrayPos >= (int)fClingVariables.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 fClingVariables.push_back(0.0);; 2624 }; 2625 // else; 2626 // {; 2627 // var.fValue = v.second;; 2628 // fClingVariables[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:100542,Modifiability,variab,variables,100542,"nt in fClingVariables; 2577 if (var.fArrayPos < 0) {; 2578 var.fArrayPos = fVars.size();; 2579 }; 2580 if (var.fArrayPos >= (int)fClingVariables.size()) {; 2581 fClingVariables.resize(var.fArrayPos + 1);; 2582 }; 2583 fClingVariables[var.fArrayPos] = value;; 2584 } else {; 2585 TFormulaVariable var(name, value, fVars.size());; 2586 fVars[name] = var;; 2587 fClingVariables.push_back(value);; 2588 if (!fFormula.IsNull()) {; 2589 // printf(""process formula again - %s \n"",fClingInput.Data() );; 2590 ProcessFormula(fClingInput);; 2591 }; 2592 }; 2593}; 2594 ; 2595////////////////////////////////////////////////////////////////////////////////; 2596/// Adds multiple variables.; 2597/// First argument is an array of pairs<TString,Double>, where; 2598/// first argument is name of variable,; 2599/// second argument represents value.; 2600/// size - number of variables passed in first argument; 2601 ; 2602void TFormula::AddVariables(const TString *vars, const Int_t size); 2603{; 2604 Bool_t anyNewVar = false;; 2605 for (Int_t i = 0; i < size; ++i) {; 2606 ; 2607 const TString &vname = vars[i];; 2608 ; 2609 TFormulaVariable &var = fVars[vname];; 2610 if (var.fArrayPos < 0) {; 2611 ; 2612 var.fName = vname;; 2613 var.fArrayPos = fVars.size();; 2614 anyNewVar = true;; 2615 var.fValue = 0;; 2616 if (var.fArrayPos >= (int)fClingVariables.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 fClingVariables.push_back(0.0);; 2624 }; 2625 // else; 2626 // {; 2627 // var.fValue = v.second;; 2628 // fClingVariables[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if (anyNewVar && !fFormula.IsNull()) {; 2632 ProcessFormula(fClingInput);; 2633 }; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Set the name of the formula. We need to allow the list ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:101893,Modifiability,variab,variable,101893,"Vars[vname];; 2610 if (var.fArrayPos < 0) {; 2611 ; 2612 var.fName = vname;; 2613 var.fArrayPos = fVars.size();; 2614 anyNewVar = true;; 2615 var.fValue = 0;; 2616 if (var.fArrayPos >= (int)fClingVariables.capacity()) {; 2617 Int_t multiplier = 2;; 2618 if (fFuncs.size() > 100) {; 2619 multiplier = TMath::Floor(TMath::Log10(fFuncs.size()) * 10);; 2620 }; 2621 fClingVariables.reserve(multiplier * fClingVariables.capacity());; 2622 }; 2623 fClingVariables.push_back(0.0);; 2624 }; 2625 // else; 2626 // {; 2627 // var.fValue = v.second;; 2628 // fClingVariables[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if (anyNewVar && !fFormula.IsNull()) {; 2632 ProcessFormula(fClingInput);; 2633 }; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Set the name of the formula. We need to allow the list of function to; 2638/// properly handle the hashes.; 2639 ; 2640void TFormula::SetName(const char* name); 2641{; 2642 if (IsReservedName(name)) {; 2643 Error(""SetName"", ""The name \'%s\' is reserved as a TFormula variable name.\n""; 2644 ""\tThis function will not be renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:102655,Modifiability,variab,variables,102655,"les[var.fArrayPos] = v.second;; 2629 // }; 2630 }; 2631 if (anyNewVar && !fFormula.IsNull()) {; 2632 ProcessFormula(fClingInput);; 2633 }; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Set the name of the formula. We need to allow the list of function to; 2638/// properly handle the hashes.; 2639 ; 2640void TFormula::SetName(const char* name); 2641{; 2642 if (IsReservedName(name)) {; 2643 Error(""SetName"", ""The name \'%s\' is reserved as a TFormula variable name.\n""; 2644 ""\tThis function will not be renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2672 {; 2673 auto &v = vars[i];; 2674 if (fVars.find(v.first) != fVars.end()) {; 2675 fVars[v.first].fValue = v.second;; 2676 fClingVariables[fVars[v.first].fArrayPos] = v.second;; 2677 } else {; 2678 Error(""SetVariables"", ""Variable %s is not defined."", v.first.Data());; 2679 }; 2680 }; 2681}; 2682 ; 2683//////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:102769,Modifiability,variab,variable,102769,"40void TFormula::SetName(const char* name); 2641{; 2642 if (IsReservedName(name)) {; 2643 Error(""SetName"", ""The name \'%s\' is reserved as a TFormula variable name.\n""; 2644 ""\tThis function will not be renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2672 {; 2673 auto &v = vars[i];; 2674 if (fVars.find(v.first) != fVars.end()) {; 2675 fVars[v.first].fValue = v.second;; 2676 fClingVariables[fVars[v.first].fArrayPos] = v.second;; 2677 } else {; 2678 Error(""SetVariables"", ""Variable %s is not defined."", v.first.Data());; 2679 }; 2680 }; 2681}; 2682 ; 2683////////////////////////////////////////////////////////////////////////////////; 2684/// Returns variable value.; 2685 ; 2686Double_t TFormula::GetVariable(const char *name) const; 2687{; 2688 const auto nameIt = fVars.find(name);; 2689 if (fVars.end() == nameIt) {; 2690 Error(""GetVariable"", ""Variable %s is not defined."", name);; 2691 return -1;; 2692 }; 2693 return nameIt->second.fValue;; 2694}; 2695 ; 2696//",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:102848,Modifiability,variab,variables,102848,"renamed."",; 2645 name);; 2646 } else {; 2647 // Here we need to remove and re-add to keep the hashes consistent with; 2648 // the underlying names.; 2649 auto listOfFunctions = gROOT->GetListOfFunctions();; 2650 TObject* thisAsFunctionInList = nullptr;; 2651 R__LOCKGUARD(gROOTMutex);; 2652 if (listOfFunctions){; 2653 thisAsFunctionInList = listOfFunctions->FindObject(this);; 2654 if (thisAsFunctionInList) listOfFunctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2672 {; 2673 auto &v = vars[i];; 2674 if (fVars.find(v.first) != fVars.end()) {; 2675 fVars[v.first].fValue = v.second;; 2676 fClingVariables[fVars[v.first].fArrayPos] = v.second;; 2677 } else {; 2678 Error(""SetVariables"", ""Variable %s is not defined."", v.first.Data());; 2679 }; 2680 }; 2681}; 2682 ; 2683////////////////////////////////////////////////////////////////////////////////; 2684/// Returns variable value.; 2685 ; 2686Double_t TFormula::GetVariable(const char *name) const; 2687{; 2688 const auto nameIt = fVars.find(name);; 2689 if (fVars.end() == nameIt) {; 2690 Error(""GetVariable"", ""Variable %s is not defined."", name);; 2691 return -1;; 2692 }; 2693 return nameIt->second.fValue;; 2694}; 2695 ; 2696////////////////////////////////////////////////////////////////////////////////; 2697/// Returns variable number (positon in array) given its name.; 2698 ; 2699Int_t TFormula::GetVarNumber(const char *nam",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:103427,Modifiability,variab,variable,103427,"nctions->Remove(thisAsFunctionInList);; 2655 }; 2656 TNamed::SetName(name);; 2657 if (thisAsFunctionInList) listOfFunctions->Add(thisAsFunctionInList);; 2658 }; 2659}; 2660 ; 2661////////////////////////////////////////////////////////////////////////////////; 2662///; 2663/// Sets multiple variables.; 2664/// First argument is an array of pairs<TString,Double>, where; 2665/// first argument is name of variable,; 2666/// second argument represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2672 {; 2673 auto &v = vars[i];; 2674 if (fVars.find(v.first) != fVars.end()) {; 2675 fVars[v.first].fValue = v.second;; 2676 fClingVariables[fVars[v.first].fArrayPos] = v.second;; 2677 } else {; 2678 Error(""SetVariables"", ""Variable %s is not defined."", v.first.Data());; 2679 }; 2680 }; 2681}; 2682 ; 2683////////////////////////////////////////////////////////////////////////////////; 2684/// Returns variable value.; 2685 ; 2686Double_t TFormula::GetVariable(const char *name) const; 2687{; 2688 const auto nameIt = fVars.find(name);; 2689 if (fVars.end() == nameIt) {; 2690 Error(""GetVariable"", ""Variable %s is not defined."", name);; 2691 return -1;; 2692 }; 2693 return nameIt->second.fValue;; 2694}; 2695 ; 2696////////////////////////////////////////////////////////////////////////////////; 2697/// Returns variable number (positon in array) given its name.; 2698 ; 2699Int_t TFormula::GetVarNumber(const char *name) const; 2700{; 2701 const auto nameIt = fVars.find(name);; 2702 if (fVars.end() == nameIt) {; 2703 Error(""GetVarNumber"", ""Variable %s is not defined."", name);; 2704 return -1;; 2705 }; 2706 return nameIt->second.fArrayPos;; 2707}; 2708 ; 2709////////////////////////////////////////////////////////////////////////////////; 2710/// Returns variable name given its position in the array.; 2711 ; 2712TString TFormula:",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:103839,Modifiability,variab,variable,103839,"nt represents value.; 2667/// size - number of variables passed in first argument; 2668 ; 2669void TFormula::SetVariables(const pair<TString,Double_t> *vars, const Int_t size); 2670{; 2671 for(Int_t i = 0; i < size; ++i); 2672 {; 2673 auto &v = vars[i];; 2674 if (fVars.find(v.first) != fVars.end()) {; 2675 fVars[v.first].fValue = v.second;; 2676 fClingVariables[fVars[v.first].fArrayPos] = v.second;; 2677 } else {; 2678 Error(""SetVariables"", ""Variable %s is not defined."", v.first.Data());; 2679 }; 2680 }; 2681}; 2682 ; 2683////////////////////////////////////////////////////////////////////////////////; 2684/// Returns variable value.; 2685 ; 2686Double_t TFormula::GetVariable(const char *name) const; 2687{; 2688 const auto nameIt = fVars.find(name);; 2689 if (fVars.end() == nameIt) {; 2690 Error(""GetVariable"", ""Variable %s is not defined."", name);; 2691 return -1;; 2692 }; 2693 return nameIt->second.fValue;; 2694}; 2695 ; 2696////////////////////////////////////////////////////////////////////////////////; 2697/// Returns variable number (positon in array) given its name.; 2698 ; 2699Int_t TFormula::GetVarNumber(const char *name) const; 2700{; 2701 const auto nameIt = fVars.find(name);; 2702 if (fVars.end() == nameIt) {; 2703 Error(""GetVarNumber"", ""Variable %s is not defined."", name);; 2704 return -1;; 2705 }; 2706 return nameIt->second.fArrayPos;; 2707}; 2708 ; 2709////////////////////////////////////////////////////////////////////////////////; 2710/// Returns variable name given its position in the array.; 2711 ; 2712TString TFormula::GetVarName(Int_t ivar) const; 2713{; 2714 if (ivar < 0 || ivar >= fNdim) return """";; 2715 ; 2716 // need to loop on the map to find corresponding variable; 2717 for ( auto & v : fVars) {; 2718 if (v.second.fArrayPos == ivar) return v.first;; 2719 }; 2720 Error(""GetVarName"",""Variable with index %d not found !!"",ivar);; 2721 //return TString::Format(""x%d"",ivar);; 2722 return """";; 2723}; 2724 ; 2725//////////////////////////////////////",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:104288,Modifiability,variab,variable,104288,"Variable %s is not defined."", v.first.Data());; 2679 }; 2680 }; 2681}; 2682 ; 2683////////////////////////////////////////////////////////////////////////////////; 2684/// Returns variable value.; 2685 ; 2686Double_t TFormula::GetVariable(const char *name) const; 2687{; 2688 const auto nameIt = fVars.find(name);; 2689 if (fVars.end() == nameIt) {; 2690 Error(""GetVariable"", ""Variable %s is not defined."", name);; 2691 return -1;; 2692 }; 2693 return nameIt->second.fValue;; 2694}; 2695 ; 2696////////////////////////////////////////////////////////////////////////////////; 2697/// Returns variable number (positon in array) given its name.; 2698 ; 2699Int_t TFormula::GetVarNumber(const char *name) const; 2700{; 2701 const auto nameIt = fVars.find(name);; 2702 if (fVars.end() == nameIt) {; 2703 Error(""GetVarNumber"", ""Variable %s is not defined."", name);; 2704 return -1;; 2705 }; 2706 return nameIt->second.fArrayPos;; 2707}; 2708 ; 2709////////////////////////////////////////////////////////////////////////////////; 2710/// Returns variable name given its position in the array.; 2711 ; 2712TString TFormula::GetVarName(Int_t ivar) const; 2713{; 2714 if (ivar < 0 || ivar >= fNdim) return """";; 2715 ; 2716 // need to loop on the map to find corresponding variable; 2717 for ( auto & v : fVars) {; 2718 if (v.second.fArrayPos == ivar) return v.first;; 2719 }; 2720 Error(""GetVarName"",""Variable with index %d not found !!"",ivar);; 2721 //return TString::Format(""x%d"",ivar);; 2722 return """";; 2723}; 2724 ; 2725////////////////////////////////////////////////////////////////////////////////; 2726/// Sets variable value.; 2727 ; 2728void TFormula::SetVariable(const TString &name, Double_t value); 2729{; 2730 if (fVars.find(name) == fVars.end()) {; 2731 Error(""SetVariable"", ""Variable %s is not defined."", name.Data());; 2732 return;; 2733 }; 2734 fVars[name].fValue = value;; 2735 fClingVariables[fVars[name].fArrayPos] = value;; 2736}; 2737 ; 2738///////////////////////////////////////////",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:104511,Modifiability,variab,variable,104511,"; 2686Double_t TFormula::GetVariable(const char *name) const; 2687{; 2688 const auto nameIt = fVars.find(name);; 2689 if (fVars.end() == nameIt) {; 2690 Error(""GetVariable"", ""Variable %s is not defined."", name);; 2691 return -1;; 2692 }; 2693 return nameIt->second.fValue;; 2694}; 2695 ; 2696////////////////////////////////////////////////////////////////////////////////; 2697/// Returns variable number (positon in array) given its name.; 2698 ; 2699Int_t TFormula::GetVarNumber(const char *name) const; 2700{; 2701 const auto nameIt = fVars.find(name);; 2702 if (fVars.end() == nameIt) {; 2703 Error(""GetVarNumber"", ""Variable %s is not defined."", name);; 2704 return -1;; 2705 }; 2706 return nameIt->second.fArrayPos;; 2707}; 2708 ; 2709////////////////////////////////////////////////////////////////////////////////; 2710/// Returns variable name given its position in the array.; 2711 ; 2712TString TFormula::GetVarName(Int_t ivar) const; 2713{; 2714 if (ivar < 0 || ivar >= fNdim) return """";; 2715 ; 2716 // need to loop on the map to find corresponding variable; 2717 for ( auto & v : fVars) {; 2718 if (v.second.fArrayPos == ivar) return v.first;; 2719 }; 2720 Error(""GetVarName"",""Variable with index %d not found !!"",ivar);; 2721 //return TString::Format(""x%d"",ivar);; 2722 return """";; 2723}; 2724 ; 2725////////////////////////////////////////////////////////////////////////////////; 2726/// Sets variable value.; 2727 ; 2728void TFormula::SetVariable(const TString &name, Double_t value); 2729{; 2730 if (fVars.find(name) == fVars.end()) {; 2731 Error(""SetVariable"", ""Variable %s is not defined."", name.Data());; 2732 return;; 2733 }; 2734 fVars[name].fValue = value;; 2735 fClingVariables[fVars[name].fArrayPos] = value;; 2736}; 2737 ; 2738////////////////////////////////////////////////////////////////////////////////; 2739/// Adds parameter to known parameters.; 2740/// User should use SetParameter, because parameters are added during initialization part,; 2741/// and after that",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:104859,Modifiability,variab,variable,104859," 2696////////////////////////////////////////////////////////////////////////////////; 2697/// Returns variable number (positon in array) given its name.; 2698 ; 2699Int_t TFormula::GetVarNumber(const char *name) const; 2700{; 2701 const auto nameIt = fVars.find(name);; 2702 if (fVars.end() == nameIt) {; 2703 Error(""GetVarNumber"", ""Variable %s is not defined."", name);; 2704 return -1;; 2705 }; 2706 return nameIt->second.fArrayPos;; 2707}; 2708 ; 2709////////////////////////////////////////////////////////////////////////////////; 2710/// Returns variable name given its position in the array.; 2711 ; 2712TString TFormula::GetVarName(Int_t ivar) const; 2713{; 2714 if (ivar < 0 || ivar >= fNdim) return """";; 2715 ; 2716 // need to loop on the map to find corresponding variable; 2717 for ( auto & v : fVars) {; 2718 if (v.second.fArrayPos == ivar) return v.first;; 2719 }; 2720 Error(""GetVarName"",""Variable with index %d not found !!"",ivar);; 2721 //return TString::Format(""x%d"",ivar);; 2722 return """";; 2723}; 2724 ; 2725////////////////////////////////////////////////////////////////////////////////; 2726/// Sets variable value.; 2727 ; 2728void TFormula::SetVariable(const TString &name, Double_t value); 2729{; 2730 if (fVars.find(name) == fVars.end()) {; 2731 Error(""SetVariable"", ""Variable %s is not defined."", name.Data());; 2732 return;; 2733 }; 2734 fVars[name].fValue = value;; 2735 fClingVariables[fVars[name].fArrayPos] = value;; 2736}; 2737 ; 2738////////////////////////////////////////////////////////////////////////////////; 2739/// Adds parameter to known parameters.; 2740/// User should use SetParameter, because parameters are added during initialization part,; 2741/// and after that adding new will be pointless.; 2742 ; 2743void TFormula::DoAddParameter(const TString &name, Double_t value, Bool_t processFormula); 2744{; 2745 //std::cout << ""adding parameter "" << name << std::endl;; 2746 ; 2747 // if parameter is already defined in fParams - just set the new value; ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:127561,Modifiability,variab,variables,127561,"if (fVectorized); 3328 return DoEvalVec(x, params);; 3329 ; 3330 if (fNdim == 0 || !x); 3331 return DoEval(nullptr, params); // automatic conversion to vectorized; 3332 ; 3333 // otherwise, trying to input vectors into a scalar function; 3334 ; 3335 if (gDebug); 3336 Info(""EvalPar"", ""Function is not vectorized - converting ROOT::Double_v into Double_t and back"");; 3337 ; 3338 const int vecSize = vecCore::VectorSize<ROOT::Double_v>();; 3339 std::vector<Double_t> xscalars(vecSize*fNdim);; 3340 ; 3341 for (int i = 0; i < vecSize; i++); 3342 for (int j = 0; j < fNdim; j++); 3343 xscalars[i*fNdim+j] = vecCore::Get(x[j],i);; 3344 ; 3345 ROOT::Double_v answers(0.);; 3346 for (int i = 0; i < vecSize; i++); 3347 vecCore::Set(answers, i, DoEval(&xscalars[i*fNdim], params));; 3348 ; 3349 return answers;; 3350}; 3351#endif; 3352 ; 3353////////////////////////////////////////////////////////////////////////////////; 3354/// Evaluate formula.; 3355/// If formula is not ready to execute(missing parameters/variables),; 3356/// print these which are not known.; 3357/// If parameter has default value, and has not been set, appropriate warning is shown.; 3358 ; 3359Double_t TFormula::DoEval(const double * x, const double * params) const; 3360{; 3361 if(!fReadyToExecute); 3362 {; 3363 Error(""Eval"", ""Formula is invalid and not ready to execute "");; 3364 for (auto it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3365 TFormulaFunction fun = *it;; 3366 if (!fun.fFound) {; 3367 printf(""%s is unknown.\n"", fun.GetName());; 3368 }; 3369 }; 3370 return TMath::QuietNaN();; 3371 }; 3372 ; 3373 // Lazy initialization is set and needed when reading from a file; 3374 if (!fClingInitialized && fLazyInitialization) {; 3375 // try recompiling the formula. We need to lock because this is not anymore thread safe; 3376 R__LOCKGUARD(gROOTMutex);; 3377 // check again in case another thread has initialized the formula (see ROOT-10994); 3378 if (!fClingInitialized) {; 3379 auto thisFormula = const_cast<TFormu",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:139079,Modifiability,variab,variables,139079,"Npar); 3632 Error(""Print"",""Number of stored parameters in vector %zu in map %zu is different than fNpar %d"",fClingParameters.size(), fParams.size(), fNpar);; 3633 assert(int(fClingParameters.size()) >= fNpar);; 3634 // print with order passed to Cling function; 3635 for ( int ipar = 0; ipar < fNpar ; ++ipar) {; 3636 printf(""Par%4d %20s = %10f \n"",ipar,GetParName(ipar), fClingParameters[ipar] );; 3637 }; 3638 }; 3639 printf(""Expression passed to Cling:\n"");; 3640 printf(""\t%s\n"",fClingInput.Data() );; 3641 if (fGradFuncPtr) {; 3642 printf(""Generated Gradient:\n"");; 3643 printf(""%s\n"", fGradGenerationInput.c_str());; 3644 printf(""%s\n"", GetGradientFormula().Data());; 3645 }; 3646 if(fHessFuncPtr) {; 3647 printf(""Generated Hessian:\n"");; 3648 printf(""%s\n"", fHessGenerationInput.c_str());; 3649 printf(""%s\n"", GetHessianFormula().Data());; 3650 }; 3651 }; 3652 if(!fReadyToExecute); 3653 {; 3654 Warning(""Print"", ""Formula is not ready to execute. Missing parameters/variables"");; 3655 for (list<TFormulaFunction>::const_iterator it = fFuncs.begin(); it != fFuncs.end(); ++it) {; 3656 TFormulaFunction fun = *it;; 3657 if (!fun.fFound) {; 3658 printf(""%s is unknown.\n"", fun.GetName());; 3659 }; 3660 }; 3661 }; 3662 if (!fAllParametersSetted) {; 3663 // we can skip this; 3664 // Info(""Print"",""Not all parameters are set."");; 3665 // for(map<TString,TFormulaVariable>::const_iterator it = fParams.begin(); it != fParams.end(); ++it); 3666 // {; 3667 // pair<TString,TFormulaVariable> param = *it;; 3668 // if(!param.second.fFound); 3669 // {; 3670 // printf(""%s has default value %lf\n"",param.first.Data(),param.second.GetInitialValue());; 3671 // }; 3672 // }; 3673 }; 3674}; 3675 ; 3676////////////////////////////////////////////////////////////////////////////////; 3677/// Stream a class object.; 3678 ; 3679void TFormula::Streamer(TBuffer &b); 3680{; 3681 if (b.IsReading() ) {; 3682 UInt_t R__s, R__c;; 3683 Version_t v = b.ReadVersion(&R__s, &R__c);; 3684 //std::cout << ""version "" << v",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:150916,Modifiability,variab,variables,150916,"ar ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TInterpreterValue.h; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMethodCall.h; TMethod.h; gDebugInt_t gDebugDefinition TROOT.cxx:597; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TRegexp.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; ROOT::v5::TFormula::Streamervoid Streamer(TBuffer &b, const TClass *onfile_class)Stream a class object.Definition TFormula_v5.cxx:3460; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3912; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TF11-Dim function classDefinition TF1.h:233; TF1::GetFormulavirtual TFormula * GetFormula()Definition TF1.h:481; TFormulaFunctionHelper class for TFormula.Definitio",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:153323,Modifiability,variab,variables,153323,"::fNameTString fNameDefinition TFormula.h:67; TFormulaVariable::fArrayPosInt_t fArrayPosDefinition TFormula.h:69; TFormulaVariable::fValueDouble_t fValueDefinition TFormula.h:68; TFormulaThe Formula class.Definition TFormula.h:89; TFormula::fHessFuncPtrCallFuncSignature fHessFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:109; TFormula::GetParameterDouble_t GetParameter(const char *name) constReturns parameter value given by string.Definition TFormula.cxx:2833; TFormula::PrepareFormulaBool_t PrepareFormula(TString &formula)prepare the formula to be executed normally is called with fFormulaDefinition TFormula.cxx:1793; TFormula::fClingInitializedstd::atomic< Bool_t > fClingInitialized! Transient to force re-initializationDefinition TFormula.h:97; TFormula::GradientParvoid GradientPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3222; TFormula::FillDefaultsvoid FillDefaults()Fill structures with default variables, constants and function shortcuts.Definition TFormula.cxx:902; TFormula::GetHessianFormulaTString GetHessianFormula() constDefinition TFormula.cxx:3602; TFormula::Clearvoid Clear(Option_t *option="""") overrideClear the formula setting expression to empty and reset the variables and parameters containers.Definition TFormula.cxx:767; TFormula::GetLinearPartconst TObject * GetLinearPart(Int_t i) constReturn linear part.Definition TFormula.cxx:2553; TFormula::InputFormulaIntoClingvoid InputFormulaIntoCling()Inputs formula, transfered to C++ code into Cling.Definition TFormula.cxx:876; TFormula::DoAddParametervoid DoAddParameter(const TString &name, Double_t value, bool processFormula)Adds parameter to known parameters.Definition TFormula.cxx:2743; TFormula::HandleLinearvoid HandleLinear(TString &formula)Handle linear functions defined with the operator ++.Definition TFormula.cxx:1735; TFormula::fClingNameTString fClingName! Unique name passed to Cling to define t",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:153601,Modifiability,variab,variables,153601,"trCallFuncSignature fHessFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:109; TFormula::GetParameterDouble_t GetParameter(const char *name) constReturns parameter value given by string.Definition TFormula.cxx:2833; TFormula::PrepareFormulaBool_t PrepareFormula(TString &formula)prepare the formula to be executed normally is called with fFormulaDefinition TFormula.cxx:1793; TFormula::fClingInitializedstd::atomic< Bool_t > fClingInitialized! Transient to force re-initializationDefinition TFormula.h:97; TFormula::GradientParvoid GradientPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3222; TFormula::FillDefaultsvoid FillDefaults()Fill structures with default variables, constants and function shortcuts.Definition TFormula.cxx:902; TFormula::GetHessianFormulaTString GetHessianFormula() constDefinition TFormula.cxx:3602; TFormula::Clearvoid Clear(Option_t *option="""") overrideClear the formula setting expression to empty and reset the variables and parameters containers.Definition TFormula.cxx:767; TFormula::GetLinearPartconst TObject * GetLinearPart(Int_t i) constReturn linear part.Definition TFormula.cxx:2553; TFormula::InputFormulaIntoClingvoid InputFormulaIntoCling()Inputs formula, transfered to C++ code into Cling.Definition TFormula.cxx:876; TFormula::DoAddParametervoid DoAddParameter(const TString &name, Double_t value, bool processFormula)Adds parameter to known parameters.Definition TFormula.cxx:2743; TFormula::HandleLinearvoid HandleLinear(TString &formula)Handle linear functions defined with the operator ++.Definition TFormula.cxx:1735; TFormula::fClingNameTString fClingName! Unique name passed to Cling to define the function ( double clingName(double*x, double*p) )Definition TFormula.h:101; TFormula::GetVarNameTString GetVarName(Int_t ivar) constReturns variable name given its position in the array.Definition TFormula.cxx:2712; TFormula::SetVariablevoid SetVari",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:154448,Modifiability,variab,variable,154448,"essianFormula() constDefinition TFormula.cxx:3602; TFormula::Clearvoid Clear(Option_t *option="""") overrideClear the formula setting expression to empty and reset the variables and parameters containers.Definition TFormula.cxx:767; TFormula::GetLinearPartconst TObject * GetLinearPart(Int_t i) constReturn linear part.Definition TFormula.cxx:2553; TFormula::InputFormulaIntoClingvoid InputFormulaIntoCling()Inputs formula, transfered to C++ code into Cling.Definition TFormula.cxx:876; TFormula::DoAddParametervoid DoAddParameter(const TString &name, Double_t value, bool processFormula)Adds parameter to known parameters.Definition TFormula.cxx:2743; TFormula::HandleLinearvoid HandleLinear(TString &formula)Handle linear functions defined with the operator ++.Definition TFormula.cxx:1735; TFormula::fClingNameTString fClingName! Unique name passed to Cling to define the function ( double clingName(double*x, double*p) )Definition TFormula.h:101; TFormula::GetVarNameTString GetVarName(Int_t ivar) constReturns variable name given its position in the array.Definition TFormula.cxx:2712; TFormula::SetVariablevoid SetVariable(const TString &name, Double_t value)Sets variable value.Definition TFormula.cxx:2728; TFormula::HessianParvoid HessianPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3286; TFormula::GetParNumberInt_t GetParNumber(const char *name) constReturn parameter index given a name (return -1 for not existing parameters) non need to print an erro...Definition TFormula.cxx:2821; TFormula::DoSetParametersvoid DoSetParameters(const Double_t *p, Int_t size)Definition TFormula.cxx:2949; TFormula::GenerateHessianParbool GenerateHessianPar()Generate hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; TFormula::GetGradientFormulaTString GetGradientFormula() constDefinition TFormula.cxx:3594; TFormula::HandleParametrizedFunctionsvoid HandleParametrizedFunctions",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:154603,Modifiability,variab,variable,154603," expression to empty and reset the variables and parameters containers.Definition TFormula.cxx:767; TFormula::GetLinearPartconst TObject * GetLinearPart(Int_t i) constReturn linear part.Definition TFormula.cxx:2553; TFormula::InputFormulaIntoClingvoid InputFormulaIntoCling()Inputs formula, transfered to C++ code into Cling.Definition TFormula.cxx:876; TFormula::DoAddParametervoid DoAddParameter(const TString &name, Double_t value, bool processFormula)Adds parameter to known parameters.Definition TFormula.cxx:2743; TFormula::HandleLinearvoid HandleLinear(TString &formula)Handle linear functions defined with the operator ++.Definition TFormula.cxx:1735; TFormula::fClingNameTString fClingName! Unique name passed to Cling to define the function ( double clingName(double*x, double*p) )Definition TFormula.h:101; TFormula::GetVarNameTString GetVarName(Int_t ivar) constReturns variable name given its position in the array.Definition TFormula.cxx:2712; TFormula::SetVariablevoid SetVariable(const TString &name, Double_t value)Sets variable value.Definition TFormula.cxx:2728; TFormula::HessianParvoid HessianPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3286; TFormula::GetParNumberInt_t GetParNumber(const char *name) constReturn parameter index given a name (return -1 for not existing parameters) non need to print an erro...Definition TFormula.cxx:2821; TFormula::DoSetParametersvoid DoSetParameters(const Double_t *p, Int_t size)Definition TFormula.cxx:2949; TFormula::GenerateHessianParbool GenerateHessianPar()Generate hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; TFormula::GetGradientFormulaTString GetGradientFormula() constDefinition TFormula.cxx:3594; TFormula::HandleParametrizedFunctionsvoid HandleParametrizedFunctions(TString &formula)Handling parametrized functions Function can be normalized, and have different variable then x.Definition TFormu",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:155533,Modifiability,variab,variable,155533,"ble name given its position in the array.Definition TFormula.cxx:2712; TFormula::SetVariablevoid SetVariable(const TString &name, Double_t value)Sets variable value.Definition TFormula.cxx:2728; TFormula::HessianParvoid HessianPar(const Double_t *x, TFormula::CladStorage &result)Compute the gradient employing automatic differentiation.Definition TFormula.cxx:3286; TFormula::GetParNumberInt_t GetParNumber(const char *name) constReturn parameter index given a name (return -1 for not existing parameters) non need to print an erro...Definition TFormula.cxx:2821; TFormula::DoSetParametersvoid DoSetParameters(const Double_t *p, Int_t size)Definition TFormula.cxx:2949; TFormula::GenerateHessianParbool GenerateHessianPar()Generate hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; TFormula::GetGradientFormulaTString GetGradientFormula() constDefinition TFormula.cxx:3594; TFormula::HandleParametrizedFunctionsvoid HandleParametrizedFunctions(TString &formula)Handling parametrized functions Function can be normalized, and have different variable then x.Definition TFormula.cxx:1103; TFormula::~TFormula~TFormula() overrideDefinition TFormula.cxx:465; TFormula::CallFuncSignatureTInterpreter::CallFuncIFacePtr_t::Generic_t CallFuncSignatureDefinition TFormula.h:104; TFormula::GetParametersDouble_t * GetParameters() constDefinition TFormula.cxx:2873; TFormula::SetParNamevoid SetParName(Int_t ipar, const char *name)Definition TFormula.cxx:2990; TFormula::SetNamevoid SetName(const char *name) overrideSet the name of the formula.Definition TFormula.cxx:2640; TFormula::GetHessianFuncNamestd::string GetHessianFuncName() constDefinition TFormula.h:131; TFormula::fGradGenerationInputstd::string fGradGenerationInput! Input query to clad to generate a gradientDefinition TFormula.h:105; TFormula::IsAParameterNamestatic Bool_t IsAParameterName(const TString &formula, int ipos)Definition TFormula.cxx:353; TFormula::HasGradientGenerationFailedbool HasGradien",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:157653,Modifiability,variab,variables,157653,"me)Replace in Formula expression the parameter name.Definition TFormula.cxx:3020; TFormula::SetPredefinedParamNamesvoid SetPredefinedParamNames()Set parameter names only in case of pre-defined functions.Definition TFormula.cxx:2471; TFormula::Copyvoid Copy(TObject &f1) const overrideCopy this to obj.Definition TFormula.cxx:684; TFormula::Classstatic TClass * Class(); TFormula::fConstsstd::map< TString, Double_t > fConsts!Definition TFormula.h:146; TFormula::fFunctionsShortcutsstd::map< TString, TString > fFunctionsShortcuts!Definition TFormula.h:147; TFormula::TFormulaTFormula()Definition TFormula.cxx:438; TFormula::HandleParamRangesvoid HandleParamRanges(TString &formula)Handling parameter ranges, in the form of [1..5].Definition TFormula.cxx:1320; TFormula::fLinearPartsstd::vector< TObject * > fLinearPartsVector of linear functions.Definition TFormula.h:152; TFormula::IsBracketstatic Bool_t IsBracket(const char c)Definition TFormula.cxx:294; TFormula::fVectorizedBool_t fVectorizedWhether we should use vectorized or regular variables.Definition TFormula.h:153; TFormula::fClingInputTString fClingInput! Input function passed to ClingDefinition TFormula.h:93; TFormula::PrepareEvalMethodBool_t PrepareEvalMethod()Sets TMethodCall to function inside Cling environment.Definition TFormula.cxx:861; TFormula::fNumberInt_t fNumberNumber used to identify pre-defined functions (gaus, expo,..)Definition TFormula.h:151; TFormula::GetGradientFuncNamestd::string GetGradientFuncName() constDefinition TFormula.h:128; TFormula::fIsCladRuntimeIncludedstatic bool fIsCladRuntimeIncludedDefinition TFormula.h:111; TFormula::CladStoragestd::vector< Double_t > CladStorageDefinition TFormula.h:184; TFormula::GetVariableDouble_t GetVariable(const char *name) constReturns variable value.Definition TFormula.cxx:2686; TFormula::fFuncsstd::list< TFormulaFunction > fFuncs!Definition TFormula.h:143; TFormula::fAllParametersSettedBool_t fAllParametersSettedFlag to control if all parameters are setted",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:158386,Modifiability,variab,variable,158386,"TFormula.cxx:1320; TFormula::fLinearPartsstd::vector< TObject * > fLinearPartsVector of linear functions.Definition TFormula.h:152; TFormula::IsBracketstatic Bool_t IsBracket(const char c)Definition TFormula.cxx:294; TFormula::fVectorizedBool_t fVectorizedWhether we should use vectorized or regular variables.Definition TFormula.h:153; TFormula::fClingInputTString fClingInput! Input function passed to ClingDefinition TFormula.h:93; TFormula::PrepareEvalMethodBool_t PrepareEvalMethod()Sets TMethodCall to function inside Cling environment.Definition TFormula.cxx:861; TFormula::fNumberInt_t fNumberNumber used to identify pre-defined functions (gaus, expo,..)Definition TFormula.h:151; TFormula::GetGradientFuncNamestd::string GetGradientFuncName() constDefinition TFormula.h:128; TFormula::fIsCladRuntimeIncludedstatic bool fIsCladRuntimeIncludedDefinition TFormula.h:111; TFormula::CladStoragestd::vector< Double_t > CladStorageDefinition TFormula.h:184; TFormula::GetVariableDouble_t GetVariable(const char *name) constReturns variable value.Definition TFormula.cxx:2686; TFormula::fFuncsstd::list< TFormulaFunction > fFuncs!Definition TFormula.h:143; TFormula::fAllParametersSettedBool_t fAllParametersSettedFlag to control if all parameters are setted.Definition TFormula.h:98; TFormula::ProcessFormulavoid ProcessFormula(TString &formula)Iterates through functors in fFuncs and performs the appropriate action.Definition TFormula.cxx:2077; TFormula::IsOperatorstatic Bool_t IsOperator(const char c)Definition TFormula.cxx:286; TFormula::HasHessianGenerationFailedbool HasHessianGenerationFailed() constDefinition TFormula.h:137; TFormula::SetVectorizedvoid SetVectorized(Bool_t vectorized)Definition TFormula.cxx:3046; TFormula::FillVecFunctionsShurtCutsvoid FillVecFunctionsShurtCuts()Fill the shortcuts for vectorized functions We will replace for example sin with vecCore::Mat::Sin.Definition TFormula.cxx:970; TFormula::GetParNameconst char * GetParName(Int_t ipar) constReturn parameter ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:159474,Modifiability,variab,variable,159474,"list< TFormulaFunction > fFuncs!Definition TFormula.h:143; TFormula::fAllParametersSettedBool_t fAllParametersSettedFlag to control if all parameters are setted.Definition TFormula.h:98; TFormula::ProcessFormulavoid ProcessFormula(TString &formula)Iterates through functors in fFuncs and performs the appropriate action.Definition TFormula.cxx:2077; TFormula::IsOperatorstatic Bool_t IsOperator(const char c)Definition TFormula.cxx:286; TFormula::HasHessianGenerationFailedbool HasHessianGenerationFailed() constDefinition TFormula.h:137; TFormula::SetVectorizedvoid SetVectorized(Bool_t vectorized)Definition TFormula.cxx:3046; TFormula::FillVecFunctionsShurtCutsvoid FillVecFunctionsShurtCuts()Fill the shortcuts for vectorized functions We will replace for example sin with vecCore::Mat::Sin.Definition TFormula.cxx:970; TFormula::GetParNameconst char * GetParName(Int_t ipar) constReturn parameter name given by integer.Definition TFormula.cxx:2859; TFormula::fVarsstd::map< TString, TFormulaVariable > fVars! List of variable namesDefinition TFormula.h:144; TFormula::fFuncPtrCallFuncSignature fFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:107; TFormula::HandlePolNvoid HandlePolN(TString &formula)Handling polN If before 'pol' exist any name, this name will be treated as variable used in polynomia...Definition TFormula.cxx:1002; TFormula::IsHexadecimalstatic Bool_t IsHexadecimal(const TString &formula, int ipos)Definition TFormula.cxx:330; TFormula::ExtractFunctorsvoid ExtractFunctors(TString &formula)Extracts functors from formula, and put them in fFuncs.Definition TFormula.cxx:1832; TFormula::InitLambdaExpressionBool_t InitLambdaExpression(const char *formula)Definition TFormula.cxx:605; TFormula::SetParametersvoid SetParameters(const Double_t *params)Set a vector of parameters value.Definition TFormula.cxx:2970; TFormula::fSavedInputFormulastd::string fSavedInputFormula! Unique name used to defined the function and used in the global map (need to be saved ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:159751,Modifiability,variab,variable,159751,"la)Iterates through functors in fFuncs and performs the appropriate action.Definition TFormula.cxx:2077; TFormula::IsOperatorstatic Bool_t IsOperator(const char c)Definition TFormula.cxx:286; TFormula::HasHessianGenerationFailedbool HasHessianGenerationFailed() constDefinition TFormula.h:137; TFormula::SetVectorizedvoid SetVectorized(Bool_t vectorized)Definition TFormula.cxx:3046; TFormula::FillVecFunctionsShurtCutsvoid FillVecFunctionsShurtCuts()Fill the shortcuts for vectorized functions We will replace for example sin with vecCore::Mat::Sin.Definition TFormula.cxx:970; TFormula::GetParNameconst char * GetParName(Int_t ipar) constReturn parameter name given by integer.Definition TFormula.cxx:2859; TFormula::fVarsstd::map< TString, TFormulaVariable > fVars! List of variable namesDefinition TFormula.h:144; TFormula::fFuncPtrCallFuncSignature fFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:107; TFormula::HandlePolNvoid HandlePolN(TString &formula)Handling polN If before 'pol' exist any name, this name will be treated as variable used in polynomia...Definition TFormula.cxx:1002; TFormula::IsHexadecimalstatic Bool_t IsHexadecimal(const TString &formula, int ipos)Definition TFormula.cxx:330; TFormula::ExtractFunctorsvoid ExtractFunctors(TString &formula)Extracts functors from formula, and put them in fFuncs.Definition TFormula.cxx:1832; TFormula::InitLambdaExpressionBool_t InitLambdaExpression(const char *formula)Definition TFormula.cxx:605; TFormula::SetParametersvoid SetParameters(const Double_t *params)Set a vector of parameters value.Definition TFormula.cxx:2970; TFormula::fSavedInputFormulastd::string fSavedInputFormula! Unique name used to defined the function and used in the global map (need to be saved in case of la...Definition TFormula.h:102; TFormula::IsValidBool_t IsValid() constDefinition TFormula.h:271; TFormula::ReplaceAllNamesvoid ReplaceAllNames(TString &formula, std::map< TString, TString > &substitutions)Definition TFormula.cxx:405;",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:161241,Modifiability,variab,variables,161241,"metersvoid SetParameters(const Double_t *params)Set a vector of parameters value.Definition TFormula.cxx:2970; TFormula::fSavedInputFormulastd::string fSavedInputFormula! Unique name used to defined the function and used in the global map (need to be saved in case of la...Definition TFormula.h:102; TFormula::IsValidBool_t IsValid() constDefinition TFormula.h:271; TFormula::ReplaceAllNamesvoid ReplaceAllNames(TString &formula, std::map< TString, TString > &substitutions)Definition TFormula.cxx:405; TFormula::IsDefaultVariableNamestatic Bool_t IsDefaultVariableName(const TString &name)Definition TFormula.cxx:312; TFormula::FillParametrizedFunctionsvoid FillParametrizedFunctions(std::map< std::pair< TString, Int_t >, std::pair< TString, TString > > &functions)Fill map with parametrized functions.Definition TFormula.cxx:2417; TFormula::EvalParDouble_t EvalPar(const Double_t *x, const Double_t *params=nullptr) constDefinition TFormula.cxx:3078; TFormula::AddVariablesvoid AddVariables(const TString *vars, const Int_t size)Adds multiple variables.Definition TFormula.cxx:2602; TFormula::GetVarNumberInt_t GetVarNumber(const char *name) constReturns variable number (positon in array) given its name.Definition TFormula.cxx:2699; TFormula::fClingVariablesstd::vector< Double_t > fClingVariables! Cached variablesDefinition TFormula.h:94; TFormula::fMethodstd::unique_ptr< TMethodCall > fMethod! Pointer to methodcallDefinition TFormula.h:100; TFormula::fFormulaTString fFormulaString representing the formula expression.Definition TFormula.h:148; TFormula::IsScientificNotationstatic Bool_t IsScientificNotation(const TString &formula, int ipos)Definition TFormula.cxx:318; TFormula::fGradFuncPtrCallFuncSignature fGradFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:108; TFormula::fClingParametersstd::vector< Double_t > fClingParametersParameter values.Definition TFormula.h:95; TFormula::SetParametervoid SetParameter(const char *name, Double_t value)Sets parameter value",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:161353,Modifiability,variab,variable,161353,"::string fSavedInputFormula! Unique name used to defined the function and used in the global map (need to be saved in case of la...Definition TFormula.h:102; TFormula::IsValidBool_t IsValid() constDefinition TFormula.h:271; TFormula::ReplaceAllNamesvoid ReplaceAllNames(TString &formula, std::map< TString, TString > &substitutions)Definition TFormula.cxx:405; TFormula::IsDefaultVariableNamestatic Bool_t IsDefaultVariableName(const TString &name)Definition TFormula.cxx:312; TFormula::FillParametrizedFunctionsvoid FillParametrizedFunctions(std::map< std::pair< TString, Int_t >, std::pair< TString, TString > > &functions)Fill map with parametrized functions.Definition TFormula.cxx:2417; TFormula::EvalParDouble_t EvalPar(const Double_t *x, const Double_t *params=nullptr) constDefinition TFormula.cxx:3078; TFormula::AddVariablesvoid AddVariables(const TString *vars, const Int_t size)Adds multiple variables.Definition TFormula.cxx:2602; TFormula::GetVarNumberInt_t GetVarNumber(const char *name) constReturns variable number (positon in array) given its name.Definition TFormula.cxx:2699; TFormula::fClingVariablesstd::vector< Double_t > fClingVariables! Cached variablesDefinition TFormula.h:94; TFormula::fMethodstd::unique_ptr< TMethodCall > fMethod! Pointer to methodcallDefinition TFormula.h:100; TFormula::fFormulaTString fFormulaString representing the formula expression.Definition TFormula.h:148; TFormula::IsScientificNotationstatic Bool_t IsScientificNotation(const TString &formula, int ipos)Definition TFormula.cxx:318; TFormula::fGradFuncPtrCallFuncSignature fGradFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:108; TFormula::fClingParametersstd::vector< Double_t > fClingParametersParameter values.Definition TFormula.h:95; TFormula::SetParametervoid SetParameter(const char *name, Double_t value)Sets parameter value.Definition TFormula.cxx:2893; TFormula::Printvoid Print(Option_t *option="""") const overridePrint the formula and its attributes.Definition TF",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:161506,Modifiability,variab,variablesDefinition,161506,"TFormula.h:102; TFormula::IsValidBool_t IsValid() constDefinition TFormula.h:271; TFormula::ReplaceAllNamesvoid ReplaceAllNames(TString &formula, std::map< TString, TString > &substitutions)Definition TFormula.cxx:405; TFormula::IsDefaultVariableNamestatic Bool_t IsDefaultVariableName(const TString &name)Definition TFormula.cxx:312; TFormula::FillParametrizedFunctionsvoid FillParametrizedFunctions(std::map< std::pair< TString, Int_t >, std::pair< TString, TString > > &functions)Fill map with parametrized functions.Definition TFormula.cxx:2417; TFormula::EvalParDouble_t EvalPar(const Double_t *x, const Double_t *params=nullptr) constDefinition TFormula.cxx:3078; TFormula::AddVariablesvoid AddVariables(const TString *vars, const Int_t size)Adds multiple variables.Definition TFormula.cxx:2602; TFormula::GetVarNumberInt_t GetVarNumber(const char *name) constReturns variable number (positon in array) given its name.Definition TFormula.cxx:2699; TFormula::fClingVariablesstd::vector< Double_t > fClingVariables! Cached variablesDefinition TFormula.h:94; TFormula::fMethodstd::unique_ptr< TMethodCall > fMethod! Pointer to methodcallDefinition TFormula.h:100; TFormula::fFormulaTString fFormulaString representing the formula expression.Definition TFormula.h:148; TFormula::IsScientificNotationstatic Bool_t IsScientificNotation(const TString &formula, int ipos)Definition TFormula.cxx:318; TFormula::fGradFuncPtrCallFuncSignature fGradFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:108; TFormula::fClingParametersstd::vector< Double_t > fClingParametersParameter values.Definition TFormula.h:95; TFormula::SetParametervoid SetParameter(const char *name, Double_t value)Sets parameter value.Definition TFormula.cxx:2893; TFormula::Printvoid Print(Option_t *option="""") const overridePrint the formula and its attributes.Definition TFormula.cxx:3611; TFormula::PreProcessFormulavoid PreProcessFormula(TString &formula)Preprocessing of formula Replace all ** by ^, and removes ",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:162857,Modifiability,variab,variables,162857,"tificNotation(const TString &formula, int ipos)Definition TFormula.cxx:318; TFormula::fGradFuncPtrCallFuncSignature fGradFuncPtr! Function pointer, owned by the JIT.Definition TFormula.h:108; TFormula::fClingParametersstd::vector< Double_t > fClingParametersParameter values.Definition TFormula.h:95; TFormula::SetParametervoid SetParameter(const char *name, Double_t value)Sets parameter value.Definition TFormula.cxx:2893; TFormula::Printvoid Print(Option_t *option="""") const overridePrint the formula and its attributes.Definition TFormula.cxx:3611; TFormula::PreProcessFormulavoid PreProcessFormula(TString &formula)Preprocessing of formula Replace all ** by ^, and removes spaces.Definition TFormula.cxx:1771; TFormula::GetExpFormulaTString GetExpFormula(Option_t *option="""") constReturn the expression formula.Definition TFormula.cxx:3524; TFormula::fNdimInt_t fNdimDimension - needed for lambda expressions.Definition TFormula.h:149; TFormula::SetVariablesvoid SetVariables(const std::pair< TString, Double_t > *vars, const Int_t size)Sets multiple variables.Definition TFormula.cxx:2669; TFormula::ReInitializeEvalMethodvoid ReInitializeEvalMethod()Re-initialize eval method.Definition TFormula.cxx:3467; TFormula::kNotGlobal@ kNotGlobalDon't store in gROOT->GetListOfFunction (it should be protected)Definition TFormula.h:179; TFormula::kLambda@ kLambdaSet to true if TFormula has been build with a lambda.Definition TFormula.h:182; TFormula::kLinear@ kLinearSet to true if the TFormula is for linear fitting.Definition TFormula.h:181; TFormula::kNormalized@ kNormalizedSet to true if the TFormula (ex gausn) is normalized.Definition TFormula.h:180; TFormula::fLambdaPtrvoid * fLambdaPtr! Pointer to the lambda functionDefinition TFormula.h:110; TFormula::operator=TFormula & operator=(const TFormula &rhs)= operator.Definition TFormula.cxx:597; TFormula::CompileInt_t Compile(const char *expression="""")Compile the given expression with Cling backward compatibility method to be used in comb",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:164097,Modifiability,variab,variables,164097,"alDon't store in gROOT->GetListOfFunction (it should be protected)Definition TFormula.h:179; TFormula::kLambda@ kLambdaSet to true if TFormula has been build with a lambda.Definition TFormula.h:182; TFormula::kLinear@ kLinearSet to true if the TFormula is for linear fitting.Definition TFormula.h:181; TFormula::kNormalized@ kNormalizedSet to true if the TFormula (ex gausn) is normalized.Definition TFormula.h:180; TFormula::fLambdaPtrvoid * fLambdaPtr! Pointer to the lambda functionDefinition TFormula.h:110; TFormula::operator=TFormula & operator=(const TFormula &rhs)= operator.Definition TFormula.cxx:597; TFormula::CompileInt_t Compile(const char *expression="""")Compile the given expression with Cling backward compatibility method to be used in combination with ...Definition TFormula.cxx:650; TFormula::fNparInt_t fNpar! Number of parameter (transient since we save the vector)Definition TFormula.h:150; TFormula::HandleFunctionArgumentsvoid HandleFunctionArguments(TString &formula)Handling user functions (and parametrized functions) to take variables and optionally parameters as a...Definition TFormula.cxx:1351; TFormula::fParamsstd::map< TString, Int_t, TFormulaParamOrder > fParams|| List of parameter namesDefinition TFormula.h:145; TFormula::AddVariablevoid AddVariable(const TString &name, Double_t value=0)Adds variable to known variables, and reprocess formula.Definition TFormula.cxx:2569; TFormula::fLazyInitializationBool_t fLazyInitialization! Transient flag to control lazy initialization (needed for reading from files)Definition TFormula.h:99; TFormula::HandleExponentiationvoid HandleExponentiation(TString &formula)Handling exponentiation Can handle multiple carets, eg.Definition TFormula.cxx:1635; TFormula::IsFunctionNameCharstatic Bool_t IsFunctionNameChar(const char c)Definition TFormula.cxx:306; TFormula::fHessGenerationInputstd::string fHessGenerationInput! Input query to clad to generate a hessianDefinition TFormula.h:106; TFormula::DoEvalDouble_t DoEval(con",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:164375,Modifiability,variab,variable,164375,"kNormalized@ kNormalizedSet to true if the TFormula (ex gausn) is normalized.Definition TFormula.h:180; TFormula::fLambdaPtrvoid * fLambdaPtr! Pointer to the lambda functionDefinition TFormula.h:110; TFormula::operator=TFormula & operator=(const TFormula &rhs)= operator.Definition TFormula.cxx:597; TFormula::CompileInt_t Compile(const char *expression="""")Compile the given expression with Cling backward compatibility method to be used in combination with ...Definition TFormula.cxx:650; TFormula::fNparInt_t fNpar! Number of parameter (transient since we save the vector)Definition TFormula.h:150; TFormula::HandleFunctionArgumentsvoid HandleFunctionArguments(TString &formula)Handling user functions (and parametrized functions) to take variables and optionally parameters as a...Definition TFormula.cxx:1351; TFormula::fParamsstd::map< TString, Int_t, TFormulaParamOrder > fParams|| List of parameter namesDefinition TFormula.h:145; TFormula::AddVariablevoid AddVariable(const TString &name, Double_t value=0)Adds variable to known variables, and reprocess formula.Definition TFormula.cxx:2569; TFormula::fLazyInitializationBool_t fLazyInitialization! Transient flag to control lazy initialization (needed for reading from files)Definition TFormula.h:99; TFormula::HandleExponentiationvoid HandleExponentiation(TString &formula)Handling exponentiation Can handle multiple carets, eg.Definition TFormula.cxx:1635; TFormula::IsFunctionNameCharstatic Bool_t IsFunctionNameChar(const char c)Definition TFormula.cxx:306; TFormula::fHessGenerationInputstd::string fHessGenerationInput! Input query to clad to generate a hessianDefinition TFormula.h:106; TFormula::DoEvalDouble_t DoEval(const Double_t *x, const Double_t *p=nullptr) constEvaluate formula.Definition TFormula.cxx:3359; TFormula::fReadyToExecuteBool_t fReadyToExecute! Transient to force initializationDefinition TFormula.h:96; TFormula::GenerateGradientParbool GenerateGradientPar()Generate gradient computation routine with respect to t",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:164393,Modifiability,variab,variables,164393,"kNormalized@ kNormalizedSet to true if the TFormula (ex gausn) is normalized.Definition TFormula.h:180; TFormula::fLambdaPtrvoid * fLambdaPtr! Pointer to the lambda functionDefinition TFormula.h:110; TFormula::operator=TFormula & operator=(const TFormula &rhs)= operator.Definition TFormula.cxx:597; TFormula::CompileInt_t Compile(const char *expression="""")Compile the given expression with Cling backward compatibility method to be used in combination with ...Definition TFormula.cxx:650; TFormula::fNparInt_t fNpar! Number of parameter (transient since we save the vector)Definition TFormula.h:150; TFormula::HandleFunctionArgumentsvoid HandleFunctionArguments(TString &formula)Handling user functions (and parametrized functions) to take variables and optionally parameters as a...Definition TFormula.cxx:1351; TFormula::fParamsstd::map< TString, Int_t, TFormulaParamOrder > fParams|| List of parameter namesDefinition TFormula.h:145; TFormula::AddVariablevoid AddVariable(const TString &name, Double_t value=0)Adds variable to known variables, and reprocess formula.Definition TFormula.cxx:2569; TFormula::fLazyInitializationBool_t fLazyInitialization! Transient flag to control lazy initialization (needed for reading from files)Definition TFormula.h:99; TFormula::HandleExponentiationvoid HandleExponentiation(TString &formula)Handling exponentiation Can handle multiple carets, eg.Definition TFormula.cxx:1635; TFormula::IsFunctionNameCharstatic Bool_t IsFunctionNameChar(const char c)Definition TFormula.cxx:306; TFormula::fHessGenerationInputstd::string fHessGenerationInput! Input query to clad to generate a hessianDefinition TFormula.h:106; TFormula::DoEvalDouble_t DoEval(const Double_t *x, const Double_t *p=nullptr) constEvaluate formula.Definition TFormula.cxx:3359; TFormula::fReadyToExecuteBool_t fReadyToExecute! Transient to force initializationDefinition TFormula.h:96; TFormula::GenerateGradientParbool GenerateGradientPar()Generate gradient computation routine with respect to t",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:1223,Performance,optimiz,optimize,1223,"ching...; No Matches. TFormula.cxx. Go to the documentation of this file. 1// @(#)root/hist:$Id$; 2// Author: Maciej Zimnoch 30/09/2013; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include ""TROOT.h""; 13#include ""TBuffer.h""; 14#include ""TMethod.h""; 15#include ""TF1.h""; 16#include ""TMethodCall.h""; 17#include <TBenchmark.h>; 18#include ""TError.h""; 19#include ""TInterpreter.h""; 20#include ""TInterpreterValue.h""; 21#include ""TFormula.h""; 22#include ""TRegexp.h""; 23 ; 24#include ""ROOT/StringUtils.hxx""; 25 ; 26#include <array>; 27#include <iostream>; 28#include <memory>; 29#include <unordered_map>; 30#include <functional>; 31#include <set>; 32#include <sstream>; 33 ; 34using std::map, std::pair, std::make_pair, std::list, std::max, std::string;; 35 ; 36#ifdef WIN32; 37#pragma optimize("""",off); 38#endif; 39#include ""v5/TFormula.h""; 40 ; 41ClassImp(TFormula);; 42 ; 43/** \class TFormula TFormula.h ""inc/TFormula.h""; 44 \ingroup Hist; 45 The Formula class; 46 ; 47 This is a new version of the TFormula class based on Cling.; 48 This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; 49 `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; 50 `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; 51 On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6; 52 ; 53 This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch.; 54 ; 55 ### Example of valid expressions:; 56 ; 57 - `sin(x)/x`; 58 - `[0]*sin(x) + [1]*exp(-[2]*x)`; 59 - `x + y**2`; 60 - `x^2 + y^2`; 61 - `[0]*p",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:26870,Performance,load,load,26870,"t is a vector of TFormula pointers) needs to be copied one by one; 705 // looping at all the elements; 706 // delete first previous elements; 707 int nLinParts = fnew.fLinearParts.size();; 708 if (nLinParts > 0) {; 709 for (int i = 0; i < nLinParts; ++i) delete fnew.fLinearParts[i];; 710 fnew.fLinearParts.clear();; 711 }; 712 // old size that needs to be copied; 713 nLinParts = fLinearParts.size();; 714 if (nLinParts > 0) {; 715 fnew.fLinearParts.reserve(nLinParts);; 716 for (int i = 0; i < nLinParts; ++i) {; 717 TFormula * linearNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; 739 bool ret = fnew.InitLambdaExpression(fnew.fFormula);; 740 if (ret) {; 741 fnew.SetBit(TFormula::kLambda);; 742 fnew.fReadyToExecute = true;; 743 }; 744 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 7",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:32032,Performance,optimiz,optimization,32032,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:32102,Performance,optimiz,optimize,32102,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:32186,Performance,load,loaded,32186,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:32206,Performance,perform,performant,32206,,MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:78236,Performance,perform,performs,78236," begin and end of replacementFormula; 2033 replacementFormula.Insert(0, '(');; 2034 replacementFormula.Insert(replacementFormula.Length(), ')');; 2035 formula.Replace(i - name.Length(), name.Length(), replacementFormula, replacementFormula.Length());; 2036 // move forward the index i of the main loop; 2037 i += replacementFormula.Length() - name.Length();; 2038 ; 2039 // we have extracted all the functor for ""fname""; 2040 // std::cout << ""We have extracted all the functors for fname"" << std::endl;; 2041 // std::cout << "" i = "" << i << "" f[i] = "" << formula[i] << "" - "" << formula << std::endl;; 2042 name = """";; 2043 ; 2044 continue;; 2045 }; 2046 ; 2047 // add now functor in; 2048 TString replacement = TString::Format(""{%s}"", name.Data());; 2049 formula.Replace(i - name.Length(), name.Length(), replacement, replacement.Length());; 2050 i += 2;; 2051 fFuncs.push_back(TFormulaFunction(name));; 2052 }; 2053 }; 2054 name = body = """";; 2055 }; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Iterates through functors in fFuncs and performs the appropriate action.; 2060/// If functor has 0 arguments (has only name) can be:; 2061/// - variable; 2062/// * will be replaced with x[num], where x is an array containing value of this variable under num.; 2063/// - pre-defined formula; 2064/// * will be replaced with formulas body; 2065/// - constant; 2066/// * will be replaced with constant value; 2067/// - parameter; 2068/// * will be replaced with p[num], where p is an array containing value of this parameter under num.; 2069/// If has arguments it can be :; 2070/// - function shortcut, eg. sin; 2071/// * will be replaced with fullname of function, eg. sin -> TMath::Sin; 2072/// - function from cling environment, eg. TMath::BreitWigner(x,y,z); 2073/// * first check if function exists, and has same number of arguments, then accept it and set as found.; 2074/// If all functors after iteration are matched with correspondin",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:119576,Performance,optimiz,optimize,119576,"params);; 3111 return vecCore::Get(ans, 0);; 3112 ; 3113#else; 3114 // this should never happen, because fVectorized can only be set true with; 3115 // R__HAS_VECCORE, but just in case:; 3116 Error(""EvalPar"", ""Formula is vectorized (even though VECCORE is disabled!)"");; 3117 return TMath::QuietNaN();; 3118#endif; 3119}; 3120 ; 3121bool TFormula::fIsCladRuntimeIncluded = false;; 3122 ; 3123static bool functionExists(const string &Name) {; 3124 return gInterpreter->GetFunction(/*cl*/nullptr, Name.c_str());; 3125}; 3126 ; 3127static void IncludeCladRuntime(Bool_t &IsCladRuntimeIncluded) {; 3128 if (!IsCladRuntimeIncluded) {; 3129 IsCladRuntimeIncluded = true;; 3130 gInterpreter->Declare(""#include <Math/CladDerivator.h>\n#pragma clad OFF"");; 3131 }; 3132}; 3133 ; 3134static bool; 3135DeclareGenerationInput(std::string FuncName, std::string CladStatement,; 3136 std::string &GenerationInput) {; 3137 std::string ReqFuncName = FuncName + ""_req"";; 3138 // We want to call clad::differentiate(TFormula_id);; 3139 GenerationInput = std::string(""#pragma cling optimize(2)\n"") +; 3140 ""#pragma clad ON\n"" +; 3141 ""void "" + ReqFuncName + ""() {\n"" +; 3142 CladStatement + ""\n "" +; 3143 ""}\n"" +; 3144 ""#pragma clad OFF"";; 3145 ; 3146 return gInterpreter->Declare(GenerationInput.c_str());; 3147}; 3148 ; 3149static TInterpreter::CallFuncIFacePtr_t::Generic_t; 3150GetFuncPtr(std::string FuncName, Int_t Npar, Int_t Ndim, Bool_t Vectorized) {; 3151 Bool_t hasParameters = (Npar > 0);; 3152 Bool_t hasVariables = (Ndim > 0);; 3153 std::unique_ptr<TMethodCall>; 3154 method = prepareMethod(hasParameters, hasVariables, FuncName.c_str(),; 3155 Vectorized, /*AddCladArrayRef*/ true);; 3156 return prepareFuncPtr(method.get());; 3157}; 3158 ; 3159static void CallCladFunction(TInterpreter::CallFuncIFacePtr_t::Generic_t FuncPtr, const Double_t *vars,; 3160 const Double_t *pars, Double_t *result, const Int_t /*result_size*/); 3161{; 3162 void *args[3];; 3163 args[0] = &vars;; 3164 if (!pars) {; 3165 // __a",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
https://root.cern/doc/master/TFormula_8cxx_source.html:151367,Performance,load,load,151367,"ROOT.cxx:597; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TRegexp.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; ROOT::v5::TFormula::Streamervoid Streamer(TBuffer &b, const TClass *onfile_class)Stream a class object.Definition TFormula_v5.cxx:3460; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetListOfAllPublicMethodsconst TList * GetListOfAllPublicMethods(Bool_t load=kTRUE)Returns a list of all public methods of this class and its base classes.Definition TClass.cxx:3912; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TF11-Dim function classDefinition TF1.h:233; TF1::GetFormulavirtual TFormula * GetFormula()Definition TF1.h:481; TFormulaFunctionHelper class for TFormula.Definition TFormula.h:32; TFormulaFunction::fFoundBool_t fFoundDefinition TFormula.h:37; TFormulaFunction::GetNameconst char * GetName() constDefinition TFormula.h:39; TFormulaFunction::GetNargsInt_t GetNargs() constDefinition TFormula.h:41; TFormulaFunction::fNameTString fNameDefinition TFormula.h:34; TFormulaFunction::IsFuncCallBool_t IsFuncCall() constDefinition TFormula.h:42; TFormulaVariableAnother helper class for TFormula.Definition TFormula.h:65; TFormulaVariable::fNameTString fNameDefinition TFormula.h:67; TFormulaVariabl",MatchSource.WIKI,doc/master/TFormula_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html
